// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum =
  | "FOREIGN_ZERO"
  | "FOREIGN_FOO"
  | "FOREIGN_BAR"
  | "FOREIGN_BAZ";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: googleProtobufUnittest_import.ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "ZERO" | "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes | null | undefined;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "UNKNOWN" | "FOO" | "BAR" | "BAZ";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum),
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage,
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt),
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt),
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader,
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage,
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage,
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt),
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader,
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestPackedTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader,
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestUnpackedTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        10,
        msg.repeatedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt),
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader,
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 3: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 4: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 5: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 6: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 8: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 10: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 11: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 14: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt),
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: PartialDeep<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: undefined,
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NestedTestAllTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader,
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.child = NestedTestAllTypes.initialize();
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: PartialDeep<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader,
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader,
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes TestMessageWithDummy to protobuf.
   */
  encode: function (msg: PartialDeep<TestMessageWithDummy>): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMessageWithDummy>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader,
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: PartialDeep<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_ZERO: "FOREIGN_ZERO",
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 0: {
        return "FOREIGN_ZERO";
      }
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_ZERO": {
        return 0;
      }
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalLazyImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage,
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage,
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage,
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const _optionalLazyImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalLazyImportMessage,
        );
      if (Object.keys(_optionalLazyImportMessage_).length > 0) {
        json["optionalLazyImportMessage"] = _optionalLazyImportMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage,
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      ForeignMessageJSON._readMessage(
        msg.optionalForeignMessage,
        _optionalForeignMessage_,
      );
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        msg.optionalImportMessage,
        _optionalImportMessage_,
      );
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        msg.optionalPublicImportMessage,
        _optionalPublicImportMessage_,
      );
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalLazyMessage,
        _optionalLazyMessage_,
      );
    }
    const _optionalLazyImportMessage_ =
      json["optionalLazyImportMessage"] ?? json["optional_lazy_import_message"];
    if (_optionalLazyImportMessage_) {
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        msg.optionalLazyImportMessage,
        _optionalLazyImportMessage_,
      );
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessageJSON.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessageJSON.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      msg.oneofNestedMessage = TestAllTypesJSON.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.oneofNestedMessage,
        _oneofNestedMessage_,
      );
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: "ZERO",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 0: {
          return "ZERO";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "ZERO": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: PartialDeep<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any,
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestPackedTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestUnpackedTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any,
  ): TestUnpackedTypes {
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    return msg;
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: PartialDeep<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: undefined,
      payload: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NestedTestAllTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any,
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      msg.child = NestedTestAllTypesJSON.initialize();
      NestedTestAllTypesJSON._readMessage(msg.child, _child_);
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      TestAllTypesJSON._readMessage(msg.payload, _payload_);
    }
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: PartialDeep<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestMessageWithDummyJSON = {
  /**
   * Serializes TestMessageWithDummy to JSON.
   */
  encode: function (msg: PartialDeep<TestMessageWithDummy>): string {
    return JSON.stringify(TestMessageWithDummyJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageWithDummy from JSON.
   */
  decode: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummyJSON._readMessage(
      TestMessageWithDummyJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMessageWithDummy>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    json: any,
  ): TestMessageWithDummy {
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: PartialDeep<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooEnum: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: "UNKNOWN",
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 0: {
          return "UNKNOWN";
        }
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "UNKNOWN": {
          return 0;
        }
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,
};
