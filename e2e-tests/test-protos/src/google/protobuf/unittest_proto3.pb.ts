// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto
import type { ByteSource } from "twirpscript";
import { BinaryReader, BinaryWriter } from "twirpscript";

import { ImportMessage } from "./unittest_import.pb";
import { PublicImportMessage } from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  writeMessage: function (msg: TestAllTypes, writer: BinaryWriter): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32.length > 0) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64.length > 0) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32.length > 0) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64.length > 0) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32.length > 0) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64.length > 0) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32.length > 0) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float.length > 0) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double.length > 0) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool.length > 0) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string.length > 0) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes.length > 0) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message.length > 0) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message.length > 0) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message.length > 0) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum.length > 0) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum.length > 0) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece.length > 0) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord.length > 0) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message.length > 0) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: TestAllTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message as ImportMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = "";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = "";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = "";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = "";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = "";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = "";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = "";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = "";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: "",
      optional_uint32: 0,
      optional_uint64: "",
      optional_sint32: 0,
      optional_sint64: "",
      optional_fixed32: 0,
      optional_fixed64: "",
      optional_sfixed32: 0,
      optional_sfixed64: "",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: "",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: "",
      optional_cord: "",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: TestAllTypes.NestedMessage,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage: TestAllTypes.NestedMessage): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg: TestPackedTypes, writer: BinaryWriter): void {
    if (msg.packed_int32.length > 0) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64.length > 0) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32.length > 0) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64.length > 0) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32.length > 0) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64.length > 0) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32.length > 0) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float.length > 0) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double.length > 0) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool.length > 0) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum.length > 0) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: TestPackedTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg: TestUnpackedTypes, writer: BinaryWriter): void {
    if (msg.repeated_int32.length > 0) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64.length > 0) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32.length > 0) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64.length > 0) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32.length > 0) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64.length > 0) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32.length > 0) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64.length > 0) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32.length > 0) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64.length > 0) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float.length > 0) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double.length > 0) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool.length > 0) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum.length > 0) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes: TestUnpackedTypes): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg: NestedTestAllTypes, writer: BinaryWriter): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (nestedTestAllTypes: NestedTestAllTypes): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (msg: ForeignMessage, writer: BinaryWriter): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage: ForeignMessage): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg: TestEmptyMessage, writer: BinaryWriter): void {},

  encode: function (testEmptyMessage: TestEmptyMessage): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (
    msg: TestMessageWithDummy,
    writer: BinaryWriter
  ): void {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (testMessageWithDummy: TestMessageWithDummy): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageWithDummy>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes: ByteSource): TestMessageWithDummy {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message as TestMessageWithDummy;
  },

  defaultValue: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (msg: TestOneof2, writer: BinaryWriter): void {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2: TestOneof2): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      if (reader.isEndGroup()) {
        break;
      }
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
