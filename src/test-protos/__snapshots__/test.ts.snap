// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (msg) {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(PublicImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _e = json.e;
    if (_e) {
      msg.e = _e;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: \\"IMPORT_FOO\\",
  IMPORT_BAR: \\"IMPORT_BAR\\",
  IMPORT_BAZ: \\"IMPORT_BAZ\\",
};

const ImportEnumFromInt = function (i) {
  switch (i) {
    case 7: {
      return \\"IMPORT_FOO\\";
    }
    case 8: {
      return \\"IMPORT_BAR\\";
    }
    case 9: {
      return \\"IMPORT_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ImportEnumToInt = function (i) {
  switch (i) {
    case \\"IMPORT_FOO\\": {
      return 7;
    }
    case \\"IMPORT_BAR\\": {
      return 8;
    }
    case \\"IMPORT_BAZ\\": {
      return 9;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const ImportEnumForMap = { UNKNOWN: \\"UNKNOWN\\", FOO: \\"FOO\\", BAR: \\"BAR\\" };

const ImportEnumForMapFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"UNKNOWN\\";
    }
    case 1: {
      return \\"FOO\\";
    }
    case 2: {
      return \\"BAR\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ImportEnumForMapToInt = function (i) {
  switch (i) {
    case \\"UNKNOWN\\": {
      return 0;
    }
    case \\"FOO\\": {
      return 1;
    }
    case \\"BAR\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (msg) {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestService(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
};

const ForeignEnumFromInt = function (i) {
  switch (i) {
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ForeignEnumToInt = function (i) {
  switch (i) {
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestEnumWithDupValue = {
  FOO1: \\"FOO1\\",
  BAR1: \\"BAR1\\",
  BAZ: \\"BAZ\\",
  FOO2: \\"FOO2\\",
  BAR2: \\"BAR2\\",
};

const TestEnumWithDupValueFromInt = function (i) {
  switch (i) {
    case 1: {
      return \\"FOO1\\";
    }
    case 2: {
      return \\"BAR1\\";
    }
    case 3: {
      return \\"BAZ\\";
    }
    case 1: {
      return \\"FOO2\\";
    }
    case 2: {
      return \\"BAR2\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const TestEnumWithDupValueToInt = function (i) {
  switch (i) {
    case \\"FOO1\\": {
      return 1;
    }
    case \\"BAR1\\": {
      return 2;
    }
    case \\"BAZ\\": {
      return 3;
    }
    case \\"FOO2\\": {
      return 1;
    }
    case \\"BAR2\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestSparseEnum = {
  SPARSE_A: \\"SPARSE_A\\",
  SPARSE_B: \\"SPARSE_B\\",
  SPARSE_C: \\"SPARSE_C\\",
  SPARSE_D: \\"SPARSE_D\\",
  SPARSE_E: \\"SPARSE_E\\",
  SPARSE_F: \\"SPARSE_F\\",
  SPARSE_G: \\"SPARSE_G\\",
};

const TestSparseEnumFromInt = function (i) {
  switch (i) {
    case 123: {
      return \\"SPARSE_A\\";
    }
    case 62374: {
      return \\"SPARSE_B\\";
    }
    case 12589234: {
      return \\"SPARSE_C\\";
    }
    case -15: {
      return \\"SPARSE_D\\";
    }
    case -53452: {
      return \\"SPARSE_E\\";
    }
    case 0: {
      return \\"SPARSE_F\\";
    }
    case 2: {
      return \\"SPARSE_G\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const TestSparseEnumToInt = function (i) {
  switch (i) {
    case \\"SPARSE_A\\": {
      return 123;
    }
    case \\"SPARSE_B\\": {
      return 62374;
    }
    case \\"SPARSE_C\\": {
      return 12589234;
    }
    case \\"SPARSE_D\\": {
      return -15;
    }
    case \\"SPARSE_E\\": {
      return -53452;
    }
    case \\"SPARSE_F\\": {
      return 0;
    }
    case \\"SPARSE_G\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: \\"ENUM_LABEL_DEFAULT\\",
  ENUM_LABEL_1: \\"ENUM_LABEL_1\\",
  ENUM_LABEL_2: \\"ENUM_LABEL_2\\",
  ENUM_LABEL_3: \\"ENUM_LABEL_3\\",
  ENUM_LABEL_4: \\"ENUM_LABEL_4\\",
  ENUM_LABEL_5: \\"ENUM_LABEL_5\\",
  ENUM_LABEL_6: \\"ENUM_LABEL_6\\",
  ENUM_LABEL_7: \\"ENUM_LABEL_7\\",
  ENUM_LABEL_8: \\"ENUM_LABEL_8\\",
  ENUM_LABEL_9: \\"ENUM_LABEL_9\\",
  ENUM_LABEL_10: \\"ENUM_LABEL_10\\",
  ENUM_LABEL_11: \\"ENUM_LABEL_11\\",
  ENUM_LABEL_12: \\"ENUM_LABEL_12\\",
  ENUM_LABEL_13: \\"ENUM_LABEL_13\\",
  ENUM_LABEL_14: \\"ENUM_LABEL_14\\",
  ENUM_LABEL_15: \\"ENUM_LABEL_15\\",
  ENUM_LABEL_16: \\"ENUM_LABEL_16\\",
  ENUM_LABEL_17: \\"ENUM_LABEL_17\\",
  ENUM_LABEL_18: \\"ENUM_LABEL_18\\",
  ENUM_LABEL_19: \\"ENUM_LABEL_19\\",
  ENUM_LABEL_20: \\"ENUM_LABEL_20\\",
  ENUM_LABEL_21: \\"ENUM_LABEL_21\\",
  ENUM_LABEL_22: \\"ENUM_LABEL_22\\",
  ENUM_LABEL_23: \\"ENUM_LABEL_23\\",
  ENUM_LABEL_24: \\"ENUM_LABEL_24\\",
  ENUM_LABEL_25: \\"ENUM_LABEL_25\\",
  ENUM_LABEL_26: \\"ENUM_LABEL_26\\",
  ENUM_LABEL_27: \\"ENUM_LABEL_27\\",
  ENUM_LABEL_28: \\"ENUM_LABEL_28\\",
  ENUM_LABEL_29: \\"ENUM_LABEL_29\\",
  ENUM_LABEL_30: \\"ENUM_LABEL_30\\",
  ENUM_LABEL_31: \\"ENUM_LABEL_31\\",
  ENUM_LABEL_32: \\"ENUM_LABEL_32\\",
  ENUM_LABEL_33: \\"ENUM_LABEL_33\\",
  ENUM_LABEL_34: \\"ENUM_LABEL_34\\",
  ENUM_LABEL_35: \\"ENUM_LABEL_35\\",
  ENUM_LABEL_36: \\"ENUM_LABEL_36\\",
  ENUM_LABEL_37: \\"ENUM_LABEL_37\\",
  ENUM_LABEL_38: \\"ENUM_LABEL_38\\",
  ENUM_LABEL_39: \\"ENUM_LABEL_39\\",
  ENUM_LABEL_40: \\"ENUM_LABEL_40\\",
  ENUM_LABEL_41: \\"ENUM_LABEL_41\\",
  ENUM_LABEL_42: \\"ENUM_LABEL_42\\",
  ENUM_LABEL_43: \\"ENUM_LABEL_43\\",
  ENUM_LABEL_44: \\"ENUM_LABEL_44\\",
  ENUM_LABEL_45: \\"ENUM_LABEL_45\\",
  ENUM_LABEL_46: \\"ENUM_LABEL_46\\",
  ENUM_LABEL_47: \\"ENUM_LABEL_47\\",
  ENUM_LABEL_48: \\"ENUM_LABEL_48\\",
  ENUM_LABEL_49: \\"ENUM_LABEL_49\\",
  ENUM_LABEL_50: \\"ENUM_LABEL_50\\",
  ENUM_LABEL_51: \\"ENUM_LABEL_51\\",
  ENUM_LABEL_52: \\"ENUM_LABEL_52\\",
  ENUM_LABEL_53: \\"ENUM_LABEL_53\\",
  ENUM_LABEL_54: \\"ENUM_LABEL_54\\",
  ENUM_LABEL_55: \\"ENUM_LABEL_55\\",
  ENUM_LABEL_56: \\"ENUM_LABEL_56\\",
  ENUM_LABEL_57: \\"ENUM_LABEL_57\\",
  ENUM_LABEL_58: \\"ENUM_LABEL_58\\",
  ENUM_LABEL_59: \\"ENUM_LABEL_59\\",
  ENUM_LABEL_60: \\"ENUM_LABEL_60\\",
  ENUM_LABEL_61: \\"ENUM_LABEL_61\\",
  ENUM_LABEL_62: \\"ENUM_LABEL_62\\",
  ENUM_LABEL_63: \\"ENUM_LABEL_63\\",
  ENUM_LABEL_64: \\"ENUM_LABEL_64\\",
  ENUM_LABEL_65: \\"ENUM_LABEL_65\\",
  ENUM_LABEL_66: \\"ENUM_LABEL_66\\",
  ENUM_LABEL_67: \\"ENUM_LABEL_67\\",
  ENUM_LABEL_68: \\"ENUM_LABEL_68\\",
  ENUM_LABEL_69: \\"ENUM_LABEL_69\\",
  ENUM_LABEL_70: \\"ENUM_LABEL_70\\",
  ENUM_LABEL_71: \\"ENUM_LABEL_71\\",
  ENUM_LABEL_72: \\"ENUM_LABEL_72\\",
  ENUM_LABEL_73: \\"ENUM_LABEL_73\\",
  ENUM_LABEL_74: \\"ENUM_LABEL_74\\",
  ENUM_LABEL_75: \\"ENUM_LABEL_75\\",
  ENUM_LABEL_76: \\"ENUM_LABEL_76\\",
  ENUM_LABEL_77: \\"ENUM_LABEL_77\\",
  ENUM_LABEL_78: \\"ENUM_LABEL_78\\",
  ENUM_LABEL_79: \\"ENUM_LABEL_79\\",
  ENUM_LABEL_80: \\"ENUM_LABEL_80\\",
  ENUM_LABEL_81: \\"ENUM_LABEL_81\\",
  ENUM_LABEL_82: \\"ENUM_LABEL_82\\",
  ENUM_LABEL_83: \\"ENUM_LABEL_83\\",
  ENUM_LABEL_84: \\"ENUM_LABEL_84\\",
  ENUM_LABEL_85: \\"ENUM_LABEL_85\\",
  ENUM_LABEL_86: \\"ENUM_LABEL_86\\",
  ENUM_LABEL_87: \\"ENUM_LABEL_87\\",
  ENUM_LABEL_88: \\"ENUM_LABEL_88\\",
  ENUM_LABEL_89: \\"ENUM_LABEL_89\\",
  ENUM_LABEL_90: \\"ENUM_LABEL_90\\",
  ENUM_LABEL_91: \\"ENUM_LABEL_91\\",
  ENUM_LABEL_92: \\"ENUM_LABEL_92\\",
  ENUM_LABEL_93: \\"ENUM_LABEL_93\\",
  ENUM_LABEL_94: \\"ENUM_LABEL_94\\",
  ENUM_LABEL_95: \\"ENUM_LABEL_95\\",
  ENUM_LABEL_96: \\"ENUM_LABEL_96\\",
  ENUM_LABEL_97: \\"ENUM_LABEL_97\\",
  ENUM_LABEL_98: \\"ENUM_LABEL_98\\",
  ENUM_LABEL_99: \\"ENUM_LABEL_99\\",
  ENUM_LABEL_100: \\"ENUM_LABEL_100\\",
};

const VeryLargeEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"ENUM_LABEL_DEFAULT\\";
    }
    case 1: {
      return \\"ENUM_LABEL_1\\";
    }
    case 2: {
      return \\"ENUM_LABEL_2\\";
    }
    case 3: {
      return \\"ENUM_LABEL_3\\";
    }
    case 4: {
      return \\"ENUM_LABEL_4\\";
    }
    case 5: {
      return \\"ENUM_LABEL_5\\";
    }
    case 6: {
      return \\"ENUM_LABEL_6\\";
    }
    case 7: {
      return \\"ENUM_LABEL_7\\";
    }
    case 8: {
      return \\"ENUM_LABEL_8\\";
    }
    case 9: {
      return \\"ENUM_LABEL_9\\";
    }
    case 10: {
      return \\"ENUM_LABEL_10\\";
    }
    case 11: {
      return \\"ENUM_LABEL_11\\";
    }
    case 12: {
      return \\"ENUM_LABEL_12\\";
    }
    case 13: {
      return \\"ENUM_LABEL_13\\";
    }
    case 14: {
      return \\"ENUM_LABEL_14\\";
    }
    case 15: {
      return \\"ENUM_LABEL_15\\";
    }
    case 16: {
      return \\"ENUM_LABEL_16\\";
    }
    case 17: {
      return \\"ENUM_LABEL_17\\";
    }
    case 18: {
      return \\"ENUM_LABEL_18\\";
    }
    case 19: {
      return \\"ENUM_LABEL_19\\";
    }
    case 20: {
      return \\"ENUM_LABEL_20\\";
    }
    case 21: {
      return \\"ENUM_LABEL_21\\";
    }
    case 22: {
      return \\"ENUM_LABEL_22\\";
    }
    case 23: {
      return \\"ENUM_LABEL_23\\";
    }
    case 24: {
      return \\"ENUM_LABEL_24\\";
    }
    case 25: {
      return \\"ENUM_LABEL_25\\";
    }
    case 26: {
      return \\"ENUM_LABEL_26\\";
    }
    case 27: {
      return \\"ENUM_LABEL_27\\";
    }
    case 28: {
      return \\"ENUM_LABEL_28\\";
    }
    case 29: {
      return \\"ENUM_LABEL_29\\";
    }
    case 30: {
      return \\"ENUM_LABEL_30\\";
    }
    case 31: {
      return \\"ENUM_LABEL_31\\";
    }
    case 32: {
      return \\"ENUM_LABEL_32\\";
    }
    case 33: {
      return \\"ENUM_LABEL_33\\";
    }
    case 34: {
      return \\"ENUM_LABEL_34\\";
    }
    case 35: {
      return \\"ENUM_LABEL_35\\";
    }
    case 36: {
      return \\"ENUM_LABEL_36\\";
    }
    case 37: {
      return \\"ENUM_LABEL_37\\";
    }
    case 38: {
      return \\"ENUM_LABEL_38\\";
    }
    case 39: {
      return \\"ENUM_LABEL_39\\";
    }
    case 40: {
      return \\"ENUM_LABEL_40\\";
    }
    case 41: {
      return \\"ENUM_LABEL_41\\";
    }
    case 42: {
      return \\"ENUM_LABEL_42\\";
    }
    case 43: {
      return \\"ENUM_LABEL_43\\";
    }
    case 44: {
      return \\"ENUM_LABEL_44\\";
    }
    case 45: {
      return \\"ENUM_LABEL_45\\";
    }
    case 46: {
      return \\"ENUM_LABEL_46\\";
    }
    case 47: {
      return \\"ENUM_LABEL_47\\";
    }
    case 48: {
      return \\"ENUM_LABEL_48\\";
    }
    case 49: {
      return \\"ENUM_LABEL_49\\";
    }
    case 50: {
      return \\"ENUM_LABEL_50\\";
    }
    case 51: {
      return \\"ENUM_LABEL_51\\";
    }
    case 52: {
      return \\"ENUM_LABEL_52\\";
    }
    case 53: {
      return \\"ENUM_LABEL_53\\";
    }
    case 54: {
      return \\"ENUM_LABEL_54\\";
    }
    case 55: {
      return \\"ENUM_LABEL_55\\";
    }
    case 56: {
      return \\"ENUM_LABEL_56\\";
    }
    case 57: {
      return \\"ENUM_LABEL_57\\";
    }
    case 58: {
      return \\"ENUM_LABEL_58\\";
    }
    case 59: {
      return \\"ENUM_LABEL_59\\";
    }
    case 60: {
      return \\"ENUM_LABEL_60\\";
    }
    case 61: {
      return \\"ENUM_LABEL_61\\";
    }
    case 62: {
      return \\"ENUM_LABEL_62\\";
    }
    case 63: {
      return \\"ENUM_LABEL_63\\";
    }
    case 64: {
      return \\"ENUM_LABEL_64\\";
    }
    case 65: {
      return \\"ENUM_LABEL_65\\";
    }
    case 66: {
      return \\"ENUM_LABEL_66\\";
    }
    case 67: {
      return \\"ENUM_LABEL_67\\";
    }
    case 68: {
      return \\"ENUM_LABEL_68\\";
    }
    case 69: {
      return \\"ENUM_LABEL_69\\";
    }
    case 70: {
      return \\"ENUM_LABEL_70\\";
    }
    case 71: {
      return \\"ENUM_LABEL_71\\";
    }
    case 72: {
      return \\"ENUM_LABEL_72\\";
    }
    case 73: {
      return \\"ENUM_LABEL_73\\";
    }
    case 74: {
      return \\"ENUM_LABEL_74\\";
    }
    case 75: {
      return \\"ENUM_LABEL_75\\";
    }
    case 76: {
      return \\"ENUM_LABEL_76\\";
    }
    case 77: {
      return \\"ENUM_LABEL_77\\";
    }
    case 78: {
      return \\"ENUM_LABEL_78\\";
    }
    case 79: {
      return \\"ENUM_LABEL_79\\";
    }
    case 80: {
      return \\"ENUM_LABEL_80\\";
    }
    case 81: {
      return \\"ENUM_LABEL_81\\";
    }
    case 82: {
      return \\"ENUM_LABEL_82\\";
    }
    case 83: {
      return \\"ENUM_LABEL_83\\";
    }
    case 84: {
      return \\"ENUM_LABEL_84\\";
    }
    case 85: {
      return \\"ENUM_LABEL_85\\";
    }
    case 86: {
      return \\"ENUM_LABEL_86\\";
    }
    case 87: {
      return \\"ENUM_LABEL_87\\";
    }
    case 88: {
      return \\"ENUM_LABEL_88\\";
    }
    case 89: {
      return \\"ENUM_LABEL_89\\";
    }
    case 90: {
      return \\"ENUM_LABEL_90\\";
    }
    case 91: {
      return \\"ENUM_LABEL_91\\";
    }
    case 92: {
      return \\"ENUM_LABEL_92\\";
    }
    case 93: {
      return \\"ENUM_LABEL_93\\";
    }
    case 94: {
      return \\"ENUM_LABEL_94\\";
    }
    case 95: {
      return \\"ENUM_LABEL_95\\";
    }
    case 96: {
      return \\"ENUM_LABEL_96\\";
    }
    case 97: {
      return \\"ENUM_LABEL_97\\";
    }
    case 98: {
      return \\"ENUM_LABEL_98\\";
    }
    case 99: {
      return \\"ENUM_LABEL_99\\";
    }
    case 100: {
      return \\"ENUM_LABEL_100\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const VeryLargeEnumToInt = function (i) {
  switch (i) {
    case \\"ENUM_LABEL_DEFAULT\\": {
      return 0;
    }
    case \\"ENUM_LABEL_1\\": {
      return 1;
    }
    case \\"ENUM_LABEL_2\\": {
      return 2;
    }
    case \\"ENUM_LABEL_3\\": {
      return 3;
    }
    case \\"ENUM_LABEL_4\\": {
      return 4;
    }
    case \\"ENUM_LABEL_5\\": {
      return 5;
    }
    case \\"ENUM_LABEL_6\\": {
      return 6;
    }
    case \\"ENUM_LABEL_7\\": {
      return 7;
    }
    case \\"ENUM_LABEL_8\\": {
      return 8;
    }
    case \\"ENUM_LABEL_9\\": {
      return 9;
    }
    case \\"ENUM_LABEL_10\\": {
      return 10;
    }
    case \\"ENUM_LABEL_11\\": {
      return 11;
    }
    case \\"ENUM_LABEL_12\\": {
      return 12;
    }
    case \\"ENUM_LABEL_13\\": {
      return 13;
    }
    case \\"ENUM_LABEL_14\\": {
      return 14;
    }
    case \\"ENUM_LABEL_15\\": {
      return 15;
    }
    case \\"ENUM_LABEL_16\\": {
      return 16;
    }
    case \\"ENUM_LABEL_17\\": {
      return 17;
    }
    case \\"ENUM_LABEL_18\\": {
      return 18;
    }
    case \\"ENUM_LABEL_19\\": {
      return 19;
    }
    case \\"ENUM_LABEL_20\\": {
      return 20;
    }
    case \\"ENUM_LABEL_21\\": {
      return 21;
    }
    case \\"ENUM_LABEL_22\\": {
      return 22;
    }
    case \\"ENUM_LABEL_23\\": {
      return 23;
    }
    case \\"ENUM_LABEL_24\\": {
      return 24;
    }
    case \\"ENUM_LABEL_25\\": {
      return 25;
    }
    case \\"ENUM_LABEL_26\\": {
      return 26;
    }
    case \\"ENUM_LABEL_27\\": {
      return 27;
    }
    case \\"ENUM_LABEL_28\\": {
      return 28;
    }
    case \\"ENUM_LABEL_29\\": {
      return 29;
    }
    case \\"ENUM_LABEL_30\\": {
      return 30;
    }
    case \\"ENUM_LABEL_31\\": {
      return 31;
    }
    case \\"ENUM_LABEL_32\\": {
      return 32;
    }
    case \\"ENUM_LABEL_33\\": {
      return 33;
    }
    case \\"ENUM_LABEL_34\\": {
      return 34;
    }
    case \\"ENUM_LABEL_35\\": {
      return 35;
    }
    case \\"ENUM_LABEL_36\\": {
      return 36;
    }
    case \\"ENUM_LABEL_37\\": {
      return 37;
    }
    case \\"ENUM_LABEL_38\\": {
      return 38;
    }
    case \\"ENUM_LABEL_39\\": {
      return 39;
    }
    case \\"ENUM_LABEL_40\\": {
      return 40;
    }
    case \\"ENUM_LABEL_41\\": {
      return 41;
    }
    case \\"ENUM_LABEL_42\\": {
      return 42;
    }
    case \\"ENUM_LABEL_43\\": {
      return 43;
    }
    case \\"ENUM_LABEL_44\\": {
      return 44;
    }
    case \\"ENUM_LABEL_45\\": {
      return 45;
    }
    case \\"ENUM_LABEL_46\\": {
      return 46;
    }
    case \\"ENUM_LABEL_47\\": {
      return 47;
    }
    case \\"ENUM_LABEL_48\\": {
      return 48;
    }
    case \\"ENUM_LABEL_49\\": {
      return 49;
    }
    case \\"ENUM_LABEL_50\\": {
      return 50;
    }
    case \\"ENUM_LABEL_51\\": {
      return 51;
    }
    case \\"ENUM_LABEL_52\\": {
      return 52;
    }
    case \\"ENUM_LABEL_53\\": {
      return 53;
    }
    case \\"ENUM_LABEL_54\\": {
      return 54;
    }
    case \\"ENUM_LABEL_55\\": {
      return 55;
    }
    case \\"ENUM_LABEL_56\\": {
      return 56;
    }
    case \\"ENUM_LABEL_57\\": {
      return 57;
    }
    case \\"ENUM_LABEL_58\\": {
      return 58;
    }
    case \\"ENUM_LABEL_59\\": {
      return 59;
    }
    case \\"ENUM_LABEL_60\\": {
      return 60;
    }
    case \\"ENUM_LABEL_61\\": {
      return 61;
    }
    case \\"ENUM_LABEL_62\\": {
      return 62;
    }
    case \\"ENUM_LABEL_63\\": {
      return 63;
    }
    case \\"ENUM_LABEL_64\\": {
      return 64;
    }
    case \\"ENUM_LABEL_65\\": {
      return 65;
    }
    case \\"ENUM_LABEL_66\\": {
      return 66;
    }
    case \\"ENUM_LABEL_67\\": {
      return 67;
    }
    case \\"ENUM_LABEL_68\\": {
      return 68;
    }
    case \\"ENUM_LABEL_69\\": {
      return 69;
    }
    case \\"ENUM_LABEL_70\\": {
      return 70;
    }
    case \\"ENUM_LABEL_71\\": {
      return 71;
    }
    case \\"ENUM_LABEL_72\\": {
      return 72;
    }
    case \\"ENUM_LABEL_73\\": {
      return 73;
    }
    case \\"ENUM_LABEL_74\\": {
      return 74;
    }
    case \\"ENUM_LABEL_75\\": {
      return 75;
    }
    case \\"ENUM_LABEL_76\\": {
      return 76;
    }
    case \\"ENUM_LABEL_77\\": {
      return 77;
    }
    case \\"ENUM_LABEL_78\\": {
      return 78;
    }
    case \\"ENUM_LABEL_79\\": {
      return 79;
    }
    case \\"ENUM_LABEL_80\\": {
      return 80;
    }
    case \\"ENUM_LABEL_81\\": {
      return 81;
    }
    case \\"ENUM_LABEL_82\\": {
      return 82;
    }
    case \\"ENUM_LABEL_83\\": {
      return 83;
    }
    case \\"ENUM_LABEL_84\\": {
      return 84;
    }
    case \\"ENUM_LABEL_85\\": {
      return 85;
    }
    case \\"ENUM_LABEL_86\\": {
      return 86;
    }
    case \\"ENUM_LABEL_87\\": {
      return 87;
    }
    case \\"ENUM_LABEL_88\\": {
      return 88;
    }
    case \\"ENUM_LABEL_89\\": {
      return 89;
    }
    case \\"ENUM_LABEL_90\\": {
      return 90;
    }
    case \\"ENUM_LABEL_91\\": {
      return 91;
    }
    case \\"ENUM_LABEL_92\\": {
      return 92;
    }
    case \\"ENUM_LABEL_93\\": {
      return 93;
    }
    case \\"ENUM_LABEL_94\\": {
      return 94;
    }
    case \\"ENUM_LABEL_95\\": {
      return 95;
    }
    case \\"ENUM_LABEL_96\\": {
      return 96;
    }
    case \\"ENUM_LABEL_97\\": {
      return 97;
    }
    case \\"ENUM_LABEL_98\\": {
      return 98;
    }
    case \\"ENUM_LABEL_99\\": {
      return 99;
    }
    case \\"ENUM_LABEL_100\\": {
      return 100;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalImportEnum: ImportEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      defaultForeignEnum: ForeignEnumFromInt(0),
      defaultImportEnum: ImportEnumFromInt(0),
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      writer.writeEnum(23, ImportEnumToInt(msg.optionalImportEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum.map(ImportEnumToInt));
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(81, TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum));
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnumToInt(msg.defaultForeignEnum));
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      writer.writeEnum(83, ImportEnumToInt(msg.defaultImportEnum));
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json.defaultBytes = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(ImportEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (_optionalImportEnum) {
      msg.optionalImportEnum = _optionalImportEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (_repeatedImportEnum) {
      msg.repeatedImportEnum = _repeatedImportEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (_defaultInt32) {
      msg.defaultInt32 = _defaultInt32;
    }
    const _defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (_defaultInt64) {
      msg.defaultInt64 = BigInt(_defaultInt64);
    }
    const _defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (_defaultUint32) {
      msg.defaultUint32 = _defaultUint32;
    }
    const _defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (_defaultUint64) {
      msg.defaultUint64 = BigInt(_defaultUint64);
    }
    const _defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (_defaultSint32) {
      msg.defaultSint32 = _defaultSint32;
    }
    const _defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (_defaultSint64) {
      msg.defaultSint64 = BigInt(_defaultSint64);
    }
    const _defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (_defaultFixed32) {
      msg.defaultFixed32 = _defaultFixed32;
    }
    const _defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (_defaultFixed64) {
      msg.defaultFixed64 = BigInt(_defaultFixed64);
    }
    const _defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (_defaultSfixed32) {
      msg.defaultSfixed32 = _defaultSfixed32;
    }
    const _defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (_defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64);
    }
    const _defaultFloat = json.defaultFloat ?? json.default_float;
    if (_defaultFloat) {
      msg.defaultFloat = _defaultFloat;
    }
    const _defaultDouble = json.defaultDouble ?? json.default_double;
    if (_defaultDouble) {
      msg.defaultDouble = _defaultDouble;
    }
    const _defaultBool = json.defaultBool ?? json.default_bool;
    if (_defaultBool) {
      msg.defaultBool = _defaultBool;
    }
    const _defaultString = json.defaultString ?? json.default_string;
    if (_defaultString) {
      msg.defaultString = _defaultString;
    }
    const _defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (_defaultBytes) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes);
    }
    const _defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (_defaultNestedEnum) {
      msg.defaultNestedEnum = _defaultNestedEnum;
    }
    const _defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (_defaultForeignEnum) {
      msg.defaultForeignEnum = _defaultForeignEnum;
    }
    const _defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (_defaultImportEnum) {
      msg.defaultImportEnum = _defaultImportEnum;
    }
    const _defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (_defaultStringPiece) {
      msg.defaultStringPiece = _defaultStringPiece;
    }
    const _defaultCord = json.defaultCord ?? json.default_cord;
    if (_defaultCord) {
      msg.defaultCord = _defaultCord;
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.RepeatedGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    const _repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (_repeatedChild) {
      for (const item of _repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (msg) {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDeprecatedFields._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json) {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (_deprecatedInt32) {
      msg.deprecatedInt32 = _deprecatedInt32;
    }
    const _deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (_deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (msg) {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OptionalGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (msg) {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(RepeatedGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (msg) {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestGroup._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json) {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestGroup.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (msg) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (msg) {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestChildExtension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json) {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _optionalExtension =
      json.optionalExtension ?? json.optional_extension;
    if (_optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, _optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (msg) {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequired._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json) {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _dummy2 = json.dummy2;
    if (_dummy2) {
      msg.dummy2 = _dummy2;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _dummy4 = json.dummy4;
    if (_dummy4) {
      msg.dummy4 = _dummy4;
    }
    const _dummy5 = json.dummy5;
    if (_dummy5) {
      msg.dummy5 = _dummy5;
    }
    const _dummy6 = json.dummy6;
    if (_dummy6) {
      msg.dummy6 = _dummy6;
    }
    const _dummy7 = json.dummy7;
    if (_dummy7) {
      msg.dummy7 = _dummy7;
    }
    const _dummy8 = json.dummy8;
    if (_dummy8) {
      msg.dummy8 = _dummy8;
    }
    const _dummy9 = json.dummy9;
    if (_dummy9) {
      msg.dummy9 = _dummy9;
    }
    const _dummy10 = json.dummy10;
    if (_dummy10) {
      msg.dummy10 = _dummy10;
    }
    const _dummy11 = json.dummy11;
    if (_dummy11) {
      msg.dummy11 = _dummy11;
    }
    const _dummy12 = json.dummy12;
    if (_dummy12) {
      msg.dummy12 = _dummy12;
    }
    const _dummy13 = json.dummy13;
    if (_dummy13) {
      msg.dummy13 = _dummy13;
    }
    const _dummy14 = json.dummy14;
    if (_dummy14) {
      msg.dummy14 = _dummy14;
    }
    const _dummy15 = json.dummy15;
    if (_dummy15) {
      msg.dummy15 = _dummy15;
    }
    const _dummy16 = json.dummy16;
    if (_dummy16) {
      msg.dummy16 = _dummy16;
    }
    const _dummy17 = json.dummy17;
    if (_dummy17) {
      msg.dummy17 = _dummy17;
    }
    const _dummy18 = json.dummy18;
    if (_dummy18) {
      msg.dummy18 = _dummy18;
    }
    const _dummy19 = json.dummy19;
    if (_dummy19) {
      msg.dummy19 = _dummy19;
    }
    const _dummy20 = json.dummy20;
    if (_dummy20) {
      msg.dummy20 = _dummy20;
    }
    const _dummy21 = json.dummy21;
    if (_dummy21) {
      msg.dummy21 = _dummy21;
    }
    const _dummy22 = json.dummy22;
    if (_dummy22) {
      msg.dummy22 = _dummy22;
    }
    const _dummy23 = json.dummy23;
    if (_dummy23) {
      msg.dummy23 = _dummy23;
    }
    const _dummy24 = json.dummy24;
    if (_dummy24) {
      msg.dummy24 = _dummy24;
    }
    const _dummy25 = json.dummy25;
    if (_dummy25) {
      msg.dummy25 = _dummy25;
    }
    const _dummy26 = json.dummy26;
    if (_dummy26) {
      msg.dummy26 = _dummy26;
    }
    const _dummy27 = json.dummy27;
    if (_dummy27) {
      msg.dummy27 = _dummy27;
    }
    const _dummy28 = json.dummy28;
    if (_dummy28) {
      msg.dummy28 = _dummy28;
    }
    const _dummy29 = json.dummy29;
    if (_dummy29) {
      msg.dummy29 = _dummy29;
    }
    const _dummy30 = json.dummy30;
    if (_dummy30) {
      msg.dummy30 = _dummy30;
    }
    const _dummy31 = json.dummy31;
    if (_dummy31) {
      msg.dummy31 = _dummy31;
    }
    const _dummy32 = json.dummy32;
    if (_dummy32) {
      msg.dummy32 = _dummy32;
    }
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (msg) {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredForeign._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage = json.requiredMessage ?? json.required_message;
    if (_requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (msg) {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestForeignNested._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json) {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _foreignNested = json.foreignNested ?? json.foreign_nested;
    if (_foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (msg) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            msg
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (json) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _cc = json.cc;
        if (_cc) {
          msg.cc = _cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg) {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestReallyLargeTagNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _bb = json.bb;
    if (_bb) {
      msg.bb = _bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRecursiveMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _i = json.i;
    if (_i) {
      msg.i = _i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMutualRecursionA._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _bb = json.bb;
    if (_bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, _bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _b = json.b;
      if (_b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, _b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _subMessage = json.subMessage ?? json.sub_message;
      if (_subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, _subMessage);
        msg.subMessage = m;
      }
      const _notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (_notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMutualRecursionB._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (msg) {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestIsInitialized._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json) {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (_msg) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes) {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */
    encodeJSON: function (_msg) {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */
    decodeJSON: function (_json) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (msg) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (json) {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _i = json.i;
        if (_i) {
          msg.i = _i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (msg) {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDupFieldNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (msg) {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (msg) {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg) {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestNestedMessageHasBits._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json) {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (_nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32;
      }
      const _nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (_nestedmessageRepeatedForeignmessage) {
        for (const item of _nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg) {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestCamelCaseFieldNames._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json) {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: ForeignEnumFromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnumToInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField.map(ForeignEnumToInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _PrimitiveField = json.PrimitiveField;
    if (_PrimitiveField) {
      msg.PrimitiveField = _PrimitiveField;
    }
    const _StringField = json.StringField;
    if (_StringField) {
      msg.StringField = _StringField;
    }
    const _EnumField = json.EnumField;
    if (_EnumField) {
      msg.EnumField = _EnumField;
    }
    const _MessageField = json.MessageField;
    if (_MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _MessageField);
      msg.MessageField = m;
    }
    const _StringPieceField = json.StringPieceField;
    if (_StringPieceField) {
      msg.StringPieceField = _StringPieceField;
    }
    const _CordField = json.CordField;
    if (_CordField) {
      msg.CordField = _CordField;
    }
    const _RepeatedPrimitiveField = json.RepeatedPrimitiveField;
    if (_RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField;
    }
    const _RepeatedStringField = json.RepeatedStringField;
    if (_RepeatedStringField) {
      msg.RepeatedStringField = _RepeatedStringField;
    }
    const _RepeatedEnumField = json.RepeatedEnumField;
    if (_RepeatedEnumField) {
      msg.RepeatedEnumField = _RepeatedEnumField;
    }
    const _RepeatedMessageField = json.RepeatedMessageField;
    if (_RepeatedMessageField) {
      for (const item of _RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField = json.RepeatedStringPieceField;
    if (_RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField;
    }
    const _RepeatedCordField = json.RepeatedCordField;
    if (_RepeatedCordField) {
      msg.RepeatedCordField = _RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (msg) {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestFieldOrderings._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json) {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    const _myInt = json.myInt ?? json.my_int;
    if (_myInt) {
      msg.myInt = BigInt(_myInt);
    }
    const _myFloat = json.myFloat ?? json.my_float;
    if (_myFloat) {
      msg.myFloat = _myFloat;
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _oo = json.oo;
      if (_oo) {
        msg.oo = BigInt(_oo);
      }
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionOrderings1._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionOrderings2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (msg) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (json) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _myString = json.myString ?? json.my_string;
      if (_myString) {
        msg.myString = _myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg) {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtremeDefaultValues._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json) {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.escapedBytes?.length) {
      json.escapedBytes = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json.bytesWithZero = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (_escapedBytes) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes);
    }
    const _largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (_largeUint32) {
      msg.largeUint32 = _largeUint32;
    }
    const _largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (_largeUint64) {
      msg.largeUint64 = BigInt(_largeUint64);
    }
    const _smallInt32 = json.smallInt32 ?? json.small_int32;
    if (_smallInt32) {
      msg.smallInt32 = _smallInt32;
    }
    const _smallInt64 = json.smallInt64 ?? json.small_int64;
    if (_smallInt64) {
      msg.smallInt64 = BigInt(_smallInt64);
    }
    const _reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (_reallySmallInt32) {
      msg.reallySmallInt32 = _reallySmallInt32;
    }
    const _reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (_reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64);
    }
    const _utf8String = json.utf8String ?? json.utf8_string;
    if (_utf8String) {
      msg.utf8String = _utf8String;
    }
    const _zeroFloat = json.zeroFloat ?? json.zero_float;
    if (_zeroFloat) {
      msg.zeroFloat = _zeroFloat;
    }
    const _oneFloat = json.oneFloat ?? json.one_float;
    if (_oneFloat) {
      msg.oneFloat = _oneFloat;
    }
    const _smallFloat = json.smallFloat ?? json.small_float;
    if (_smallFloat) {
      msg.smallFloat = _smallFloat;
    }
    const _negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (_negativeOneFloat) {
      msg.negativeOneFloat = _negativeOneFloat;
    }
    const _negativeFloat = json.negativeFloat ?? json.negative_float;
    if (_negativeFloat) {
      msg.negativeFloat = _negativeFloat;
    }
    const _largeFloat = json.largeFloat ?? json.large_float;
    if (_largeFloat) {
      msg.largeFloat = _largeFloat;
    }
    const _smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (_smallNegativeFloat) {
      msg.smallNegativeFloat = _smallNegativeFloat;
    }
    const _infDouble = json.infDouble ?? json.inf_double;
    if (_infDouble) {
      msg.infDouble = _infDouble;
    }
    const _negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (_negInfDouble) {
      msg.negInfDouble = _negInfDouble;
    }
    const _nanDouble = json.nanDouble ?? json.nan_double;
    if (_nanDouble) {
      msg.nanDouble = _nanDouble;
    }
    const _infFloat = json.infFloat ?? json.inf_float;
    if (_infFloat) {
      msg.infFloat = _infFloat;
    }
    const _negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (_negInfFloat) {
      msg.negInfFloat = _negInfFloat;
    }
    const _nanFloat = json.nanFloat ?? json.nan_float;
    if (_nanFloat) {
      msg.nanFloat = _nanFloat;
    }
    const _cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (_cppTrigraph) {
      msg.cppTrigraph = _cppTrigraph;
    }
    const _stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (_stringWithZero) {
      msg.stringWithZero = _stringWithZero;
    }
    const _bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (_bytesWithZero) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero);
    }
    const _stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (_stringPieceWithZero) {
      msg.stringPieceWithZero = _stringPieceWithZero;
    }
    const _cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (_cordWithZero) {
      msg.cordWithZero = _cordWithZero;
    }
    const _replacementString =
      json.replacementString ?? json.replacement_string;
    if (_replacementString) {
      msg.replacementString = _replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (msg) {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(SparseEnumMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json) {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnumToInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (_sparseEnum) {
      msg.sparseEnum = _sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (msg) {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json) {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (msg) {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MoreString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json) {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (msg) {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json) {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = decodeBase64Bytes(_data);
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (msg) {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MoreBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json) {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (msg) {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json) {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (msg) {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Uint32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (msg) {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json) {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (msg) {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Uint64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (msg) {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BoolMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json) {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (msg) {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg) {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneofBackwardsCompatible._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json) {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnumToInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json.fooBytes = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json.barBytes = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json.barBytesWithEmptyDefault = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooCord = json.fooCord ?? json.foo_cord;
    if (_fooCord) {
      msg.fooCord = _fooCord;
    }
    const _fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (_fooStringPiece) {
      msg.fooStringPiece = _fooStringPiece;
    }
    const _fooBytes = json.fooBytes ?? json.foo_bytes;
    if (_fooBytes) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes);
    }
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    const _fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (_fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const _barInt = json.barInt ?? json.bar_int;
    if (_barInt) {
      msg.barInt = _barInt;
    }
    const _barString = json.barString ?? json.bar_string;
    if (_barString) {
      msg.barString = _barString;
    }
    const _barCord = json.barCord ?? json.bar_cord;
    if (_barCord) {
      msg.barCord = _barCord;
    }
    const _barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (_barStringPiece) {
      msg.barStringPiece = _barStringPiece;
    }
    const _barBytes = json.barBytes ?? json.bar_bytes;
    if (_barBytes) {
      msg.barBytes = decodeBase64Bytes(_barBytes);
    }
    const _barEnum = json.barEnum ?? json.bar_enum;
    if (_barEnum) {
      msg.barEnum = _barEnum;
    }
    const _barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (_barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault;
    }
    const _barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (_barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault;
    }
    const _barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (_barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault;
    }
    const _barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (_barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault
      );
    }
    const _bazInt = json.bazInt ?? json.baz_int;
    if (_bazInt) {
      msg.bazInt = _bazInt;
    }
    const _bazString = json.bazString ?? json.baz_string;
    if (_bazString) {
      msg.bazString = _bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof2.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _quxInt = json.quxInt ?? json.qux_int;
      if (_quxInt) {
        msg.quxInt = BigInt(_quxInt);
      }
      const _corgeInt = json.corgeInt ?? json.corge_int;
      if (_corgeInt) {
        msg.corgeInt = _corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (msg) {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _requiredDouble = json.requiredDouble ?? json.required_double;
      if (_requiredDouble) {
        msg.requiredDouble = _requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (_unpackedInt32) {
      msg.unpackedInt32 = _unpackedInt32;
    }
    const _unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (_unpackedInt64) {
      msg.unpackedInt64 = _unpackedInt64.map(BigInt);
    }
    const _unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (_unpackedUint32) {
      msg.unpackedUint32 = _unpackedUint32;
    }
    const _unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (_unpackedUint64) {
      msg.unpackedUint64 = _unpackedUint64.map(BigInt);
    }
    const _unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (_unpackedSint32) {
      msg.unpackedSint32 = _unpackedSint32;
    }
    const _unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (_unpackedSint64) {
      msg.unpackedSint64 = _unpackedSint64.map(BigInt);
    }
    const _unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (_unpackedFixed32) {
      msg.unpackedFixed32 = _unpackedFixed32;
    }
    const _unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (_unpackedFixed64) {
      msg.unpackedFixed64 = _unpackedFixed64.map(BigInt);
    }
    const _unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (_unpackedSfixed32) {
      msg.unpackedSfixed32 = _unpackedSfixed32;
    }
    const _unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (_unpackedSfixed64) {
      msg.unpackedSfixed64 = _unpackedSfixed64.map(BigInt);
    }
    const _unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (_unpackedFloat) {
      msg.unpackedFloat = _unpackedFloat;
    }
    const _unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (_unpackedDouble) {
      msg.unpackedDouble = _unpackedDouble;
    }
    const _unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (_unpackedBool) {
      msg.unpackedBool = _unpackedBool;
    }
    const _unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (_unpackedEnum) {
      msg.unpackedEnum = _unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (msg) {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDynamicExtensions._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json) {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnumFromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumTypeFromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnumToInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      json.enumExtension = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumTypeFromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (_scalarExtension) {
      msg.scalarExtension = _scalarExtension;
    }
    const _enumExtension = json.enumExtension ?? json.enum_extension;
    if (_enumExtension) {
      msg.enumExtension = _enumExtension;
    }
    const _dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (_dynamicEnumExtension) {
      msg.dynamicEnumExtension = _dynamicEnumExtension;
    }
    const _messageExtension = json.messageExtension ?? json.message_extension;
    if (_messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _messageExtension);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (_dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        _dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension =
      json.repeatedExtension ?? json.repeated_extension;
    if (_repeatedExtension) {
      msg.repeatedExtension = _repeatedExtension;
    }
    const _packedExtension = json.packedExtension ?? json.packed_extension;
    if (_packedExtension) {
      msg.packedExtension = _packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: \\"DYNAMIC_FOO\\",
    DYNAMIC_BAR: \\"DYNAMIC_BAR\\",
    DYNAMIC_BAZ: \\"DYNAMIC_BAZ\\",
  },

  DynamicEnumTypeFromInt: function (i) {
    switch (i) {
      case 2200: {
        return \\"DYNAMIC_FOO\\";
      }
      case 2201: {
        return \\"DYNAMIC_BAR\\";
      }
      case 2202: {
        return \\"DYNAMIC_BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  DynamicEnumTypeToInt: function (i) {
    switch (i) {
      case \\"DYNAMIC_FOO\\": {
        return 2200;
      }
      case \\"DYNAMIC_BAR\\": {
        return 2201;
      }
      case \\"DYNAMIC_BAZ\\": {
        return 2202;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (msg) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (json) {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _dynamicField = json.dynamicField ?? json.dynamic_field;
      if (_dynamicField) {
        msg.dynamicField = _dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (msg) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json) {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (msg) {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json) {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (_requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (_optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (_repeatedAllTypes) {
      for (const item of _repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _field1 = json.field1;
      if (_field1) {
        for (const item of _field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const _field2 = json.field2;
      if (_field2) {
        for (const item of _field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const _field3 = json.field3;
      if (_field3) {
        for (const item of _field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1 = json.ext1;
      if (_ext1) {
        for (const item of _ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2 = json.ext2;
      if (_ext2) {
        for (const item of _ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (_optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (_repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg) {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestCommentInjectionMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (msg) {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestJsonName._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json) {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fieldName1 = json.fieldName1 ?? json.field_name1;
    if (_fieldName1) {
      msg.fieldName1 = _fieldName1;
    }
    const _fieldName2 = json.fieldName2;
    if (_fieldName2) {
      msg.fieldName2 = _fieldName2;
    }
    const _FieldName3 = json.FieldName3;
    if (_FieldName3) {
      msg.FieldName3 = _FieldName3;
    }
    const _FieldName4 = json.FieldName4 ?? json._field_name4;
    if (_FieldName4) {
      msg.FieldName4 = _FieldName4;
    }
    const _FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (_FIELDNAME5) {
      msg.FIELDNAME5 = _FIELDNAME5;
    }
    const _fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (_fieldName6) {
      msg.fieldName6 = _fieldName6;
    }
    const _fieldname7 = json.fieldname7;
    if (_fieldname7) {
      msg.fieldname7 = _fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg) {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestHugeFieldNumbers._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json) {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnumFromInt(0),
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnumToInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      const stringStringMap = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringStringMap).length > 0) {
        json.stringStringMap = stringStringMap;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const stringStringMap = {};
          reader.readMessage(
            stringStringMap,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[stringStringMap.key] = stringStringMap.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _fixed32 = json.fixed32 ?? json.fixed_32;
    if (_fixed32) {
      msg.fixed32 = _fixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (_optionalEnum) {
      msg.optionalEnum = _optionalEnum;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (_stringStringMap) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (_oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _groupA = json.groupA ?? json.group_a;
      if (_groupA) {
        msg.groupA = _groupA;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (msg) {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionInsideTable._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _field1 = json.field1;
    if (_field1) {
      msg.field1 = _field1;
    }
    const _field2 = json.field2;
    if (_field2) {
      msg.field2 = _field2;
    }
    const _field3 = json.field3;
    if (_field3) {
      msg.field3 = _field3;
    }
    const _field4 = json.field4;
    if (_field4) {
      msg.field4 = _field4;
    }
    const _field6 = json.field6;
    if (_field6) {
      msg.field6 = _field6;
    }
    const _field7 = json.field7;
    if (_field7) {
      msg.field7 = _field7;
    }
    const _field8 = json.field8;
    if (_field8) {
      msg.field8 = _field8;
    }
    const _field9 = json.field9;
    if (_field9) {
      msg.field9 = _field9;
    }
    const _field10 = json.field10;
    if (_field10) {
      msg.field10 = _field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg) {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionRangeSerialize._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooOne = json.fooOne ?? json.foo_one;
    if (_fooOne) {
      msg.fooOne = _fooOne;
    }
    const _fooTwo = json.fooTwo ?? json.foo_two;
    if (_fooTwo) {
      msg.fooTwo = _fooTwo;
    }
    const _fooThree = json.fooThree ?? json.foo_three;
    if (_fooThree) {
      msg.fooThree = _fooThree;
    }
    const _fooFour = json.fooFour ?? json.foo_four;
    if (_fooFour) {
      msg.fooFour = _fooFour;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: \\"MAP_ENUM_FOO\\",
  MAP_ENUM_BAR: \\"MAP_ENUM_BAR\\",
  MAP_ENUM_BAZ: \\"MAP_ENUM_BAZ\\",
};

const MapEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"MAP_ENUM_FOO\\";
    }
    case 1: {
      return \\"MAP_ENUM_BAR\\";
    }
    case 2: {
      return \\"MAP_ENUM_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const MapEnumToInt = function (i) {
  switch (i) {
    case \\"MAP_ENUM_FOO\\": {
      return 0;
    }
    case \\"MAP_ENUM_BAR\\": {
      return 1;
    }
    case \\"MAP_ENUM_BAZ\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (msg) {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    if (msg.mapStringForeignMessage) {
      const mapStringForeignMessage = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringForeignMessage).length > 0) {
        json.mapStringForeignMessage = mapStringForeignMessage;
      }
    }
    if (msg.mapInt32AllTypes) {
      const mapInt32AllTypes = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32AllTypes).length > 0) {
        json.mapInt32AllTypes = mapInt32AllTypes;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {};
          reader.readMessage(mapInt32Int32, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {};
          reader.readMessage(mapInt64Int64, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {};
          reader.readMessage(
            mapUint32Uint32,
            TestMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {};
          reader.readMessage(
            mapUint64Uint64,
            TestMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {};
          reader.readMessage(
            mapSint32Sint32,
            TestMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {};
          reader.readMessage(
            mapSint64Sint64,
            TestMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {};
          reader.readMessage(
            mapFixed32Fixed32,
            TestMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {};
          reader.readMessage(
            mapFixed64Fixed64,
            TestMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 = {};
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 = {};
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {};
          reader.readMessage(mapInt32Float, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {};
          reader.readMessage(
            mapInt32Double,
            TestMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {};
          reader.readMessage(mapBoolBool, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {};
          reader.readMessage(
            mapStringString,
            TestMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {};
          reader.readMessage(mapInt32Bytes, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {};
          reader.readMessage(mapInt32Enum, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage = {};
          reader.readMessage(
            mapInt32ForeignMessage,
            TestMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        case 18: {
          const mapStringForeignMessage = {};
          reader.readMessage(
            mapStringForeignMessage,
            TestMap.MapStringForeignMessage._readMessage
          );
          msg.mapStringForeignMessage[mapStringForeignMessage.key] =
            mapStringForeignMessage.value;
          break;
        }
        case 19: {
          const mapInt32AllTypes = {};
          reader.readMessage(
            mapInt32AllTypes,
            TestMap.MapInt32AllTypes._readMessage
          );
          msg.mapInt32AllTypes[mapInt32AllTypes.key] = mapInt32AllTypes.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (_mapStringForeignMessage) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (_mapInt32AllTypes) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (msg) {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMapSubmessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json) {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _testMap = json.testMap ?? json.test_map;
    if (_testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, _testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      const mapInt32Message = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Message).length > 0) {
        json.mapInt32Message = mapInt32Message;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Message = {};
          reader.readMessage(
            mapInt32Message,
            TestMessageMap.MapInt32Message._readMessage
          );
          msg.mapInt32Message[mapInt32Message.key] = mapInt32Message.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (_mapInt32Message) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (msg) {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json) {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.map1) {
      const map1 = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map1).length > 0) {
        json.map1 = map1;
      }
    }
    if (msg.map2) {
      const map2 = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map2).length > 0) {
        json.map2 = map2;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map1 = {};
          reader.readMessage(map1, TestSameTypeMap.Map1._readMessage);
          msg.map1[map1.key] = map1.value;
          break;
        }
        case 2: {
          const map2 = {};
          reader.readMessage(map2, TestSameTypeMap.Map2._readMessage);
          msg.map2[map2.key] = map2.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _map1 = json.map1;
    if (_map1) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2 = json.map2;
    if (_map2) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapField) {
      const mapField = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapField).length > 0) {
        json.mapField = mapField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapField = {};
          reader.readMessage(
            mapField,
            TestRequiredMessageMap.MapField._readMessage
          );
          msg.mapField[mapField.key] = mapField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapField = json.mapField ?? json.map_field;
    if (_mapField) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestRequired._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRequired._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (msg) {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestArenaMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json) {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {};
          reader.readMessage(
            mapInt32Int32,
            TestArenaMap.MapInt32Int32._readMessage
          );
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {};
          reader.readMessage(
            mapInt64Int64,
            TestArenaMap.MapInt64Int64._readMessage
          );
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {};
          reader.readMessage(
            mapUint32Uint32,
            TestArenaMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {};
          reader.readMessage(
            mapUint64Uint64,
            TestArenaMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {};
          reader.readMessage(
            mapSint32Sint32,
            TestArenaMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {};
          reader.readMessage(
            mapSint64Sint64,
            TestArenaMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {};
          reader.readMessage(
            mapFixed32Fixed32,
            TestArenaMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {};
          reader.readMessage(
            mapFixed64Fixed64,
            TestArenaMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 = {};
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 = {};
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {};
          reader.readMessage(
            mapInt32Float,
            TestArenaMap.MapInt32Float._readMessage
          );
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {};
          reader.readMessage(
            mapInt32Double,
            TestArenaMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {};
          reader.readMessage(
            mapBoolBool,
            TestArenaMap.MapBoolBool._readMessage
          );
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {};
          reader.readMessage(
            mapStringString,
            TestArenaMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {};
          reader.readMessage(
            mapInt32Bytes,
            TestArenaMap.MapInt32Bytes._readMessage
          );
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {};
          reader.readMessage(
            mapInt32Enum,
            TestArenaMap.MapInt32Enum._readMessage
          );
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage = {};
          reader.readMessage(
            mapInt32ForeignMessage,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg) {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json) {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.entry) {
      const entry = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(entry).length > 0) {
        json.entry = entry;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const entry = {};
          reader.readMessage(
            entry,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[entry.key] = entry.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _entry = json.entry;
    if (_entry) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRecursiveMapMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const a = {};
          reader.readMessage(a, TestRecursiveMapMessage.A._readMessage);
          msg.a[a.key] = a.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = Object.fromEntries(
        Object.entries(_a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRecursiveMapMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRecursiveMapMessage.initialize(),
              TestRecursiveMapMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      Array [
        "google/protobuf/any.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/any.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Any = {
  /**
   * Serializes a Any to protobuf.
   */
  encode: function (msg) {
    return Any._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Any from protobuf.
   */
  decode: function (bytes) {
    return Any._readMessage(Any.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Any to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Any._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Any from JSON.
   */
  decodeJSON: function (json) {
    return Any._readMessageJSON(Any.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Any with all fields set to their default value.
   */
  initialize: function () {
    return {
      typeUrl: \\"\\",
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/source_context.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/source_context.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SourceContext = {
  /**
   * Serializes a SourceContext to protobuf.
   */
  encode: function (msg) {
    return SourceContext._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SourceContext from protobuf.
   */
  decode: function (bytes) {
    return SourceContext._readMessage(
      SourceContext.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SourceContext to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(SourceContext._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SourceContext from JSON.
   */
  decodeJSON: function (json) {
    return SourceContext._readMessageJSON(
      SourceContext.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SourceContext with all fields set to their default value.
   */
  initialize: function () {
    return {
      fileName: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fileName) {
      json.fileName = msg.fileName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fileName = json.fileName ?? json.file_name;
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/type.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { SourceContext } from \\"./source_context.pb\\";
import { Any } from \\"./any.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Syntax = {
  /**
   * Syntax \`proto2\`.
   */
  SYNTAX_PROTO2: \\"SYNTAX_PROTO2\\",
  /**
   * Syntax \`proto3\`.
   */
  SYNTAX_PROTO3: \\"SYNTAX_PROTO3\\",
};

const SyntaxFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"SYNTAX_PROTO2\\";
    }
    case 1: {
      return \\"SYNTAX_PROTO3\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const SyntaxToInt = function (i) {
  switch (i) {
    case \\"SYNTAX_PROTO2\\": {
      return 0;
    }
    case \\"SYNTAX_PROTO3\\": {
      return 1;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const Type = {
  /**
   * Serializes a Type to protobuf.
   */
  encode: function (msg) {
    return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Type from protobuf.
   */
  decode: function (bytes) {
    return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Type to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Type._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Type from JSON.
   */
  decodeJSON: function (json) {
    return Type._readMessageJSON(Type.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Type with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(6, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.fields?.length) {
      json.fields = msg.fields.map(Field._writeMessageJSON);
    }
    if (msg.oneofs?.length) {
      json.oneofs = msg.oneofs;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _fields = json.fields;
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        Field._readMessageJSON(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json.oneofs;
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Field = {
  /**
   * Serializes a Field to protobuf.
   */
  encode: function (msg) {
    return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Field from protobuf.
   */
  decode: function (bytes) {
    return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Field to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Field._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Field from JSON.
   */
  decodeJSON: function (json) {
    return Field._readMessageJSON(Field.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Field with all fields set to their default value.
   */
  initialize: function () {
    return {
      kind: Field.KindFromInt(0),
      cardinality: Field.CardinalityFromInt(0),
      number: 0,
      name: \\"\\",
      typeUrl: \\"\\",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: \\"\\",
      defaultValue: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.kind && Field.KindToInt(msg.kind)) {
      writer.writeEnum(1, Field.KindToInt(msg.kind));
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      writer.writeEnum(2, Field.CardinalityToInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options, Option._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.kind && Field.KindToInt(msg.kind)) {
      json.kind = msg.kind;
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      json.cardinality = msg.cardinality;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json.oneofIndex = msg.oneofIndex;
    }
    if (msg.packed) {
      json.packed = msg.packed;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.jsonName) {
      json.jsonName = msg.jsonName;
    }
    if (msg.defaultValue) {
      json.defaultValue = msg.defaultValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.KindFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.CardinalityFromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _kind = json.kind;
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json.cardinality;
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json.oneofIndex ?? json.oneof_index;
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json.packed;
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json.jsonName ?? json.json_name;
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json.defaultValue ?? json.default_value;
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: \\"TYPE_UNKNOWN\\",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: \\"TYPE_DOUBLE\\",
    /**
     * Field type float.
     */
    TYPE_FLOAT: \\"TYPE_FLOAT\\",
    /**
     * Field type int64.
     */
    TYPE_INT64: \\"TYPE_INT64\\",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: \\"TYPE_UINT64\\",
    /**
     * Field type int32.
     */
    TYPE_INT32: \\"TYPE_INT32\\",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: \\"TYPE_FIXED64\\",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: \\"TYPE_FIXED32\\",
    /**
     * Field type bool.
     */
    TYPE_BOOL: \\"TYPE_BOOL\\",
    /**
     * Field type string.
     */
    TYPE_STRING: \\"TYPE_STRING\\",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: \\"TYPE_GROUP\\",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: \\"TYPE_MESSAGE\\",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: \\"TYPE_BYTES\\",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: \\"TYPE_UINT32\\",
    /**
     * Field type enum.
     */
    TYPE_ENUM: \\"TYPE_ENUM\\",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: \\"TYPE_SFIXED32\\",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: \\"TYPE_SFIXED64\\",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: \\"TYPE_SINT32\\",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: \\"TYPE_SINT64\\",
  },

  KindFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"TYPE_UNKNOWN\\";
      }
      case 1: {
        return \\"TYPE_DOUBLE\\";
      }
      case 2: {
        return \\"TYPE_FLOAT\\";
      }
      case 3: {
        return \\"TYPE_INT64\\";
      }
      case 4: {
        return \\"TYPE_UINT64\\";
      }
      case 5: {
        return \\"TYPE_INT32\\";
      }
      case 6: {
        return \\"TYPE_FIXED64\\";
      }
      case 7: {
        return \\"TYPE_FIXED32\\";
      }
      case 8: {
        return \\"TYPE_BOOL\\";
      }
      case 9: {
        return \\"TYPE_STRING\\";
      }
      case 10: {
        return \\"TYPE_GROUP\\";
      }
      case 11: {
        return \\"TYPE_MESSAGE\\";
      }
      case 12: {
        return \\"TYPE_BYTES\\";
      }
      case 13: {
        return \\"TYPE_UINT32\\";
      }
      case 14: {
        return \\"TYPE_ENUM\\";
      }
      case 15: {
        return \\"TYPE_SFIXED32\\";
      }
      case 16: {
        return \\"TYPE_SFIXED64\\";
      }
      case 17: {
        return \\"TYPE_SINT32\\";
      }
      case 18: {
        return \\"TYPE_SINT64\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  KindToInt: function (i) {
    switch (i) {
      case \\"TYPE_UNKNOWN\\": {
        return 0;
      }
      case \\"TYPE_DOUBLE\\": {
        return 1;
      }
      case \\"TYPE_FLOAT\\": {
        return 2;
      }
      case \\"TYPE_INT64\\": {
        return 3;
      }
      case \\"TYPE_UINT64\\": {
        return 4;
      }
      case \\"TYPE_INT32\\": {
        return 5;
      }
      case \\"TYPE_FIXED64\\": {
        return 6;
      }
      case \\"TYPE_FIXED32\\": {
        return 7;
      }
      case \\"TYPE_BOOL\\": {
        return 8;
      }
      case \\"TYPE_STRING\\": {
        return 9;
      }
      case \\"TYPE_GROUP\\": {
        return 10;
      }
      case \\"TYPE_MESSAGE\\": {
        return 11;
      }
      case \\"TYPE_BYTES\\": {
        return 12;
      }
      case \\"TYPE_UINT32\\": {
        return 13;
      }
      case \\"TYPE_ENUM\\": {
        return 14;
      }
      case \\"TYPE_SFIXED32\\": {
        return 15;
      }
      case \\"TYPE_SFIXED64\\": {
        return 16;
      }
      case \\"TYPE_SINT32\\": {
        return 17;
      }
      case \\"TYPE_SINT64\\": {
        return 18;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: \\"CARDINALITY_UNKNOWN\\",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: \\"CARDINALITY_OPTIONAL\\",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: \\"CARDINALITY_REQUIRED\\",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: \\"CARDINALITY_REPEATED\\",
  },

  CardinalityFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"CARDINALITY_UNKNOWN\\";
      }
      case 1: {
        return \\"CARDINALITY_OPTIONAL\\";
      }
      case 2: {
        return \\"CARDINALITY_REQUIRED\\";
      }
      case 3: {
        return \\"CARDINALITY_REPEATED\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  CardinalityToInt: function (i) {
    switch (i) {
      case \\"CARDINALITY_UNKNOWN\\": {
        return 0;
      }
      case \\"CARDINALITY_OPTIONAL\\": {
        return 1;
      }
      case \\"CARDINALITY_REQUIRED\\": {
        return 2;
      }
      case \\"CARDINALITY_REPEATED\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const Enum = {
  /**
   * Serializes a Enum to protobuf.
   */
  encode: function (msg) {
    return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Enum from protobuf.
   */
  decode: function (bytes) {
    return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Enum to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Enum._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Enum from JSON.
   */
  decodeJSON: function (json) {
    return Enum._readMessageJSON(Enum.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Enum with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(2, msg.enumvalue, EnumValue._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(5, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.enumvalue?.length) {
      json.enumvalue = msg.enumvalue.map(EnumValue._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json.enumvalue;
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValue._readMessageJSON(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const EnumValue = {
  /**
   * Serializes a EnumValue to protobuf.
   */
  encode: function (msg) {
    return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a EnumValue from protobuf.
   */
  decode: function (bytes) {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a EnumValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(EnumValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a EnumValue from JSON.
   */
  decodeJSON: function (json) {
    return EnumValue._readMessageJSON(EnumValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a EnumValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  },
};

export const Option = {
  /**
   * Serializes a Option to protobuf.
   */
  encode: function (msg) {
    return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Option from protobuf.
   */
  decode: function (bytes) {
    return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Option to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Option._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Option from JSON.
   */
  decodeJSON: function (json) {
    return Option._readMessageJSON(Option.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Option with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.value) {
      const value = Any._writeMessageJSON(msg.value);
      if (Object.keys(value).length > 0) {
        json.value = value;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _value = json.value;
    if (_value) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _value);
      msg.value = m;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/api.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Option, Syntax } from \\"./type.pb\\";
import { SourceContext } from \\"./source_context.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Api = {
  /**
   * Serializes a Api to protobuf.
   */
  encode: function (msg) {
    return Api._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Api from protobuf.
   */
  decode: function (bytes) {
    return Api._readMessage(Api.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Api to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Api._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Api from JSON.
   */
  decodeJSON: function (json) {
    return Api._readMessageJSON(Api.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Api with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      methods: [],
      options: [],
      version: \\"\\",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.methods?.length) {
      json.methods = msg.methods.map(Method._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.version) {
      json.version = msg.version;
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.mixins?.length) {
      json.mixins = msg.mixins.map(Mixin._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _methods = json.methods;
    if (_methods) {
      for (const item of _methods) {
        const m = Method.initialize();
        Method._readMessageJSON(m, item);
        msg.methods.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _mixins = json.mixins;
    if (_mixins) {
      for (const item of _mixins) {
        const m = Mixin.initialize();
        Mixin._readMessageJSON(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Method = {
  /**
   * Serializes a Method to protobuf.
   */
  encode: function (msg) {
    return Method._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Method from protobuf.
   */
  decode: function (bytes) {
    return Method._readMessage(Method.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Method to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Method._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Method from JSON.
   */
  decodeJSON: function (json) {
    return Method._readMessageJSON(Method.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Method with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      requestTypeUrl: \\"\\",
      requestStreaming: false,
      responseTypeUrl: \\"\\",
      responseStreaming: false,
      options: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(6, msg.options, Option._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.requestTypeUrl) {
      json.requestTypeUrl = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json.requestStreaming = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json.responseTypeUrl = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json.responseStreaming = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _requestTypeUrl = json.requestTypeUrl ?? json.request_type_url;
    if (_requestTypeUrl) {
      msg.requestTypeUrl = _requestTypeUrl;
    }
    const _requestStreaming = json.requestStreaming ?? json.request_streaming;
    if (_requestStreaming) {
      msg.requestStreaming = _requestStreaming;
    }
    const _responseTypeUrl = json.responseTypeUrl ?? json.response_type_url;
    if (_responseTypeUrl) {
      msg.responseTypeUrl = _responseTypeUrl;
    }
    const _responseStreaming =
      json.responseStreaming ?? json.response_streaming;
    if (_responseStreaming) {
      msg.responseStreaming = _responseStreaming;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Mixin = {
  /**
   * Serializes a Mixin to protobuf.
   */
  encode: function (msg) {
    return Mixin._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Mixin from protobuf.
   */
  decode: function (bytes) {
    return Mixin._readMessage(Mixin.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Mixin to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Mixin._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Mixin from JSON.
   */
  decodeJSON: function (json) {
    return Mixin._readMessageJSON(Mixin.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Mixin with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      root: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.root) {
      json.root = msg.root;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _root = json.root;
    if (_root) {
      msg.root = _root;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/duration.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/duration.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Duration = {
  /**
   * Serializes a Duration to protobuf.
   */
  encode: function (msg) {
    return Duration._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Duration from protobuf.
   */
  decode: function (bytes) {
    return Duration._readMessage(
      Duration.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Duration to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Duration._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Duration from JSON.
   */
  decodeJSON: function (json) {
    return Duration._readMessageJSON(Duration.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Duration with all fields set to their default value.
   */
  initialize: function () {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};
",
      ],
      Array [
        "google/protobuf/field_mask.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/field_mask.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const FieldMask = {
  /**
   * Serializes a FieldMask to protobuf.
   */
  encode: function (msg) {
    return FieldMask._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FieldMask from protobuf.
   */
  decode: function (bytes) {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FieldMask to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(FieldMask._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FieldMask from JSON.
   */
  decodeJSON: function (json) {
    return FieldMask._readMessageJSON(FieldMask.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a FieldMask with all fields set to their default value.
   */
  initialize: function () {
    return {
      paths: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.paths?.length) {
      json.paths = msg.paths;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _paths = json.paths;
    if (_paths) {
      msg.paths = _paths;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/struct.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: \\"NULL_VALUE\\",
};

const NullValueFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"NULL_VALUE\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const NullValueToInt = function (i) {
  switch (i) {
    case \\"NULL_VALUE\\": {
      return 0;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const Struct = {
  /**
   * Serializes a Struct to protobuf.
   */
  encode: function (msg) {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Struct from protobuf.
   */
  decode: function (bytes) {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Struct to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Struct._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Struct from JSON.
   */
  decodeJSON: function (json) {
    return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Struct with all fields set to their default value.
   */
  initialize: function () {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.fields).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries(msg.fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const fields = {};
          reader.readMessage(fields, Struct.Fields._readMessage);
          msg.fields[fields.key] = fields.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries(_fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes a Value to protobuf.
   */
  encode: function (msg) {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Value from protobuf.
   */
  decode: function (bytes) {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Value from JSON.
   */
  decodeJSON: function (json) {
    return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      structValue: Struct.initialize(),
      listValue: ListValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValueToInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = Struct._writeMessageJSON(msg.structValue);
      if (Object.keys(structValue).length > 0) {
        json.structValue = structValue;
      }
    }
    if (msg.listValue != undefined) {
      const listValue = ListValue._writeMessageJSON(msg.listValue);
      if (Object.keys(listValue).length > 0) {
        json.listValue = listValue;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValueFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValue._readMessageJSON(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes a ListValue to protobuf.
   */
  encode: function (msg) {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a ListValue from protobuf.
   */
  decode: function (bytes) {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ListValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ListValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ListValue from JSON.
   */
  decodeJSON: function (json) {
    return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a ListValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.values?.length) {
      json.values = msg.values.map(Value._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        Value._readMessageJSON(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/timestamp.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/timestamp.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Timestamp = {
  /**
   * Serializes a Timestamp to protobuf.
   */
  encode: function (msg) {
    return Timestamp._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Timestamp from protobuf.
   */
  decode: function (bytes) {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Timestamp to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Timestamp._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Timestamp from JSON.
   */
  decodeJSON: function (json) {
    return Timestamp._readMessageJSON(Timestamp.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Timestamp with all fields set to their default value.
   */
  initialize: function () {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/wrappers.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/wrappers.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const DoubleValue = {
  /**
   * Serializes a DoubleValue to protobuf.
   */
  encode: function (msg) {
    return DoubleValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a DoubleValue from protobuf.
   */
  decode: function (bytes) {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a DoubleValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(DoubleValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a DoubleValue from JSON.
   */
  decodeJSON: function (json) {
    return DoubleValue._readMessageJSON(
      DoubleValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a DoubleValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const FloatValue = {
  /**
   * Serializes a FloatValue to protobuf.
   */
  encode: function (msg) {
    return FloatValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FloatValue from protobuf.
   */
  decode: function (bytes) {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FloatValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(FloatValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FloatValue from JSON.
   */
  decodeJSON: function (json) {
    return FloatValue._readMessageJSON(
      FloatValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FloatValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const Int64Value = {
  /**
   * Serializes a Int64Value to protobuf.
   */
  encode: function (msg) {
    return Int64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int64Value from protobuf.
   */
  decode: function (bytes) {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Value from JSON.
   */
  decodeJSON: function (json) {
    return Int64Value._readMessageJSON(
      Int64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const UInt64Value = {
  /**
   * Serializes a UInt64Value to protobuf.
   */
  encode: function (msg) {
    return UInt64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt64Value from protobuf.
   */
  decode: function (bytes) {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt64Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(UInt64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt64Value from JSON.
   */
  decodeJSON: function (json) {
    return UInt64Value._readMessageJSON(
      UInt64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt64Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const Int32Value = {
  /**
   * Serializes a Int32Value to protobuf.
   */
  encode: function (msg) {
    return Int32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int32Value from protobuf.
   */
  decode: function (bytes) {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Value from JSON.
   */
  decodeJSON: function (json) {
    return Int32Value._readMessageJSON(
      Int32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const UInt32Value = {
  /**
   * Serializes a UInt32Value to protobuf.
   */
  encode: function (msg) {
    return UInt32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt32Value from protobuf.
   */
  decode: function (bytes) {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt32Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(UInt32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt32Value from JSON.
   */
  decodeJSON: function (json) {
    return UInt32Value._readMessageJSON(
      UInt32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt32Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BoolValue = {
  /**
   * Serializes a BoolValue to protobuf.
   */
  encode: function (msg) {
    return BoolValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolValue from protobuf.
   */
  decode: function (bytes) {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BoolValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolValue from JSON.
   */
  decodeJSON: function (json) {
    return BoolValue._readMessageJSON(BoolValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a BoolValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const StringValue = {
  /**
   * Serializes a StringValue to protobuf.
   */
  encode: function (msg) {
    return StringValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a StringValue from protobuf.
   */
  decode: function (bytes) {
    return StringValue._readMessage(
      StringValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a StringValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(StringValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a StringValue from JSON.
   */
  decodeJSON: function (json) {
    return StringValue._readMessageJSON(
      StringValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a StringValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BytesValue = {
  /**
   * Serializes a BytesValue to protobuf.
   */
  encode: function (msg) {
    return BytesValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BytesValue from protobuf.
   */
  decode: function (bytes) {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BytesValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BytesValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BytesValue from JSON.
   */
  decodeJSON: function (json) {
    return BytesValue._readMessageJSON(
      BytesValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BytesValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_well_known_types.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Any } from \\"./any.pb\\";
import { Api } from \\"./api.pb\\";
import { Duration } from \\"./duration.pb\\";
import { Empty } from \\"./empty.pb\\";
import { FieldMask } from \\"./field_mask.pb\\";
import { SourceContext } from \\"./source_context.pb\\";
import { Struct, Value } from \\"./struct.pb\\";
import { Timestamp } from \\"./timestamp.pb\\";
import { Type } from \\"./type.pb\\";
import {
  DoubleValue,
  FloatValue,
  Int64Value,
  UInt64Value,
  Int32Value,
  UInt32Value,
  BoolValue,
  StringValue,
  BytesValue,
} from \\"./wrappers.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes a TestWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestWellKnownTypes._readMessageJSON(
      TestWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
      valueField: Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    if (msg.valueField) {
      const valueField = Value._writeMessageJSON(msg.valueField);
      if (Object.keys(valueField).length > 0) {
        json.valueField = valueField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    const _valueField = json.valueField ?? json.value_field;
    if (_valueField) {
      const m = Value.initialize();
      Value._readMessageJSON(m, _valueField);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes a RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(RepeatedWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedWellKnownTypes._readMessageJSON(
      RepeatedWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField,
        FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField,
        Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField,
        DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field,
        UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field,
        UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField,
        StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField?.length) {
      json.anyField = msg.anyField.map(Any._writeMessageJSON);
    }
    if (msg.apiField?.length) {
      json.apiField = msg.apiField.map(Api._writeMessageJSON);
    }
    if (msg.durationField?.length) {
      json.durationField = msg.durationField.map(Duration._writeMessageJSON);
    }
    if (msg.emptyField?.length) {
      json.emptyField = msg.emptyField.map(Empty._writeMessageJSON);
    }
    if (msg.fieldMaskField?.length) {
      json.fieldMaskField = msg.fieldMaskField.map(FieldMask._writeMessageJSON);
    }
    if (msg.sourceContextField?.length) {
      json.sourceContextField = msg.sourceContextField.map(
        SourceContext._writeMessageJSON
      );
    }
    if (msg.structField?.length) {
      json.structField = msg.structField.map(Struct._writeMessageJSON);
    }
    if (msg.timestampField?.length) {
      json.timestampField = msg.timestampField.map(Timestamp._writeMessageJSON);
    }
    if (msg.typeField?.length) {
      json.typeField = msg.typeField.map(Type._writeMessageJSON);
    }
    if (msg.doubleField?.length) {
      json.doubleField = msg.doubleField.map(DoubleValue._writeMessageJSON);
    }
    if (msg.floatField?.length) {
      json.floatField = msg.floatField.map(FloatValue._writeMessageJSON);
    }
    if (msg.int64Field?.length) {
      json.int64Field = msg.int64Field.map(Int64Value._writeMessageJSON);
    }
    if (msg.uint64Field?.length) {
      json.uint64Field = msg.uint64Field.map(UInt64Value._writeMessageJSON);
    }
    if (msg.int32Field?.length) {
      json.int32Field = msg.int32Field.map(Int32Value._writeMessageJSON);
    }
    if (msg.uint32Field?.length) {
      json.uint32Field = msg.uint32Field.map(UInt32Value._writeMessageJSON);
    }
    if (msg.boolField?.length) {
      json.boolField = msg.boolField.map(BoolValue._writeMessageJSON);
    }
    if (msg.stringField?.length) {
      json.stringField = msg.stringField.map(StringValue._writeMessageJSON);
    }
    if (msg.bytesField?.length) {
      json.bytesField = msg.bytesField.map(BytesValue._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Any.initialize();
          reader.readMessage(m, Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = Api.initialize();
          reader.readMessage(m, Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = Duration.initialize();
          reader.readMessage(m, Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = Empty.initialize();
          reader.readMessage(m, Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = FieldMask.initialize();
          reader.readMessage(m, FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = SourceContext.initialize();
          reader.readMessage(m, SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = Struct.initialize();
          reader.readMessage(m, Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = Timestamp.initialize();
          reader.readMessage(m, Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = Type.initialize();
          reader.readMessage(m, Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = DoubleValue.initialize();
          reader.readMessage(m, DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = FloatValue.initialize();
          reader.readMessage(m, FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = Int64Value.initialize();
          reader.readMessage(m, Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = UInt64Value.initialize();
          reader.readMessage(m, UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = Int32Value.initialize();
          reader.readMessage(m, Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = UInt32Value.initialize();
          reader.readMessage(m, UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = BoolValue.initialize();
          reader.readMessage(m, BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = StringValue.initialize();
          reader.readMessage(m, StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = BytesValue.initialize();
          reader.readMessage(m, BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      for (const item of _anyField) {
        const m = Any.initialize();
        Any._readMessageJSON(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      for (const item of _apiField) {
        const m = Api.initialize();
        Api._readMessageJSON(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      for (const item of _durationField) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      for (const item of _emptyField) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      for (const item of _fieldMaskField) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      for (const item of _sourceContextField) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      for (const item of _structField) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      for (const item of _timestampField) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      for (const item of _typeField) {
        const m = Type.initialize();
        Type._readMessageJSON(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      for (const item of _doubleField) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      for (const item of _floatField) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      for (const item of _int64Field) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      for (const item of _uint64Field) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      for (const item of _int32Field) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      for (const item of _uint32Field) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      for (const item of _boolField) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      for (const item of _stringField) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      for (const item of _bytesField) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes a OneofWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneofWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneofWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneofWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return OneofWellKnownTypes._readMessageJSON(
      OneofWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField != undefined) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField != undefined) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField != undefined) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField != undefined) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField != undefined) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField != undefined) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField != undefined) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField != undefined) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField != undefined) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField != undefined) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField != undefined) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field != undefined) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field != undefined) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field != undefined) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field != undefined) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField != undefined) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField != undefined) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField != undefined) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes a MapWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MapWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MapWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MapWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MapWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return MapWellKnownTypes._readMessageJSON(
      MapWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField) {
      const anyField = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const anyField = {};
          reader.readMessage(anyField, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[anyField.key] = anyField.value;
          break;
        }
        case 2: {
          const apiField = {};
          reader.readMessage(apiField, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[apiField.key] = apiField.value;
          break;
        }
        case 3: {
          const durationField = {};
          reader.readMessage(
            durationField,
            MapWellKnownTypes.DurationField._readMessage
          );
          msg.durationField[durationField.key] = durationField.value;
          break;
        }
        case 4: {
          const emptyField = {};
          reader.readMessage(
            emptyField,
            MapWellKnownTypes.EmptyField._readMessage
          );
          msg.emptyField[emptyField.key] = emptyField.value;
          break;
        }
        case 5: {
          const fieldMaskField = {};
          reader.readMessage(
            fieldMaskField,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[fieldMaskField.key] = fieldMaskField.value;
          break;
        }
        case 6: {
          const sourceContextField = {};
          reader.readMessage(
            sourceContextField,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[sourceContextField.key] =
            sourceContextField.value;
          break;
        }
        case 7: {
          const structField = {};
          reader.readMessage(
            structField,
            MapWellKnownTypes.StructField._readMessage
          );
          msg.structField[structField.key] = structField.value;
          break;
        }
        case 8: {
          const timestampField = {};
          reader.readMessage(
            timestampField,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[timestampField.key] = timestampField.value;
          break;
        }
        case 9: {
          const typeField = {};
          reader.readMessage(
            typeField,
            MapWellKnownTypes.TypeField._readMessage
          );
          msg.typeField[typeField.key] = typeField.value;
          break;
        }
        case 10: {
          const doubleField = {};
          reader.readMessage(
            doubleField,
            MapWellKnownTypes.DoubleField._readMessage
          );
          msg.doubleField[doubleField.key] = doubleField.value;
          break;
        }
        case 11: {
          const floatField = {};
          reader.readMessage(
            floatField,
            MapWellKnownTypes.FloatField._readMessage
          );
          msg.floatField[floatField.key] = floatField.value;
          break;
        }
        case 12: {
          const int64Field = {};
          reader.readMessage(
            int64Field,
            MapWellKnownTypes.Int64Field._readMessage
          );
          msg.int64Field[int64Field.key] = int64Field.value;
          break;
        }
        case 13: {
          const uint64Field = {};
          reader.readMessage(
            uint64Field,
            MapWellKnownTypes.Uint64Field._readMessage
          );
          msg.uint64Field[uint64Field.key] = uint64Field.value;
          break;
        }
        case 14: {
          const int32Field = {};
          reader.readMessage(
            int32Field,
            MapWellKnownTypes.Int32Field._readMessage
          );
          msg.int32Field[int32Field.key] = int32Field.value;
          break;
        }
        case 15: {
          const uint32Field = {};
          reader.readMessage(
            uint32Field,
            MapWellKnownTypes.Uint32Field._readMessage
          );
          msg.uint32Field[uint32Field.key] = uint32Field.value;
          break;
        }
        case 16: {
          const boolField = {};
          reader.readMessage(
            boolField,
            MapWellKnownTypes.BoolField._readMessage
          );
          msg.boolField[boolField.key] = boolField.value;
          break;
        }
        case 17: {
          const stringField = {};
          reader.readMessage(
            stringField,
            MapWellKnownTypes.StringField._readMessage
          );
          msg.stringField[stringField.key] = stringField.value;
          break;
        }
        case 18: {
          const bytesField = {};
          reader.readMessage(
            bytesField,
            MapWellKnownTypes.BytesField._readMessage
          );
          msg.bytesField[bytesField.key] = bytesField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Any._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Any.initialize(), Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Any.initialize();
        Any._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Api._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Api.initialize(), Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Api.initialize();
        Api._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Duration._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Duration.initialize(), Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Empty._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Empty.initialize(), Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FieldMask._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(FieldMask.initialize(), FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, SourceContext._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = SourceContext._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              SourceContext.initialize(),
              SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Struct._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Struct.initialize(), Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Timestamp._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Timestamp.initialize(), Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Type._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Type.initialize(), Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Type.initialize();
        Type._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, DoubleValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = DoubleValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              DoubleValue.initialize(),
              DoubleValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FloatValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              FloatValue.initialize(),
              FloatValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int64Value.initialize(),
              Int64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt64Value.initialize(),
              UInt64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int32Value.initialize(),
              Int32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt32Value.initialize(),
              UInt32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BoolValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(BoolValue.initialize(), BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = StringValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              StringValue.initialize(),
              StringValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BytesValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              BytesValue.initialize(),
              BytesValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: \\"FOREIGN_ZERO\\",
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
};

const ForeignEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"FOREIGN_ZERO\\";
    }
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ForeignEnumToInt = function (i) {
  switch (i) {
    case \\"FOREIGN_ZERO\\": {
      return 0;
    }
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (_optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { ZERO: \\"ZERO\\", FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"ZERO\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"ZERO\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (msg) {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMessageWithDummy._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: \\"UNKNOWN\\", FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"UNKNOWN\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"UNKNOWN\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};
",
      ],
      Array [
        "empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import {
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFoo(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (msg) {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(PublicImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _e = json.e;
    if (_e) {
      msg.e = _e;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: \\"IMPORT_FOO\\",
  IMPORT_BAR: \\"IMPORT_BAR\\",
  IMPORT_BAZ: \\"IMPORT_BAZ\\",
};

const ImportEnumFromInt = function (i) {
  switch (i) {
    case 7: {
      return \\"IMPORT_FOO\\";
    }
    case 8: {
      return \\"IMPORT_BAR\\";
    }
    case 9: {
      return \\"IMPORT_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ImportEnumToInt = function (i) {
  switch (i) {
    case \\"IMPORT_FOO\\": {
      return 7;
    }
    case \\"IMPORT_BAR\\": {
      return 8;
    }
    case \\"IMPORT_BAZ\\": {
      return 9;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const ImportEnumForMap = { UNKNOWN: \\"UNKNOWN\\", FOO: \\"FOO\\", BAR: \\"BAR\\" };

const ImportEnumForMapFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"UNKNOWN\\";
    }
    case 1: {
      return \\"FOO\\";
    }
    case 2: {
      return \\"BAR\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ImportEnumForMapToInt = function (i) {
  switch (i) {
    case \\"UNKNOWN\\": {
      return 0;
    }
    case \\"FOO\\": {
      return 1;
    }
    case \\"BAR\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (msg) {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestService(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
};

const ForeignEnumFromInt = function (i) {
  switch (i) {
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ForeignEnumToInt = function (i) {
  switch (i) {
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestEnumWithDupValue = {
  FOO1: \\"FOO1\\",
  BAR1: \\"BAR1\\",
  BAZ: \\"BAZ\\",
  FOO2: \\"FOO2\\",
  BAR2: \\"BAR2\\",
};

const TestEnumWithDupValueFromInt = function (i) {
  switch (i) {
    case 1: {
      return \\"FOO1\\";
    }
    case 2: {
      return \\"BAR1\\";
    }
    case 3: {
      return \\"BAZ\\";
    }
    case 1: {
      return \\"FOO2\\";
    }
    case 2: {
      return \\"BAR2\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const TestEnumWithDupValueToInt = function (i) {
  switch (i) {
    case \\"FOO1\\": {
      return 1;
    }
    case \\"BAR1\\": {
      return 2;
    }
    case \\"BAZ\\": {
      return 3;
    }
    case \\"FOO2\\": {
      return 1;
    }
    case \\"BAR2\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestSparseEnum = {
  SPARSE_A: \\"SPARSE_A\\",
  SPARSE_B: \\"SPARSE_B\\",
  SPARSE_C: \\"SPARSE_C\\",
  SPARSE_D: \\"SPARSE_D\\",
  SPARSE_E: \\"SPARSE_E\\",
  SPARSE_F: \\"SPARSE_F\\",
  SPARSE_G: \\"SPARSE_G\\",
};

const TestSparseEnumFromInt = function (i) {
  switch (i) {
    case 123: {
      return \\"SPARSE_A\\";
    }
    case 62374: {
      return \\"SPARSE_B\\";
    }
    case 12589234: {
      return \\"SPARSE_C\\";
    }
    case -15: {
      return \\"SPARSE_D\\";
    }
    case -53452: {
      return \\"SPARSE_E\\";
    }
    case 0: {
      return \\"SPARSE_F\\";
    }
    case 2: {
      return \\"SPARSE_G\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const TestSparseEnumToInt = function (i) {
  switch (i) {
    case \\"SPARSE_A\\": {
      return 123;
    }
    case \\"SPARSE_B\\": {
      return 62374;
    }
    case \\"SPARSE_C\\": {
      return 12589234;
    }
    case \\"SPARSE_D\\": {
      return -15;
    }
    case \\"SPARSE_E\\": {
      return -53452;
    }
    case \\"SPARSE_F\\": {
      return 0;
    }
    case \\"SPARSE_G\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: \\"ENUM_LABEL_DEFAULT\\",
  ENUM_LABEL_1: \\"ENUM_LABEL_1\\",
  ENUM_LABEL_2: \\"ENUM_LABEL_2\\",
  ENUM_LABEL_3: \\"ENUM_LABEL_3\\",
  ENUM_LABEL_4: \\"ENUM_LABEL_4\\",
  ENUM_LABEL_5: \\"ENUM_LABEL_5\\",
  ENUM_LABEL_6: \\"ENUM_LABEL_6\\",
  ENUM_LABEL_7: \\"ENUM_LABEL_7\\",
  ENUM_LABEL_8: \\"ENUM_LABEL_8\\",
  ENUM_LABEL_9: \\"ENUM_LABEL_9\\",
  ENUM_LABEL_10: \\"ENUM_LABEL_10\\",
  ENUM_LABEL_11: \\"ENUM_LABEL_11\\",
  ENUM_LABEL_12: \\"ENUM_LABEL_12\\",
  ENUM_LABEL_13: \\"ENUM_LABEL_13\\",
  ENUM_LABEL_14: \\"ENUM_LABEL_14\\",
  ENUM_LABEL_15: \\"ENUM_LABEL_15\\",
  ENUM_LABEL_16: \\"ENUM_LABEL_16\\",
  ENUM_LABEL_17: \\"ENUM_LABEL_17\\",
  ENUM_LABEL_18: \\"ENUM_LABEL_18\\",
  ENUM_LABEL_19: \\"ENUM_LABEL_19\\",
  ENUM_LABEL_20: \\"ENUM_LABEL_20\\",
  ENUM_LABEL_21: \\"ENUM_LABEL_21\\",
  ENUM_LABEL_22: \\"ENUM_LABEL_22\\",
  ENUM_LABEL_23: \\"ENUM_LABEL_23\\",
  ENUM_LABEL_24: \\"ENUM_LABEL_24\\",
  ENUM_LABEL_25: \\"ENUM_LABEL_25\\",
  ENUM_LABEL_26: \\"ENUM_LABEL_26\\",
  ENUM_LABEL_27: \\"ENUM_LABEL_27\\",
  ENUM_LABEL_28: \\"ENUM_LABEL_28\\",
  ENUM_LABEL_29: \\"ENUM_LABEL_29\\",
  ENUM_LABEL_30: \\"ENUM_LABEL_30\\",
  ENUM_LABEL_31: \\"ENUM_LABEL_31\\",
  ENUM_LABEL_32: \\"ENUM_LABEL_32\\",
  ENUM_LABEL_33: \\"ENUM_LABEL_33\\",
  ENUM_LABEL_34: \\"ENUM_LABEL_34\\",
  ENUM_LABEL_35: \\"ENUM_LABEL_35\\",
  ENUM_LABEL_36: \\"ENUM_LABEL_36\\",
  ENUM_LABEL_37: \\"ENUM_LABEL_37\\",
  ENUM_LABEL_38: \\"ENUM_LABEL_38\\",
  ENUM_LABEL_39: \\"ENUM_LABEL_39\\",
  ENUM_LABEL_40: \\"ENUM_LABEL_40\\",
  ENUM_LABEL_41: \\"ENUM_LABEL_41\\",
  ENUM_LABEL_42: \\"ENUM_LABEL_42\\",
  ENUM_LABEL_43: \\"ENUM_LABEL_43\\",
  ENUM_LABEL_44: \\"ENUM_LABEL_44\\",
  ENUM_LABEL_45: \\"ENUM_LABEL_45\\",
  ENUM_LABEL_46: \\"ENUM_LABEL_46\\",
  ENUM_LABEL_47: \\"ENUM_LABEL_47\\",
  ENUM_LABEL_48: \\"ENUM_LABEL_48\\",
  ENUM_LABEL_49: \\"ENUM_LABEL_49\\",
  ENUM_LABEL_50: \\"ENUM_LABEL_50\\",
  ENUM_LABEL_51: \\"ENUM_LABEL_51\\",
  ENUM_LABEL_52: \\"ENUM_LABEL_52\\",
  ENUM_LABEL_53: \\"ENUM_LABEL_53\\",
  ENUM_LABEL_54: \\"ENUM_LABEL_54\\",
  ENUM_LABEL_55: \\"ENUM_LABEL_55\\",
  ENUM_LABEL_56: \\"ENUM_LABEL_56\\",
  ENUM_LABEL_57: \\"ENUM_LABEL_57\\",
  ENUM_LABEL_58: \\"ENUM_LABEL_58\\",
  ENUM_LABEL_59: \\"ENUM_LABEL_59\\",
  ENUM_LABEL_60: \\"ENUM_LABEL_60\\",
  ENUM_LABEL_61: \\"ENUM_LABEL_61\\",
  ENUM_LABEL_62: \\"ENUM_LABEL_62\\",
  ENUM_LABEL_63: \\"ENUM_LABEL_63\\",
  ENUM_LABEL_64: \\"ENUM_LABEL_64\\",
  ENUM_LABEL_65: \\"ENUM_LABEL_65\\",
  ENUM_LABEL_66: \\"ENUM_LABEL_66\\",
  ENUM_LABEL_67: \\"ENUM_LABEL_67\\",
  ENUM_LABEL_68: \\"ENUM_LABEL_68\\",
  ENUM_LABEL_69: \\"ENUM_LABEL_69\\",
  ENUM_LABEL_70: \\"ENUM_LABEL_70\\",
  ENUM_LABEL_71: \\"ENUM_LABEL_71\\",
  ENUM_LABEL_72: \\"ENUM_LABEL_72\\",
  ENUM_LABEL_73: \\"ENUM_LABEL_73\\",
  ENUM_LABEL_74: \\"ENUM_LABEL_74\\",
  ENUM_LABEL_75: \\"ENUM_LABEL_75\\",
  ENUM_LABEL_76: \\"ENUM_LABEL_76\\",
  ENUM_LABEL_77: \\"ENUM_LABEL_77\\",
  ENUM_LABEL_78: \\"ENUM_LABEL_78\\",
  ENUM_LABEL_79: \\"ENUM_LABEL_79\\",
  ENUM_LABEL_80: \\"ENUM_LABEL_80\\",
  ENUM_LABEL_81: \\"ENUM_LABEL_81\\",
  ENUM_LABEL_82: \\"ENUM_LABEL_82\\",
  ENUM_LABEL_83: \\"ENUM_LABEL_83\\",
  ENUM_LABEL_84: \\"ENUM_LABEL_84\\",
  ENUM_LABEL_85: \\"ENUM_LABEL_85\\",
  ENUM_LABEL_86: \\"ENUM_LABEL_86\\",
  ENUM_LABEL_87: \\"ENUM_LABEL_87\\",
  ENUM_LABEL_88: \\"ENUM_LABEL_88\\",
  ENUM_LABEL_89: \\"ENUM_LABEL_89\\",
  ENUM_LABEL_90: \\"ENUM_LABEL_90\\",
  ENUM_LABEL_91: \\"ENUM_LABEL_91\\",
  ENUM_LABEL_92: \\"ENUM_LABEL_92\\",
  ENUM_LABEL_93: \\"ENUM_LABEL_93\\",
  ENUM_LABEL_94: \\"ENUM_LABEL_94\\",
  ENUM_LABEL_95: \\"ENUM_LABEL_95\\",
  ENUM_LABEL_96: \\"ENUM_LABEL_96\\",
  ENUM_LABEL_97: \\"ENUM_LABEL_97\\",
  ENUM_LABEL_98: \\"ENUM_LABEL_98\\",
  ENUM_LABEL_99: \\"ENUM_LABEL_99\\",
  ENUM_LABEL_100: \\"ENUM_LABEL_100\\",
};

const VeryLargeEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"ENUM_LABEL_DEFAULT\\";
    }
    case 1: {
      return \\"ENUM_LABEL_1\\";
    }
    case 2: {
      return \\"ENUM_LABEL_2\\";
    }
    case 3: {
      return \\"ENUM_LABEL_3\\";
    }
    case 4: {
      return \\"ENUM_LABEL_4\\";
    }
    case 5: {
      return \\"ENUM_LABEL_5\\";
    }
    case 6: {
      return \\"ENUM_LABEL_6\\";
    }
    case 7: {
      return \\"ENUM_LABEL_7\\";
    }
    case 8: {
      return \\"ENUM_LABEL_8\\";
    }
    case 9: {
      return \\"ENUM_LABEL_9\\";
    }
    case 10: {
      return \\"ENUM_LABEL_10\\";
    }
    case 11: {
      return \\"ENUM_LABEL_11\\";
    }
    case 12: {
      return \\"ENUM_LABEL_12\\";
    }
    case 13: {
      return \\"ENUM_LABEL_13\\";
    }
    case 14: {
      return \\"ENUM_LABEL_14\\";
    }
    case 15: {
      return \\"ENUM_LABEL_15\\";
    }
    case 16: {
      return \\"ENUM_LABEL_16\\";
    }
    case 17: {
      return \\"ENUM_LABEL_17\\";
    }
    case 18: {
      return \\"ENUM_LABEL_18\\";
    }
    case 19: {
      return \\"ENUM_LABEL_19\\";
    }
    case 20: {
      return \\"ENUM_LABEL_20\\";
    }
    case 21: {
      return \\"ENUM_LABEL_21\\";
    }
    case 22: {
      return \\"ENUM_LABEL_22\\";
    }
    case 23: {
      return \\"ENUM_LABEL_23\\";
    }
    case 24: {
      return \\"ENUM_LABEL_24\\";
    }
    case 25: {
      return \\"ENUM_LABEL_25\\";
    }
    case 26: {
      return \\"ENUM_LABEL_26\\";
    }
    case 27: {
      return \\"ENUM_LABEL_27\\";
    }
    case 28: {
      return \\"ENUM_LABEL_28\\";
    }
    case 29: {
      return \\"ENUM_LABEL_29\\";
    }
    case 30: {
      return \\"ENUM_LABEL_30\\";
    }
    case 31: {
      return \\"ENUM_LABEL_31\\";
    }
    case 32: {
      return \\"ENUM_LABEL_32\\";
    }
    case 33: {
      return \\"ENUM_LABEL_33\\";
    }
    case 34: {
      return \\"ENUM_LABEL_34\\";
    }
    case 35: {
      return \\"ENUM_LABEL_35\\";
    }
    case 36: {
      return \\"ENUM_LABEL_36\\";
    }
    case 37: {
      return \\"ENUM_LABEL_37\\";
    }
    case 38: {
      return \\"ENUM_LABEL_38\\";
    }
    case 39: {
      return \\"ENUM_LABEL_39\\";
    }
    case 40: {
      return \\"ENUM_LABEL_40\\";
    }
    case 41: {
      return \\"ENUM_LABEL_41\\";
    }
    case 42: {
      return \\"ENUM_LABEL_42\\";
    }
    case 43: {
      return \\"ENUM_LABEL_43\\";
    }
    case 44: {
      return \\"ENUM_LABEL_44\\";
    }
    case 45: {
      return \\"ENUM_LABEL_45\\";
    }
    case 46: {
      return \\"ENUM_LABEL_46\\";
    }
    case 47: {
      return \\"ENUM_LABEL_47\\";
    }
    case 48: {
      return \\"ENUM_LABEL_48\\";
    }
    case 49: {
      return \\"ENUM_LABEL_49\\";
    }
    case 50: {
      return \\"ENUM_LABEL_50\\";
    }
    case 51: {
      return \\"ENUM_LABEL_51\\";
    }
    case 52: {
      return \\"ENUM_LABEL_52\\";
    }
    case 53: {
      return \\"ENUM_LABEL_53\\";
    }
    case 54: {
      return \\"ENUM_LABEL_54\\";
    }
    case 55: {
      return \\"ENUM_LABEL_55\\";
    }
    case 56: {
      return \\"ENUM_LABEL_56\\";
    }
    case 57: {
      return \\"ENUM_LABEL_57\\";
    }
    case 58: {
      return \\"ENUM_LABEL_58\\";
    }
    case 59: {
      return \\"ENUM_LABEL_59\\";
    }
    case 60: {
      return \\"ENUM_LABEL_60\\";
    }
    case 61: {
      return \\"ENUM_LABEL_61\\";
    }
    case 62: {
      return \\"ENUM_LABEL_62\\";
    }
    case 63: {
      return \\"ENUM_LABEL_63\\";
    }
    case 64: {
      return \\"ENUM_LABEL_64\\";
    }
    case 65: {
      return \\"ENUM_LABEL_65\\";
    }
    case 66: {
      return \\"ENUM_LABEL_66\\";
    }
    case 67: {
      return \\"ENUM_LABEL_67\\";
    }
    case 68: {
      return \\"ENUM_LABEL_68\\";
    }
    case 69: {
      return \\"ENUM_LABEL_69\\";
    }
    case 70: {
      return \\"ENUM_LABEL_70\\";
    }
    case 71: {
      return \\"ENUM_LABEL_71\\";
    }
    case 72: {
      return \\"ENUM_LABEL_72\\";
    }
    case 73: {
      return \\"ENUM_LABEL_73\\";
    }
    case 74: {
      return \\"ENUM_LABEL_74\\";
    }
    case 75: {
      return \\"ENUM_LABEL_75\\";
    }
    case 76: {
      return \\"ENUM_LABEL_76\\";
    }
    case 77: {
      return \\"ENUM_LABEL_77\\";
    }
    case 78: {
      return \\"ENUM_LABEL_78\\";
    }
    case 79: {
      return \\"ENUM_LABEL_79\\";
    }
    case 80: {
      return \\"ENUM_LABEL_80\\";
    }
    case 81: {
      return \\"ENUM_LABEL_81\\";
    }
    case 82: {
      return \\"ENUM_LABEL_82\\";
    }
    case 83: {
      return \\"ENUM_LABEL_83\\";
    }
    case 84: {
      return \\"ENUM_LABEL_84\\";
    }
    case 85: {
      return \\"ENUM_LABEL_85\\";
    }
    case 86: {
      return \\"ENUM_LABEL_86\\";
    }
    case 87: {
      return \\"ENUM_LABEL_87\\";
    }
    case 88: {
      return \\"ENUM_LABEL_88\\";
    }
    case 89: {
      return \\"ENUM_LABEL_89\\";
    }
    case 90: {
      return \\"ENUM_LABEL_90\\";
    }
    case 91: {
      return \\"ENUM_LABEL_91\\";
    }
    case 92: {
      return \\"ENUM_LABEL_92\\";
    }
    case 93: {
      return \\"ENUM_LABEL_93\\";
    }
    case 94: {
      return \\"ENUM_LABEL_94\\";
    }
    case 95: {
      return \\"ENUM_LABEL_95\\";
    }
    case 96: {
      return \\"ENUM_LABEL_96\\";
    }
    case 97: {
      return \\"ENUM_LABEL_97\\";
    }
    case 98: {
      return \\"ENUM_LABEL_98\\";
    }
    case 99: {
      return \\"ENUM_LABEL_99\\";
    }
    case 100: {
      return \\"ENUM_LABEL_100\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const VeryLargeEnumToInt = function (i) {
  switch (i) {
    case \\"ENUM_LABEL_DEFAULT\\": {
      return 0;
    }
    case \\"ENUM_LABEL_1\\": {
      return 1;
    }
    case \\"ENUM_LABEL_2\\": {
      return 2;
    }
    case \\"ENUM_LABEL_3\\": {
      return 3;
    }
    case \\"ENUM_LABEL_4\\": {
      return 4;
    }
    case \\"ENUM_LABEL_5\\": {
      return 5;
    }
    case \\"ENUM_LABEL_6\\": {
      return 6;
    }
    case \\"ENUM_LABEL_7\\": {
      return 7;
    }
    case \\"ENUM_LABEL_8\\": {
      return 8;
    }
    case \\"ENUM_LABEL_9\\": {
      return 9;
    }
    case \\"ENUM_LABEL_10\\": {
      return 10;
    }
    case \\"ENUM_LABEL_11\\": {
      return 11;
    }
    case \\"ENUM_LABEL_12\\": {
      return 12;
    }
    case \\"ENUM_LABEL_13\\": {
      return 13;
    }
    case \\"ENUM_LABEL_14\\": {
      return 14;
    }
    case \\"ENUM_LABEL_15\\": {
      return 15;
    }
    case \\"ENUM_LABEL_16\\": {
      return 16;
    }
    case \\"ENUM_LABEL_17\\": {
      return 17;
    }
    case \\"ENUM_LABEL_18\\": {
      return 18;
    }
    case \\"ENUM_LABEL_19\\": {
      return 19;
    }
    case \\"ENUM_LABEL_20\\": {
      return 20;
    }
    case \\"ENUM_LABEL_21\\": {
      return 21;
    }
    case \\"ENUM_LABEL_22\\": {
      return 22;
    }
    case \\"ENUM_LABEL_23\\": {
      return 23;
    }
    case \\"ENUM_LABEL_24\\": {
      return 24;
    }
    case \\"ENUM_LABEL_25\\": {
      return 25;
    }
    case \\"ENUM_LABEL_26\\": {
      return 26;
    }
    case \\"ENUM_LABEL_27\\": {
      return 27;
    }
    case \\"ENUM_LABEL_28\\": {
      return 28;
    }
    case \\"ENUM_LABEL_29\\": {
      return 29;
    }
    case \\"ENUM_LABEL_30\\": {
      return 30;
    }
    case \\"ENUM_LABEL_31\\": {
      return 31;
    }
    case \\"ENUM_LABEL_32\\": {
      return 32;
    }
    case \\"ENUM_LABEL_33\\": {
      return 33;
    }
    case \\"ENUM_LABEL_34\\": {
      return 34;
    }
    case \\"ENUM_LABEL_35\\": {
      return 35;
    }
    case \\"ENUM_LABEL_36\\": {
      return 36;
    }
    case \\"ENUM_LABEL_37\\": {
      return 37;
    }
    case \\"ENUM_LABEL_38\\": {
      return 38;
    }
    case \\"ENUM_LABEL_39\\": {
      return 39;
    }
    case \\"ENUM_LABEL_40\\": {
      return 40;
    }
    case \\"ENUM_LABEL_41\\": {
      return 41;
    }
    case \\"ENUM_LABEL_42\\": {
      return 42;
    }
    case \\"ENUM_LABEL_43\\": {
      return 43;
    }
    case \\"ENUM_LABEL_44\\": {
      return 44;
    }
    case \\"ENUM_LABEL_45\\": {
      return 45;
    }
    case \\"ENUM_LABEL_46\\": {
      return 46;
    }
    case \\"ENUM_LABEL_47\\": {
      return 47;
    }
    case \\"ENUM_LABEL_48\\": {
      return 48;
    }
    case \\"ENUM_LABEL_49\\": {
      return 49;
    }
    case \\"ENUM_LABEL_50\\": {
      return 50;
    }
    case \\"ENUM_LABEL_51\\": {
      return 51;
    }
    case \\"ENUM_LABEL_52\\": {
      return 52;
    }
    case \\"ENUM_LABEL_53\\": {
      return 53;
    }
    case \\"ENUM_LABEL_54\\": {
      return 54;
    }
    case \\"ENUM_LABEL_55\\": {
      return 55;
    }
    case \\"ENUM_LABEL_56\\": {
      return 56;
    }
    case \\"ENUM_LABEL_57\\": {
      return 57;
    }
    case \\"ENUM_LABEL_58\\": {
      return 58;
    }
    case \\"ENUM_LABEL_59\\": {
      return 59;
    }
    case \\"ENUM_LABEL_60\\": {
      return 60;
    }
    case \\"ENUM_LABEL_61\\": {
      return 61;
    }
    case \\"ENUM_LABEL_62\\": {
      return 62;
    }
    case \\"ENUM_LABEL_63\\": {
      return 63;
    }
    case \\"ENUM_LABEL_64\\": {
      return 64;
    }
    case \\"ENUM_LABEL_65\\": {
      return 65;
    }
    case \\"ENUM_LABEL_66\\": {
      return 66;
    }
    case \\"ENUM_LABEL_67\\": {
      return 67;
    }
    case \\"ENUM_LABEL_68\\": {
      return 68;
    }
    case \\"ENUM_LABEL_69\\": {
      return 69;
    }
    case \\"ENUM_LABEL_70\\": {
      return 70;
    }
    case \\"ENUM_LABEL_71\\": {
      return 71;
    }
    case \\"ENUM_LABEL_72\\": {
      return 72;
    }
    case \\"ENUM_LABEL_73\\": {
      return 73;
    }
    case \\"ENUM_LABEL_74\\": {
      return 74;
    }
    case \\"ENUM_LABEL_75\\": {
      return 75;
    }
    case \\"ENUM_LABEL_76\\": {
      return 76;
    }
    case \\"ENUM_LABEL_77\\": {
      return 77;
    }
    case \\"ENUM_LABEL_78\\": {
      return 78;
    }
    case \\"ENUM_LABEL_79\\": {
      return 79;
    }
    case \\"ENUM_LABEL_80\\": {
      return 80;
    }
    case \\"ENUM_LABEL_81\\": {
      return 81;
    }
    case \\"ENUM_LABEL_82\\": {
      return 82;
    }
    case \\"ENUM_LABEL_83\\": {
      return 83;
    }
    case \\"ENUM_LABEL_84\\": {
      return 84;
    }
    case \\"ENUM_LABEL_85\\": {
      return 85;
    }
    case \\"ENUM_LABEL_86\\": {
      return 86;
    }
    case \\"ENUM_LABEL_87\\": {
      return 87;
    }
    case \\"ENUM_LABEL_88\\": {
      return 88;
    }
    case \\"ENUM_LABEL_89\\": {
      return 89;
    }
    case \\"ENUM_LABEL_90\\": {
      return 90;
    }
    case \\"ENUM_LABEL_91\\": {
      return 91;
    }
    case \\"ENUM_LABEL_92\\": {
      return 92;
    }
    case \\"ENUM_LABEL_93\\": {
      return 93;
    }
    case \\"ENUM_LABEL_94\\": {
      return 94;
    }
    case \\"ENUM_LABEL_95\\": {
      return 95;
    }
    case \\"ENUM_LABEL_96\\": {
      return 96;
    }
    case \\"ENUM_LABEL_97\\": {
      return 97;
    }
    case \\"ENUM_LABEL_98\\": {
      return 98;
    }
    case \\"ENUM_LABEL_99\\": {
      return 99;
    }
    case \\"ENUM_LABEL_100\\": {
      return 100;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalImportEnum: ImportEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      defaultForeignEnum: ForeignEnumFromInt(0),
      defaultImportEnum: ImportEnumFromInt(0),
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      writer.writeEnum(23, ImportEnumToInt(msg.optionalImportEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum.map(ImportEnumToInt));
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(81, TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum));
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnumToInt(msg.defaultForeignEnum));
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      writer.writeEnum(83, ImportEnumToInt(msg.defaultImportEnum));
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json.defaultBytes = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(ImportEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (_optionalImportEnum) {
      msg.optionalImportEnum = _optionalImportEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (_repeatedImportEnum) {
      msg.repeatedImportEnum = _repeatedImportEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (_defaultInt32) {
      msg.defaultInt32 = _defaultInt32;
    }
    const _defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (_defaultInt64) {
      msg.defaultInt64 = BigInt(_defaultInt64);
    }
    const _defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (_defaultUint32) {
      msg.defaultUint32 = _defaultUint32;
    }
    const _defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (_defaultUint64) {
      msg.defaultUint64 = BigInt(_defaultUint64);
    }
    const _defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (_defaultSint32) {
      msg.defaultSint32 = _defaultSint32;
    }
    const _defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (_defaultSint64) {
      msg.defaultSint64 = BigInt(_defaultSint64);
    }
    const _defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (_defaultFixed32) {
      msg.defaultFixed32 = _defaultFixed32;
    }
    const _defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (_defaultFixed64) {
      msg.defaultFixed64 = BigInt(_defaultFixed64);
    }
    const _defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (_defaultSfixed32) {
      msg.defaultSfixed32 = _defaultSfixed32;
    }
    const _defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (_defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64);
    }
    const _defaultFloat = json.defaultFloat ?? json.default_float;
    if (_defaultFloat) {
      msg.defaultFloat = _defaultFloat;
    }
    const _defaultDouble = json.defaultDouble ?? json.default_double;
    if (_defaultDouble) {
      msg.defaultDouble = _defaultDouble;
    }
    const _defaultBool = json.defaultBool ?? json.default_bool;
    if (_defaultBool) {
      msg.defaultBool = _defaultBool;
    }
    const _defaultString = json.defaultString ?? json.default_string;
    if (_defaultString) {
      msg.defaultString = _defaultString;
    }
    const _defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (_defaultBytes) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes);
    }
    const _defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (_defaultNestedEnum) {
      msg.defaultNestedEnum = _defaultNestedEnum;
    }
    const _defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (_defaultForeignEnum) {
      msg.defaultForeignEnum = _defaultForeignEnum;
    }
    const _defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (_defaultImportEnum) {
      msg.defaultImportEnum = _defaultImportEnum;
    }
    const _defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (_defaultStringPiece) {
      msg.defaultStringPiece = _defaultStringPiece;
    }
    const _defaultCord = json.defaultCord ?? json.default_cord;
    if (_defaultCord) {
      msg.defaultCord = _defaultCord;
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.RepeatedGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    const _repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (_repeatedChild) {
      for (const item of _repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (msg) {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDeprecatedFields._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json) {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (_deprecatedInt32) {
      msg.deprecatedInt32 = _deprecatedInt32;
    }
    const _deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (_deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (msg) {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OptionalGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (msg) {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(RepeatedGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (msg) {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestGroup._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json) {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestGroup.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (msg) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (msg) {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestChildExtension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json) {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _optionalExtension =
      json.optionalExtension ?? json.optional_extension;
    if (_optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, _optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (msg) {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequired._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json) {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _dummy2 = json.dummy2;
    if (_dummy2) {
      msg.dummy2 = _dummy2;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _dummy4 = json.dummy4;
    if (_dummy4) {
      msg.dummy4 = _dummy4;
    }
    const _dummy5 = json.dummy5;
    if (_dummy5) {
      msg.dummy5 = _dummy5;
    }
    const _dummy6 = json.dummy6;
    if (_dummy6) {
      msg.dummy6 = _dummy6;
    }
    const _dummy7 = json.dummy7;
    if (_dummy7) {
      msg.dummy7 = _dummy7;
    }
    const _dummy8 = json.dummy8;
    if (_dummy8) {
      msg.dummy8 = _dummy8;
    }
    const _dummy9 = json.dummy9;
    if (_dummy9) {
      msg.dummy9 = _dummy9;
    }
    const _dummy10 = json.dummy10;
    if (_dummy10) {
      msg.dummy10 = _dummy10;
    }
    const _dummy11 = json.dummy11;
    if (_dummy11) {
      msg.dummy11 = _dummy11;
    }
    const _dummy12 = json.dummy12;
    if (_dummy12) {
      msg.dummy12 = _dummy12;
    }
    const _dummy13 = json.dummy13;
    if (_dummy13) {
      msg.dummy13 = _dummy13;
    }
    const _dummy14 = json.dummy14;
    if (_dummy14) {
      msg.dummy14 = _dummy14;
    }
    const _dummy15 = json.dummy15;
    if (_dummy15) {
      msg.dummy15 = _dummy15;
    }
    const _dummy16 = json.dummy16;
    if (_dummy16) {
      msg.dummy16 = _dummy16;
    }
    const _dummy17 = json.dummy17;
    if (_dummy17) {
      msg.dummy17 = _dummy17;
    }
    const _dummy18 = json.dummy18;
    if (_dummy18) {
      msg.dummy18 = _dummy18;
    }
    const _dummy19 = json.dummy19;
    if (_dummy19) {
      msg.dummy19 = _dummy19;
    }
    const _dummy20 = json.dummy20;
    if (_dummy20) {
      msg.dummy20 = _dummy20;
    }
    const _dummy21 = json.dummy21;
    if (_dummy21) {
      msg.dummy21 = _dummy21;
    }
    const _dummy22 = json.dummy22;
    if (_dummy22) {
      msg.dummy22 = _dummy22;
    }
    const _dummy23 = json.dummy23;
    if (_dummy23) {
      msg.dummy23 = _dummy23;
    }
    const _dummy24 = json.dummy24;
    if (_dummy24) {
      msg.dummy24 = _dummy24;
    }
    const _dummy25 = json.dummy25;
    if (_dummy25) {
      msg.dummy25 = _dummy25;
    }
    const _dummy26 = json.dummy26;
    if (_dummy26) {
      msg.dummy26 = _dummy26;
    }
    const _dummy27 = json.dummy27;
    if (_dummy27) {
      msg.dummy27 = _dummy27;
    }
    const _dummy28 = json.dummy28;
    if (_dummy28) {
      msg.dummy28 = _dummy28;
    }
    const _dummy29 = json.dummy29;
    if (_dummy29) {
      msg.dummy29 = _dummy29;
    }
    const _dummy30 = json.dummy30;
    if (_dummy30) {
      msg.dummy30 = _dummy30;
    }
    const _dummy31 = json.dummy31;
    if (_dummy31) {
      msg.dummy31 = _dummy31;
    }
    const _dummy32 = json.dummy32;
    if (_dummy32) {
      msg.dummy32 = _dummy32;
    }
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (msg) {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredForeign._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage = json.requiredMessage ?? json.required_message;
    if (_requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (msg) {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestForeignNested._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json) {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _foreignNested = json.foreignNested ?? json.foreign_nested;
    if (_foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (msg) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            msg
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (json) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _cc = json.cc;
        if (_cc) {
          msg.cc = _cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg) {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestReallyLargeTagNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _bb = json.bb;
    if (_bb) {
      msg.bb = _bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRecursiveMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _i = json.i;
    if (_i) {
      msg.i = _i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMutualRecursionA._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _bb = json.bb;
    if (_bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, _bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _b = json.b;
      if (_b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, _b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _subMessage = json.subMessage ?? json.sub_message;
      if (_subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, _subMessage);
        msg.subMessage = m;
      }
      const _notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (_notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMutualRecursionB._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (msg) {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestIsInitialized._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json) {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (_msg) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes) {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */
    encodeJSON: function (_msg) {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */
    decodeJSON: function (_json) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (msg) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (json) {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _i = json.i;
        if (_i) {
          msg.i = _i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (msg) {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDupFieldNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (msg) {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (msg) {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg) {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestNestedMessageHasBits._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json) {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (_nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32;
      }
      const _nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (_nestedmessageRepeatedForeignmessage) {
        for (const item of _nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg) {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestCamelCaseFieldNames._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json) {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: ForeignEnumFromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnumToInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField.map(ForeignEnumToInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _PrimitiveField = json.PrimitiveField;
    if (_PrimitiveField) {
      msg.PrimitiveField = _PrimitiveField;
    }
    const _StringField = json.StringField;
    if (_StringField) {
      msg.StringField = _StringField;
    }
    const _EnumField = json.EnumField;
    if (_EnumField) {
      msg.EnumField = _EnumField;
    }
    const _MessageField = json.MessageField;
    if (_MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _MessageField);
      msg.MessageField = m;
    }
    const _StringPieceField = json.StringPieceField;
    if (_StringPieceField) {
      msg.StringPieceField = _StringPieceField;
    }
    const _CordField = json.CordField;
    if (_CordField) {
      msg.CordField = _CordField;
    }
    const _RepeatedPrimitiveField = json.RepeatedPrimitiveField;
    if (_RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField;
    }
    const _RepeatedStringField = json.RepeatedStringField;
    if (_RepeatedStringField) {
      msg.RepeatedStringField = _RepeatedStringField;
    }
    const _RepeatedEnumField = json.RepeatedEnumField;
    if (_RepeatedEnumField) {
      msg.RepeatedEnumField = _RepeatedEnumField;
    }
    const _RepeatedMessageField = json.RepeatedMessageField;
    if (_RepeatedMessageField) {
      for (const item of _RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField = json.RepeatedStringPieceField;
    if (_RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField;
    }
    const _RepeatedCordField = json.RepeatedCordField;
    if (_RepeatedCordField) {
      msg.RepeatedCordField = _RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (msg) {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestFieldOrderings._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json) {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    const _myInt = json.myInt ?? json.my_int;
    if (_myInt) {
      msg.myInt = BigInt(_myInt);
    }
    const _myFloat = json.myFloat ?? json.my_float;
    if (_myFloat) {
      msg.myFloat = _myFloat;
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _oo = json.oo;
      if (_oo) {
        msg.oo = BigInt(_oo);
      }
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionOrderings1._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionOrderings2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (msg) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (json) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _myString = json.myString ?? json.my_string;
      if (_myString) {
        msg.myString = _myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg) {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtremeDefaultValues._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json) {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.escapedBytes?.length) {
      json.escapedBytes = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json.bytesWithZero = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (_escapedBytes) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes);
    }
    const _largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (_largeUint32) {
      msg.largeUint32 = _largeUint32;
    }
    const _largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (_largeUint64) {
      msg.largeUint64 = BigInt(_largeUint64);
    }
    const _smallInt32 = json.smallInt32 ?? json.small_int32;
    if (_smallInt32) {
      msg.smallInt32 = _smallInt32;
    }
    const _smallInt64 = json.smallInt64 ?? json.small_int64;
    if (_smallInt64) {
      msg.smallInt64 = BigInt(_smallInt64);
    }
    const _reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (_reallySmallInt32) {
      msg.reallySmallInt32 = _reallySmallInt32;
    }
    const _reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (_reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64);
    }
    const _utf8String = json.utf8String ?? json.utf8_string;
    if (_utf8String) {
      msg.utf8String = _utf8String;
    }
    const _zeroFloat = json.zeroFloat ?? json.zero_float;
    if (_zeroFloat) {
      msg.zeroFloat = _zeroFloat;
    }
    const _oneFloat = json.oneFloat ?? json.one_float;
    if (_oneFloat) {
      msg.oneFloat = _oneFloat;
    }
    const _smallFloat = json.smallFloat ?? json.small_float;
    if (_smallFloat) {
      msg.smallFloat = _smallFloat;
    }
    const _negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (_negativeOneFloat) {
      msg.negativeOneFloat = _negativeOneFloat;
    }
    const _negativeFloat = json.negativeFloat ?? json.negative_float;
    if (_negativeFloat) {
      msg.negativeFloat = _negativeFloat;
    }
    const _largeFloat = json.largeFloat ?? json.large_float;
    if (_largeFloat) {
      msg.largeFloat = _largeFloat;
    }
    const _smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (_smallNegativeFloat) {
      msg.smallNegativeFloat = _smallNegativeFloat;
    }
    const _infDouble = json.infDouble ?? json.inf_double;
    if (_infDouble) {
      msg.infDouble = _infDouble;
    }
    const _negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (_negInfDouble) {
      msg.negInfDouble = _negInfDouble;
    }
    const _nanDouble = json.nanDouble ?? json.nan_double;
    if (_nanDouble) {
      msg.nanDouble = _nanDouble;
    }
    const _infFloat = json.infFloat ?? json.inf_float;
    if (_infFloat) {
      msg.infFloat = _infFloat;
    }
    const _negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (_negInfFloat) {
      msg.negInfFloat = _negInfFloat;
    }
    const _nanFloat = json.nanFloat ?? json.nan_float;
    if (_nanFloat) {
      msg.nanFloat = _nanFloat;
    }
    const _cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (_cppTrigraph) {
      msg.cppTrigraph = _cppTrigraph;
    }
    const _stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (_stringWithZero) {
      msg.stringWithZero = _stringWithZero;
    }
    const _bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (_bytesWithZero) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero);
    }
    const _stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (_stringPieceWithZero) {
      msg.stringPieceWithZero = _stringPieceWithZero;
    }
    const _cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (_cordWithZero) {
      msg.cordWithZero = _cordWithZero;
    }
    const _replacementString =
      json.replacementString ?? json.replacement_string;
    if (_replacementString) {
      msg.replacementString = _replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (msg) {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(SparseEnumMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json) {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnumToInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (_sparseEnum) {
      msg.sparseEnum = _sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (msg) {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json) {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (msg) {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MoreString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json) {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (msg) {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json) {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = decodeBase64Bytes(_data);
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (msg) {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MoreBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json) {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (msg) {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json) {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (msg) {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Uint32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (msg) {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json) {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (msg) {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Uint64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (msg) {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BoolMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json) {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (msg) {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg) {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneofBackwardsCompatible._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json) {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnumToInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json.fooBytes = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json.barBytes = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json.barBytesWithEmptyDefault = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooCord = json.fooCord ?? json.foo_cord;
    if (_fooCord) {
      msg.fooCord = _fooCord;
    }
    const _fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (_fooStringPiece) {
      msg.fooStringPiece = _fooStringPiece;
    }
    const _fooBytes = json.fooBytes ?? json.foo_bytes;
    if (_fooBytes) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes);
    }
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    const _fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (_fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const _barInt = json.barInt ?? json.bar_int;
    if (_barInt) {
      msg.barInt = _barInt;
    }
    const _barString = json.barString ?? json.bar_string;
    if (_barString) {
      msg.barString = _barString;
    }
    const _barCord = json.barCord ?? json.bar_cord;
    if (_barCord) {
      msg.barCord = _barCord;
    }
    const _barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (_barStringPiece) {
      msg.barStringPiece = _barStringPiece;
    }
    const _barBytes = json.barBytes ?? json.bar_bytes;
    if (_barBytes) {
      msg.barBytes = decodeBase64Bytes(_barBytes);
    }
    const _barEnum = json.barEnum ?? json.bar_enum;
    if (_barEnum) {
      msg.barEnum = _barEnum;
    }
    const _barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (_barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault;
    }
    const _barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (_barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault;
    }
    const _barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (_barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault;
    }
    const _barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (_barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault
      );
    }
    const _bazInt = json.bazInt ?? json.baz_int;
    if (_bazInt) {
      msg.bazInt = _bazInt;
    }
    const _bazString = json.bazString ?? json.baz_string;
    if (_bazString) {
      msg.bazString = _bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestOneof2.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _quxInt = json.quxInt ?? json.qux_int;
      if (_quxInt) {
        msg.quxInt = BigInt(_quxInt);
      }
      const _corgeInt = json.corgeInt ?? json.corge_int;
      if (_corgeInt) {
        msg.corgeInt = _corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (msg) {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _requiredDouble = json.requiredDouble ?? json.required_double;
      if (_requiredDouble) {
        msg.requiredDouble = _requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (_unpackedInt32) {
      msg.unpackedInt32 = _unpackedInt32;
    }
    const _unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (_unpackedInt64) {
      msg.unpackedInt64 = _unpackedInt64.map(BigInt);
    }
    const _unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (_unpackedUint32) {
      msg.unpackedUint32 = _unpackedUint32;
    }
    const _unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (_unpackedUint64) {
      msg.unpackedUint64 = _unpackedUint64.map(BigInt);
    }
    const _unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (_unpackedSint32) {
      msg.unpackedSint32 = _unpackedSint32;
    }
    const _unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (_unpackedSint64) {
      msg.unpackedSint64 = _unpackedSint64.map(BigInt);
    }
    const _unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (_unpackedFixed32) {
      msg.unpackedFixed32 = _unpackedFixed32;
    }
    const _unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (_unpackedFixed64) {
      msg.unpackedFixed64 = _unpackedFixed64.map(BigInt);
    }
    const _unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (_unpackedSfixed32) {
      msg.unpackedSfixed32 = _unpackedSfixed32;
    }
    const _unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (_unpackedSfixed64) {
      msg.unpackedSfixed64 = _unpackedSfixed64.map(BigInt);
    }
    const _unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (_unpackedFloat) {
      msg.unpackedFloat = _unpackedFloat;
    }
    const _unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (_unpackedDouble) {
      msg.unpackedDouble = _unpackedDouble;
    }
    const _unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (_unpackedBool) {
      msg.unpackedBool = _unpackedBool;
    }
    const _unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (_unpackedEnum) {
      msg.unpackedEnum = _unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (msg) {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestDynamicExtensions._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json) {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnumFromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumTypeFromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnumToInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      json.enumExtension = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumTypeFromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (_scalarExtension) {
      msg.scalarExtension = _scalarExtension;
    }
    const _enumExtension = json.enumExtension ?? json.enum_extension;
    if (_enumExtension) {
      msg.enumExtension = _enumExtension;
    }
    const _dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (_dynamicEnumExtension) {
      msg.dynamicEnumExtension = _dynamicEnumExtension;
    }
    const _messageExtension = json.messageExtension ?? json.message_extension;
    if (_messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _messageExtension);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (_dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        _dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension =
      json.repeatedExtension ?? json.repeated_extension;
    if (_repeatedExtension) {
      msg.repeatedExtension = _repeatedExtension;
    }
    const _packedExtension = json.packedExtension ?? json.packed_extension;
    if (_packedExtension) {
      msg.packedExtension = _packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: \\"DYNAMIC_FOO\\",
    DYNAMIC_BAR: \\"DYNAMIC_BAR\\",
    DYNAMIC_BAZ: \\"DYNAMIC_BAZ\\",
  },

  DynamicEnumTypeFromInt: function (i) {
    switch (i) {
      case 2200: {
        return \\"DYNAMIC_FOO\\";
      }
      case 2201: {
        return \\"DYNAMIC_BAR\\";
      }
      case 2202: {
        return \\"DYNAMIC_BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  DynamicEnumTypeToInt: function (i) {
    switch (i) {
      case \\"DYNAMIC_FOO\\": {
        return 2200;
      }
      case \\"DYNAMIC_BAR\\": {
        return 2201;
      }
      case \\"DYNAMIC_BAZ\\": {
        return 2202;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (msg) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (json) {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _dynamicField = json.dynamicField ?? json.dynamic_field;
      if (_dynamicField) {
        msg.dynamicField = _dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (msg) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json) {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (msg) {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json) {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (_requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (_optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (_repeatedAllTypes) {
      for (const item of _repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _field1 = json.field1;
      if (_field1) {
        for (const item of _field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const _field2 = json.field2;
      if (_field2) {
        for (const item of _field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const _field3 = json.field3;
      if (_field3) {
        for (const item of _field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1 = json.ext1;
      if (_ext1) {
        for (const item of _ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2 = json.ext2;
      if (_ext2) {
        for (const item of _ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (msg) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (_optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (_repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg) {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestCommentInjectionMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (msg) {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestJsonName._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json) {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fieldName1 = json.fieldName1 ?? json.field_name1;
    if (_fieldName1) {
      msg.fieldName1 = _fieldName1;
    }
    const _fieldName2 = json.fieldName2;
    if (_fieldName2) {
      msg.fieldName2 = _fieldName2;
    }
    const _FieldName3 = json.FieldName3;
    if (_FieldName3) {
      msg.FieldName3 = _FieldName3;
    }
    const _FieldName4 = json.FieldName4 ?? json._field_name4;
    if (_FieldName4) {
      msg.FieldName4 = _FieldName4;
    }
    const _FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (_FIELDNAME5) {
      msg.FIELDNAME5 = _FIELDNAME5;
    }
    const _fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (_fieldName6) {
      msg.fieldName6 = _fieldName6;
    }
    const _fieldname7 = json.fieldname7;
    if (_fieldname7) {
      msg.fieldname7 = _fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg) {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestHugeFieldNumbers._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json) {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnumFromInt(0),
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnumToInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      const stringStringMap = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringStringMap).length > 0) {
        json.stringStringMap = stringStringMap;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const stringStringMap = {};
          reader.readMessage(
            stringStringMap,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[stringStringMap.key] = stringStringMap.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _fixed32 = json.fixed32 ?? json.fixed_32;
    if (_fixed32) {
      msg.fixed32 = _fixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (_optionalEnum) {
      msg.optionalEnum = _optionalEnum;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (_stringStringMap) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (_oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _groupA = json.groupA ?? json.group_a;
      if (_groupA) {
        msg.groupA = _groupA;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (msg) {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionInsideTable._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _field1 = json.field1;
    if (_field1) {
      msg.field1 = _field1;
    }
    const _field2 = json.field2;
    if (_field2) {
      msg.field2 = _field2;
    }
    const _field3 = json.field3;
    if (_field3) {
      msg.field3 = _field3;
    }
    const _field4 = json.field4;
    if (_field4) {
      msg.field4 = _field4;
    }
    const _field6 = json.field6;
    if (_field6) {
      msg.field6 = _field6;
    }
    const _field7 = json.field7;
    if (_field7) {
      msg.field7 = _field7;
    }
    const _field8 = json.field8;
    if (_field8) {
      msg.field8 = _field8;
    }
    const _field9 = json.field9;
    if (_field9) {
      msg.field9 = _field9;
    }
    const _field10 = json.field10;
    if (_field10) {
      msg.field10 = _field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg) {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestExtensionRangeSerialize._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooOne = json.fooOne ?? json.foo_one;
    if (_fooOne) {
      msg.fooOne = _fooOne;
    }
    const _fooTwo = json.fooTwo ?? json.foo_two;
    if (_fooTwo) {
      msg.fooTwo = _fooTwo;
    }
    const _fooThree = json.fooThree ?? json.foo_three;
    if (_fooThree) {
      msg.fooThree = _fooThree;
    }
    const _fooFour = json.fooFour ?? json.foo_four;
    if (_fooFour) {
      msg.fooFour = _fooFour;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: \\"MAP_ENUM_FOO\\",
  MAP_ENUM_BAR: \\"MAP_ENUM_BAR\\",
  MAP_ENUM_BAZ: \\"MAP_ENUM_BAZ\\",
};

const MapEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"MAP_ENUM_FOO\\";
    }
    case 1: {
      return \\"MAP_ENUM_BAR\\";
    }
    case 2: {
      return \\"MAP_ENUM_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const MapEnumToInt = function (i) {
  switch (i) {
    case \\"MAP_ENUM_FOO\\": {
      return 0;
    }
    case \\"MAP_ENUM_BAR\\": {
      return 1;
    }
    case \\"MAP_ENUM_BAZ\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (msg) {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    if (msg.mapStringForeignMessage) {
      const mapStringForeignMessage = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringForeignMessage).length > 0) {
        json.mapStringForeignMessage = mapStringForeignMessage;
      }
    }
    if (msg.mapInt32AllTypes) {
      const mapInt32AllTypes = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32AllTypes).length > 0) {
        json.mapInt32AllTypes = mapInt32AllTypes;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {};
          reader.readMessage(mapInt32Int32, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {};
          reader.readMessage(mapInt64Int64, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {};
          reader.readMessage(
            mapUint32Uint32,
            TestMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {};
          reader.readMessage(
            mapUint64Uint64,
            TestMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {};
          reader.readMessage(
            mapSint32Sint32,
            TestMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {};
          reader.readMessage(
            mapSint64Sint64,
            TestMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {};
          reader.readMessage(
            mapFixed32Fixed32,
            TestMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {};
          reader.readMessage(
            mapFixed64Fixed64,
            TestMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 = {};
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 = {};
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {};
          reader.readMessage(mapInt32Float, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {};
          reader.readMessage(
            mapInt32Double,
            TestMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {};
          reader.readMessage(mapBoolBool, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {};
          reader.readMessage(
            mapStringString,
            TestMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {};
          reader.readMessage(mapInt32Bytes, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {};
          reader.readMessage(mapInt32Enum, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage = {};
          reader.readMessage(
            mapInt32ForeignMessage,
            TestMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        case 18: {
          const mapStringForeignMessage = {};
          reader.readMessage(
            mapStringForeignMessage,
            TestMap.MapStringForeignMessage._readMessage
          );
          msg.mapStringForeignMessage[mapStringForeignMessage.key] =
            mapStringForeignMessage.value;
          break;
        }
        case 19: {
          const mapInt32AllTypes = {};
          reader.readMessage(
            mapInt32AllTypes,
            TestMap.MapInt32AllTypes._readMessage
          );
          msg.mapInt32AllTypes[mapInt32AllTypes.key] = mapInt32AllTypes.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (_mapStringForeignMessage) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (_mapInt32AllTypes) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (msg) {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMapSubmessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json) {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _testMap = json.testMap ?? json.test_map;
    if (_testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, _testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      const mapInt32Message = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Message).length > 0) {
        json.mapInt32Message = mapInt32Message;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Message = {};
          reader.readMessage(
            mapInt32Message,
            TestMessageMap.MapInt32Message._readMessage
          );
          msg.mapInt32Message[mapInt32Message.key] = mapInt32Message.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (_mapInt32Message) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (msg) {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json) {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.map1) {
      const map1 = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map1).length > 0) {
        json.map1 = map1;
      }
    }
    if (msg.map2) {
      const map2 = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map2).length > 0) {
        json.map2 = map2;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map1 = {};
          reader.readMessage(map1, TestSameTypeMap.Map1._readMessage);
          msg.map1[map1.key] = map1.value;
          break;
        }
        case 2: {
          const map2 = {};
          reader.readMessage(map2, TestSameTypeMap.Map2._readMessage);
          msg.map2[map2.key] = map2.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _map1 = json.map1;
    if (_map1) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2 = json.map2;
    if (_map2) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRequiredMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapField) {
      const mapField = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapField).length > 0) {
        json.mapField = mapField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapField = {};
          reader.readMessage(
            mapField,
            TestRequiredMessageMap.MapField._readMessage
          );
          msg.mapField[mapField.key] = mapField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapField = json.mapField ?? json.map_field;
    if (_mapField) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestRequired._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRequired._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (msg) {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestArenaMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json) {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {};
          reader.readMessage(
            mapInt32Int32,
            TestArenaMap.MapInt32Int32._readMessage
          );
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {};
          reader.readMessage(
            mapInt64Int64,
            TestArenaMap.MapInt64Int64._readMessage
          );
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {};
          reader.readMessage(
            mapUint32Uint32,
            TestArenaMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {};
          reader.readMessage(
            mapUint64Uint64,
            TestArenaMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {};
          reader.readMessage(
            mapSint32Sint32,
            TestArenaMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {};
          reader.readMessage(
            mapSint64Sint64,
            TestArenaMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {};
          reader.readMessage(
            mapFixed32Fixed32,
            TestArenaMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {};
          reader.readMessage(
            mapFixed64Fixed64,
            TestArenaMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 = {};
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 = {};
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {};
          reader.readMessage(
            mapInt32Float,
            TestArenaMap.MapInt32Float._readMessage
          );
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {};
          reader.readMessage(
            mapInt32Double,
            TestArenaMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {};
          reader.readMessage(
            mapBoolBool,
            TestArenaMap.MapBoolBool._readMessage
          );
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {};
          reader.readMessage(
            mapStringString,
            TestArenaMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {};
          reader.readMessage(
            mapInt32Bytes,
            TestArenaMap.MapInt32Bytes._readMessage
          );
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {};
          reader.readMessage(
            mapInt32Enum,
            TestArenaMap.MapInt32Enum._readMessage
          );
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage = {};
          reader.readMessage(
            mapInt32ForeignMessage,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg) {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json) {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.entry) {
      const entry = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(entry).length > 0) {
        json.entry = entry;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const entry = {};
          reader.readMessage(
            entry,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[entry.key] = entry.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _entry = json.entry;
    if (_entry) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestRecursiveMapMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const a = {};
          reader.readMessage(a, TestRecursiveMapMessage.A._readMessage);
          msg.a[a.key] = a.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _a = json.a;
    if (_a) {
      msg.a = Object.fromEntries(
        Object.entries(_a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRecursiveMapMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRecursiveMapMessage.initialize(),
              TestRecursiveMapMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/any.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/any.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Any = {
  /**
   * Serializes a Any to protobuf.
   */
  encode: function (msg) {
    return Any._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Any from protobuf.
   */
  decode: function (bytes) {
    return Any._readMessage(Any.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Any to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Any._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Any from JSON.
   */
  decodeJSON: function (json) {
    return Any._readMessageJSON(Any.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Any with all fields set to their default value.
   */
  initialize: function () {
    return {
      typeUrl: \\"\\",
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/source_context.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/source_context.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SourceContext = {
  /**
   * Serializes a SourceContext to protobuf.
   */
  encode: function (msg) {
    return SourceContext._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SourceContext from protobuf.
   */
  decode: function (bytes) {
    return SourceContext._readMessage(
      SourceContext.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SourceContext to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(SourceContext._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SourceContext from JSON.
   */
  decodeJSON: function (json) {
    return SourceContext._readMessageJSON(
      SourceContext.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SourceContext with all fields set to their default value.
   */
  initialize: function () {
    return {
      fileName: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fileName) {
      json.fileName = msg.fileName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fileName = json.fileName ?? json.file_name;
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/type.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { SourceContext } from \\"./source_context.pb\\";
import { Any } from \\"./any.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Syntax = {
  /**
   * Syntax \`proto2\`.
   */
  SYNTAX_PROTO2: \\"SYNTAX_PROTO2\\",
  /**
   * Syntax \`proto3\`.
   */
  SYNTAX_PROTO3: \\"SYNTAX_PROTO3\\",
};

const SyntaxFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"SYNTAX_PROTO2\\";
    }
    case 1: {
      return \\"SYNTAX_PROTO3\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const SyntaxToInt = function (i) {
  switch (i) {
    case \\"SYNTAX_PROTO2\\": {
      return 0;
    }
    case \\"SYNTAX_PROTO3\\": {
      return 1;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const Type = {
  /**
   * Serializes a Type to protobuf.
   */
  encode: function (msg) {
    return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Type from protobuf.
   */
  decode: function (bytes) {
    return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Type to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Type._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Type from JSON.
   */
  decodeJSON: function (json) {
    return Type._readMessageJSON(Type.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Type with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(6, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.fields?.length) {
      json.fields = msg.fields.map(Field._writeMessageJSON);
    }
    if (msg.oneofs?.length) {
      json.oneofs = msg.oneofs;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _fields = json.fields;
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        Field._readMessageJSON(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json.oneofs;
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Field = {
  /**
   * Serializes a Field to protobuf.
   */
  encode: function (msg) {
    return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Field from protobuf.
   */
  decode: function (bytes) {
    return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Field to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Field._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Field from JSON.
   */
  decodeJSON: function (json) {
    return Field._readMessageJSON(Field.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Field with all fields set to their default value.
   */
  initialize: function () {
    return {
      kind: Field.KindFromInt(0),
      cardinality: Field.CardinalityFromInt(0),
      number: 0,
      name: \\"\\",
      typeUrl: \\"\\",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: \\"\\",
      defaultValue: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.kind && Field.KindToInt(msg.kind)) {
      writer.writeEnum(1, Field.KindToInt(msg.kind));
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      writer.writeEnum(2, Field.CardinalityToInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options, Option._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.kind && Field.KindToInt(msg.kind)) {
      json.kind = msg.kind;
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      json.cardinality = msg.cardinality;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json.oneofIndex = msg.oneofIndex;
    }
    if (msg.packed) {
      json.packed = msg.packed;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.jsonName) {
      json.jsonName = msg.jsonName;
    }
    if (msg.defaultValue) {
      json.defaultValue = msg.defaultValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.KindFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.CardinalityFromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _kind = json.kind;
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json.cardinality;
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json.oneofIndex ?? json.oneof_index;
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json.packed;
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json.jsonName ?? json.json_name;
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json.defaultValue ?? json.default_value;
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: \\"TYPE_UNKNOWN\\",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: \\"TYPE_DOUBLE\\",
    /**
     * Field type float.
     */
    TYPE_FLOAT: \\"TYPE_FLOAT\\",
    /**
     * Field type int64.
     */
    TYPE_INT64: \\"TYPE_INT64\\",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: \\"TYPE_UINT64\\",
    /**
     * Field type int32.
     */
    TYPE_INT32: \\"TYPE_INT32\\",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: \\"TYPE_FIXED64\\",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: \\"TYPE_FIXED32\\",
    /**
     * Field type bool.
     */
    TYPE_BOOL: \\"TYPE_BOOL\\",
    /**
     * Field type string.
     */
    TYPE_STRING: \\"TYPE_STRING\\",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: \\"TYPE_GROUP\\",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: \\"TYPE_MESSAGE\\",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: \\"TYPE_BYTES\\",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: \\"TYPE_UINT32\\",
    /**
     * Field type enum.
     */
    TYPE_ENUM: \\"TYPE_ENUM\\",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: \\"TYPE_SFIXED32\\",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: \\"TYPE_SFIXED64\\",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: \\"TYPE_SINT32\\",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: \\"TYPE_SINT64\\",
  },

  KindFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"TYPE_UNKNOWN\\";
      }
      case 1: {
        return \\"TYPE_DOUBLE\\";
      }
      case 2: {
        return \\"TYPE_FLOAT\\";
      }
      case 3: {
        return \\"TYPE_INT64\\";
      }
      case 4: {
        return \\"TYPE_UINT64\\";
      }
      case 5: {
        return \\"TYPE_INT32\\";
      }
      case 6: {
        return \\"TYPE_FIXED64\\";
      }
      case 7: {
        return \\"TYPE_FIXED32\\";
      }
      case 8: {
        return \\"TYPE_BOOL\\";
      }
      case 9: {
        return \\"TYPE_STRING\\";
      }
      case 10: {
        return \\"TYPE_GROUP\\";
      }
      case 11: {
        return \\"TYPE_MESSAGE\\";
      }
      case 12: {
        return \\"TYPE_BYTES\\";
      }
      case 13: {
        return \\"TYPE_UINT32\\";
      }
      case 14: {
        return \\"TYPE_ENUM\\";
      }
      case 15: {
        return \\"TYPE_SFIXED32\\";
      }
      case 16: {
        return \\"TYPE_SFIXED64\\";
      }
      case 17: {
        return \\"TYPE_SINT32\\";
      }
      case 18: {
        return \\"TYPE_SINT64\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  KindToInt: function (i) {
    switch (i) {
      case \\"TYPE_UNKNOWN\\": {
        return 0;
      }
      case \\"TYPE_DOUBLE\\": {
        return 1;
      }
      case \\"TYPE_FLOAT\\": {
        return 2;
      }
      case \\"TYPE_INT64\\": {
        return 3;
      }
      case \\"TYPE_UINT64\\": {
        return 4;
      }
      case \\"TYPE_INT32\\": {
        return 5;
      }
      case \\"TYPE_FIXED64\\": {
        return 6;
      }
      case \\"TYPE_FIXED32\\": {
        return 7;
      }
      case \\"TYPE_BOOL\\": {
        return 8;
      }
      case \\"TYPE_STRING\\": {
        return 9;
      }
      case \\"TYPE_GROUP\\": {
        return 10;
      }
      case \\"TYPE_MESSAGE\\": {
        return 11;
      }
      case \\"TYPE_BYTES\\": {
        return 12;
      }
      case \\"TYPE_UINT32\\": {
        return 13;
      }
      case \\"TYPE_ENUM\\": {
        return 14;
      }
      case \\"TYPE_SFIXED32\\": {
        return 15;
      }
      case \\"TYPE_SFIXED64\\": {
        return 16;
      }
      case \\"TYPE_SINT32\\": {
        return 17;
      }
      case \\"TYPE_SINT64\\": {
        return 18;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: \\"CARDINALITY_UNKNOWN\\",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: \\"CARDINALITY_OPTIONAL\\",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: \\"CARDINALITY_REQUIRED\\",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: \\"CARDINALITY_REPEATED\\",
  },

  CardinalityFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"CARDINALITY_UNKNOWN\\";
      }
      case 1: {
        return \\"CARDINALITY_OPTIONAL\\";
      }
      case 2: {
        return \\"CARDINALITY_REQUIRED\\";
      }
      case 3: {
        return \\"CARDINALITY_REPEATED\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  CardinalityToInt: function (i) {
    switch (i) {
      case \\"CARDINALITY_UNKNOWN\\": {
        return 0;
      }
      case \\"CARDINALITY_OPTIONAL\\": {
        return 1;
      }
      case \\"CARDINALITY_REQUIRED\\": {
        return 2;
      }
      case \\"CARDINALITY_REPEATED\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const Enum = {
  /**
   * Serializes a Enum to protobuf.
   */
  encode: function (msg) {
    return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Enum from protobuf.
   */
  decode: function (bytes) {
    return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Enum to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Enum._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Enum from JSON.
   */
  decodeJSON: function (json) {
    return Enum._readMessageJSON(Enum.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Enum with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(2, msg.enumvalue, EnumValue._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(5, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.enumvalue?.length) {
      json.enumvalue = msg.enumvalue.map(EnumValue._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json.enumvalue;
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValue._readMessageJSON(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const EnumValue = {
  /**
   * Serializes a EnumValue to protobuf.
   */
  encode: function (msg) {
    return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a EnumValue from protobuf.
   */
  decode: function (bytes) {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a EnumValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(EnumValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a EnumValue from JSON.
   */
  decodeJSON: function (json) {
    return EnumValue._readMessageJSON(EnumValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a EnumValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  },
};

export const Option = {
  /**
   * Serializes a Option to protobuf.
   */
  encode: function (msg) {
    return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Option from protobuf.
   */
  decode: function (bytes) {
    return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Option to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Option._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Option from JSON.
   */
  decodeJSON: function (json) {
    return Option._readMessageJSON(Option.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Option with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.value) {
      const value = Any._writeMessageJSON(msg.value);
      if (Object.keys(value).length > 0) {
        json.value = value;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _value = json.value;
    if (_value) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _value);
      msg.value = m;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/api.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Option, Syntax } from \\"./type.pb\\";
import { SourceContext } from \\"./source_context.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Api = {
  /**
   * Serializes a Api to protobuf.
   */
  encode: function (msg) {
    return Api._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Api from protobuf.
   */
  decode: function (bytes) {
    return Api._readMessage(Api.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Api to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Api._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Api from JSON.
   */
  decodeJSON: function (json) {
    return Api._readMessageJSON(Api.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Api with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      methods: [],
      options: [],
      version: \\"\\",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options, Option._writeMessage);
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins, Mixin._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.methods?.length) {
      json.methods = msg.methods.map(Method._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.version) {
      json.version = msg.version;
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.mixins?.length) {
      json.mixins = msg.mixins.map(Mixin._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _methods = json.methods;
    if (_methods) {
      for (const item of _methods) {
        const m = Method.initialize();
        Method._readMessageJSON(m, item);
        msg.methods.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _mixins = json.mixins;
    if (_mixins) {
      for (const item of _mixins) {
        const m = Mixin.initialize();
        Mixin._readMessageJSON(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Method = {
  /**
   * Serializes a Method to protobuf.
   */
  encode: function (msg) {
    return Method._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Method from protobuf.
   */
  decode: function (bytes) {
    return Method._readMessage(Method.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Method to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Method._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Method from JSON.
   */
  decodeJSON: function (json) {
    return Method._readMessageJSON(Method.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Method with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      requestTypeUrl: \\"\\",
      requestStreaming: false,
      responseTypeUrl: \\"\\",
      responseStreaming: false,
      options: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(6, msg.options, Option._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.requestTypeUrl) {
      json.requestTypeUrl = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json.requestStreaming = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json.responseTypeUrl = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json.responseStreaming = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _requestTypeUrl = json.requestTypeUrl ?? json.request_type_url;
    if (_requestTypeUrl) {
      msg.requestTypeUrl = _requestTypeUrl;
    }
    const _requestStreaming = json.requestStreaming ?? json.request_streaming;
    if (_requestStreaming) {
      msg.requestStreaming = _requestStreaming;
    }
    const _responseTypeUrl = json.responseTypeUrl ?? json.response_type_url;
    if (_responseTypeUrl) {
      msg.responseTypeUrl = _responseTypeUrl;
    }
    const _responseStreaming =
      json.responseStreaming ?? json.response_streaming;
    if (_responseStreaming) {
      msg.responseStreaming = _responseStreaming;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Mixin = {
  /**
   * Serializes a Mixin to protobuf.
   */
  encode: function (msg) {
    return Mixin._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Mixin from protobuf.
   */
  decode: function (bytes) {
    return Mixin._readMessage(Mixin.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Mixin to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Mixin._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Mixin from JSON.
   */
  decodeJSON: function (json) {
    return Mixin._readMessageJSON(Mixin.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Mixin with all fields set to their default value.
   */
  initialize: function () {
    return {
      name: \\"\\",
      root: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.root) {
      json.root = msg.root;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _root = json.root;
    if (_root) {
      msg.root = _root;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/duration.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/duration.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Duration = {
  /**
   * Serializes a Duration to protobuf.
   */
  encode: function (msg) {
    return Duration._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Duration from protobuf.
   */
  decode: function (bytes) {
    return Duration._readMessage(
      Duration.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Duration to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Duration._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Duration from JSON.
   */
  decodeJSON: function (json) {
    return Duration._readMessageJSON(Duration.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Duration with all fields set to their default value.
   */
  initialize: function () {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/field_mask.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/field_mask.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const FieldMask = {
  /**
   * Serializes a FieldMask to protobuf.
   */
  encode: function (msg) {
    return FieldMask._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FieldMask from protobuf.
   */
  decode: function (bytes) {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FieldMask to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(FieldMask._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FieldMask from JSON.
   */
  decodeJSON: function (json) {
    return FieldMask._readMessageJSON(FieldMask.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a FieldMask with all fields set to their default value.
   */
  initialize: function () {
    return {
      paths: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.paths?.length) {
      json.paths = msg.paths;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _paths = json.paths;
    if (_paths) {
      msg.paths = _paths;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/struct.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: \\"NULL_VALUE\\",
};

const NullValueFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"NULL_VALUE\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const NullValueToInt = function (i) {
  switch (i) {
    case \\"NULL_VALUE\\": {
      return 0;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const Struct = {
  /**
   * Serializes a Struct to protobuf.
   */
  encode: function (msg) {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Struct from protobuf.
   */
  decode: function (bytes) {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Struct to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Struct._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Struct from JSON.
   */
  decodeJSON: function (json) {
    return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Struct with all fields set to their default value.
   */
  initialize: function () {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.fields).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries(msg.fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const fields = {};
          reader.readMessage(fields, Struct.Fields._readMessage);
          msg.fields[fields.key] = fields.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries(_fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes a Value to protobuf.
   */
  encode: function (msg) {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Value from protobuf.
   */
  decode: function (bytes) {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Value from JSON.
   */
  decodeJSON: function (json) {
    return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      structValue: Struct.initialize(),
      listValue: ListValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValueToInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = Struct._writeMessageJSON(msg.structValue);
      if (Object.keys(structValue).length > 0) {
        json.structValue = structValue;
      }
    }
    if (msg.listValue != undefined) {
      const listValue = ListValue._writeMessageJSON(msg.listValue);
      if (Object.keys(listValue).length > 0) {
        json.listValue = listValue;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValueFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValue._readMessageJSON(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes a ListValue to protobuf.
   */
  encode: function (msg) {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a ListValue from protobuf.
   */
  decode: function (bytes) {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ListValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ListValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ListValue from JSON.
   */
  decodeJSON: function (json) {
    return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a ListValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.values?.length) {
      json.values = msg.values.map(Value._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        Value._readMessageJSON(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/timestamp.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/timestamp.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Timestamp = {
  /**
   * Serializes a Timestamp to protobuf.
   */
  encode: function (msg) {
    return Timestamp._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Timestamp from protobuf.
   */
  decode: function (bytes) {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Timestamp to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Timestamp._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Timestamp from JSON.
   */
  decodeJSON: function (json) {
    return Timestamp._readMessageJSON(Timestamp.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Timestamp with all fields set to their default value.
   */
  initialize: function () {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/wrappers.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/wrappers.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const DoubleValue = {
  /**
   * Serializes a DoubleValue to protobuf.
   */
  encode: function (msg) {
    return DoubleValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a DoubleValue from protobuf.
   */
  decode: function (bytes) {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a DoubleValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(DoubleValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a DoubleValue from JSON.
   */
  decodeJSON: function (json) {
    return DoubleValue._readMessageJSON(
      DoubleValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a DoubleValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const FloatValue = {
  /**
   * Serializes a FloatValue to protobuf.
   */
  encode: function (msg) {
    return FloatValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FloatValue from protobuf.
   */
  decode: function (bytes) {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FloatValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(FloatValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FloatValue from JSON.
   */
  decodeJSON: function (json) {
    return FloatValue._readMessageJSON(
      FloatValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FloatValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const Int64Value = {
  /**
   * Serializes a Int64Value to protobuf.
   */
  encode: function (msg) {
    return Int64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int64Value from protobuf.
   */
  decode: function (bytes) {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Value from JSON.
   */
  decodeJSON: function (json) {
    return Int64Value._readMessageJSON(
      Int64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const UInt64Value = {
  /**
   * Serializes a UInt64Value to protobuf.
   */
  encode: function (msg) {
    return UInt64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt64Value from protobuf.
   */
  decode: function (bytes) {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt64Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(UInt64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt64Value from JSON.
   */
  decodeJSON: function (json) {
    return UInt64Value._readMessageJSON(
      UInt64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt64Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const Int32Value = {
  /**
   * Serializes a Int32Value to protobuf.
   */
  encode: function (msg) {
    return Int32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int32Value from protobuf.
   */
  decode: function (bytes) {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(Int32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Value from JSON.
   */
  decodeJSON: function (json) {
    return Int32Value._readMessageJSON(
      Int32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const UInt32Value = {
  /**
   * Serializes a UInt32Value to protobuf.
   */
  encode: function (msg) {
    return UInt32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt32Value from protobuf.
   */
  decode: function (bytes) {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt32Value to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(UInt32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt32Value from JSON.
   */
  decodeJSON: function (json) {
    return UInt32Value._readMessageJSON(
      UInt32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt32Value with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BoolValue = {
  /**
   * Serializes a BoolValue to protobuf.
   */
  encode: function (msg) {
    return BoolValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolValue from protobuf.
   */
  decode: function (bytes) {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BoolValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolValue from JSON.
   */
  decodeJSON: function (json) {
    return BoolValue._readMessageJSON(BoolValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a BoolValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const StringValue = {
  /**
   * Serializes a StringValue to protobuf.
   */
  encode: function (msg) {
    return StringValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a StringValue from protobuf.
   */
  decode: function (bytes) {
    return StringValue._readMessage(
      StringValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a StringValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(StringValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a StringValue from JSON.
   */
  decodeJSON: function (json) {
    return StringValue._readMessageJSON(
      StringValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a StringValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BytesValue = {
  /**
   * Serializes a BytesValue to protobuf.
   */
  encode: function (msg) {
    return BytesValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BytesValue from protobuf.
   */
  decode: function (bytes) {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BytesValue to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(BytesValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BytesValue from JSON.
   */
  decodeJSON: function (json) {
    return BytesValue._readMessageJSON(
      BytesValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BytesValue with all fields set to their default value.
   */
  initialize: function () {
    return {
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_well_known_types.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Any } from \\"./any.pb\\";
import { Api } from \\"./api.pb\\";
import { Duration } from \\"./duration.pb\\";
import { Empty } from \\"./empty.pb\\";
import { FieldMask } from \\"./field_mask.pb\\";
import { SourceContext } from \\"./source_context.pb\\";
import { Struct, Value } from \\"./struct.pb\\";
import { Timestamp } from \\"./timestamp.pb\\";
import { Type } from \\"./type.pb\\";
import {
  DoubleValue,
  FloatValue,
  Int64Value,
  UInt64Value,
  Int32Value,
  UInt32Value,
  BoolValue,
  StringValue,
  BytesValue,
} from \\"./wrappers.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes a TestWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestWellKnownTypes._readMessageJSON(
      TestWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
      valueField: Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    if (msg.valueField) {
      const valueField = Value._writeMessageJSON(msg.valueField);
      if (Object.keys(valueField).length > 0) {
        json.valueField = valueField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    const _valueField = json.valueField ?? json.value_field;
    if (_valueField) {
      const m = Value.initialize();
      Value._readMessageJSON(m, _valueField);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes a RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(RepeatedWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedWellKnownTypes._readMessageJSON(
      RepeatedWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField,
        FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField,
        Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField,
        DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field,
        UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field,
        UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField,
        StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField?.length) {
      json.anyField = msg.anyField.map(Any._writeMessageJSON);
    }
    if (msg.apiField?.length) {
      json.apiField = msg.apiField.map(Api._writeMessageJSON);
    }
    if (msg.durationField?.length) {
      json.durationField = msg.durationField.map(Duration._writeMessageJSON);
    }
    if (msg.emptyField?.length) {
      json.emptyField = msg.emptyField.map(Empty._writeMessageJSON);
    }
    if (msg.fieldMaskField?.length) {
      json.fieldMaskField = msg.fieldMaskField.map(FieldMask._writeMessageJSON);
    }
    if (msg.sourceContextField?.length) {
      json.sourceContextField = msg.sourceContextField.map(
        SourceContext._writeMessageJSON
      );
    }
    if (msg.structField?.length) {
      json.structField = msg.structField.map(Struct._writeMessageJSON);
    }
    if (msg.timestampField?.length) {
      json.timestampField = msg.timestampField.map(Timestamp._writeMessageJSON);
    }
    if (msg.typeField?.length) {
      json.typeField = msg.typeField.map(Type._writeMessageJSON);
    }
    if (msg.doubleField?.length) {
      json.doubleField = msg.doubleField.map(DoubleValue._writeMessageJSON);
    }
    if (msg.floatField?.length) {
      json.floatField = msg.floatField.map(FloatValue._writeMessageJSON);
    }
    if (msg.int64Field?.length) {
      json.int64Field = msg.int64Field.map(Int64Value._writeMessageJSON);
    }
    if (msg.uint64Field?.length) {
      json.uint64Field = msg.uint64Field.map(UInt64Value._writeMessageJSON);
    }
    if (msg.int32Field?.length) {
      json.int32Field = msg.int32Field.map(Int32Value._writeMessageJSON);
    }
    if (msg.uint32Field?.length) {
      json.uint32Field = msg.uint32Field.map(UInt32Value._writeMessageJSON);
    }
    if (msg.boolField?.length) {
      json.boolField = msg.boolField.map(BoolValue._writeMessageJSON);
    }
    if (msg.stringField?.length) {
      json.stringField = msg.stringField.map(StringValue._writeMessageJSON);
    }
    if (msg.bytesField?.length) {
      json.bytesField = msg.bytesField.map(BytesValue._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Any.initialize();
          reader.readMessage(m, Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = Api.initialize();
          reader.readMessage(m, Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = Duration.initialize();
          reader.readMessage(m, Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = Empty.initialize();
          reader.readMessage(m, Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = FieldMask.initialize();
          reader.readMessage(m, FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = SourceContext.initialize();
          reader.readMessage(m, SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = Struct.initialize();
          reader.readMessage(m, Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = Timestamp.initialize();
          reader.readMessage(m, Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = Type.initialize();
          reader.readMessage(m, Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = DoubleValue.initialize();
          reader.readMessage(m, DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = FloatValue.initialize();
          reader.readMessage(m, FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = Int64Value.initialize();
          reader.readMessage(m, Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = UInt64Value.initialize();
          reader.readMessage(m, UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = Int32Value.initialize();
          reader.readMessage(m, Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = UInt32Value.initialize();
          reader.readMessage(m, UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = BoolValue.initialize();
          reader.readMessage(m, BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = StringValue.initialize();
          reader.readMessage(m, StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = BytesValue.initialize();
          reader.readMessage(m, BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      for (const item of _anyField) {
        const m = Any.initialize();
        Any._readMessageJSON(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      for (const item of _apiField) {
        const m = Api.initialize();
        Api._readMessageJSON(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      for (const item of _durationField) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      for (const item of _emptyField) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      for (const item of _fieldMaskField) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      for (const item of _sourceContextField) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      for (const item of _structField) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      for (const item of _timestampField) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      for (const item of _typeField) {
        const m = Type.initialize();
        Type._readMessageJSON(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      for (const item of _doubleField) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      for (const item of _floatField) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      for (const item of _int64Field) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      for (const item of _uint64Field) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      for (const item of _int32Field) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      for (const item of _uint32Field) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      for (const item of _boolField) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      for (const item of _stringField) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      for (const item of _bytesField) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes a OneofWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneofWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(OneofWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneofWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return OneofWellKnownTypes._readMessageJSON(
      OneofWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField != undefined) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField != undefined) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField != undefined) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField != undefined) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField != undefined) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField != undefined) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField != undefined) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField != undefined) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField != undefined) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField != undefined) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField != undefined) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field != undefined) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field != undefined) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field != undefined) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field != undefined) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField != undefined) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField != undefined) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField != undefined) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes a MapWellKnownTypes to protobuf.
   */
  encode: function (msg) {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MapWellKnownTypes from protobuf.
   */
  decode: function (bytes) {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MapWellKnownTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(MapWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MapWellKnownTypes from JSON.
   */
  decodeJSON: function (json) {
    return MapWellKnownTypes._readMessageJSON(
      MapWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.anyField) {
      const anyField = Object.fromEntries(
        Object.entries(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Object.fromEntries(
        Object.entries(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Object.fromEntries(
        Object.entries(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Object.fromEntries(
        Object.entries(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = Object.fromEntries(
        Object.entries(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = Object.fromEntries(
        Object.entries(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Object.fromEntries(
        Object.entries(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Object.fromEntries(
        Object.entries(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Object.fromEntries(
        Object.entries(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = Object.fromEntries(
        Object.entries(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = Object.fromEntries(
        Object.entries(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Object.fromEntries(
        Object.entries(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = Object.fromEntries(
        Object.entries(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Object.fromEntries(
        Object.entries(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = Object.fromEntries(
        Object.entries(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = Object.fromEntries(
        Object.entries(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = Object.fromEntries(
        Object.entries(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = Object.fromEntries(
        Object.entries(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const anyField = {};
          reader.readMessage(anyField, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[anyField.key] = anyField.value;
          break;
        }
        case 2: {
          const apiField = {};
          reader.readMessage(apiField, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[apiField.key] = apiField.value;
          break;
        }
        case 3: {
          const durationField = {};
          reader.readMessage(
            durationField,
            MapWellKnownTypes.DurationField._readMessage
          );
          msg.durationField[durationField.key] = durationField.value;
          break;
        }
        case 4: {
          const emptyField = {};
          reader.readMessage(
            emptyField,
            MapWellKnownTypes.EmptyField._readMessage
          );
          msg.emptyField[emptyField.key] = emptyField.value;
          break;
        }
        case 5: {
          const fieldMaskField = {};
          reader.readMessage(
            fieldMaskField,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[fieldMaskField.key] = fieldMaskField.value;
          break;
        }
        case 6: {
          const sourceContextField = {};
          reader.readMessage(
            sourceContextField,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[sourceContextField.key] =
            sourceContextField.value;
          break;
        }
        case 7: {
          const structField = {};
          reader.readMessage(
            structField,
            MapWellKnownTypes.StructField._readMessage
          );
          msg.structField[structField.key] = structField.value;
          break;
        }
        case 8: {
          const timestampField = {};
          reader.readMessage(
            timestampField,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[timestampField.key] = timestampField.value;
          break;
        }
        case 9: {
          const typeField = {};
          reader.readMessage(
            typeField,
            MapWellKnownTypes.TypeField._readMessage
          );
          msg.typeField[typeField.key] = typeField.value;
          break;
        }
        case 10: {
          const doubleField = {};
          reader.readMessage(
            doubleField,
            MapWellKnownTypes.DoubleField._readMessage
          );
          msg.doubleField[doubleField.key] = doubleField.value;
          break;
        }
        case 11: {
          const floatField = {};
          reader.readMessage(
            floatField,
            MapWellKnownTypes.FloatField._readMessage
          );
          msg.floatField[floatField.key] = floatField.value;
          break;
        }
        case 12: {
          const int64Field = {};
          reader.readMessage(
            int64Field,
            MapWellKnownTypes.Int64Field._readMessage
          );
          msg.int64Field[int64Field.key] = int64Field.value;
          break;
        }
        case 13: {
          const uint64Field = {};
          reader.readMessage(
            uint64Field,
            MapWellKnownTypes.Uint64Field._readMessage
          );
          msg.uint64Field[uint64Field.key] = uint64Field.value;
          break;
        }
        case 14: {
          const int32Field = {};
          reader.readMessage(
            int32Field,
            MapWellKnownTypes.Int32Field._readMessage
          );
          msg.int32Field[int32Field.key] = int32Field.value;
          break;
        }
        case 15: {
          const uint32Field = {};
          reader.readMessage(
            uint32Field,
            MapWellKnownTypes.Uint32Field._readMessage
          );
          msg.uint32Field[uint32Field.key] = uint32Field.value;
          break;
        }
        case 16: {
          const boolField = {};
          reader.readMessage(
            boolField,
            MapWellKnownTypes.BoolField._readMessage
          );
          msg.boolField[boolField.key] = boolField.value;
          break;
        }
        case 17: {
          const stringField = {};
          reader.readMessage(
            stringField,
            MapWellKnownTypes.StringField._readMessage
          );
          msg.stringField[stringField.key] = stringField.value;
          break;
        }
        case 18: {
          const bytesField = {};
          reader.readMessage(
            bytesField,
            MapWellKnownTypes.BytesField._readMessage
          );
          msg.bytesField[bytesField.key] = bytesField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      msg.anyField = Object.fromEntries(
        Object.entries(_anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      msg.apiField = Object.fromEntries(
        Object.entries(_apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      msg.durationField = Object.fromEntries(
        Object.entries(_durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      msg.emptyField = Object.fromEntries(
        Object.entries(_emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries(_fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries(_sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      msg.structField = Object.fromEntries(
        Object.entries(_structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      msg.timestampField = Object.fromEntries(
        Object.entries(_timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      msg.typeField = Object.fromEntries(
        Object.entries(_typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      msg.doubleField = Object.fromEntries(
        Object.entries(_doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      msg.floatField = Object.fromEntries(
        Object.entries(_floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      msg.int64Field = Object.fromEntries(
        Object.entries(_int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      msg.uint64Field = Object.fromEntries(
        Object.entries(_uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      msg.int32Field = Object.fromEntries(
        Object.entries(_int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      msg.uint32Field = Object.fromEntries(
        Object.entries(_uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      msg.boolField = Object.fromEntries(
        Object.entries(_boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      msg.stringField = Object.fromEntries(
        Object.entries(_stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      msg.bytesField = Object.fromEntries(
        Object.entries(_bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Any._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Any.initialize(), Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Any.initialize();
        Any._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Api._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Api.initialize(), Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Api.initialize();
        Api._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Duration._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Duration.initialize(), Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Empty._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Empty.initialize(), Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FieldMask._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(FieldMask.initialize(), FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, SourceContext._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = SourceContext._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              SourceContext.initialize(),
              SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Struct._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Struct.initialize(), Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Timestamp._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Timestamp.initialize(), Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Type._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Type.initialize(), Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Type.initialize();
        Type._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, DoubleValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = DoubleValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              DoubleValue.initialize(),
              DoubleValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FloatValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              FloatValue.initialize(),
              FloatValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int64Value.initialize(),
              Int64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt64Value.initialize(),
              UInt64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int32Value.initialize(),
              Int32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt32Value.initialize(),
              UInt32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BoolValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(BoolValue.initialize(), BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = StringValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              StringValue.initialize(),
              StringValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BytesValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              BytesValue.initialize(),
              BytesValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: \\"FOREIGN_ZERO\\",
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
};

const ForeignEnumFromInt = function (i) {
  switch (i) {
    case 0: {
      return \\"FOREIGN_ZERO\\";
    }
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

const ForeignEnumToInt = function (i) {
  switch (i) {
    case \\"FOREIGN_ZERO\\": {
      return 0;
    }
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (_optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { ZERO: \\"ZERO\\", FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"ZERO\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"ZERO\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg) {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (msg) {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestMessageWithDummy._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: \\"UNKNOWN\\", FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" },

  NestedEnumFromInt: function (i) {
    switch (i) {
      case 0: {
        return \\"UNKNOWN\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },

  NestedEnumToInt: function (i) {
    switch (i) {
      case \\"UNKNOWN\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import {
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFoo(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (msg: Partial<PublicImportMessage>): Uint8Array {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (msg: Partial<PublicImportMessage>): string {
    return JSON.stringify(PublicImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json: string): PublicImportMessage {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const _e = json.e;
    if (_e) {
      msg.e = _e;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = \\"IMPORT_FOO\\" | \\"IMPORT_BAR\\" | \\"IMPORT_BAZ\\";

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap = \\"UNKNOWN\\" | \\"FOO\\" | \\"BAR\\";

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: \\"IMPORT_FOO\\",
  IMPORT_BAR: \\"IMPORT_BAR\\",
  IMPORT_BAZ: \\"IMPORT_BAZ\\",
} as const;

const ImportEnumFromInt = function (i: number): ImportEnum {
  switch (i) {
    case 7: {
      return \\"IMPORT_FOO\\";
    }
    case 8: {
      return \\"IMPORT_BAR\\";
    }
    case 9: {
      return \\"IMPORT_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ImportEnum;
    }
  }
};

const ImportEnumToInt = function (i: ImportEnum): number {
  switch (i) {
    case \\"IMPORT_FOO\\": {
      return 7;
    }
    case \\"IMPORT_BAR\\": {
      return 8;
    }
    case \\"IMPORT_BAZ\\": {
      return 9;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const ImportEnumForMap = {
  UNKNOWN: \\"UNKNOWN\\",
  FOO: \\"FOO\\",
  BAR: \\"BAR\\",
} as const;

const ImportEnumForMapFromInt = function (i: number): ImportEnumForMap {
  switch (i) {
    case 0: {
      return \\"UNKNOWN\\";
    }
    case 1: {
      return \\"FOO\\";
    }
    case 2: {
      return \\"BAR\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ImportEnumForMap;
    }
  }
};

const ImportEnumForMapToInt = function (i: ImportEnumForMap): number {
  switch (i) {
    case \\"UNKNOWN\\": {
      return 0;
    }
    case \\"FOO\\": {
      return 1;
    }
    case \\"BAR\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (msg: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json: string): ImportMessage {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ImportMessage, json: any): ImportMessage {
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, MapMessage, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//              TestService               //
//========================================//

export interface TestService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestService<Context>(service: TestService<Context>) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = \\"FOREIGN_FOO\\" | \\"FOREIGN_BAR\\" | \\"FOREIGN_BAZ\\";

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue = \\"FOO1\\" | \\"BAR1\\" | \\"BAZ\\" | \\"FOO2\\" | \\"BAR2\\";

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum =
  | \\"SPARSE_A\\"
  | \\"SPARSE_B\\"
  | \\"SPARSE_C\\"
  | \\"SPARSE_D\\"
  | \\"SPARSE_E\\"
  | \\"SPARSE_F\\"
  | \\"SPARSE_G\\";

export type VeryLargeEnum =
  | \\"ENUM_LABEL_DEFAULT\\"
  | \\"ENUM_LABEL_1\\"
  | \\"ENUM_LABEL_2\\"
  | \\"ENUM_LABEL_3\\"
  | \\"ENUM_LABEL_4\\"
  | \\"ENUM_LABEL_5\\"
  | \\"ENUM_LABEL_6\\"
  | \\"ENUM_LABEL_7\\"
  | \\"ENUM_LABEL_8\\"
  | \\"ENUM_LABEL_9\\"
  | \\"ENUM_LABEL_10\\"
  | \\"ENUM_LABEL_11\\"
  | \\"ENUM_LABEL_12\\"
  | \\"ENUM_LABEL_13\\"
  | \\"ENUM_LABEL_14\\"
  | \\"ENUM_LABEL_15\\"
  | \\"ENUM_LABEL_16\\"
  | \\"ENUM_LABEL_17\\"
  | \\"ENUM_LABEL_18\\"
  | \\"ENUM_LABEL_19\\"
  | \\"ENUM_LABEL_20\\"
  | \\"ENUM_LABEL_21\\"
  | \\"ENUM_LABEL_22\\"
  | \\"ENUM_LABEL_23\\"
  | \\"ENUM_LABEL_24\\"
  | \\"ENUM_LABEL_25\\"
  | \\"ENUM_LABEL_26\\"
  | \\"ENUM_LABEL_27\\"
  | \\"ENUM_LABEL_28\\"
  | \\"ENUM_LABEL_29\\"
  | \\"ENUM_LABEL_30\\"
  | \\"ENUM_LABEL_31\\"
  | \\"ENUM_LABEL_32\\"
  | \\"ENUM_LABEL_33\\"
  | \\"ENUM_LABEL_34\\"
  | \\"ENUM_LABEL_35\\"
  | \\"ENUM_LABEL_36\\"
  | \\"ENUM_LABEL_37\\"
  | \\"ENUM_LABEL_38\\"
  | \\"ENUM_LABEL_39\\"
  | \\"ENUM_LABEL_40\\"
  | \\"ENUM_LABEL_41\\"
  | \\"ENUM_LABEL_42\\"
  | \\"ENUM_LABEL_43\\"
  | \\"ENUM_LABEL_44\\"
  | \\"ENUM_LABEL_45\\"
  | \\"ENUM_LABEL_46\\"
  | \\"ENUM_LABEL_47\\"
  | \\"ENUM_LABEL_48\\"
  | \\"ENUM_LABEL_49\\"
  | \\"ENUM_LABEL_50\\"
  | \\"ENUM_LABEL_51\\"
  | \\"ENUM_LABEL_52\\"
  | \\"ENUM_LABEL_53\\"
  | \\"ENUM_LABEL_54\\"
  | \\"ENUM_LABEL_55\\"
  | \\"ENUM_LABEL_56\\"
  | \\"ENUM_LABEL_57\\"
  | \\"ENUM_LABEL_58\\"
  | \\"ENUM_LABEL_59\\"
  | \\"ENUM_LABEL_60\\"
  | \\"ENUM_LABEL_61\\"
  | \\"ENUM_LABEL_62\\"
  | \\"ENUM_LABEL_63\\"
  | \\"ENUM_LABEL_64\\"
  | \\"ENUM_LABEL_65\\"
  | \\"ENUM_LABEL_66\\"
  | \\"ENUM_LABEL_67\\"
  | \\"ENUM_LABEL_68\\"
  | \\"ENUM_LABEL_69\\"
  | \\"ENUM_LABEL_70\\"
  | \\"ENUM_LABEL_71\\"
  | \\"ENUM_LABEL_72\\"
  | \\"ENUM_LABEL_73\\"
  | \\"ENUM_LABEL_74\\"
  | \\"ENUM_LABEL_75\\"
  | \\"ENUM_LABEL_76\\"
  | \\"ENUM_LABEL_77\\"
  | \\"ENUM_LABEL_78\\"
  | \\"ENUM_LABEL_79\\"
  | \\"ENUM_LABEL_80\\"
  | \\"ENUM_LABEL_81\\"
  | \\"ENUM_LABEL_82\\"
  | \\"ENUM_LABEL_83\\"
  | \\"ENUM_LABEL_84\\"
  | \\"ENUM_LABEL_85\\"
  | \\"ENUM_LABEL_86\\"
  | \\"ENUM_LABEL_87\\"
  | \\"ENUM_LABEL_88\\"
  | \\"ENUM_LABEL_89\\"
  | \\"ENUM_LABEL_90\\"
  | \\"ENUM_LABEL_91\\"
  | \\"ENUM_LABEL_92\\"
  | \\"ENUM_LABEL_93\\"
  | \\"ENUM_LABEL_94\\"
  | \\"ENUM_LABEL_95\\"
  | \\"ENUM_LABEL_96\\"
  | \\"ENUM_LABEL_97\\"
  | \\"ENUM_LABEL_98\\"
  | \\"ENUM_LABEL_99\\"
  | \\"ENUM_LABEL_100\\";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestAllTypes {
  export type NestedEnum = \\"FOO\\" | \\"BAR\\" | \\"BAZ\\" | \\"NEG\\";

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number | null | undefined;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

declare namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

declare namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

declare namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

declare namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

declare namespace TestIsInitialized {
  export interface SubMessage {}

  namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

declare namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

declare namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

declare namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

declare namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestAllTypes | null | undefined;
}

declare namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

declare namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooCord?: string | null | undefined;
  fooStringPiece?: string | null | undefined;
  fooBytes?: Uint8Array | null | undefined;
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
  fooMessage?: TestOneof2.NestedMessage | null | undefined;
  fooLazyMessage?: TestOneof2.NestedMessage | null | undefined;
  barInt?: number | null | undefined;
  barString?: string | null | undefined;
  barCord?: string | null | undefined;
  barStringPiece?: string | null | undefined;
  barBytes?: Uint8Array | null | undefined;
  barEnum?: TestOneof2.NestedEnum | null | undefined;
  barStringWithEmptyDefault?: string | null | undefined;
  barCordWithEmptyDefault?: string | null | undefined;
  barStringPieceWithEmptyDefault?: string | null | undefined;
  barBytesWithEmptyDefault?: Uint8Array | null | undefined;
  bazInt: number;
  bazString: string;
}

declare namespace TestOneof2 {
  export type NestedEnum = \\"FOO\\" | \\"BAR\\" | \\"BAZ\\";

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestRequiredOneof.NestedMessage | null | undefined;
}

declare namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

declare namespace TestDynamicExtensions {
  export type DynamicEnumType = \\"DYNAMIC_FOO\\" | \\"DYNAMIC_BAR\\" | \\"DYNAMIC_BAZ\\";

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

declare namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: TestHugeFieldNumbers.StringStringMap;
  oneofUint32?: number | null | undefined;
  oneofTestAllTypes?: TestAllTypes | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }

  export type StringStringMap = Record<string, string | undefined>;
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
} as const;

const ForeignEnumFromInt = function (i: number): ForeignEnum {
  switch (i) {
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ForeignEnum;
    }
  }
};

const ForeignEnumToInt = function (i: ForeignEnum): number {
  switch (i) {
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestEnumWithDupValue = {
  FOO1: \\"FOO1\\",
  BAR1: \\"BAR1\\",
  BAZ: \\"BAZ\\",
  FOO2: \\"FOO2\\",
  BAR2: \\"BAR2\\",
} as const;

const TestEnumWithDupValueFromInt = function (i: number): TestEnumWithDupValue {
  switch (i) {
    case 1: {
      return \\"FOO1\\";
    }
    case 2: {
      return \\"BAR1\\";
    }
    case 3: {
      return \\"BAZ\\";
    }
    case 1: {
      return \\"FOO2\\";
    }
    case 2: {
      return \\"BAR2\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as TestEnumWithDupValue;
    }
  }
};

const TestEnumWithDupValueToInt = function (i: TestEnumWithDupValue): number {
  switch (i) {
    case \\"FOO1\\": {
      return 1;
    }
    case \\"BAR1\\": {
      return 2;
    }
    case \\"BAZ\\": {
      return 3;
    }
    case \\"FOO2\\": {
      return 1;
    }
    case \\"BAR2\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestSparseEnum = {
  SPARSE_A: \\"SPARSE_A\\",
  SPARSE_B: \\"SPARSE_B\\",
  SPARSE_C: \\"SPARSE_C\\",
  SPARSE_D: \\"SPARSE_D\\",
  SPARSE_E: \\"SPARSE_E\\",
  SPARSE_F: \\"SPARSE_F\\",
  SPARSE_G: \\"SPARSE_G\\",
} as const;

const TestSparseEnumFromInt = function (i: number): TestSparseEnum {
  switch (i) {
    case 123: {
      return \\"SPARSE_A\\";
    }
    case 62374: {
      return \\"SPARSE_B\\";
    }
    case 12589234: {
      return \\"SPARSE_C\\";
    }
    case -15: {
      return \\"SPARSE_D\\";
    }
    case -53452: {
      return \\"SPARSE_E\\";
    }
    case 0: {
      return \\"SPARSE_F\\";
    }
    case 2: {
      return \\"SPARSE_G\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as TestSparseEnum;
    }
  }
};

const TestSparseEnumToInt = function (i: TestSparseEnum): number {
  switch (i) {
    case \\"SPARSE_A\\": {
      return 123;
    }
    case \\"SPARSE_B\\": {
      return 62374;
    }
    case \\"SPARSE_C\\": {
      return 12589234;
    }
    case \\"SPARSE_D\\": {
      return -15;
    }
    case \\"SPARSE_E\\": {
      return -53452;
    }
    case \\"SPARSE_F\\": {
      return 0;
    }
    case \\"SPARSE_G\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: \\"ENUM_LABEL_DEFAULT\\",
  ENUM_LABEL_1: \\"ENUM_LABEL_1\\",
  ENUM_LABEL_2: \\"ENUM_LABEL_2\\",
  ENUM_LABEL_3: \\"ENUM_LABEL_3\\",
  ENUM_LABEL_4: \\"ENUM_LABEL_4\\",
  ENUM_LABEL_5: \\"ENUM_LABEL_5\\",
  ENUM_LABEL_6: \\"ENUM_LABEL_6\\",
  ENUM_LABEL_7: \\"ENUM_LABEL_7\\",
  ENUM_LABEL_8: \\"ENUM_LABEL_8\\",
  ENUM_LABEL_9: \\"ENUM_LABEL_9\\",
  ENUM_LABEL_10: \\"ENUM_LABEL_10\\",
  ENUM_LABEL_11: \\"ENUM_LABEL_11\\",
  ENUM_LABEL_12: \\"ENUM_LABEL_12\\",
  ENUM_LABEL_13: \\"ENUM_LABEL_13\\",
  ENUM_LABEL_14: \\"ENUM_LABEL_14\\",
  ENUM_LABEL_15: \\"ENUM_LABEL_15\\",
  ENUM_LABEL_16: \\"ENUM_LABEL_16\\",
  ENUM_LABEL_17: \\"ENUM_LABEL_17\\",
  ENUM_LABEL_18: \\"ENUM_LABEL_18\\",
  ENUM_LABEL_19: \\"ENUM_LABEL_19\\",
  ENUM_LABEL_20: \\"ENUM_LABEL_20\\",
  ENUM_LABEL_21: \\"ENUM_LABEL_21\\",
  ENUM_LABEL_22: \\"ENUM_LABEL_22\\",
  ENUM_LABEL_23: \\"ENUM_LABEL_23\\",
  ENUM_LABEL_24: \\"ENUM_LABEL_24\\",
  ENUM_LABEL_25: \\"ENUM_LABEL_25\\",
  ENUM_LABEL_26: \\"ENUM_LABEL_26\\",
  ENUM_LABEL_27: \\"ENUM_LABEL_27\\",
  ENUM_LABEL_28: \\"ENUM_LABEL_28\\",
  ENUM_LABEL_29: \\"ENUM_LABEL_29\\",
  ENUM_LABEL_30: \\"ENUM_LABEL_30\\",
  ENUM_LABEL_31: \\"ENUM_LABEL_31\\",
  ENUM_LABEL_32: \\"ENUM_LABEL_32\\",
  ENUM_LABEL_33: \\"ENUM_LABEL_33\\",
  ENUM_LABEL_34: \\"ENUM_LABEL_34\\",
  ENUM_LABEL_35: \\"ENUM_LABEL_35\\",
  ENUM_LABEL_36: \\"ENUM_LABEL_36\\",
  ENUM_LABEL_37: \\"ENUM_LABEL_37\\",
  ENUM_LABEL_38: \\"ENUM_LABEL_38\\",
  ENUM_LABEL_39: \\"ENUM_LABEL_39\\",
  ENUM_LABEL_40: \\"ENUM_LABEL_40\\",
  ENUM_LABEL_41: \\"ENUM_LABEL_41\\",
  ENUM_LABEL_42: \\"ENUM_LABEL_42\\",
  ENUM_LABEL_43: \\"ENUM_LABEL_43\\",
  ENUM_LABEL_44: \\"ENUM_LABEL_44\\",
  ENUM_LABEL_45: \\"ENUM_LABEL_45\\",
  ENUM_LABEL_46: \\"ENUM_LABEL_46\\",
  ENUM_LABEL_47: \\"ENUM_LABEL_47\\",
  ENUM_LABEL_48: \\"ENUM_LABEL_48\\",
  ENUM_LABEL_49: \\"ENUM_LABEL_49\\",
  ENUM_LABEL_50: \\"ENUM_LABEL_50\\",
  ENUM_LABEL_51: \\"ENUM_LABEL_51\\",
  ENUM_LABEL_52: \\"ENUM_LABEL_52\\",
  ENUM_LABEL_53: \\"ENUM_LABEL_53\\",
  ENUM_LABEL_54: \\"ENUM_LABEL_54\\",
  ENUM_LABEL_55: \\"ENUM_LABEL_55\\",
  ENUM_LABEL_56: \\"ENUM_LABEL_56\\",
  ENUM_LABEL_57: \\"ENUM_LABEL_57\\",
  ENUM_LABEL_58: \\"ENUM_LABEL_58\\",
  ENUM_LABEL_59: \\"ENUM_LABEL_59\\",
  ENUM_LABEL_60: \\"ENUM_LABEL_60\\",
  ENUM_LABEL_61: \\"ENUM_LABEL_61\\",
  ENUM_LABEL_62: \\"ENUM_LABEL_62\\",
  ENUM_LABEL_63: \\"ENUM_LABEL_63\\",
  ENUM_LABEL_64: \\"ENUM_LABEL_64\\",
  ENUM_LABEL_65: \\"ENUM_LABEL_65\\",
  ENUM_LABEL_66: \\"ENUM_LABEL_66\\",
  ENUM_LABEL_67: \\"ENUM_LABEL_67\\",
  ENUM_LABEL_68: \\"ENUM_LABEL_68\\",
  ENUM_LABEL_69: \\"ENUM_LABEL_69\\",
  ENUM_LABEL_70: \\"ENUM_LABEL_70\\",
  ENUM_LABEL_71: \\"ENUM_LABEL_71\\",
  ENUM_LABEL_72: \\"ENUM_LABEL_72\\",
  ENUM_LABEL_73: \\"ENUM_LABEL_73\\",
  ENUM_LABEL_74: \\"ENUM_LABEL_74\\",
  ENUM_LABEL_75: \\"ENUM_LABEL_75\\",
  ENUM_LABEL_76: \\"ENUM_LABEL_76\\",
  ENUM_LABEL_77: \\"ENUM_LABEL_77\\",
  ENUM_LABEL_78: \\"ENUM_LABEL_78\\",
  ENUM_LABEL_79: \\"ENUM_LABEL_79\\",
  ENUM_LABEL_80: \\"ENUM_LABEL_80\\",
  ENUM_LABEL_81: \\"ENUM_LABEL_81\\",
  ENUM_LABEL_82: \\"ENUM_LABEL_82\\",
  ENUM_LABEL_83: \\"ENUM_LABEL_83\\",
  ENUM_LABEL_84: \\"ENUM_LABEL_84\\",
  ENUM_LABEL_85: \\"ENUM_LABEL_85\\",
  ENUM_LABEL_86: \\"ENUM_LABEL_86\\",
  ENUM_LABEL_87: \\"ENUM_LABEL_87\\",
  ENUM_LABEL_88: \\"ENUM_LABEL_88\\",
  ENUM_LABEL_89: \\"ENUM_LABEL_89\\",
  ENUM_LABEL_90: \\"ENUM_LABEL_90\\",
  ENUM_LABEL_91: \\"ENUM_LABEL_91\\",
  ENUM_LABEL_92: \\"ENUM_LABEL_92\\",
  ENUM_LABEL_93: \\"ENUM_LABEL_93\\",
  ENUM_LABEL_94: \\"ENUM_LABEL_94\\",
  ENUM_LABEL_95: \\"ENUM_LABEL_95\\",
  ENUM_LABEL_96: \\"ENUM_LABEL_96\\",
  ENUM_LABEL_97: \\"ENUM_LABEL_97\\",
  ENUM_LABEL_98: \\"ENUM_LABEL_98\\",
  ENUM_LABEL_99: \\"ENUM_LABEL_99\\",
  ENUM_LABEL_100: \\"ENUM_LABEL_100\\",
} as const;

const VeryLargeEnumFromInt = function (i: number): VeryLargeEnum {
  switch (i) {
    case 0: {
      return \\"ENUM_LABEL_DEFAULT\\";
    }
    case 1: {
      return \\"ENUM_LABEL_1\\";
    }
    case 2: {
      return \\"ENUM_LABEL_2\\";
    }
    case 3: {
      return \\"ENUM_LABEL_3\\";
    }
    case 4: {
      return \\"ENUM_LABEL_4\\";
    }
    case 5: {
      return \\"ENUM_LABEL_5\\";
    }
    case 6: {
      return \\"ENUM_LABEL_6\\";
    }
    case 7: {
      return \\"ENUM_LABEL_7\\";
    }
    case 8: {
      return \\"ENUM_LABEL_8\\";
    }
    case 9: {
      return \\"ENUM_LABEL_9\\";
    }
    case 10: {
      return \\"ENUM_LABEL_10\\";
    }
    case 11: {
      return \\"ENUM_LABEL_11\\";
    }
    case 12: {
      return \\"ENUM_LABEL_12\\";
    }
    case 13: {
      return \\"ENUM_LABEL_13\\";
    }
    case 14: {
      return \\"ENUM_LABEL_14\\";
    }
    case 15: {
      return \\"ENUM_LABEL_15\\";
    }
    case 16: {
      return \\"ENUM_LABEL_16\\";
    }
    case 17: {
      return \\"ENUM_LABEL_17\\";
    }
    case 18: {
      return \\"ENUM_LABEL_18\\";
    }
    case 19: {
      return \\"ENUM_LABEL_19\\";
    }
    case 20: {
      return \\"ENUM_LABEL_20\\";
    }
    case 21: {
      return \\"ENUM_LABEL_21\\";
    }
    case 22: {
      return \\"ENUM_LABEL_22\\";
    }
    case 23: {
      return \\"ENUM_LABEL_23\\";
    }
    case 24: {
      return \\"ENUM_LABEL_24\\";
    }
    case 25: {
      return \\"ENUM_LABEL_25\\";
    }
    case 26: {
      return \\"ENUM_LABEL_26\\";
    }
    case 27: {
      return \\"ENUM_LABEL_27\\";
    }
    case 28: {
      return \\"ENUM_LABEL_28\\";
    }
    case 29: {
      return \\"ENUM_LABEL_29\\";
    }
    case 30: {
      return \\"ENUM_LABEL_30\\";
    }
    case 31: {
      return \\"ENUM_LABEL_31\\";
    }
    case 32: {
      return \\"ENUM_LABEL_32\\";
    }
    case 33: {
      return \\"ENUM_LABEL_33\\";
    }
    case 34: {
      return \\"ENUM_LABEL_34\\";
    }
    case 35: {
      return \\"ENUM_LABEL_35\\";
    }
    case 36: {
      return \\"ENUM_LABEL_36\\";
    }
    case 37: {
      return \\"ENUM_LABEL_37\\";
    }
    case 38: {
      return \\"ENUM_LABEL_38\\";
    }
    case 39: {
      return \\"ENUM_LABEL_39\\";
    }
    case 40: {
      return \\"ENUM_LABEL_40\\";
    }
    case 41: {
      return \\"ENUM_LABEL_41\\";
    }
    case 42: {
      return \\"ENUM_LABEL_42\\";
    }
    case 43: {
      return \\"ENUM_LABEL_43\\";
    }
    case 44: {
      return \\"ENUM_LABEL_44\\";
    }
    case 45: {
      return \\"ENUM_LABEL_45\\";
    }
    case 46: {
      return \\"ENUM_LABEL_46\\";
    }
    case 47: {
      return \\"ENUM_LABEL_47\\";
    }
    case 48: {
      return \\"ENUM_LABEL_48\\";
    }
    case 49: {
      return \\"ENUM_LABEL_49\\";
    }
    case 50: {
      return \\"ENUM_LABEL_50\\";
    }
    case 51: {
      return \\"ENUM_LABEL_51\\";
    }
    case 52: {
      return \\"ENUM_LABEL_52\\";
    }
    case 53: {
      return \\"ENUM_LABEL_53\\";
    }
    case 54: {
      return \\"ENUM_LABEL_54\\";
    }
    case 55: {
      return \\"ENUM_LABEL_55\\";
    }
    case 56: {
      return \\"ENUM_LABEL_56\\";
    }
    case 57: {
      return \\"ENUM_LABEL_57\\";
    }
    case 58: {
      return \\"ENUM_LABEL_58\\";
    }
    case 59: {
      return \\"ENUM_LABEL_59\\";
    }
    case 60: {
      return \\"ENUM_LABEL_60\\";
    }
    case 61: {
      return \\"ENUM_LABEL_61\\";
    }
    case 62: {
      return \\"ENUM_LABEL_62\\";
    }
    case 63: {
      return \\"ENUM_LABEL_63\\";
    }
    case 64: {
      return \\"ENUM_LABEL_64\\";
    }
    case 65: {
      return \\"ENUM_LABEL_65\\";
    }
    case 66: {
      return \\"ENUM_LABEL_66\\";
    }
    case 67: {
      return \\"ENUM_LABEL_67\\";
    }
    case 68: {
      return \\"ENUM_LABEL_68\\";
    }
    case 69: {
      return \\"ENUM_LABEL_69\\";
    }
    case 70: {
      return \\"ENUM_LABEL_70\\";
    }
    case 71: {
      return \\"ENUM_LABEL_71\\";
    }
    case 72: {
      return \\"ENUM_LABEL_72\\";
    }
    case 73: {
      return \\"ENUM_LABEL_73\\";
    }
    case 74: {
      return \\"ENUM_LABEL_74\\";
    }
    case 75: {
      return \\"ENUM_LABEL_75\\";
    }
    case 76: {
      return \\"ENUM_LABEL_76\\";
    }
    case 77: {
      return \\"ENUM_LABEL_77\\";
    }
    case 78: {
      return \\"ENUM_LABEL_78\\";
    }
    case 79: {
      return \\"ENUM_LABEL_79\\";
    }
    case 80: {
      return \\"ENUM_LABEL_80\\";
    }
    case 81: {
      return \\"ENUM_LABEL_81\\";
    }
    case 82: {
      return \\"ENUM_LABEL_82\\";
    }
    case 83: {
      return \\"ENUM_LABEL_83\\";
    }
    case 84: {
      return \\"ENUM_LABEL_84\\";
    }
    case 85: {
      return \\"ENUM_LABEL_85\\";
    }
    case 86: {
      return \\"ENUM_LABEL_86\\";
    }
    case 87: {
      return \\"ENUM_LABEL_87\\";
    }
    case 88: {
      return \\"ENUM_LABEL_88\\";
    }
    case 89: {
      return \\"ENUM_LABEL_89\\";
    }
    case 90: {
      return \\"ENUM_LABEL_90\\";
    }
    case 91: {
      return \\"ENUM_LABEL_91\\";
    }
    case 92: {
      return \\"ENUM_LABEL_92\\";
    }
    case 93: {
      return \\"ENUM_LABEL_93\\";
    }
    case 94: {
      return \\"ENUM_LABEL_94\\";
    }
    case 95: {
      return \\"ENUM_LABEL_95\\";
    }
    case 96: {
      return \\"ENUM_LABEL_96\\";
    }
    case 97: {
      return \\"ENUM_LABEL_97\\";
    }
    case 98: {
      return \\"ENUM_LABEL_98\\";
    }
    case 99: {
      return \\"ENUM_LABEL_99\\";
    }
    case 100: {
      return \\"ENUM_LABEL_100\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as VeryLargeEnum;
    }
  }
};

const VeryLargeEnumToInt = function (i: VeryLargeEnum): number {
  switch (i) {
    case \\"ENUM_LABEL_DEFAULT\\": {
      return 0;
    }
    case \\"ENUM_LABEL_1\\": {
      return 1;
    }
    case \\"ENUM_LABEL_2\\": {
      return 2;
    }
    case \\"ENUM_LABEL_3\\": {
      return 3;
    }
    case \\"ENUM_LABEL_4\\": {
      return 4;
    }
    case \\"ENUM_LABEL_5\\": {
      return 5;
    }
    case \\"ENUM_LABEL_6\\": {
      return 6;
    }
    case \\"ENUM_LABEL_7\\": {
      return 7;
    }
    case \\"ENUM_LABEL_8\\": {
      return 8;
    }
    case \\"ENUM_LABEL_9\\": {
      return 9;
    }
    case \\"ENUM_LABEL_10\\": {
      return 10;
    }
    case \\"ENUM_LABEL_11\\": {
      return 11;
    }
    case \\"ENUM_LABEL_12\\": {
      return 12;
    }
    case \\"ENUM_LABEL_13\\": {
      return 13;
    }
    case \\"ENUM_LABEL_14\\": {
      return 14;
    }
    case \\"ENUM_LABEL_15\\": {
      return 15;
    }
    case \\"ENUM_LABEL_16\\": {
      return 16;
    }
    case \\"ENUM_LABEL_17\\": {
      return 17;
    }
    case \\"ENUM_LABEL_18\\": {
      return 18;
    }
    case \\"ENUM_LABEL_19\\": {
      return 19;
    }
    case \\"ENUM_LABEL_20\\": {
      return 20;
    }
    case \\"ENUM_LABEL_21\\": {
      return 21;
    }
    case \\"ENUM_LABEL_22\\": {
      return 22;
    }
    case \\"ENUM_LABEL_23\\": {
      return 23;
    }
    case \\"ENUM_LABEL_24\\": {
      return 24;
    }
    case \\"ENUM_LABEL_25\\": {
      return 25;
    }
    case \\"ENUM_LABEL_26\\": {
      return 26;
    }
    case \\"ENUM_LABEL_27\\": {
      return 27;
    }
    case \\"ENUM_LABEL_28\\": {
      return 28;
    }
    case \\"ENUM_LABEL_29\\": {
      return 29;
    }
    case \\"ENUM_LABEL_30\\": {
      return 30;
    }
    case \\"ENUM_LABEL_31\\": {
      return 31;
    }
    case \\"ENUM_LABEL_32\\": {
      return 32;
    }
    case \\"ENUM_LABEL_33\\": {
      return 33;
    }
    case \\"ENUM_LABEL_34\\": {
      return 34;
    }
    case \\"ENUM_LABEL_35\\": {
      return 35;
    }
    case \\"ENUM_LABEL_36\\": {
      return 36;
    }
    case \\"ENUM_LABEL_37\\": {
      return 37;
    }
    case \\"ENUM_LABEL_38\\": {
      return 38;
    }
    case \\"ENUM_LABEL_39\\": {
      return 39;
    }
    case \\"ENUM_LABEL_40\\": {
      return 40;
    }
    case \\"ENUM_LABEL_41\\": {
      return 41;
    }
    case \\"ENUM_LABEL_42\\": {
      return 42;
    }
    case \\"ENUM_LABEL_43\\": {
      return 43;
    }
    case \\"ENUM_LABEL_44\\": {
      return 44;
    }
    case \\"ENUM_LABEL_45\\": {
      return 45;
    }
    case \\"ENUM_LABEL_46\\": {
      return 46;
    }
    case \\"ENUM_LABEL_47\\": {
      return 47;
    }
    case \\"ENUM_LABEL_48\\": {
      return 48;
    }
    case \\"ENUM_LABEL_49\\": {
      return 49;
    }
    case \\"ENUM_LABEL_50\\": {
      return 50;
    }
    case \\"ENUM_LABEL_51\\": {
      return 51;
    }
    case \\"ENUM_LABEL_52\\": {
      return 52;
    }
    case \\"ENUM_LABEL_53\\": {
      return 53;
    }
    case \\"ENUM_LABEL_54\\": {
      return 54;
    }
    case \\"ENUM_LABEL_55\\": {
      return 55;
    }
    case \\"ENUM_LABEL_56\\": {
      return 56;
    }
    case \\"ENUM_LABEL_57\\": {
      return 57;
    }
    case \\"ENUM_LABEL_58\\": {
      return 58;
    }
    case \\"ENUM_LABEL_59\\": {
      return 59;
    }
    case \\"ENUM_LABEL_60\\": {
      return 60;
    }
    case \\"ENUM_LABEL_61\\": {
      return 61;
    }
    case \\"ENUM_LABEL_62\\": {
      return 62;
    }
    case \\"ENUM_LABEL_63\\": {
      return 63;
    }
    case \\"ENUM_LABEL_64\\": {
      return 64;
    }
    case \\"ENUM_LABEL_65\\": {
      return 65;
    }
    case \\"ENUM_LABEL_66\\": {
      return 66;
    }
    case \\"ENUM_LABEL_67\\": {
      return 67;
    }
    case \\"ENUM_LABEL_68\\": {
      return 68;
    }
    case \\"ENUM_LABEL_69\\": {
      return 69;
    }
    case \\"ENUM_LABEL_70\\": {
      return 70;
    }
    case \\"ENUM_LABEL_71\\": {
      return 71;
    }
    case \\"ENUM_LABEL_72\\": {
      return 72;
    }
    case \\"ENUM_LABEL_73\\": {
      return 73;
    }
    case \\"ENUM_LABEL_74\\": {
      return 74;
    }
    case \\"ENUM_LABEL_75\\": {
      return 75;
    }
    case \\"ENUM_LABEL_76\\": {
      return 76;
    }
    case \\"ENUM_LABEL_77\\": {
      return 77;
    }
    case \\"ENUM_LABEL_78\\": {
      return 78;
    }
    case \\"ENUM_LABEL_79\\": {
      return 79;
    }
    case \\"ENUM_LABEL_80\\": {
      return 80;
    }
    case \\"ENUM_LABEL_81\\": {
      return 81;
    }
    case \\"ENUM_LABEL_82\\": {
      return 82;
    }
    case \\"ENUM_LABEL_83\\": {
      return 83;
    }
    case \\"ENUM_LABEL_84\\": {
      return 84;
    }
    case \\"ENUM_LABEL_85\\": {
      return 85;
    }
    case \\"ENUM_LABEL_86\\": {
      return 86;
    }
    case \\"ENUM_LABEL_87\\": {
      return 87;
    }
    case \\"ENUM_LABEL_88\\": {
      return 88;
    }
    case \\"ENUM_LABEL_89\\": {
      return 89;
    }
    case \\"ENUM_LABEL_90\\": {
      return 90;
    }
    case \\"ENUM_LABEL_91\\": {
      return 91;
    }
    case \\"ENUM_LABEL_92\\": {
      return 92;
    }
    case \\"ENUM_LABEL_93\\": {
      return 93;
    }
    case \\"ENUM_LABEL_94\\": {
      return 94;
    }
    case \\"ENUM_LABEL_95\\": {
      return 95;
    }
    case \\"ENUM_LABEL_96\\": {
      return 96;
    }
    case \\"ENUM_LABEL_97\\": {
      return 97;
    }
    case \\"ENUM_LABEL_98\\": {
      return 98;
    }
    case \\"ENUM_LABEL_99\\": {
      return 99;
    }
    case \\"ENUM_LABEL_100\\": {
      return 100;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalImportEnum: ImportEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      defaultForeignEnum: ForeignEnumFromInt(0),
      defaultImportEnum: ImportEnumFromInt(0),
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      writer.writeEnum(23, ImportEnumToInt(msg.optionalImportEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum.map(ImportEnumToInt));
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(81, TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum));
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnumToInt(msg.defaultForeignEnum));
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      writer.writeEnum(83, ImportEnumToInt(msg.defaultImportEnum));
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json.defaultBytes = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(ImportEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (_optionalImportEnum) {
      msg.optionalImportEnum = _optionalImportEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (_repeatedImportEnum) {
      msg.repeatedImportEnum = _repeatedImportEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (_defaultInt32) {
      msg.defaultInt32 = _defaultInt32;
    }
    const _defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (_defaultInt64) {
      msg.defaultInt64 = BigInt(_defaultInt64);
    }
    const _defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (_defaultUint32) {
      msg.defaultUint32 = _defaultUint32;
    }
    const _defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (_defaultUint64) {
      msg.defaultUint64 = BigInt(_defaultUint64);
    }
    const _defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (_defaultSint32) {
      msg.defaultSint32 = _defaultSint32;
    }
    const _defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (_defaultSint64) {
      msg.defaultSint64 = BigInt(_defaultSint64);
    }
    const _defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (_defaultFixed32) {
      msg.defaultFixed32 = _defaultFixed32;
    }
    const _defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (_defaultFixed64) {
      msg.defaultFixed64 = BigInt(_defaultFixed64);
    }
    const _defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (_defaultSfixed32) {
      msg.defaultSfixed32 = _defaultSfixed32;
    }
    const _defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (_defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64);
    }
    const _defaultFloat = json.defaultFloat ?? json.default_float;
    if (_defaultFloat) {
      msg.defaultFloat = _defaultFloat;
    }
    const _defaultDouble = json.defaultDouble ?? json.default_double;
    if (_defaultDouble) {
      msg.defaultDouble = _defaultDouble;
    }
    const _defaultBool = json.defaultBool ?? json.default_bool;
    if (_defaultBool) {
      msg.defaultBool = _defaultBool;
    }
    const _defaultString = json.defaultString ?? json.default_string;
    if (_defaultString) {
      msg.defaultString = _defaultString;
    }
    const _defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (_defaultBytes) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes);
    }
    const _defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (_defaultNestedEnum) {
      msg.defaultNestedEnum = _defaultNestedEnum;
    }
    const _defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (_defaultForeignEnum) {
      msg.defaultForeignEnum = _defaultForeignEnum;
    }
    const _defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (_defaultImportEnum) {
      msg.defaultImportEnum = _defaultImportEnum;
    }
    const _defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (_defaultStringPiece) {
      msg.defaultStringPiece = _defaultStringPiece;
    }
    const _defaultCord = json.defaultCord ?? json.default_cord;
    if (_defaultCord) {
      msg.defaultCord = _defaultCord;
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" } as const,

  NestedEnumFromInt: function (i: number): TestAllTypes.NestedEnum {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestAllTypes.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestAllTypes.NestedEnum): number {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.OptionalGroup>): string {
      return JSON.stringify(TestAllTypes.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.RepeatedGroup>): string {
      return JSON.stringify(TestAllTypes.RepeatedGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    const _repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (_repeatedChild) {
      for (const item of _repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (msg: Partial<TestDeprecatedFields>): string {
    return JSON.stringify(TestDeprecatedFields._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const _deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (_deprecatedInt32) {
      msg.deprecatedInt32 = _deprecatedInt32;
    }
    const _deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (_deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestDeprecatedMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (_msg?: Partial<TestReservedFields>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestReservedFields>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */
  decodeJSON: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestAllExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (msg: Partial<OptionalGroup_extension>): string {
    return JSON.stringify(OptionalGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (msg: Partial<RepeatedGroup_extension>): string {
    return JSON.stringify(RepeatedGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (msg: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (msg: Partial<TestGroup>): string {
    return JSON.stringify(TestGroup._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json: string): TestGroup {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestGroup>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestGroup, json: any): TestGroup {
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestGroup.OptionalGroup>): string {
      return JSON.stringify(TestGroup.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestGroupExtension>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */
  decodeJSON: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestNestedExtension>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */
  decodeJSON: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (msg: Partial<TestChildExtension>): Uint8Array {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (msg: Partial<TestChildExtension>): string {
    return JSON.stringify(TestChildExtension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json: string): TestChildExtension {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _optionalExtension =
      json.optionalExtension ?? json.optional_extension;
    if (_optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, _optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (msg: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequired>): string {
    return JSON.stringify(TestRequired._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json: string): TestRequired {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestRequired, json: any): TestRequired {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _dummy2 = json.dummy2;
    if (_dummy2) {
      msg.dummy2 = _dummy2;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _dummy4 = json.dummy4;
    if (_dummy4) {
      msg.dummy4 = _dummy4;
    }
    const _dummy5 = json.dummy5;
    if (_dummy5) {
      msg.dummy5 = _dummy5;
    }
    const _dummy6 = json.dummy6;
    if (_dummy6) {
      msg.dummy6 = _dummy6;
    }
    const _dummy7 = json.dummy7;
    if (_dummy7) {
      msg.dummy7 = _dummy7;
    }
    const _dummy8 = json.dummy8;
    if (_dummy8) {
      msg.dummy8 = _dummy8;
    }
    const _dummy9 = json.dummy9;
    if (_dummy9) {
      msg.dummy9 = _dummy9;
    }
    const _dummy10 = json.dummy10;
    if (_dummy10) {
      msg.dummy10 = _dummy10;
    }
    const _dummy11 = json.dummy11;
    if (_dummy11) {
      msg.dummy11 = _dummy11;
    }
    const _dummy12 = json.dummy12;
    if (_dummy12) {
      msg.dummy12 = _dummy12;
    }
    const _dummy13 = json.dummy13;
    if (_dummy13) {
      msg.dummy13 = _dummy13;
    }
    const _dummy14 = json.dummy14;
    if (_dummy14) {
      msg.dummy14 = _dummy14;
    }
    const _dummy15 = json.dummy15;
    if (_dummy15) {
      msg.dummy15 = _dummy15;
    }
    const _dummy16 = json.dummy16;
    if (_dummy16) {
      msg.dummy16 = _dummy16;
    }
    const _dummy17 = json.dummy17;
    if (_dummy17) {
      msg.dummy17 = _dummy17;
    }
    const _dummy18 = json.dummy18;
    if (_dummy18) {
      msg.dummy18 = _dummy18;
    }
    const _dummy19 = json.dummy19;
    if (_dummy19) {
      msg.dummy19 = _dummy19;
    }
    const _dummy20 = json.dummy20;
    if (_dummy20) {
      msg.dummy20 = _dummy20;
    }
    const _dummy21 = json.dummy21;
    if (_dummy21) {
      msg.dummy21 = _dummy21;
    }
    const _dummy22 = json.dummy22;
    if (_dummy22) {
      msg.dummy22 = _dummy22;
    }
    const _dummy23 = json.dummy23;
    if (_dummy23) {
      msg.dummy23 = _dummy23;
    }
    const _dummy24 = json.dummy24;
    if (_dummy24) {
      msg.dummy24 = _dummy24;
    }
    const _dummy25 = json.dummy25;
    if (_dummy25) {
      msg.dummy25 = _dummy25;
    }
    const _dummy26 = json.dummy26;
    if (_dummy26) {
      msg.dummy26 = _dummy26;
    }
    const _dummy27 = json.dummy27;
    if (_dummy27) {
      msg.dummy27 = _dummy27;
    }
    const _dummy28 = json.dummy28;
    if (_dummy28) {
      msg.dummy28 = _dummy28;
    }
    const _dummy29 = json.dummy29;
    if (_dummy29) {
      msg.dummy29 = _dummy29;
    }
    const _dummy30 = json.dummy30;
    if (_dummy30) {
      msg.dummy30 = _dummy30;
    }
    const _dummy31 = json.dummy31;
    if (_dummy31) {
      msg.dummy31 = _dummy31;
    }
    const _dummy32 = json.dummy32;
    if (_dummy32) {
      msg.dummy32 = _dummy32;
    }
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (msg: Partial<TestRequiredForeign>): Uint8Array {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredForeign>): string {
    return JSON.stringify(TestRequiredForeign._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json: string): TestRequiredForeign {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessage>): Uint8Array {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredMessage>): string {
    return JSON.stringify(TestRequiredMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessage {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage = json.requiredMessage ?? json.required_message;
    if (_requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (msg: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (msg: Partial<TestForeignNested>): string {
    return JSON.stringify(TestForeignNested._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json: string): TestForeignNested {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const _foreignNested = json.foreignNested ?? json.foreign_nested;
    if (_foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */
  encodeJSON: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestPickleNestedMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            msg
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const _cc = json.cc;
        if (_cc) {
          msg.cc = _cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestMultipleExtensionRanges>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */
  decodeJSON: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (msg: Partial<TestReallyLargeTagNumber>): string {
    return JSON.stringify(TestReallyLargeTagNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _bb = json.bb;
    if (_bb) {
      msg.bb = _bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRecursiveMessage>): string {
    return JSON.stringify(TestRecursiveMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const _a = json.a;
    if (_a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _i = json.i;
    if (_i) {
      msg.i = _i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (msg: Partial<TestMutualRecursionA>): string {
    return JSON.stringify(TestMutualRecursionA._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const _bb = json.bb;
    if (_bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, _bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const _b = json.b;
      if (_b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, _b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestMutualRecursionA.SubGroup>): string {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const _subMessage = json.subMessage ?? json.sub_message;
      if (_subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, _subMessage);
        msg.subMessage = m;
      }
      const _notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (_notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (msg: Partial<TestMutualRecursionB>): string {
    return JSON.stringify(TestMutualRecursionB._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const _a = json.a;
    if (_a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (msg: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (msg: Partial<TestIsInitialized>): string {
    return JSON.stringify(TestIsInitialized._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json: string): TestIsInitialized {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */
    encodeJSON: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): string {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */
    decodeJSON: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const _i = json.i;
        if (_i) {
          msg.i = _i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (msg: Partial<TestDupFieldNumber>): string {
    return JSON.stringify(TestDupFieldNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (msg: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (msg: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (msg: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json: string): TestEagerMessage {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEagerMessage,
    json: any
  ): TestEagerMessage {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (msg: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json: string): TestLazyMessage {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestLazyMessage,
    json: any
  ): TestLazyMessage {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (msg: Partial<TestNestedMessageHasBits>): string {
    return JSON.stringify(TestNestedMessageHasBits._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const _nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (_nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32;
      }
      const _nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (_nestedmessageRepeatedForeignmessage) {
        for (const item of _nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (msg: Partial<TestCamelCaseFieldNames>): string {
    return JSON.stringify(TestCamelCaseFieldNames._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: ForeignEnumFromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnumToInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField.map(ForeignEnumToInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const _PrimitiveField = json.PrimitiveField;
    if (_PrimitiveField) {
      msg.PrimitiveField = _PrimitiveField;
    }
    const _StringField = json.StringField;
    if (_StringField) {
      msg.StringField = _StringField;
    }
    const _EnumField = json.EnumField;
    if (_EnumField) {
      msg.EnumField = _EnumField;
    }
    const _MessageField = json.MessageField;
    if (_MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _MessageField);
      msg.MessageField = m;
    }
    const _StringPieceField = json.StringPieceField;
    if (_StringPieceField) {
      msg.StringPieceField = _StringPieceField;
    }
    const _CordField = json.CordField;
    if (_CordField) {
      msg.CordField = _CordField;
    }
    const _RepeatedPrimitiveField = json.RepeatedPrimitiveField;
    if (_RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField;
    }
    const _RepeatedStringField = json.RepeatedStringField;
    if (_RepeatedStringField) {
      msg.RepeatedStringField = _RepeatedStringField;
    }
    const _RepeatedEnumField = json.RepeatedEnumField;
    if (_RepeatedEnumField) {
      msg.RepeatedEnumField = _RepeatedEnumField;
    }
    const _RepeatedMessageField = json.RepeatedMessageField;
    if (_RepeatedMessageField) {
      for (const item of _RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField = json.RepeatedStringPieceField;
    if (_RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField;
    }
    const _RepeatedCordField = json.RepeatedCordField;
    if (_RepeatedCordField) {
      msg.RepeatedCordField = _RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (msg: Partial<TestFieldOrderings>): Uint8Array {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (msg: Partial<TestFieldOrderings>): string {
    return JSON.stringify(TestFieldOrderings._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json: string): TestFieldOrderings {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    const _myInt = json.myInt ?? json.my_int;
    if (_myInt) {
      msg.myInt = BigInt(_myInt);
    }
    const _myFloat = json.myFloat ?? json.my_float;
    if (_myFloat) {
      msg.myFloat = _myFloat;
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): string {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const _oo = json.oo;
      if (_oo) {
        msg.oo = BigInt(_oo);
      }
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionOrderings1>): string {
    return JSON.stringify(TestExtensionOrderings1._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionOrderings2>): string {
    return JSON.stringify(TestExtensionOrderings2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const _myString = json.myString ?? json.my_string;
      if (_myString) {
        msg.myString = _myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtremeDefaultValues>): string {
    return JSON.stringify(TestExtremeDefaultValues._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes?.length) {
      json.escapedBytes = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json.bytesWithZero = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const _escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (_escapedBytes) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes);
    }
    const _largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (_largeUint32) {
      msg.largeUint32 = _largeUint32;
    }
    const _largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (_largeUint64) {
      msg.largeUint64 = BigInt(_largeUint64);
    }
    const _smallInt32 = json.smallInt32 ?? json.small_int32;
    if (_smallInt32) {
      msg.smallInt32 = _smallInt32;
    }
    const _smallInt64 = json.smallInt64 ?? json.small_int64;
    if (_smallInt64) {
      msg.smallInt64 = BigInt(_smallInt64);
    }
    const _reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (_reallySmallInt32) {
      msg.reallySmallInt32 = _reallySmallInt32;
    }
    const _reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (_reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64);
    }
    const _utf8String = json.utf8String ?? json.utf8_string;
    if (_utf8String) {
      msg.utf8String = _utf8String;
    }
    const _zeroFloat = json.zeroFloat ?? json.zero_float;
    if (_zeroFloat) {
      msg.zeroFloat = _zeroFloat;
    }
    const _oneFloat = json.oneFloat ?? json.one_float;
    if (_oneFloat) {
      msg.oneFloat = _oneFloat;
    }
    const _smallFloat = json.smallFloat ?? json.small_float;
    if (_smallFloat) {
      msg.smallFloat = _smallFloat;
    }
    const _negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (_negativeOneFloat) {
      msg.negativeOneFloat = _negativeOneFloat;
    }
    const _negativeFloat = json.negativeFloat ?? json.negative_float;
    if (_negativeFloat) {
      msg.negativeFloat = _negativeFloat;
    }
    const _largeFloat = json.largeFloat ?? json.large_float;
    if (_largeFloat) {
      msg.largeFloat = _largeFloat;
    }
    const _smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (_smallNegativeFloat) {
      msg.smallNegativeFloat = _smallNegativeFloat;
    }
    const _infDouble = json.infDouble ?? json.inf_double;
    if (_infDouble) {
      msg.infDouble = _infDouble;
    }
    const _negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (_negInfDouble) {
      msg.negInfDouble = _negInfDouble;
    }
    const _nanDouble = json.nanDouble ?? json.nan_double;
    if (_nanDouble) {
      msg.nanDouble = _nanDouble;
    }
    const _infFloat = json.infFloat ?? json.inf_float;
    if (_infFloat) {
      msg.infFloat = _infFloat;
    }
    const _negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (_negInfFloat) {
      msg.negInfFloat = _negInfFloat;
    }
    const _nanFloat = json.nanFloat ?? json.nan_float;
    if (_nanFloat) {
      msg.nanFloat = _nanFloat;
    }
    const _cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (_cppTrigraph) {
      msg.cppTrigraph = _cppTrigraph;
    }
    const _stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (_stringWithZero) {
      msg.stringWithZero = _stringWithZero;
    }
    const _bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (_bytesWithZero) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero);
    }
    const _stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (_stringPieceWithZero) {
      msg.stringPieceWithZero = _stringPieceWithZero;
    }
    const _cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (_cordWithZero) {
      msg.cordWithZero = _cordWithZero;
    }
    const _replacementString =
      json.replacementString ?? json.replacement_string;
    if (_replacementString) {
      msg.replacementString = _replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (msg: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (msg: Partial<SparseEnumMessage>): string {
    return JSON.stringify(SparseEnumMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json: string): SparseEnumMessage {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnumToInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const _sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (_sparseEnum) {
      msg.sparseEnum = _sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (msg: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (msg: Partial<OneString>): string {
    return JSON.stringify(OneString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json: string): OneString {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneString, json: any): OneString {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (msg: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (msg: Partial<MoreString>): string {
    return JSON.stringify(MoreString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json: string): MoreString {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreString, json: any): MoreString {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (msg: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (msg: Partial<OneBytes>): string {
    return JSON.stringify(OneBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json: string): OneBytes {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneBytes, json: any): OneBytes {
    const _data = json.data;
    if (_data) {
      msg.data = decodeBase64Bytes(_data);
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (msg: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (msg: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json: string): MoreBytes {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreBytes, json: any): MoreBytes {
    const _data = json.data;
    if (_data) {
      msg.data = _data.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (msg: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (msg: Partial<Int32Message>): string {
    return JSON.stringify(Int32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json: string): Int32Message {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Message, json: any): Int32Message {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (msg: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (msg: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json: string): Uint32Message {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint32Message, json: any): Uint32Message {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (msg: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (msg: Partial<Int64Message>): string {
    return JSON.stringify(Int64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json: string): Int64Message {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Message, json: any): Int64Message {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (msg: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (msg: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json: string): Uint64Message {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint64Message, json: any): Uint64Message {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (msg: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (msg: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json: string): BoolMessage {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolMessage, json: any): BoolMessage {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (msg: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof>): string {
    return JSON.stringify(TestOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json: string): TestOneof {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof, json: any): TestOneof {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneofBackwardsCompatible>): string {
    return JSON.stringify(TestOneofBackwardsCompatible._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnumToInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json.fooBytes = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json.barBytes = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json.barBytesWithEmptyDefault = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooCord = json.fooCord ?? json.foo_cord;
    if (_fooCord) {
      msg.fooCord = _fooCord;
    }
    const _fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (_fooStringPiece) {
      msg.fooStringPiece = _fooStringPiece;
    }
    const _fooBytes = json.fooBytes ?? json.foo_bytes;
    if (_fooBytes) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes);
    }
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    const _fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (_fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const _barInt = json.barInt ?? json.bar_int;
    if (_barInt) {
      msg.barInt = _barInt;
    }
    const _barString = json.barString ?? json.bar_string;
    if (_barString) {
      msg.barString = _barString;
    }
    const _barCord = json.barCord ?? json.bar_cord;
    if (_barCord) {
      msg.barCord = _barCord;
    }
    const _barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (_barStringPiece) {
      msg.barStringPiece = _barStringPiece;
    }
    const _barBytes = json.barBytes ?? json.bar_bytes;
    if (_barBytes) {
      msg.barBytes = decodeBase64Bytes(_barBytes);
    }
    const _barEnum = json.barEnum ?? json.bar_enum;
    if (_barEnum) {
      msg.barEnum = _barEnum;
    }
    const _barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (_barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault;
    }
    const _barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (_barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault;
    }
    const _barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (_barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault;
    }
    const _barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (_barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault
      );
    }
    const _bazInt = json.bazInt ?? json.baz_int;
    if (_bazInt) {
      msg.bazInt = _bazInt;
    }
    const _bazString = json.bazString ?? json.baz_string;
    if (_bazString) {
      msg.bazString = _bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" } as const,

  NestedEnumFromInt: function (i: number): TestOneof2.NestedEnum {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestOneof2.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestOneof2.NestedEnum): number {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof2.NestedMessage>): string {
      return JSON.stringify(TestOneof2.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const _quxInt = json.quxInt ?? json.qux_int;
      if (_quxInt) {
        msg.quxInt = BigInt(_quxInt);
      }
      const _corgeInt = json.corgeInt ?? json.corge_int;
      if (_corgeInt) {
        msg.corgeInt = _corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (msg: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredOneof>): string {
    return JSON.stringify(TestRequiredOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json: string): TestRequiredOneof {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): string {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const _requiredDouble = json.requiredDouble ?? json.required_double;
      if (_requiredDouble) {
        msg.requiredDouble = _requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (_unpackedInt32) {
      msg.unpackedInt32 = _unpackedInt32;
    }
    const _unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (_unpackedInt64) {
      msg.unpackedInt64 = _unpackedInt64.map(BigInt);
    }
    const _unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (_unpackedUint32) {
      msg.unpackedUint32 = _unpackedUint32;
    }
    const _unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (_unpackedUint64) {
      msg.unpackedUint64 = _unpackedUint64.map(BigInt);
    }
    const _unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (_unpackedSint32) {
      msg.unpackedSint32 = _unpackedSint32;
    }
    const _unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (_unpackedSint64) {
      msg.unpackedSint64 = _unpackedSint64.map(BigInt);
    }
    const _unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (_unpackedFixed32) {
      msg.unpackedFixed32 = _unpackedFixed32;
    }
    const _unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (_unpackedFixed64) {
      msg.unpackedFixed64 = _unpackedFixed64.map(BigInt);
    }
    const _unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (_unpackedSfixed32) {
      msg.unpackedSfixed32 = _unpackedSfixed32;
    }
    const _unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (_unpackedSfixed64) {
      msg.unpackedSfixed64 = _unpackedSfixed64.map(BigInt);
    }
    const _unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (_unpackedFloat) {
      msg.unpackedFloat = _unpackedFloat;
    }
    const _unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (_unpackedDouble) {
      msg.unpackedDouble = _unpackedDouble;
    }
    const _unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (_unpackedBool) {
      msg.unpackedBool = _unpackedBool;
    }
    const _unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (_unpackedEnum) {
      msg.unpackedEnum = _unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestPackedExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestUnpackedExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (msg: Partial<TestDynamicExtensions>): string {
    return JSON.stringify(TestDynamicExtensions._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnumFromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumTypeFromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnumToInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      json.enumExtension = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumTypeFromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const _scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (_scalarExtension) {
      msg.scalarExtension = _scalarExtension;
    }
    const _enumExtension = json.enumExtension ?? json.enum_extension;
    if (_enumExtension) {
      msg.enumExtension = _enumExtension;
    }
    const _dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (_dynamicEnumExtension) {
      msg.dynamicEnumExtension = _dynamicEnumExtension;
    }
    const _messageExtension = json.messageExtension ?? json.message_extension;
    if (_messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _messageExtension);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (_dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        _dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension =
      json.repeatedExtension ?? json.repeated_extension;
    if (_repeatedExtension) {
      msg.repeatedExtension = _repeatedExtension;
    }
    const _packedExtension = json.packedExtension ?? json.packed_extension;
    if (_packedExtension) {
      msg.packedExtension = _packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: \\"DYNAMIC_FOO\\",
    DYNAMIC_BAR: \\"DYNAMIC_BAR\\",
    DYNAMIC_BAZ: \\"DYNAMIC_BAZ\\",
  } as const,

  DynamicEnumTypeFromInt: function (
    i: number
  ): TestDynamicExtensions.DynamicEnumType {
    switch (i) {
      case 2200: {
        return \\"DYNAMIC_FOO\\";
      }
      case 2201: {
        return \\"DYNAMIC_BAR\\";
      }
      case 2202: {
        return \\"DYNAMIC_BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestDynamicExtensions.DynamicEnumType;
      }
    }
  },

  DynamicEnumTypeToInt: function (
    i: TestDynamicExtensions.DynamicEnumType
  ): number {
    switch (i) {
      case \\"DYNAMIC_FOO\\": {
        return 2200;
      }
      case \\"DYNAMIC_BAR\\": {
        return 2201;
      }
      case \\"DYNAMIC_BAZ\\": {
        return 2202;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const _dynamicField = json.dynamicField ?? json.dynamic_field;
      if (_dynamicField) {
        msg.dynamicField = _dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (msg: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (msg: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json: string): TestParsingMerge {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestParsingMerge,
    json: any
  ): TestParsingMerge {
    const _requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (_requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (_optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (_repeatedAllTypes) {
      for (const item of _repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const _field1 = json.field1;
      if (_field1) {
        for (const item of _field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const _field2 = json.field2;
      if (_field2) {
        for (const item of _field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const _field3 = json.field3;
      if (_field3) {
        for (const item of _field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1 = json.ext1;
      if (_ext1) {
        for (const item of _ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2 = json.ext2;
      if (_ext2) {
        for (const item of _ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const _optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (_optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const _repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (_repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestCommentInjectionMessage>): string {
    return JSON.stringify(TestCommentInjectionMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (_msg?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */
  decodeJSON: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (_msg?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */
  decodeJSON: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooClientMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */
  decodeJSON: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooServerMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */
  decodeJSON: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (_msg?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */
  encodeJSON: function (_msg?: Partial<BarRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */
  decodeJSON: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (_msg?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */
  encodeJSON: function (_msg?: Partial<BarResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */
  decodeJSON: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (msg: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (msg: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonName._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json: string): TestJsonName {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestJsonName, json: any): TestJsonName {
    const _fieldName1 = json.fieldName1 ?? json.field_name1;
    if (_fieldName1) {
      msg.fieldName1 = _fieldName1;
    }
    const _fieldName2 = json.fieldName2;
    if (_fieldName2) {
      msg.fieldName2 = _fieldName2;
    }
    const _FieldName3 = json.FieldName3;
    if (_FieldName3) {
      msg.FieldName3 = _FieldName3;
    }
    const _FieldName4 = json.FieldName4 ?? json._field_name4;
    if (_FieldName4) {
      msg.FieldName4 = _FieldName4;
    }
    const _FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (_FIELDNAME5) {
      msg.FIELDNAME5 = _FIELDNAME5;
    }
    const _fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (_fieldName6) {
      msg.fieldName6 = _fieldName6;
    }
    const _fieldname7 = json.fieldname7;
    if (_fieldname7) {
      msg.fieldname7 = _fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (msg: Partial<TestHugeFieldNumbers>): string {
    return JSON.stringify(TestHugeFieldNumbers._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnumFromInt(0),
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnumToInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries<any>(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      const stringStringMap = Object.fromEntries(
        Object.entries<any>(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringStringMap).length > 0) {
        json.stringStringMap = stringStringMap;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const stringStringMap =
            {} as MapMessage<TestHugeFieldNumbers.StringStringMap>;
          reader.readMessage(
            stringStringMap,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[stringStringMap.key] = stringStringMap.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _fixed32 = json.fixed32 ?? json.fixed_32;
    if (_fixed32) {
      msg.fixed32 = _fixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (_optionalEnum) {
      msg.optionalEnum = _optionalEnum;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (_stringStringMap) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries<any>(_stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (_oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const _groupA = json.groupA ?? json.group_a;
      if (_groupA) {
        msg.groupA = _groupA;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      reader: BinaryReader
    ): MapMessage<TestHugeFieldNumbers.StringStringMap> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      json: any
    ): MapMessage<TestHugeFieldNumbers.StringStringMap> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionInsideTable>): string {
    return JSON.stringify(TestExtensionInsideTable._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const _field1 = json.field1;
    if (_field1) {
      msg.field1 = _field1;
    }
    const _field2 = json.field2;
    if (_field2) {
      msg.field2 = _field2;
    }
    const _field3 = json.field3;
    if (_field3) {
      msg.field3 = _field3;
    }
    const _field4 = json.field4;
    if (_field4) {
      msg.field4 = _field4;
    }
    const _field6 = json.field6;
    if (_field6) {
      msg.field6 = _field6;
    }
    const _field7 = json.field7;
    if (_field7) {
      msg.field7 = _field7;
    }
    const _field8 = json.field8;
    if (_field8) {
      msg.field8 = _field8;
    }
    const _field9 = json.field9;
    if (_field9) {
      msg.field9 = _field9;
    }
    const _field10 = json.field10;
    if (_field10) {
      msg.field10 = _field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionRangeSerialize>): string {
    return JSON.stringify(TestExtensionRangeSerialize._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const _fooOne = json.fooOne ?? json.foo_one;
    if (_fooOne) {
      msg.fooOne = _fooOne;
    }
    const _fooTwo = json.fooTwo ?? json.foo_two;
    if (_fooTwo) {
      msg.fooTwo = _fooTwo;
    }
    const _fooThree = json.fooThree ?? json.foo_three;
    if (_fooThree) {
      msg.fooThree = _fooThree;
    }
    const _fooFour = json.fooFour ?? json.foo_four;
    if (_fooFour) {
      msg.fooFour = _fooFour;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = \\"MAP_ENUM_FOO\\" | \\"MAP_ENUM_BAR\\" | \\"MAP_ENUM_BAZ\\";

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: TestMap.MapInt32Int32;
  mapInt64Int64: TestMap.MapInt64Int64;
  mapUint32Uint32: TestMap.MapUint32Uint32;
  mapUint64Uint64: TestMap.MapUint64Uint64;
  mapSint32Sint32: TestMap.MapSint32Sint32;
  mapSint64Sint64: TestMap.MapSint64Sint64;
  mapFixed32Fixed32: TestMap.MapFixed32Fixed32;
  mapFixed64Fixed64: TestMap.MapFixed64Fixed64;
  mapSfixed32Sfixed32: TestMap.MapSfixed32Sfixed32;
  mapSfixed64Sfixed64: TestMap.MapSfixed64Sfixed64;
  mapInt32Float: TestMap.MapInt32Float;
  mapInt32Double: TestMap.MapInt32Double;
  mapBoolBool: TestMap.MapBoolBool;
  mapStringString: TestMap.MapStringString;
  mapInt32Bytes: TestMap.MapInt32Bytes;
  mapInt32Enum: TestMap.MapInt32Enum;
  mapInt32ForeignMessage: TestMap.MapInt32ForeignMessage;
  mapStringForeignMessage: TestMap.MapStringForeignMessage;
  mapInt32AllTypes: TestMap.MapInt32AllTypes;
}

declare namespace TestMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<bigint, bigint | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<bigint, bigint | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<bigint, bigint | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<bigint, bigint | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<bigint, bigint | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;

  export type MapStringForeignMessage = Record<
    string,
    ForeignMessage | undefined
  >;

  export type MapInt32AllTypes = Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: TestMessageMap.MapInt32Message;
}

declare namespace TestMessageMap {
  export type MapInt32Message = Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: TestSameTypeMap.Map1;
  map2: TestSameTypeMap.Map2;
}

declare namespace TestSameTypeMap {
  export type Map1 = Record<number, number | undefined>;

  export type Map2 = Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: TestRequiredMessageMap.MapField;
}

declare namespace TestRequiredMessageMap {
  export type MapField = Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: TestArenaMap.MapInt32Int32;
  mapInt64Int64: TestArenaMap.MapInt64Int64;
  mapUint32Uint32: TestArenaMap.MapUint32Uint32;
  mapUint64Uint64: TestArenaMap.MapUint64Uint64;
  mapSint32Sint32: TestArenaMap.MapSint32Sint32;
  mapSint64Sint64: TestArenaMap.MapSint64Sint64;
  mapFixed32Fixed32: TestArenaMap.MapFixed32Fixed32;
  mapFixed64Fixed64: TestArenaMap.MapFixed64Fixed64;
  mapSfixed32Sfixed32: TestArenaMap.MapSfixed32Sfixed32;
  mapSfixed64Sfixed64: TestArenaMap.MapSfixed64Sfixed64;
  mapInt32Float: TestArenaMap.MapInt32Float;
  mapInt32Double: TestArenaMap.MapInt32Double;
  mapBoolBool: TestArenaMap.MapBoolBool;
  mapStringString: TestArenaMap.MapStringString;
  mapInt32Bytes: TestArenaMap.MapInt32Bytes;
  mapInt32Enum: TestArenaMap.MapInt32Enum;
  mapInt32ForeignMessage: TestArenaMap.MapInt32ForeignMessage;
}

declare namespace TestArenaMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<bigint, bigint | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<bigint, bigint | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<bigint, bigint | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<bigint, bigint | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<bigint, bigint | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: MessageContainingMapCalledEntry.Entry;
}

declare namespace MessageContainingMapCalledEntry {
  export type Entry = Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: TestRecursiveMapMessage.A;
}

declare namespace TestRecursiveMapMessage {
  export type A = Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: \\"MAP_ENUM_FOO\\",
  MAP_ENUM_BAR: \\"MAP_ENUM_BAR\\",
  MAP_ENUM_BAZ: \\"MAP_ENUM_BAZ\\",
} as const;

const MapEnumFromInt = function (i: number): MapEnum {
  switch (i) {
    case 0: {
      return \\"MAP_ENUM_FOO\\";
    }
    case 1: {
      return \\"MAP_ENUM_BAR\\";
    }
    case 2: {
      return \\"MAP_ENUM_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as MapEnum;
    }
  }
};

const MapEnumToInt = function (i: MapEnum): number {
  switch (i) {
    case \\"MAP_ENUM_FOO\\": {
      return 0;
    }
    case \\"MAP_ENUM_BAR\\": {
      return 1;
    }
    case \\"MAP_ENUM_BAZ\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (msg: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestMap>): string {
    return JSON.stringify(TestMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json: string): TestMap {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries<any>(msg.mapStringForeignMessage).map(
          ([key, value]) => ({ key: key, value: value })
        ) as any,
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries<any>(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries<any>(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries<any>(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    if (msg.mapStringForeignMessage) {
      const mapStringForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringForeignMessage).length > 0) {
        json.mapStringForeignMessage = mapStringForeignMessage;
      }
    }
    if (msg.mapInt32AllTypes) {
      const mapInt32AllTypes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32AllTypes).length > 0) {
        json.mapInt32AllTypes = mapInt32AllTypes;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {} as MapMessage<TestMap.MapInt32Int32>;
          reader.readMessage(mapInt32Int32, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {} as MapMessage<TestMap.MapInt64Int64>;
          reader.readMessage(mapInt64Int64, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {} as MapMessage<TestMap.MapUint32Uint32>;
          reader.readMessage(
            mapUint32Uint32,
            TestMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {} as MapMessage<TestMap.MapUint64Uint64>;
          reader.readMessage(
            mapUint64Uint64,
            TestMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {} as MapMessage<TestMap.MapSint32Sint32>;
          reader.readMessage(
            mapSint32Sint32,
            TestMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {} as MapMessage<TestMap.MapSint64Sint64>;
          reader.readMessage(
            mapSint64Sint64,
            TestMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {} as MapMessage<TestMap.MapFixed32Fixed32>;
          reader.readMessage(
            mapFixed32Fixed32,
            TestMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {} as MapMessage<TestMap.MapFixed64Fixed64>;
          reader.readMessage(
            mapFixed64Fixed64,
            TestMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 =
            {} as MapMessage<TestMap.MapSfixed32Sfixed32>;
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 =
            {} as MapMessage<TestMap.MapSfixed64Sfixed64>;
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {} as MapMessage<TestMap.MapInt32Float>;
          reader.readMessage(mapInt32Float, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {} as MapMessage<TestMap.MapInt32Double>;
          reader.readMessage(
            mapInt32Double,
            TestMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {} as MapMessage<TestMap.MapBoolBool>;
          reader.readMessage(mapBoolBool, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {} as MapMessage<TestMap.MapStringString>;
          reader.readMessage(
            mapStringString,
            TestMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {} as MapMessage<TestMap.MapInt32Bytes>;
          reader.readMessage(mapInt32Bytes, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {} as MapMessage<TestMap.MapInt32Enum>;
          reader.readMessage(mapInt32Enum, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage =
            {} as MapMessage<TestMap.MapInt32ForeignMessage>;
          reader.readMessage(
            mapInt32ForeignMessage,
            TestMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        case 18: {
          const mapStringForeignMessage =
            {} as MapMessage<TestMap.MapStringForeignMessage>;
          reader.readMessage(
            mapStringForeignMessage,
            TestMap.MapStringForeignMessage._readMessage
          );
          msg.mapStringForeignMessage[mapStringForeignMessage.key] =
            mapStringForeignMessage.value;
          break;
        }
        case 19: {
          const mapInt32AllTypes = {} as MapMessage<TestMap.MapInt32AllTypes>;
          reader.readMessage(
            mapInt32AllTypes,
            TestMap.MapInt32AllTypes._readMessage
          );
          msg.mapInt32AllTypes[mapInt32AllTypes.key] = mapInt32AllTypes.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMap, json: any): TestMap {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries<any>(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries<any>(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries<any>(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries<any>(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries<any>(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (_mapStringForeignMessage) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (_mapInt32AllTypes) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries<any>(_mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Int32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      json: any
    ): MapMessage<TestMap.MapInt32Int32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt64Int64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      json: any
    ): MapMessage<TestMap.MapInt64Int64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapUint32Uint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      json: any
    ): MapMessage<TestMap.MapUint32Uint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapUint64Uint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      json: any
    ): MapMessage<TestMap.MapUint64Uint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSint32Sint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      json: any
    ): MapMessage<TestMap.MapSint32Sint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSint64Sint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      json: any
    ): MapMessage<TestMap.MapSint64Sint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapFixed32Fixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      json: any
    ): MapMessage<TestMap.MapFixed32Fixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapFixed64Fixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      json: any
    ): MapMessage<TestMap.MapFixed64Fixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSfixed32Sfixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      json: any
    ): MapMessage<TestMap.MapSfixed32Sfixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSfixed64Sfixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      json: any
    ): MapMessage<TestMap.MapSfixed64Sfixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Float> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      json: any
    ): MapMessage<TestMap.MapInt32Float> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Double> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      json: any
    ): MapMessage<TestMap.MapInt32Double> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapBoolBool> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      json: any
    ): MapMessage<TestMap.MapBoolBool> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapStringString>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapStringString> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapStringString>,
      json: any
    ): MapMessage<TestMap.MapStringString> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Bytes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      json: any
    ): MapMessage<TestMap.MapInt32Bytes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Enum> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      json: any
    ): MapMessage<TestMap.MapInt32Enum> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32ForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      json: any
    ): MapMessage<TestMap.MapInt32ForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapStringForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      json: any
    ): MapMessage<TestMap.MapStringForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32AllTypes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      json: any
    ): MapMessage<TestMap.MapInt32AllTypes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (msg: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestMapSubmessage>): string {
    return JSON.stringify(TestMapSubmessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json: string): TestMapSubmessage {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const _testMap = json.testMap ?? json.test_map;
    if (_testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, _testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestMessageMap {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      const mapInt32Message = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Message).length > 0) {
        json.mapInt32Message = mapInt32Message;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Message =
            {} as MapMessage<TestMessageMap.MapInt32Message>;
          reader.readMessage(
            mapInt32Message,
            TestMessageMap.MapInt32Message._readMessage
          );
          msg.mapInt32Message[mapInt32Message.key] = mapInt32Message.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMessageMap, json: any): TestMessageMap {
    const _mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (_mapInt32Message) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries<any>(_mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      reader: BinaryReader
    ): MapMessage<TestMessageMap.MapInt32Message> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      json: any
    ): MapMessage<TestMessageMap.MapInt32Message> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (msg: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json: string): TestSameTypeMap {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      const map1 = Object.fromEntries(
        Object.entries<any>(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map1).length > 0) {
        json.map1 = map1;
      }
    }
    if (msg.map2) {
      const map2 = Object.fromEntries(
        Object.entries<any>(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map2).length > 0) {
        json.map2 = map2;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map1 = {} as MapMessage<TestSameTypeMap.Map1>;
          reader.readMessage(map1, TestSameTypeMap.Map1._readMessage);
          msg.map1[map1.key] = map1.value;
          break;
        }
        case 2: {
          const map2 = {} as MapMessage<TestSameTypeMap.Map2>;
          reader.readMessage(map2, TestSameTypeMap.Map2._readMessage);
          msg.map2[map2.key] = map2.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestSameTypeMap,
    json: any
  ): TestSameTypeMap {
    const _map1 = json.map1;
    if (_map1) {
      msg.map1 = Object.fromEntries(
        Object.entries<any>(_map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2 = json.map2;
    if (_map2) {
      msg.map2 = Object.fromEntries(
        Object.entries<any>(_map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map1>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      reader: BinaryReader
    ): MapMessage<TestSameTypeMap.Map1> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      json: any
    ): MapMessage<TestSameTypeMap.Map1> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map2>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      reader: BinaryReader
    ): MapMessage<TestSameTypeMap.Map2> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      json: any
    ): MapMessage<TestSameTypeMap.Map2> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredMessageMap>): string {
    return JSON.stringify(TestRequiredMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      const mapField = Object.fromEntries(
        Object.entries<any>(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapField).length > 0) {
        json.mapField = mapField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapField = {} as MapMessage<TestRequiredMessageMap.MapField>;
          reader.readMessage(
            mapField,
            TestRequiredMessageMap.MapField._readMessage
          );
          msg.mapField[mapField.key] = mapField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const _mapField = json.mapField ?? json.map_field;
    if (_mapField) {
      msg.mapField = Object.fromEntries(
        Object.entries<any>(_mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestRequired._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRequired._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      reader: BinaryReader
    ): MapMessage<TestRequiredMessageMap.MapField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      json: any
    ): MapMessage<TestRequiredMessageMap.MapField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (msg: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json: string): TestArenaMap {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries<any>(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries<any>(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {} as MapMessage<TestArenaMap.MapInt32Int32>;
          reader.readMessage(
            mapInt32Int32,
            TestArenaMap.MapInt32Int32._readMessage
          );
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {} as MapMessage<TestArenaMap.MapInt64Int64>;
          reader.readMessage(
            mapInt64Int64,
            TestArenaMap.MapInt64Int64._readMessage
          );
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 =
            {} as MapMessage<TestArenaMap.MapUint32Uint32>;
          reader.readMessage(
            mapUint32Uint32,
            TestArenaMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 =
            {} as MapMessage<TestArenaMap.MapUint64Uint64>;
          reader.readMessage(
            mapUint64Uint64,
            TestArenaMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 =
            {} as MapMessage<TestArenaMap.MapSint32Sint32>;
          reader.readMessage(
            mapSint32Sint32,
            TestArenaMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 =
            {} as MapMessage<TestArenaMap.MapSint64Sint64>;
          reader.readMessage(
            mapSint64Sint64,
            TestArenaMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 =
            {} as MapMessage<TestArenaMap.MapFixed32Fixed32>;
          reader.readMessage(
            mapFixed32Fixed32,
            TestArenaMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 =
            {} as MapMessage<TestArenaMap.MapFixed64Fixed64>;
          reader.readMessage(
            mapFixed64Fixed64,
            TestArenaMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 =
            {} as MapMessage<TestArenaMap.MapSfixed32Sfixed32>;
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 =
            {} as MapMessage<TestArenaMap.MapSfixed64Sfixed64>;
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {} as MapMessage<TestArenaMap.MapInt32Float>;
          reader.readMessage(
            mapInt32Float,
            TestArenaMap.MapInt32Float._readMessage
          );
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {} as MapMessage<TestArenaMap.MapInt32Double>;
          reader.readMessage(
            mapInt32Double,
            TestArenaMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {} as MapMessage<TestArenaMap.MapBoolBool>;
          reader.readMessage(
            mapBoolBool,
            TestArenaMap.MapBoolBool._readMessage
          );
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString =
            {} as MapMessage<TestArenaMap.MapStringString>;
          reader.readMessage(
            mapStringString,
            TestArenaMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {} as MapMessage<TestArenaMap.MapInt32Bytes>;
          reader.readMessage(
            mapInt32Bytes,
            TestArenaMap.MapInt32Bytes._readMessage
          );
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {} as MapMessage<TestArenaMap.MapInt32Enum>;
          reader.readMessage(
            mapInt32Enum,
            TestArenaMap.MapInt32Enum._readMessage
          );
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage =
            {} as MapMessage<TestArenaMap.MapInt32ForeignMessage>;
          reader.readMessage(
            mapInt32ForeignMessage,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestArenaMap, json: any): TestArenaMap {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries<any>(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries<any>(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries<any>(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries<any>(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries<any>(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Int32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Int32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt64Int64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      json: any
    ): MapMessage<TestArenaMap.MapInt64Int64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapUint32Uint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      json: any
    ): MapMessage<TestArenaMap.MapUint32Uint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapUint64Uint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      json: any
    ): MapMessage<TestArenaMap.MapUint64Uint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSint32Sint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      json: any
    ): MapMessage<TestArenaMap.MapSint32Sint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSint64Sint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      json: any
    ): MapMessage<TestArenaMap.MapSint64Sint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapFixed32Fixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      json: any
    ): MapMessage<TestArenaMap.MapFixed32Fixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapFixed64Fixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      json: any
    ): MapMessage<TestArenaMap.MapFixed64Fixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSfixed32Sfixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      json: any
    ): MapMessage<TestArenaMap.MapSfixed32Sfixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSfixed64Sfixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      json: any
    ): MapMessage<TestArenaMap.MapSfixed64Sfixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Float> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Float> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Double> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Double> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapBoolBool> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      json: any
    ): MapMessage<TestArenaMap.MapBoolBool> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapStringString> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      json: any
    ): MapMessage<TestArenaMap.MapStringString> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Bytes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Bytes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Enum> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Enum> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32ForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32ForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (msg: Partial<MessageContainingMapCalledEntry>): string {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      const entry = Object.fromEntries(
        Object.entries<any>(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(entry).length > 0) {
        json.entry = entry;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const entry = {} as MapMessage<MessageContainingMapCalledEntry.Entry>;
          reader.readMessage(
            entry,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[entry.key] = entry.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const _entry = json.entry;
    if (_entry) {
      msg.entry = Object.fromEntries(
        Object.entries<any>(_entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      reader: BinaryReader
    ): MapMessage<MessageContainingMapCalledEntry.Entry> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      json: any
    ): MapMessage<MessageContainingMapCalledEntry.Entry> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRecursiveMapMessage>): string {
    return JSON.stringify(TestRecursiveMapMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = Object.fromEntries(
        Object.entries<any>(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const a = {} as MapMessage<TestRecursiveMapMessage.A>;
          reader.readMessage(a, TestRecursiveMapMessage.A._readMessage);
          msg.a[a.key] = a.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const _a = json.a;
    if (_a) {
      msg.a = Object.fromEntries(
        Object.entries<any>(_a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestRecursiveMapMessage.A>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRecursiveMapMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      reader: BinaryReader
    ): MapMessage<TestRecursiveMapMessage.A> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRecursiveMapMessage.initialize(),
              TestRecursiveMapMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      json: any
    ): MapMessage<TestRecursiveMapMessage.A> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      Array [
        "google/protobuf/any.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/any.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`Any\` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type
 * name \\"y.z\\".
 *
 *
 * JSON
 * ====
 * The JSON representation of an \`Any\` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field \`@type\` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",
 *       \\"firstName\\": <string>,
 *       \\"lastName\\": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * \`value\` which holds the custom JSON in addition to the \`@type\`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",
 *       \\"value\\": \\"1.212s\\"
 *     }
 *
 */
export interface Any {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized
   * protocol buffer message. This string must contain at least
   * one \\"/\\" character. The last segment of the URL's path must represent
   * the fully qualified name of the type (as in
   * \`path/google.protobuf.Duration\`). The name should be in a canonical form
   * (e.g., leading \\".\\" is not accepted).
   *
   * In practice, teams usually precompile into the binary all types that they
   * expect it to use in the context of Any. However, for URLs which use the
   * scheme \`http\`, \`https\`, or no scheme, one can optionally set up a type
   * server that maps type URLs to message definitions as follows:
   *
   * * If no scheme is provided, \`https\` is assumed.
   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   *   value in binary format, or produce an error.
   * * Applications are allowed to cache lookup results based on the
   *   URL, or have them precompiled into a binary to avoid any
   *   lookup. Therefore, binary compatibility needs to be preserved
   *   on changes to types. (Use versioned type names to manage
   *   breaking changes.)
   *
   * Note: this functionality is not currently available in the official
   * protobuf release, and it is not used for type URLs beginning with
   * type.googleapis.com.
   *
   * Schemes other than \`http\`, \`https\` (or the empty scheme) might be
   * used with implementation specific semantics.
   *
   */
  typeUrl: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   */
  value: Uint8Array;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Any = {
  /**
   * Serializes a Any to protobuf.
   */
  encode: function (msg: Partial<Any>): Uint8Array {
    return Any._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Any from protobuf.
   */
  decode: function (bytes: ByteSource): Any {
    return Any._readMessage(Any.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Any to JSON.
   */
  encodeJSON: function (msg: Partial<Any>): string {
    return JSON.stringify(Any._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Any from JSON.
   */
  decodeJSON: function (json: string): Any {
    return Any._readMessageJSON(Any.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Any with all fields set to their default value.
   */
  initialize: function (): Any {
    return {
      typeUrl: \\"\\",
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Any>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Any>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Any, reader: BinaryReader): Any {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Any, json: any): Any {
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/source_context.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/source_context.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`SourceContext\` represents information about the source of a
 * protobuf element, like the file in which it is defined.
 */
export interface SourceContext {
  /**
   * The path-qualified name of the .proto file that contained the associated
   * protobuf element.  For example: \`\\"google/protobuf/source_context.proto\\"\`.
   */
  fileName: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SourceContext = {
  /**
   * Serializes a SourceContext to protobuf.
   */
  encode: function (msg: Partial<SourceContext>): Uint8Array {
    return SourceContext._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SourceContext from protobuf.
   */
  decode: function (bytes: ByteSource): SourceContext {
    return SourceContext._readMessage(
      SourceContext.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SourceContext to JSON.
   */
  encodeJSON: function (msg: Partial<SourceContext>): string {
    return JSON.stringify(SourceContext._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SourceContext from JSON.
   */
  decodeJSON: function (json: string): SourceContext {
    return SourceContext._readMessageJSON(
      SourceContext.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SourceContext with all fields set to their default value.
   */
  initialize: function (): SourceContext {
    return {
      fileName: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SourceContext>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SourceContext>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fileName) {
      json.fileName = msg.fileName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SourceContext,
    reader: BinaryReader
  ): SourceContext {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: SourceContext, json: any): SourceContext {
    const _fileName = json.fileName ?? json.file_name;
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/type.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { SourceContext } from \\"./source_context.pb\\";
import { Any } from \\"./any.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * The syntax in which a protocol buffer element is defined.
 */
export type Syntax = \\"SYNTAX_PROTO2\\" | \\"SYNTAX_PROTO3\\";

/**
 * A protocol buffer message type.
 */
export interface Type {
  /**
   * The fully qualified message name.
   */
  name: string;
  /**
   * The list of fields.
   */
  fields: Field[];
  /**
   * The list of types appearing in \`oneof\` definitions in this type.
   */
  oneofs: string[];
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * A single field of a message type.
 */
export interface Field {
  /**
   * The field type.
   */
  kind: Field.Kind;
  /**
   * The field cardinality.
   */
  cardinality: Field.Cardinality;
  /**
   * The field number.
   */
  number: number;
  /**
   * The field name.
   */
  name: string;
  /**
   * The field type URL, without the scheme, for message or enumeration
   * types. Example: \`\\"type.googleapis.com/google.protobuf.Timestamp\\"\`.
   */
  typeUrl: string;
  /**
   * The index of the field type in \`Type.oneofs\`, for message or enumeration
   * types. The first type has index 1; zero means the type is not in the list.
   */
  oneofIndex: number;
  /**
   * Whether to use alternative packed wire representation.
   */
  packed: boolean;
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The field JSON name.
   */
  jsonName: string;
  /**
   * The string value of the default value of this field. Proto2 syntax only.
   */
  defaultValue: string;
}

declare namespace Field {
  /**
   * Basic field types.
   */
  export type Kind =
    | \\"TYPE_UNKNOWN\\"
    | \\"TYPE_DOUBLE\\"
    | \\"TYPE_FLOAT\\"
    | \\"TYPE_INT64\\"
    | \\"TYPE_UINT64\\"
    | \\"TYPE_INT32\\"
    | \\"TYPE_FIXED64\\"
    | \\"TYPE_FIXED32\\"
    | \\"TYPE_BOOL\\"
    | \\"TYPE_STRING\\"
    | \\"TYPE_GROUP\\"
    | \\"TYPE_MESSAGE\\"
    | \\"TYPE_BYTES\\"
    | \\"TYPE_UINT32\\"
    | \\"TYPE_ENUM\\"
    | \\"TYPE_SFIXED32\\"
    | \\"TYPE_SFIXED64\\"
    | \\"TYPE_SINT32\\"
    | \\"TYPE_SINT64\\";

  /**
   * Whether a field is optional, required, or repeated.
   */
  export type Cardinality =
    | \\"CARDINALITY_UNKNOWN\\"
    | \\"CARDINALITY_OPTIONAL\\"
    | \\"CARDINALITY_REQUIRED\\"
    | \\"CARDINALITY_REPEATED\\";
}

/**
 * Enum type definition.
 */
export interface Enum {
  /**
   * Enum type name.
   */
  name: string;
  /**
   * Enum value definitions.
   */
  enumvalue: EnumValue[];
  /**
   * Protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * Enum value definition.
 */
export interface EnumValue {
  /**
   * Enum value name.
   */
  name: string;
  /**
   * Enum value number.
   */
  number: number;
  /**
   * Protocol buffer options.
   */
  options: Option[];
}

/**
 * A protocol buffer option, which can be attached to a message, field,
 * enumeration, etc.
 */
export interface Option {
  /**
   * The option's name. For protobuf built-in options (options defined in
   * descriptor.proto), this is the short name. For example, \`\\"map_entry\\"\`.
   * For custom options, it should be the fully-qualified name. For example,
   * \`\\"google.api.http\\"\`.
   */
  name: string;
  /**
   * The option's value packed in an Any message. If the value is a primitive,
   * the corresponding wrapper type defined in google/protobuf/wrappers.proto
   * should be used. If the value is an enum, it should be stored as an int32
   * value using the google.protobuf.Int32Value type.
   */
  value: Any;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Syntax = {
  /**
   * Syntax \`proto2\`.
   */
  SYNTAX_PROTO2: \\"SYNTAX_PROTO2\\",
  /**
   * Syntax \`proto3\`.
   */
  SYNTAX_PROTO3: \\"SYNTAX_PROTO3\\",
} as const;

const SyntaxFromInt = function (i: number): Syntax {
  switch (i) {
    case 0: {
      return \\"SYNTAX_PROTO2\\";
    }
    case 1: {
      return \\"SYNTAX_PROTO3\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as Syntax;
    }
  }
};

const SyntaxToInt = function (i: Syntax): number {
  switch (i) {
    case \\"SYNTAX_PROTO2\\": {
      return 0;
    }
    case \\"SYNTAX_PROTO3\\": {
      return 1;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Type = {
  /**
   * Serializes a Type to protobuf.
   */
  encode: function (msg: Partial<Type>): Uint8Array {
    return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Type from protobuf.
   */
  decode: function (bytes: ByteSource): Type {
    return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Type to JSON.
   */
  encodeJSON: function (msg: Partial<Type>): string {
    return JSON.stringify(Type._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Type from JSON.
   */
  decodeJSON: function (json: string): Type {
    return Type._readMessageJSON(Type.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Type with all fields set to their default value.
   */
  initialize: function (): Type {
    return {
      name: \\"\\",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Type>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields as any, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(6, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Type>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.fields?.length) {
      json.fields = msg.fields.map(Field._writeMessageJSON);
    }
    if (msg.oneofs?.length) {
      json.oneofs = msg.oneofs;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Type, reader: BinaryReader): Type {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Type, json: any): Type {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _fields = json.fields;
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        Field._readMessageJSON(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json.oneofs;
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Field = {
  /**
   * Serializes a Field to protobuf.
   */
  encode: function (msg: Partial<Field>): Uint8Array {
    return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Field from protobuf.
   */
  decode: function (bytes: ByteSource): Field {
    return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Field to JSON.
   */
  encodeJSON: function (msg: Partial<Field>): string {
    return JSON.stringify(Field._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Field from JSON.
   */
  decodeJSON: function (json: string): Field {
    return Field._readMessageJSON(Field.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Field with all fields set to their default value.
   */
  initialize: function (): Field {
    return {
      kind: Field.KindFromInt(0),
      cardinality: Field.CardinalityFromInt(0),
      number: 0,
      name: \\"\\",
      typeUrl: \\"\\",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: \\"\\",
      defaultValue: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Field>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.kind && Field.KindToInt(msg.kind)) {
      writer.writeEnum(1, Field.KindToInt(msg.kind));
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      writer.writeEnum(2, Field.CardinalityToInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options as any, Option._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Field>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.kind && Field.KindToInt(msg.kind)) {
      json.kind = msg.kind;
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      json.cardinality = msg.cardinality;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json.oneofIndex = msg.oneofIndex;
    }
    if (msg.packed) {
      json.packed = msg.packed;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.jsonName) {
      json.jsonName = msg.jsonName;
    }
    if (msg.defaultValue) {
      json.defaultValue = msg.defaultValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Field, reader: BinaryReader): Field {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.KindFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.CardinalityFromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Field, json: any): Field {
    const _kind = json.kind;
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json.cardinality;
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json.oneofIndex ?? json.oneof_index;
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json.packed;
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json.jsonName ?? json.json_name;
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json.defaultValue ?? json.default_value;
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: \\"TYPE_UNKNOWN\\",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: \\"TYPE_DOUBLE\\",
    /**
     * Field type float.
     */
    TYPE_FLOAT: \\"TYPE_FLOAT\\",
    /**
     * Field type int64.
     */
    TYPE_INT64: \\"TYPE_INT64\\",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: \\"TYPE_UINT64\\",
    /**
     * Field type int32.
     */
    TYPE_INT32: \\"TYPE_INT32\\",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: \\"TYPE_FIXED64\\",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: \\"TYPE_FIXED32\\",
    /**
     * Field type bool.
     */
    TYPE_BOOL: \\"TYPE_BOOL\\",
    /**
     * Field type string.
     */
    TYPE_STRING: \\"TYPE_STRING\\",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: \\"TYPE_GROUP\\",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: \\"TYPE_MESSAGE\\",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: \\"TYPE_BYTES\\",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: \\"TYPE_UINT32\\",
    /**
     * Field type enum.
     */
    TYPE_ENUM: \\"TYPE_ENUM\\",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: \\"TYPE_SFIXED32\\",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: \\"TYPE_SFIXED64\\",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: \\"TYPE_SINT32\\",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: \\"TYPE_SINT64\\",
  } as const,

  KindFromInt: function (i: number): Field.Kind {
    switch (i) {
      case 0: {
        return \\"TYPE_UNKNOWN\\";
      }
      case 1: {
        return \\"TYPE_DOUBLE\\";
      }
      case 2: {
        return \\"TYPE_FLOAT\\";
      }
      case 3: {
        return \\"TYPE_INT64\\";
      }
      case 4: {
        return \\"TYPE_UINT64\\";
      }
      case 5: {
        return \\"TYPE_INT32\\";
      }
      case 6: {
        return \\"TYPE_FIXED64\\";
      }
      case 7: {
        return \\"TYPE_FIXED32\\";
      }
      case 8: {
        return \\"TYPE_BOOL\\";
      }
      case 9: {
        return \\"TYPE_STRING\\";
      }
      case 10: {
        return \\"TYPE_GROUP\\";
      }
      case 11: {
        return \\"TYPE_MESSAGE\\";
      }
      case 12: {
        return \\"TYPE_BYTES\\";
      }
      case 13: {
        return \\"TYPE_UINT32\\";
      }
      case 14: {
        return \\"TYPE_ENUM\\";
      }
      case 15: {
        return \\"TYPE_SFIXED32\\";
      }
      case 16: {
        return \\"TYPE_SFIXED64\\";
      }
      case 17: {
        return \\"TYPE_SINT32\\";
      }
      case 18: {
        return \\"TYPE_SINT64\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Field.Kind;
      }
    }
  },

  KindToInt: function (i: Field.Kind): number {
    switch (i) {
      case \\"TYPE_UNKNOWN\\": {
        return 0;
      }
      case \\"TYPE_DOUBLE\\": {
        return 1;
      }
      case \\"TYPE_FLOAT\\": {
        return 2;
      }
      case \\"TYPE_INT64\\": {
        return 3;
      }
      case \\"TYPE_UINT64\\": {
        return 4;
      }
      case \\"TYPE_INT32\\": {
        return 5;
      }
      case \\"TYPE_FIXED64\\": {
        return 6;
      }
      case \\"TYPE_FIXED32\\": {
        return 7;
      }
      case \\"TYPE_BOOL\\": {
        return 8;
      }
      case \\"TYPE_STRING\\": {
        return 9;
      }
      case \\"TYPE_GROUP\\": {
        return 10;
      }
      case \\"TYPE_MESSAGE\\": {
        return 11;
      }
      case \\"TYPE_BYTES\\": {
        return 12;
      }
      case \\"TYPE_UINT32\\": {
        return 13;
      }
      case \\"TYPE_ENUM\\": {
        return 14;
      }
      case \\"TYPE_SFIXED32\\": {
        return 15;
      }
      case \\"TYPE_SFIXED64\\": {
        return 16;
      }
      case \\"TYPE_SINT32\\": {
        return 17;
      }
      case \\"TYPE_SINT64\\": {
        return 18;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: \\"CARDINALITY_UNKNOWN\\",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: \\"CARDINALITY_OPTIONAL\\",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: \\"CARDINALITY_REQUIRED\\",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: \\"CARDINALITY_REPEATED\\",
  } as const,

  CardinalityFromInt: function (i: number): Field.Cardinality {
    switch (i) {
      case 0: {
        return \\"CARDINALITY_UNKNOWN\\";
      }
      case 1: {
        return \\"CARDINALITY_OPTIONAL\\";
      }
      case 2: {
        return \\"CARDINALITY_REQUIRED\\";
      }
      case 3: {
        return \\"CARDINALITY_REPEATED\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Field.Cardinality;
      }
    }
  },

  CardinalityToInt: function (i: Field.Cardinality): number {
    switch (i) {
      case \\"CARDINALITY_UNKNOWN\\": {
        return 0;
      }
      case \\"CARDINALITY_OPTIONAL\\": {
        return 1;
      }
      case \\"CARDINALITY_REQUIRED\\": {
        return 2;
      }
      case \\"CARDINALITY_REPEATED\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};

export const Enum = {
  /**
   * Serializes a Enum to protobuf.
   */
  encode: function (msg: Partial<Enum>): Uint8Array {
    return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Enum from protobuf.
   */
  decode: function (bytes: ByteSource): Enum {
    return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Enum to JSON.
   */
  encodeJSON: function (msg: Partial<Enum>): string {
    return JSON.stringify(Enum._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Enum from JSON.
   */
  decodeJSON: function (json: string): Enum {
    return Enum._readMessageJSON(Enum.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Enum with all fields set to their default value.
   */
  initialize: function (): Enum {
    return {
      name: \\"\\",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Enum>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.enumvalue as any,
        EnumValue._writeMessage
      );
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(5, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Enum>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.enumvalue?.length) {
      json.enumvalue = msg.enumvalue.map(EnumValue._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Enum, reader: BinaryReader): Enum {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Enum, json: any): Enum {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json.enumvalue;
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValue._readMessageJSON(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const EnumValue = {
  /**
   * Serializes a EnumValue to protobuf.
   */
  encode: function (msg: Partial<EnumValue>): Uint8Array {
    return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a EnumValue from protobuf.
   */
  decode: function (bytes: ByteSource): EnumValue {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a EnumValue to JSON.
   */
  encodeJSON: function (msg: Partial<EnumValue>): string {
    return JSON.stringify(EnumValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a EnumValue from JSON.
   */
  decodeJSON: function (json: string): EnumValue {
    return EnumValue._readMessageJSON(EnumValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a EnumValue with all fields set to their default value.
   */
  initialize: function (): EnumValue {
    return {
      name: \\"\\",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<EnumValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<EnumValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EnumValue, reader: BinaryReader): EnumValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: EnumValue, json: any): EnumValue {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  },
};

export const Option = {
  /**
   * Serializes a Option to protobuf.
   */
  encode: function (msg: Partial<Option>): Uint8Array {
    return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Option from protobuf.
   */
  decode: function (bytes: ByteSource): Option {
    return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Option to JSON.
   */
  encodeJSON: function (msg: Partial<Option>): string {
    return JSON.stringify(Option._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Option from JSON.
   */
  decodeJSON: function (json: string): Option {
    return Option._readMessageJSON(Option.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Option with all fields set to their default value.
   */
  initialize: function (): Option {
    return {
      name: \\"\\",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Option>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Option>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.value) {
      const value = Any._writeMessageJSON(msg.value);
      if (Object.keys(value).length > 0) {
        json.value = value;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Option, reader: BinaryReader): Option {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Option, json: any): Option {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _value = json.value;
    if (_value) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _value);
      msg.value = m;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/api.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Option, Syntax } from \\"./type.pb\\";
import { SourceContext } from \\"./source_context.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Api is a light-weight descriptor for an API Interface.
 *
 * Interfaces are also described as \\"protocol buffer services\\" in some contexts,
 * such as by the \\"service\\" keyword in a .proto file, but they are different
 * from API Services, which represent a concrete implementation of an interface
 * as opposed to simply a description of methods and bindings. They are also
 * sometimes simply referred to as \\"APIs\\" in other contexts, such as the name of
 * this message itself. See https://cloud.google.com/apis/design/glossary for
 * detailed terminology.
 */
export interface Api {
  /**
   * The fully qualified name of this interface, including package name
   * followed by the interface's simple name.
   */
  name: string;
  /**
   * The methods of this interface, in unspecified order.
   */
  methods: Method[];
  /**
   * Any metadata attached to the interface.
   */
  options: Option[];
  /**
   * A version string for this interface. If specified, must have the form
   * \`major-version.minor-version\`, as in \`1.10\`. If the minor version is
   * omitted, it defaults to zero. If the entire version field is empty, the
   * major version is derived from the package name, as outlined below. If the
   * field is not empty, the version in the package name will be verified to be
   * consistent with what is provided here.
   *
   * The versioning schema uses [semantic
   * versioning](http://semver.org) where the major version number
   * indicates a breaking change and the minor version an additive,
   * non-breaking change. Both version numbers are signals to users
   * what to expect from different versions, and should be carefully
   * chosen based on the product plan.
   *
   * The major version is also reflected in the package name of the
   * interface, which must end in \`v<major-version>\`, as in
   * \`google.feature.v1\`. For major versions 0 and 1, the suffix can
   * be omitted. Zero major versions must only be used for
   * experimental, non-GA interfaces.
   *
   *
   */
  version: string;
  /**
   * Source context for the protocol buffer service represented by this
   * message.
   */
  sourceContext: SourceContext;
  /**
   * Included interfaces. See [Mixin][].
   */
  mixins: Mixin[];
  /**
   * The source syntax of the service.
   */
  syntax: Syntax;
}

/**
 * Method represents a method of an API interface.
 */
export interface Method {
  /**
   * The simple name of this method.
   */
  name: string;
  /**
   * A URL of the input message type.
   */
  requestTypeUrl: string;
  /**
   * If true, the request is streamed.
   */
  requestStreaming: boolean;
  /**
   * The URL of the output message type.
   */
  responseTypeUrl: string;
  /**
   * If true, the response is streamed.
   */
  responseStreaming: boolean;
  /**
   * Any metadata attached to the method.
   */
  options: Option[];
  /**
   * The source syntax of this method.
   */
  syntax: Syntax;
}

/**
 * Declares an API Interface to be included in this interface. The including
 * interface must redeclare all the methods from the included interface, but
 * documentation and options are inherited as follows:
 *
 * - If after comment and whitespace stripping, the documentation
 *   string of the redeclared method is empty, it will be inherited
 *   from the original method.
 *
 * - Each annotation belonging to the service config (http,
 *   visibility) which is not set in the redeclared method will be
 *   inherited.
 *
 * - If an http annotation is inherited, the path pattern will be
 *   modified as follows. Any version prefix will be replaced by the
 *   version of the including interface plus the [root][] path if
 *   specified.
 *
 * Example of a simple mixin:
 *
 *     package google.acl.v1;
 *     service AccessControl {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v1/{resource=**}:getAcl\\";
 *       }
 *     }
 *
 *     package google.storage.v2;
 *     service Storage {
 *       rpc GetAcl(GetAclRequest) returns (Acl);
 *
 *       // Get a data record.
 *       rpc GetData(GetDataRequest) returns (Data) {
 *         option (google.api.http).get = \\"/v2/{resource=**}\\";
 *       }
 *     }
 *
 * Example of a mixin configuration:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *
 * The mixin construct implies that all methods in \`AccessControl\` are
 * also declared with same name and request/response types in
 * \`Storage\`. A documentation generator or annotation processor will
 * see the effective \`Storage.GetAcl\` method after inheriting
 * documentation and annotations as follows:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v2/{resource=**}:getAcl\\";
 *       }
 *       ...
 *     }
 *
 * Note how the version in the path pattern changed from \`v1\` to \`v2\`.
 *
 * If the \`root\` field in the mixin is specified, it should be a
 * relative path under which inherited HTTP paths are placed. Example:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *         root: acls
 *
 * This implies the following inherited HTTP annotation:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v2/acls/{resource=**}:getAcl\\";
 *       }
 *       ...
 *     }
 */
export interface Mixin {
  /**
   * The fully qualified name of the interface which is included.
   */
  name: string;
  /**
   * If non-empty specifies a path under which inherited HTTP paths
   * are rooted.
   */
  root: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Api = {
  /**
   * Serializes a Api to protobuf.
   */
  encode: function (msg: Partial<Api>): Uint8Array {
    return Api._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Api from protobuf.
   */
  decode: function (bytes: ByteSource): Api {
    return Api._readMessage(Api.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Api to JSON.
   */
  encodeJSON: function (msg: Partial<Api>): string {
    return JSON.stringify(Api._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Api from JSON.
   */
  decodeJSON: function (json: string): Api {
    return Api._readMessageJSON(Api.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Api with all fields set to their default value.
   */
  initialize: function (): Api {
    return {
      name: \\"\\",
      methods: [],
      options: [],
      version: \\"\\",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Api>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods as any, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins as any, Mixin._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Api>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.methods?.length) {
      json.methods = msg.methods.map(Method._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.version) {
      json.version = msg.version;
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.mixins?.length) {
      json.mixins = msg.mixins.map(Mixin._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Api, reader: BinaryReader): Api {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Api, json: any): Api {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _methods = json.methods;
    if (_methods) {
      for (const item of _methods) {
        const m = Method.initialize();
        Method._readMessageJSON(m, item);
        msg.methods.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _mixins = json.mixins;
    if (_mixins) {
      for (const item of _mixins) {
        const m = Mixin.initialize();
        Mixin._readMessageJSON(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Method = {
  /**
   * Serializes a Method to protobuf.
   */
  encode: function (msg: Partial<Method>): Uint8Array {
    return Method._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Method from protobuf.
   */
  decode: function (bytes: ByteSource): Method {
    return Method._readMessage(Method.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Method to JSON.
   */
  encodeJSON: function (msg: Partial<Method>): string {
    return JSON.stringify(Method._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Method from JSON.
   */
  decodeJSON: function (json: string): Method {
    return Method._readMessageJSON(Method.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Method with all fields set to their default value.
   */
  initialize: function (): Method {
    return {
      name: \\"\\",
      requestTypeUrl: \\"\\",
      requestStreaming: false,
      responseTypeUrl: \\"\\",
      responseStreaming: false,
      options: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Method>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(6, msg.options as any, Option._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Method>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.requestTypeUrl) {
      json.requestTypeUrl = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json.requestStreaming = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json.responseTypeUrl = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json.responseStreaming = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Method, reader: BinaryReader): Method {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Method, json: any): Method {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _requestTypeUrl = json.requestTypeUrl ?? json.request_type_url;
    if (_requestTypeUrl) {
      msg.requestTypeUrl = _requestTypeUrl;
    }
    const _requestStreaming = json.requestStreaming ?? json.request_streaming;
    if (_requestStreaming) {
      msg.requestStreaming = _requestStreaming;
    }
    const _responseTypeUrl = json.responseTypeUrl ?? json.response_type_url;
    if (_responseTypeUrl) {
      msg.responseTypeUrl = _responseTypeUrl;
    }
    const _responseStreaming =
      json.responseStreaming ?? json.response_streaming;
    if (_responseStreaming) {
      msg.responseStreaming = _responseStreaming;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Mixin = {
  /**
   * Serializes a Mixin to protobuf.
   */
  encode: function (msg: Partial<Mixin>): Uint8Array {
    return Mixin._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Mixin from protobuf.
   */
  decode: function (bytes: ByteSource): Mixin {
    return Mixin._readMessage(Mixin.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Mixin to JSON.
   */
  encodeJSON: function (msg: Partial<Mixin>): string {
    return JSON.stringify(Mixin._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Mixin from JSON.
   */
  decodeJSON: function (json: string): Mixin {
    return Mixin._readMessageJSON(Mixin.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Mixin with all fields set to their default value.
   */
  initialize: function (): Mixin {
    return {
      name: \\"\\",
      root: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Mixin>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Mixin>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.root) {
      json.root = msg.root;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Mixin, reader: BinaryReader): Mixin {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Mixin, json: any): Mixin {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _root = json.root;
    if (_root) {
      msg.root = _root;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/duration.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/duration.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like \\"day\\"
 * or \\"month\\". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix \\"s\\" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as \\"3s\\", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as \\"3.000000001s\\", and 3 seconds and 1
 * microsecond should be expressed in JSON format as \\"3.000001s\\".
 *
 *
 */
export interface Duration {
  /**
   * Signed seconds of the span of time. Must be from -315,576,000,000
   * to +315,576,000,000 inclusive. Note: these bounds are computed from:
   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   */
  seconds: bigint;
  /**
   * Signed fractions of a second at nanosecond resolution of the span
   * of time. Durations less than one second are represented with a 0
   * \`seconds\` field and a positive or negative \`nanos\` field. For durations
   * of one second or more, a non-zero value for the \`nanos\` field must be
   * of the same sign as the \`seconds\` field. Must be from -999,999,999
   * to +999,999,999 inclusive.
   */
  nanos: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Duration = {
  /**
   * Serializes a Duration to protobuf.
   */
  encode: function (msg: Partial<Duration>): Uint8Array {
    return Duration._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Duration from protobuf.
   */
  decode: function (bytes: ByteSource): Duration {
    return Duration._readMessage(
      Duration.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Duration to JSON.
   */
  encodeJSON: function (msg: Partial<Duration>): string {
    return JSON.stringify(Duration._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Duration from JSON.
   */
  decodeJSON: function (json: string): Duration {
    return Duration._readMessageJSON(Duration.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Duration with all fields set to their default value.
   */
  initialize: function (): Duration {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Duration>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Duration>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Duration, reader: BinaryReader): Duration {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Duration, json: any): Duration {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */
  encode: function (_msg?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */
  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */
  encodeJSON: function (_msg?: Partial<Empty>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */
  decodeJSON: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },
};
",
      ],
      Array [
        "google/protobuf/field_mask.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/field_mask.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`FieldMask\` represents a set of symbolic field paths, for example:
 *
 *     paths: \\"f.a\\"
 *     paths: \\"f.b.d\\"
 *
 * Here \`f\` represents a field in some root message, \`a\` and \`b\`
 * fields in the message found in \`f\`, and \`d\` a field found in the
 * message in \`f.b\`.
 *
 * Field masks are used to specify a subset of fields that should be
 * returned by a get operation or modified by an update operation.
 * Field masks also have a custom JSON encoding (see below).
 *
 * # Field Masks in Projections
 *
 * When used in the context of a projection, a response message or
 * sub-message is filtered by the API to only contain those fields as
 * specified in the mask. For example, if the mask in the previous
 * example is applied to a response message as follows:
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *         x : 2
 *       }
 *       y : 13
 *     }
 *     z: 8
 *
 * The result will not contain specific values for fields x,y and z
 * (their value will be set to the default, and omitted in proto text
 * output):
 *
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *       }
 *     }
 *
 * A repeated field is not allowed except at the last position of a
 * paths string.
 *
 * If a FieldMask object is not present in a get operation, the
 * operation applies to all fields (as if a FieldMask of all fields
 * had been specified).
 *
 * Note that a field mask does not necessarily apply to the
 * top-level response message. In case of a REST get operation, the
 * field mask applies directly to the response, but in case of a REST
 * list operation, the mask instead applies to each individual message
 * in the returned resource list. In case of a REST custom method,
 * other definitions may be used. Where the mask applies will be
 * clearly documented together with its declaration in the API.  In
 * any case, the effect on the returned resource/resources is required
 * behavior for APIs.
 *
 * # Field Masks in Update Operations
 *
 * A field mask in update operations specifies which fields of the
 * targeted resource are going to be updated. The API is required
 * to only change the values of the fields as specified in the mask
 * and leave the others untouched. If a resource is passed in to
 * describe the updated values, the API ignores the values of all
 * fields not covered by the mask.
 *
 * If a repeated field is specified for an update operation, new values will
 * be appended to the existing repeated field in the target resource. Note that
 * a repeated field is only allowed in the last position of a \`paths\` string.
 *
 * If a sub-message is specified in the last position of the field mask for an
 * update operation, then new value will be merged into the existing sub-message
 * in the target resource.
 *
 * For example, given the target message:
 *
 *     f {
 *       b {
 *         d: 1
 *         x: 2
 *       }
 *       c: [1]
 *     }
 *
 * And an update message:
 *
 *     f {
 *       b {
 *         d: 10
 *       }
 *       c: [2]
 *     }
 *
 * then if the field mask is:
 *
 *  paths: [\\"f.b\\", \\"f.c\\"]
 *
 * then the result will be:
 *
 *     f {
 *       b {
 *         d: 10
 *         x: 2
 *       }
 *       c: [1, 2]
 *     }
 *
 * An implementation may provide options to override this default behavior for
 * repeated and message fields.
 *
 * In order to reset a field's value to the default, the field must
 * be in the mask and set to the default value in the provided resource.
 * Hence, in order to reset all fields of a resource, provide a default
 * instance of the resource and set all fields in the mask, or do
 * not provide a mask as described below.
 *
 * If a field mask is not present on update, the operation applies to
 * all fields (as if a field mask of all fields has been specified).
 * Note that in the presence of schema evolution, this may mean that
 * fields the client does not know and has therefore not filled into
 * the request will be reset to their default. If this is unwanted
 * behavior, a specific service may require a client to always specify
 * a field mask, producing an error if not.
 *
 * As with get operations, the location of the resource which
 * describes the updated values in the request message depends on the
 * operation kind. In any case, the effect of the field mask is
 * required to be honored by the API.
 *
 * ## Considerations for HTTP REST
 *
 * The HTTP kind of an update operation which uses a field mask must
 * be set to PATCH instead of PUT in order to satisfy HTTP semantics
 * (PUT must only be used for full updates).
 *
 * # JSON Encoding of Field Masks
 *
 * In JSON, a field mask is encoded as a single string where paths are
 * separated by a comma. Fields name in each path are converted
 * to/from lower-camel naming conventions.
 *
 * As an example, consider the following message declarations:
 *
 *     message Profile {
 *       User user = 1;
 *       Photo photo = 2;
 *     }
 *     message User {
 *       string display_name = 1;
 *       string address = 2;
 *     }
 *
 * In proto a field mask for \`Profile\` may look as such:
 *
 *     mask {
 *       paths: \\"user.display_name\\"
 *       paths: \\"photo\\"
 *     }
 *
 * In JSON, the same mask is represented as below:
 *
 *     {
 *       mask: \\"user.displayName,photo\\"
 *     }
 *
 * # Field Masks and Oneof Fields
 *
 * Field masks treat fields in oneofs just as regular fields. Consider the
 * following message:
 *
 *     message SampleMessage {
 *       oneof test_oneof {
 *         string name = 4;
 *         SubMessage sub_message = 9;
 *       }
 *     }
 *
 * The field mask can be:
 *
 *     mask {
 *       paths: \\"name\\"
 *     }
 *
 * Or:
 *
 *     mask {
 *       paths: \\"sub_message\\"
 *     }
 *
 * Note that oneof type names (\\"test_oneof\\" in this case) cannot be used in
 * paths.
 *
 * ## Field Mask Verification
 *
 * The implementation of any API method which has a FieldMask type field in the
 * request should verify the included field paths, and return an
 * \`INVALID_ARGUMENT\` error if any path is unmappable.
 */
export interface FieldMask {
  /**
   * The set of field mask paths.
   */
  paths: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const FieldMask = {
  /**
   * Serializes a FieldMask to protobuf.
   */
  encode: function (msg: Partial<FieldMask>): Uint8Array {
    return FieldMask._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FieldMask from protobuf.
   */
  decode: function (bytes: ByteSource): FieldMask {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FieldMask to JSON.
   */
  encodeJSON: function (msg: Partial<FieldMask>): string {
    return JSON.stringify(FieldMask._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FieldMask from JSON.
   */
  decodeJSON: function (json: string): FieldMask {
    return FieldMask._readMessageJSON(FieldMask.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a FieldMask with all fields set to their default value.
   */
  initialize: function (): FieldMask {
    return {
      paths: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FieldMask>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FieldMask>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.paths?.length) {
      json.paths = msg.paths;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FieldMask, reader: BinaryReader): FieldMask {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FieldMask, json: any): FieldMask {
    const _paths = json.paths;
    if (_paths) {
      msg.paths = _paths;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/struct.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`NullValue\` is a singleton enumeration to represent the null value for the
 * \`Value\` type union.
 *
 *  The JSON representation for \`NullValue\` is JSON \`null\`.
 */
export type NullValue = \\"NULL_VALUE\\";

/**
 * \`Struct\` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, \`Struct\`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for \`Struct\` is JSON object.
 */
export interface Struct {
  /**
   * Unordered map of dynamically typed values.
   */
  fields: Struct.Fields;
}

declare namespace Struct {
  export type Fields = Record<string, Value | undefined>;
}

/**
 * \`Value\` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of these
 * variants. Absence of any variant indicates an error.
 *
 * The JSON representation for \`Value\` is JSON value.
 */
export interface Value {
  /**
   * Represents a null value.
   */
  nullValue?: NullValue | null | undefined;
  /**
   * Represents a double value.
   */
  numberValue?: number | null | undefined;
  /**
   * Represents a string value.
   */
  stringValue?: string | null | undefined;
  /**
   * Represents a boolean value.
   */
  boolValue?: boolean | null | undefined;
  /**
   * Represents a structured value.
   */
  structValue?: Struct | null | undefined;
  /**
   * Represents a repeated \`Value\`.
   */
  listValue?: ListValue | null | undefined;
}

/**
 * \`ListValue\` is a wrapper around a repeated field of values.
 *
 * The JSON representation for \`ListValue\` is JSON array.
 */
export interface ListValue {
  /**
   * Repeated field of dynamically typed values.
   */
  values: Value[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: \\"NULL_VALUE\\",
} as const;

const NullValueFromInt = function (i: number): NullValue {
  switch (i) {
    case 0: {
      return \\"NULL_VALUE\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as NullValue;
    }
  }
};

const NullValueToInt = function (i: NullValue): number {
  switch (i) {
    case \\"NULL_VALUE\\": {
      return 0;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Struct = {
  /**
   * Serializes a Struct to protobuf.
   */
  encode: function (msg: Partial<Struct>): Uint8Array {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Struct from protobuf.
   */
  decode: function (bytes: ByteSource): Struct {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Struct to JSON.
   */
  encodeJSON: function (msg: Partial<Struct>): string {
    return JSON.stringify(Struct._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Struct from JSON.
   */
  decodeJSON: function (json: string): Struct {
    return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Struct with all fields set to their default value.
   */
  initialize: function (): Struct {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Struct>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.fields).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Struct>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries<any>(msg.fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Struct, reader: BinaryReader): Struct {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const fields = {} as MapMessage<Struct.Fields>;
          reader.readMessage(fields, Struct.Fields._readMessage);
          msg.fields[fields.key] = fields.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Struct, json: any): Struct {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries<any>(_fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Struct.Fields>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Struct.Fields>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Struct.Fields>,
      reader: BinaryReader
    ): MapMessage<Struct.Fields> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Struct.Fields>,
      json: any
    ): MapMessage<Struct.Fields> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes a Value to protobuf.
   */
  encode: function (msg: Partial<Value>): Uint8Array {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Value from protobuf.
   */
  decode: function (bytes: ByteSource): Value {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Value to JSON.
   */
  encodeJSON: function (msg: Partial<Value>): string {
    return JSON.stringify(Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Value from JSON.
   */
  decodeJSON: function (json: string): Value {
    return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Value with all fields set to their default value.
   */
  initialize: function (): Value {
    return {
      structValue: Struct.initialize(),
      listValue: ListValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValueToInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Value>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = Struct._writeMessageJSON(msg.structValue);
      if (Object.keys(structValue).length > 0) {
        json.structValue = structValue;
      }
    }
    if (msg.listValue != undefined) {
      const listValue = ListValue._writeMessageJSON(msg.listValue);
      if (Object.keys(listValue).length > 0) {
        json.listValue = listValue;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Value, reader: BinaryReader): Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValueFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Value, json: any): Value {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValue._readMessageJSON(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes a ListValue to protobuf.
   */
  encode: function (msg: Partial<ListValue>): Uint8Array {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a ListValue from protobuf.
   */
  decode: function (bytes: ByteSource): ListValue {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ListValue to JSON.
   */
  encodeJSON: function (msg: Partial<ListValue>): string {
    return JSON.stringify(ListValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ListValue from JSON.
   */
  decodeJSON: function (json: string): ListValue {
    return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a ListValue with all fields set to their default value.
   */
  initialize: function (): ListValue {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values as any, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ListValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.values?.length) {
      json.values = msg.values.map(Value._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListValue, reader: BinaryReader): ListValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ListValue, json: any): ListValue {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        Value._readMessageJSON(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/timestamp.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/timestamp.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A Timestamp represents a point in time independent of any time zone or local
 * calendar, encoded as a count of seconds and fractions of seconds at
 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
 * January 1, 1970, in the proleptic Gregorian calendar which extends the
 * Gregorian calendar backwards to year one.
 *
 * All minutes are 60 seconds long. Leap seconds are \\"smeared\\" so that no leap
 * second table is needed for interpretation, using a [24-hour linear
 * smear](https://developers.google.com/time/smear).
 *
 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 * restricting to that range, we ensure that we can convert to and from [RFC
 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
 *
 * # Examples
 *
 * Example 1: Compute Timestamp from POSIX \`time()\`.
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(time(NULL));
 *     timestamp.set_nanos(0);
 *
 * Example 2: Compute Timestamp from POSIX \`gettimeofday()\`.
 *
 *     struct timeval tv;
 *     gettimeofday(&tv, NULL);
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(tv.tv_sec);
 *     timestamp.set_nanos(tv.tv_usec * 1000);
 *
 * Example 3: Compute Timestamp from Win32 \`GetSystemTimeAsFileTime()\`.
 *
 *     FILETIME ft;
 *     GetSystemTimeAsFileTime(&ft);
 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 *
 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
 *     Timestamp timestamp;
 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
 *
 * Example 4: Compute Timestamp from Java \`System.currentTimeMillis()\`.
 *
 *     long millis = System.currentTimeMillis();
 *
 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
 *
 *
 * Example 5: Compute Timestamp from Java \`Instant.now()\`.
 *
 *     Instant now = Instant.now();
 *
 *     Timestamp timestamp =
 *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
 *             .setNanos(now.getNano()).build();
 *
 *
 * Example 6: Compute Timestamp from current time in Python.
 *
 *     timestamp = Timestamp()
 *     timestamp.GetCurrentTime()
 *
 * # JSON Mapping
 *
 * In JSON format, the Timestamp type is encoded as a string in the
 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 * format is \\"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\\"
 * where {year} is always expressed using four digits while {month}, {day},
 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 * are optional. The \\"Z\\" suffix indicates the timezone (\\"UTC\\"); the timezone
 * is required. A proto3 JSON serializer should always use UTC (as indicated by
 * \\"Z\\") when printing the Timestamp type and a proto3 JSON parser should be
 * able to accept both UTC and other timezones (as indicated by an offset).
 *
 * For example, \\"2017-01-15T01:30:15.01Z\\" encodes 15.01 seconds past
 * 01:30 UTC on January 15, 2017.
 *
 * In JavaScript, one can convert a Date object to this format using the
 * standard
 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 * method. In Python, a standard \`datetime.datetime\` object can be converted
 * to this format using
 * [\`strftime\`](https://docs.python.org/2/library/time.html#time.strftime) with
 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 * the Joda Time's [\`ISODateTimeFormat.dateTime()\`](
 * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
 * ) to obtain a formatter capable of generating timestamps in this format.
 *
 *
 */
export interface Timestamp {
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds: bigint;
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive.
   */
  nanos: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Timestamp = {
  /**
   * Serializes a Timestamp to protobuf.
   */
  encode: function (msg: Partial<Timestamp>): Uint8Array {
    return Timestamp._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Timestamp from protobuf.
   */
  decode: function (bytes: ByteSource): Timestamp {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Timestamp to JSON.
   */
  encodeJSON: function (msg: Partial<Timestamp>): string {
    return JSON.stringify(Timestamp._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Timestamp from JSON.
   */
  decodeJSON: function (json: string): Timestamp {
    return Timestamp._readMessageJSON(Timestamp.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Timestamp with all fields set to their default value.
   */
  initialize: function (): Timestamp {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Timestamp>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Timestamp>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Timestamp, reader: BinaryReader): Timestamp {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Timestamp, json: any): Timestamp {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/wrappers.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/wrappers.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Wrapper message for \`double\`.
 *
 * The JSON representation for \`DoubleValue\` is JSON number.
 */
export interface DoubleValue {
  /**
   * The double value.
   */
  value: number;
}

/**
 * Wrapper message for \`float\`.
 *
 * The JSON representation for \`FloatValue\` is JSON number.
 */
export interface FloatValue {
  /**
   * The float value.
   */
  value: number;
}

/**
 * Wrapper message for \`int64\`.
 *
 * The JSON representation for \`Int64Value\` is JSON string.
 */
export interface Int64Value {
  /**
   * The int64 value.
   */
  value: bigint;
}

/**
 * Wrapper message for \`uint64\`.
 *
 * The JSON representation for \`UInt64Value\` is JSON string.
 */
export interface UInt64Value {
  /**
   * The uint64 value.
   */
  value: bigint;
}

/**
 * Wrapper message for \`int32\`.
 *
 * The JSON representation for \`Int32Value\` is JSON number.
 */
export interface Int32Value {
  /**
   * The int32 value.
   */
  value: number;
}

/**
 * Wrapper message for \`uint32\`.
 *
 * The JSON representation for \`UInt32Value\` is JSON number.
 */
export interface UInt32Value {
  /**
   * The uint32 value.
   */
  value: number;
}

/**
 * Wrapper message for \`bool\`.
 *
 * The JSON representation for \`BoolValue\` is JSON \`true\` and \`false\`.
 */
export interface BoolValue {
  /**
   * The bool value.
   */
  value: boolean;
}

/**
 * Wrapper message for \`string\`.
 *
 * The JSON representation for \`StringValue\` is JSON string.
 */
export interface StringValue {
  /**
   * The string value.
   */
  value: string;
}

/**
 * Wrapper message for \`bytes\`.
 *
 * The JSON representation for \`BytesValue\` is JSON string.
 */
export interface BytesValue {
  /**
   * The bytes value.
   */
  value: Uint8Array;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const DoubleValue = {
  /**
   * Serializes a DoubleValue to protobuf.
   */
  encode: function (msg: Partial<DoubleValue>): Uint8Array {
    return DoubleValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a DoubleValue from protobuf.
   */
  decode: function (bytes: ByteSource): DoubleValue {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a DoubleValue to JSON.
   */
  encodeJSON: function (msg: Partial<DoubleValue>): string {
    return JSON.stringify(DoubleValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a DoubleValue from JSON.
   */
  decodeJSON: function (json: string): DoubleValue {
    return DoubleValue._readMessageJSON(
      DoubleValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a DoubleValue with all fields set to their default value.
   */
  initialize: function (): DoubleValue {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<DoubleValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<DoubleValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: DoubleValue, reader: BinaryReader): DoubleValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: DoubleValue, json: any): DoubleValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const FloatValue = {
  /**
   * Serializes a FloatValue to protobuf.
   */
  encode: function (msg: Partial<FloatValue>): Uint8Array {
    return FloatValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FloatValue from protobuf.
   */
  decode: function (bytes: ByteSource): FloatValue {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FloatValue to JSON.
   */
  encodeJSON: function (msg: Partial<FloatValue>): string {
    return JSON.stringify(FloatValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FloatValue from JSON.
   */
  decodeJSON: function (json: string): FloatValue {
    return FloatValue._readMessageJSON(
      FloatValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FloatValue with all fields set to their default value.
   */
  initialize: function (): FloatValue {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FloatValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FloatValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FloatValue, reader: BinaryReader): FloatValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FloatValue, json: any): FloatValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const Int64Value = {
  /**
   * Serializes a Int64Value to protobuf.
   */
  encode: function (msg: Partial<Int64Value>): Uint8Array {
    return Int64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int64Value from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Value {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Value to JSON.
   */
  encodeJSON: function (msg: Partial<Int64Value>): string {
    return JSON.stringify(Int64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Value from JSON.
   */
  decodeJSON: function (json: string): Int64Value {
    return Int64Value._readMessageJSON(
      Int64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Value with all fields set to their default value.
   */
  initialize: function (): Int64Value {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int64Value, reader: BinaryReader): Int64Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Value, json: any): Int64Value {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const UInt64Value = {
  /**
   * Serializes a UInt64Value to protobuf.
   */
  encode: function (msg: Partial<UInt64Value>): Uint8Array {
    return UInt64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt64Value from protobuf.
   */
  decode: function (bytes: ByteSource): UInt64Value {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt64Value to JSON.
   */
  encodeJSON: function (msg: Partial<UInt64Value>): string {
    return JSON.stringify(UInt64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt64Value from JSON.
   */
  decodeJSON: function (json: string): UInt64Value {
    return UInt64Value._readMessageJSON(
      UInt64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt64Value with all fields set to their default value.
   */
  initialize: function (): UInt64Value {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UInt64Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UInt64Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: UInt64Value, reader: BinaryReader): UInt64Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UInt64Value, json: any): UInt64Value {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const Int32Value = {
  /**
   * Serializes a Int32Value to protobuf.
   */
  encode: function (msg: Partial<Int32Value>): Uint8Array {
    return Int32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int32Value from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Value {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Value to JSON.
   */
  encodeJSON: function (msg: Partial<Int32Value>): string {
    return JSON.stringify(Int32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Value from JSON.
   */
  decodeJSON: function (json: string): Int32Value {
    return Int32Value._readMessageJSON(
      Int32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Value with all fields set to their default value.
   */
  initialize: function (): Int32Value {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int32Value, reader: BinaryReader): Int32Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Value, json: any): Int32Value {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const UInt32Value = {
  /**
   * Serializes a UInt32Value to protobuf.
   */
  encode: function (msg: Partial<UInt32Value>): Uint8Array {
    return UInt32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt32Value from protobuf.
   */
  decode: function (bytes: ByteSource): UInt32Value {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt32Value to JSON.
   */
  encodeJSON: function (msg: Partial<UInt32Value>): string {
    return JSON.stringify(UInt32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt32Value from JSON.
   */
  decodeJSON: function (json: string): UInt32Value {
    return UInt32Value._readMessageJSON(
      UInt32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt32Value with all fields set to their default value.
   */
  initialize: function (): UInt32Value {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UInt32Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UInt32Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: UInt32Value, reader: BinaryReader): UInt32Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UInt32Value, json: any): UInt32Value {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BoolValue = {
  /**
   * Serializes a BoolValue to protobuf.
   */
  encode: function (msg: Partial<BoolValue>): Uint8Array {
    return BoolValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolValue from protobuf.
   */
  decode: function (bytes: ByteSource): BoolValue {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolValue to JSON.
   */
  encodeJSON: function (msg: Partial<BoolValue>): string {
    return JSON.stringify(BoolValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolValue from JSON.
   */
  decodeJSON: function (json: string): BoolValue {
    return BoolValue._readMessageJSON(BoolValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a BoolValue with all fields set to their default value.
   */
  initialize: function (): BoolValue {
    return {
      value: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolValue, reader: BinaryReader): BoolValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolValue, json: any): BoolValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const StringValue = {
  /**
   * Serializes a StringValue to protobuf.
   */
  encode: function (msg: Partial<StringValue>): Uint8Array {
    return StringValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a StringValue from protobuf.
   */
  decode: function (bytes: ByteSource): StringValue {
    return StringValue._readMessage(
      StringValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a StringValue to JSON.
   */
  encodeJSON: function (msg: Partial<StringValue>): string {
    return JSON.stringify(StringValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a StringValue from JSON.
   */
  decodeJSON: function (json: string): StringValue {
    return StringValue._readMessageJSON(
      StringValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a StringValue with all fields set to their default value.
   */
  initialize: function (): StringValue {
    return {
      value: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<StringValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<StringValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: StringValue, reader: BinaryReader): StringValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: StringValue, json: any): StringValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BytesValue = {
  /**
   * Serializes a BytesValue to protobuf.
   */
  encode: function (msg: Partial<BytesValue>): Uint8Array {
    return BytesValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BytesValue from protobuf.
   */
  decode: function (bytes: ByteSource): BytesValue {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BytesValue to JSON.
   */
  encodeJSON: function (msg: Partial<BytesValue>): string {
    return JSON.stringify(BytesValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BytesValue from JSON.
   */
  decodeJSON: function (json: string): BytesValue {
    return BytesValue._readMessageJSON(
      BytesValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BytesValue with all fields set to their default value.
   */
  initialize: function (): BytesValue {
    return {
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BytesValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BytesValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BytesValue, reader: BinaryReader): BytesValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BytesValue, json: any): BytesValue {
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_well_known_types.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Any } from \\"./any.pb\\";
import { Api } from \\"./api.pb\\";
import { Duration } from \\"./duration.pb\\";
import { Empty } from \\"./empty.pb\\";
import { FieldMask } from \\"./field_mask.pb\\";
import { SourceContext } from \\"./source_context.pb\\";
import { Struct, Value } from \\"./struct.pb\\";
import { Timestamp } from \\"./timestamp.pb\\";
import { Type } from \\"./type.pb\\";
import {
  DoubleValue,
  FloatValue,
  Int64Value,
  UInt64Value,
  Int32Value,
  UInt32Value,
  BoolValue,
  StringValue,
  BytesValue,
} from \\"./wrappers.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Test that we can include all well-known types.
 * Each wrapper type is included separately, as languages
 * map handle different wrappers in different ways.
 */
export interface TestWellKnownTypes {
  anyField: Any;
  apiField: Api;
  durationField: Duration;
  emptyField: Empty;
  fieldMaskField: FieldMask;
  sourceContextField: SourceContext;
  structField: Struct;
  timestampField: Timestamp;
  typeField: Type;
  doubleField: DoubleValue;
  floatField: FloatValue;
  int64Field: Int64Value;
  uint64Field: UInt64Value;
  int32Field: Int32Value;
  uint32Field: UInt32Value;
  boolField: BoolValue;
  stringField: StringValue;
  bytesField: BytesValue;
  /**
   * Part of struct, but useful to be able to test separately
   */
  valueField: Value;
}

/**
 * A repeated field for each well-known type.
 */
export interface RepeatedWellKnownTypes {
  anyField: Any[];
  apiField: Api[];
  durationField: Duration[];
  emptyField: Empty[];
  fieldMaskField: FieldMask[];
  sourceContextField: SourceContext[];
  structField: Struct[];
  timestampField: Timestamp[];
  typeField: Type[];
  /**
   * These don't actually make a lot of sense, but they're not prohibited...
   */
  doubleField: DoubleValue[];
  floatField: FloatValue[];
  int64Field: Int64Value[];
  uint64Field: UInt64Value[];
  int32Field: Int32Value[];
  uint32Field: UInt32Value[];
  boolField: BoolValue[];
  stringField: StringValue[];
  bytesField: BytesValue[];
}

export interface OneofWellKnownTypes {
  anyField?: Any | null | undefined;
  apiField?: Api | null | undefined;
  durationField?: Duration | null | undefined;
  emptyField?: Empty | null | undefined;
  fieldMaskField?: FieldMask | null | undefined;
  sourceContextField?: SourceContext | null | undefined;
  structField?: Struct | null | undefined;
  timestampField?: Timestamp | null | undefined;
  typeField?: Type | null | undefined;
  doubleField?: DoubleValue | null | undefined;
  floatField?: FloatValue | null | undefined;
  int64Field?: Int64Value | null | undefined;
  uint64Field?: UInt64Value | null | undefined;
  int32Field?: Int32Value | null | undefined;
  uint32Field?: UInt32Value | null | undefined;
  boolField?: BoolValue | null | undefined;
  stringField?: StringValue | null | undefined;
  bytesField?: BytesValue | null | undefined;
}

/**
 * A map field for each well-known type. We only
 * need to worry about the value part of the map being the
 * well-known types, as messages can't be map keys.
 */
export interface MapWellKnownTypes {
  anyField: MapWellKnownTypes.AnyField;
  apiField: MapWellKnownTypes.ApiField;
  durationField: MapWellKnownTypes.DurationField;
  emptyField: MapWellKnownTypes.EmptyField;
  fieldMaskField: MapWellKnownTypes.FieldMaskField;
  sourceContextField: MapWellKnownTypes.SourceContextField;
  structField: MapWellKnownTypes.StructField;
  timestampField: MapWellKnownTypes.TimestampField;
  typeField: MapWellKnownTypes.TypeField;
  doubleField: MapWellKnownTypes.DoubleField;
  floatField: MapWellKnownTypes.FloatField;
  int64Field: MapWellKnownTypes.Int64Field;
  uint64Field: MapWellKnownTypes.Uint64Field;
  int32Field: MapWellKnownTypes.Int32Field;
  uint32Field: MapWellKnownTypes.Uint32Field;
  boolField: MapWellKnownTypes.BoolField;
  stringField: MapWellKnownTypes.StringField;
  bytesField: MapWellKnownTypes.BytesField;
}

declare namespace MapWellKnownTypes {
  export type AnyField = Record<number, Any | undefined>;

  export type ApiField = Record<number, Api | undefined>;

  export type DurationField = Record<number, Duration | undefined>;

  export type EmptyField = Record<number, Empty | undefined>;

  export type FieldMaskField = Record<number, FieldMask | undefined>;

  export type SourceContextField = Record<number, SourceContext | undefined>;

  export type StructField = Record<number, Struct | undefined>;

  export type TimestampField = Record<number, Timestamp | undefined>;

  export type TypeField = Record<number, Type | undefined>;

  export type DoubleField = Record<number, DoubleValue | undefined>;

  export type FloatField = Record<number, FloatValue | undefined>;

  export type Int64Field = Record<number, Int64Value | undefined>;

  export type Uint64Field = Record<number, UInt64Value | undefined>;

  export type Int32Field = Record<number, Int32Value | undefined>;

  export type Uint32Field = Record<number, UInt32Value | undefined>;

  export type BoolField = Record<number, BoolValue | undefined>;

  export type StringField = Record<number, StringValue | undefined>;

  export type BytesField = Record<number, BytesValue | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes a TestWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): Uint8Array {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestWellKnownTypes {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestWellKnownTypes>): string {
    return JSON.stringify(TestWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): TestWellKnownTypes {
    return TestWellKnownTypes._readMessageJSON(
      TestWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
      valueField: Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    if (msg.valueField) {
      const valueField = Value._writeMessageJSON(msg.valueField);
      if (Object.keys(valueField).length > 0) {
        json.valueField = valueField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    reader: BinaryReader
  ): TestWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestWellKnownTypes,
    json: any
  ): TestWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    const _valueField = json.valueField ?? json.value_field;
    if (_valueField) {
      const m = Value.initialize();
      Value._readMessageJSON(m, _valueField);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes a RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): Uint8Array {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<RepeatedWellKnownTypes>): string {
    return JSON.stringify(RepeatedWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessageJSON(
      RepeatedWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(1, msg.anyField as any, Any._writeMessage);
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(2, msg.apiField as any, Api._writeMessage);
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField as any,
        Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField as any,
        Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField as any,
        FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField as any,
        SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField as any,
        Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField as any,
        Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(9, msg.typeField as any, Type._writeMessage);
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField as any,
        DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField as any,
        FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field as any,
        Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field as any,
        UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field as any,
        Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field as any,
        UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField as any,
        BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField as any,
        StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField as any,
        BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField?.length) {
      json.anyField = msg.anyField.map(Any._writeMessageJSON);
    }
    if (msg.apiField?.length) {
      json.apiField = msg.apiField.map(Api._writeMessageJSON);
    }
    if (msg.durationField?.length) {
      json.durationField = msg.durationField.map(Duration._writeMessageJSON);
    }
    if (msg.emptyField?.length) {
      json.emptyField = msg.emptyField.map(Empty._writeMessageJSON);
    }
    if (msg.fieldMaskField?.length) {
      json.fieldMaskField = msg.fieldMaskField.map(FieldMask._writeMessageJSON);
    }
    if (msg.sourceContextField?.length) {
      json.sourceContextField = msg.sourceContextField.map(
        SourceContext._writeMessageJSON
      );
    }
    if (msg.structField?.length) {
      json.structField = msg.structField.map(Struct._writeMessageJSON);
    }
    if (msg.timestampField?.length) {
      json.timestampField = msg.timestampField.map(Timestamp._writeMessageJSON);
    }
    if (msg.typeField?.length) {
      json.typeField = msg.typeField.map(Type._writeMessageJSON);
    }
    if (msg.doubleField?.length) {
      json.doubleField = msg.doubleField.map(DoubleValue._writeMessageJSON);
    }
    if (msg.floatField?.length) {
      json.floatField = msg.floatField.map(FloatValue._writeMessageJSON);
    }
    if (msg.int64Field?.length) {
      json.int64Field = msg.int64Field.map(Int64Value._writeMessageJSON);
    }
    if (msg.uint64Field?.length) {
      json.uint64Field = msg.uint64Field.map(UInt64Value._writeMessageJSON);
    }
    if (msg.int32Field?.length) {
      json.int32Field = msg.int32Field.map(Int32Value._writeMessageJSON);
    }
    if (msg.uint32Field?.length) {
      json.uint32Field = msg.uint32Field.map(UInt32Value._writeMessageJSON);
    }
    if (msg.boolField?.length) {
      json.boolField = msg.boolField.map(BoolValue._writeMessageJSON);
    }
    if (msg.stringField?.length) {
      json.stringField = msg.stringField.map(StringValue._writeMessageJSON);
    }
    if (msg.bytesField?.length) {
      json.bytesField = msg.bytesField.map(BytesValue._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    reader: BinaryReader
  ): RepeatedWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Any.initialize();
          reader.readMessage(m, Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = Api.initialize();
          reader.readMessage(m, Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = Duration.initialize();
          reader.readMessage(m, Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = Empty.initialize();
          reader.readMessage(m, Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = FieldMask.initialize();
          reader.readMessage(m, FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = SourceContext.initialize();
          reader.readMessage(m, SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = Struct.initialize();
          reader.readMessage(m, Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = Timestamp.initialize();
          reader.readMessage(m, Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = Type.initialize();
          reader.readMessage(m, Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = DoubleValue.initialize();
          reader.readMessage(m, DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = FloatValue.initialize();
          reader.readMessage(m, FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = Int64Value.initialize();
          reader.readMessage(m, Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = UInt64Value.initialize();
          reader.readMessage(m, UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = Int32Value.initialize();
          reader.readMessage(m, Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = UInt32Value.initialize();
          reader.readMessage(m, UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = BoolValue.initialize();
          reader.readMessage(m, BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = StringValue.initialize();
          reader.readMessage(m, StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = BytesValue.initialize();
          reader.readMessage(m, BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedWellKnownTypes,
    json: any
  ): RepeatedWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      for (const item of _anyField) {
        const m = Any.initialize();
        Any._readMessageJSON(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      for (const item of _apiField) {
        const m = Api.initialize();
        Api._readMessageJSON(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      for (const item of _durationField) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      for (const item of _emptyField) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      for (const item of _fieldMaskField) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      for (const item of _sourceContextField) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      for (const item of _structField) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      for (const item of _timestampField) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      for (const item of _typeField) {
        const m = Type.initialize();
        Type._readMessageJSON(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      for (const item of _doubleField) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      for (const item of _floatField) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      for (const item of _int64Field) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      for (const item of _uint64Field) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      for (const item of _int32Field) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      for (const item of _uint32Field) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      for (const item of _boolField) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      for (const item of _stringField) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      for (const item of _bytesField) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes a OneofWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): Uint8Array {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneofWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<OneofWellKnownTypes>): string {
    return JSON.stringify(OneofWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneofWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessageJSON(
      OneofWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneofWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField != undefined) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField != undefined) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField != undefined) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField != undefined) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField != undefined) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField != undefined) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField != undefined) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField != undefined) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField != undefined) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField != undefined) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField != undefined) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field != undefined) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field != undefined) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field != undefined) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field != undefined) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField != undefined) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField != undefined) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField != undefined) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    reader: BinaryReader
  ): OneofWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OneofWellKnownTypes,
    json: any
  ): OneofWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes a MapWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): Uint8Array {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MapWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): MapWellKnownTypes {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MapWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<MapWellKnownTypes>): string {
    return JSON.stringify(MapWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MapWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): MapWellKnownTypes {
    return MapWellKnownTypes._readMessageJSON(
      MapWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries<any>(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MapWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const anyField = Object.fromEntries(
        Object.entries<any>(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Object.fromEntries(
        Object.entries<any>(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Object.fromEntries(
        Object.entries<any>(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Object.fromEntries(
        Object.entries<any>(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = Object.fromEntries(
        Object.entries<any>(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = Object.fromEntries(
        Object.entries<any>(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Object.fromEntries(
        Object.entries<any>(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Object.fromEntries(
        Object.entries<any>(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Object.fromEntries(
        Object.entries<any>(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = Object.fromEntries(
        Object.entries<any>(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = Object.fromEntries(
        Object.entries<any>(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Object.fromEntries(
        Object.entries<any>(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = Object.fromEntries(
        Object.entries<any>(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Object.fromEntries(
        Object.entries<any>(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = Object.fromEntries(
        Object.entries<any>(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = Object.fromEntries(
        Object.entries<any>(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = Object.fromEntries(
        Object.entries<any>(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = Object.fromEntries(
        Object.entries<any>(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    reader: BinaryReader
  ): MapWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const anyField = {} as MapMessage<MapWellKnownTypes.AnyField>;
          reader.readMessage(anyField, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[anyField.key] = anyField.value;
          break;
        }
        case 2: {
          const apiField = {} as MapMessage<MapWellKnownTypes.ApiField>;
          reader.readMessage(apiField, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[apiField.key] = apiField.value;
          break;
        }
        case 3: {
          const durationField =
            {} as MapMessage<MapWellKnownTypes.DurationField>;
          reader.readMessage(
            durationField,
            MapWellKnownTypes.DurationField._readMessage
          );
          msg.durationField[durationField.key] = durationField.value;
          break;
        }
        case 4: {
          const emptyField = {} as MapMessage<MapWellKnownTypes.EmptyField>;
          reader.readMessage(
            emptyField,
            MapWellKnownTypes.EmptyField._readMessage
          );
          msg.emptyField[emptyField.key] = emptyField.value;
          break;
        }
        case 5: {
          const fieldMaskField =
            {} as MapMessage<MapWellKnownTypes.FieldMaskField>;
          reader.readMessage(
            fieldMaskField,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[fieldMaskField.key] = fieldMaskField.value;
          break;
        }
        case 6: {
          const sourceContextField =
            {} as MapMessage<MapWellKnownTypes.SourceContextField>;
          reader.readMessage(
            sourceContextField,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[sourceContextField.key] =
            sourceContextField.value;
          break;
        }
        case 7: {
          const structField = {} as MapMessage<MapWellKnownTypes.StructField>;
          reader.readMessage(
            structField,
            MapWellKnownTypes.StructField._readMessage
          );
          msg.structField[structField.key] = structField.value;
          break;
        }
        case 8: {
          const timestampField =
            {} as MapMessage<MapWellKnownTypes.TimestampField>;
          reader.readMessage(
            timestampField,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[timestampField.key] = timestampField.value;
          break;
        }
        case 9: {
          const typeField = {} as MapMessage<MapWellKnownTypes.TypeField>;
          reader.readMessage(
            typeField,
            MapWellKnownTypes.TypeField._readMessage
          );
          msg.typeField[typeField.key] = typeField.value;
          break;
        }
        case 10: {
          const doubleField = {} as MapMessage<MapWellKnownTypes.DoubleField>;
          reader.readMessage(
            doubleField,
            MapWellKnownTypes.DoubleField._readMessage
          );
          msg.doubleField[doubleField.key] = doubleField.value;
          break;
        }
        case 11: {
          const floatField = {} as MapMessage<MapWellKnownTypes.FloatField>;
          reader.readMessage(
            floatField,
            MapWellKnownTypes.FloatField._readMessage
          );
          msg.floatField[floatField.key] = floatField.value;
          break;
        }
        case 12: {
          const int64Field = {} as MapMessage<MapWellKnownTypes.Int64Field>;
          reader.readMessage(
            int64Field,
            MapWellKnownTypes.Int64Field._readMessage
          );
          msg.int64Field[int64Field.key] = int64Field.value;
          break;
        }
        case 13: {
          const uint64Field = {} as MapMessage<MapWellKnownTypes.Uint64Field>;
          reader.readMessage(
            uint64Field,
            MapWellKnownTypes.Uint64Field._readMessage
          );
          msg.uint64Field[uint64Field.key] = uint64Field.value;
          break;
        }
        case 14: {
          const int32Field = {} as MapMessage<MapWellKnownTypes.Int32Field>;
          reader.readMessage(
            int32Field,
            MapWellKnownTypes.Int32Field._readMessage
          );
          msg.int32Field[int32Field.key] = int32Field.value;
          break;
        }
        case 15: {
          const uint32Field = {} as MapMessage<MapWellKnownTypes.Uint32Field>;
          reader.readMessage(
            uint32Field,
            MapWellKnownTypes.Uint32Field._readMessage
          );
          msg.uint32Field[uint32Field.key] = uint32Field.value;
          break;
        }
        case 16: {
          const boolField = {} as MapMessage<MapWellKnownTypes.BoolField>;
          reader.readMessage(
            boolField,
            MapWellKnownTypes.BoolField._readMessage
          );
          msg.boolField[boolField.key] = boolField.value;
          break;
        }
        case 17: {
          const stringField = {} as MapMessage<MapWellKnownTypes.StringField>;
          reader.readMessage(
            stringField,
            MapWellKnownTypes.StringField._readMessage
          );
          msg.stringField[stringField.key] = stringField.value;
          break;
        }
        case 18: {
          const bytesField = {} as MapMessage<MapWellKnownTypes.BytesField>;
          reader.readMessage(
            bytesField,
            MapWellKnownTypes.BytesField._readMessage
          );
          msg.bytesField[bytesField.key] = bytesField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MapWellKnownTypes,
    json: any
  ): MapWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      msg.anyField = Object.fromEntries(
        Object.entries<any>(_anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      msg.apiField = Object.fromEntries(
        Object.entries<any>(_apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      msg.durationField = Object.fromEntries(
        Object.entries<any>(_durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      msg.emptyField = Object.fromEntries(
        Object.entries<any>(_emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries<any>(_fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries<any>(_sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      msg.structField = Object.fromEntries(
        Object.entries<any>(_structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      msg.timestampField = Object.fromEntries(
        Object.entries<any>(_timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      msg.typeField = Object.fromEntries(
        Object.entries<any>(_typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      msg.doubleField = Object.fromEntries(
        Object.entries<any>(_doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      msg.floatField = Object.fromEntries(
        Object.entries<any>(_floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      msg.int64Field = Object.fromEntries(
        Object.entries<any>(_int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      msg.uint64Field = Object.fromEntries(
        Object.entries<any>(_uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      msg.int32Field = Object.fromEntries(
        Object.entries<any>(_int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      msg.uint32Field = Object.fromEntries(
        Object.entries<any>(_uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      msg.boolField = Object.fromEntries(
        Object.entries<any>(_boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      msg.stringField = Object.fromEntries(
        Object.entries<any>(_stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      msg.bytesField = Object.fromEntries(
        Object.entries<any>(_bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Any._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.AnyField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Any.initialize(), Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      json: any
    ): MapMessage<MapWellKnownTypes.AnyField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Any.initialize();
        Any._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Api._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.ApiField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Api.initialize(), Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      json: any
    ): MapMessage<MapWellKnownTypes.ApiField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Api.initialize();
        Api._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Duration._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.DurationField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Duration.initialize(), Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      json: any
    ): MapMessage<MapWellKnownTypes.DurationField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Empty._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.EmptyField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Empty.initialize(), Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      json: any
    ): MapMessage<MapWellKnownTypes.EmptyField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FieldMask._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.FieldMaskField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(FieldMask.initialize(), FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      json: any
    ): MapMessage<MapWellKnownTypes.FieldMaskField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, SourceContext._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = SourceContext._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.SourceContextField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              SourceContext.initialize(),
              SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      json: any
    ): MapMessage<MapWellKnownTypes.SourceContextField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StructField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Struct._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.StructField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Struct.initialize(), Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      json: any
    ): MapMessage<MapWellKnownTypes.StructField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Timestamp._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.TimestampField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Timestamp.initialize(), Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      json: any
    ): MapMessage<MapWellKnownTypes.TimestampField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Type._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.TypeField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Type.initialize(), Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      json: any
    ): MapMessage<MapWellKnownTypes.TypeField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Type.initialize();
        Type._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, DoubleValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = DoubleValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.DoubleField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              DoubleValue.initialize(),
              DoubleValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      json: any
    ): MapMessage<MapWellKnownTypes.DoubleField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FloatValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.FloatField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              FloatValue.initialize(),
              FloatValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      json: any
    ): MapMessage<MapWellKnownTypes.FloatField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Int64Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int64Value.initialize(),
              Int64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Int64Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Uint64Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt64Value.initialize(),
              UInt64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Uint64Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Int32Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int32Value.initialize(),
              Int32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Int32Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Uint32Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt32Value.initialize(),
              UInt32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Uint32Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BoolValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.BoolField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(BoolValue.initialize(), BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      json: any
    ): MapMessage<MapWellKnownTypes.BoolField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StringField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = StringValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.StringField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              StringValue.initialize(),
              StringValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      json: any
    ): MapMessage<MapWellKnownTypes.StringField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BytesValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.BytesField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              BytesValue.initialize(),
              BytesValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      json: any
    ): MapMessage<MapWellKnownTypes.BytesField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum =
  | \\"FOREIGN_ZERO\\"
  | \\"FOREIGN_FOO\\"
  | \\"FOREIGN_BAR\\"
  | \\"FOREIGN_BAZ\\";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestAllTypes {
  export type NestedEnum = \\"ZERO\\" | \\"FOO\\" | \\"BAR\\" | \\"BAZ\\" | \\"NEG\\";

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
}

declare namespace TestOneof2 {
  export type NestedEnum = \\"UNKNOWN\\" | \\"FOO\\" | \\"BAR\\" | \\"BAZ\\";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: \\"FOREIGN_ZERO\\",
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
} as const;

const ForeignEnumFromInt = function (i: number): ForeignEnum {
  switch (i) {
    case 0: {
      return \\"FOREIGN_ZERO\\";
    }
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ForeignEnum;
    }
  }
};

const ForeignEnumToInt = function (i: ForeignEnum): number {
  switch (i) {
    case \\"FOREIGN_ZERO\\": {
      return 0;
    }
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (_optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: \\"ZERO\\",
    FOO: \\"FOO\\",
    BAR: \\"BAR\\",
    BAZ: \\"BAZ\\",
    NEG: \\"NEG\\",
  } as const,

  NestedEnumFromInt: function (i: number): TestAllTypes.NestedEnum {
    switch (i) {
      case 0: {
        return \\"ZERO\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestAllTypes.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestAllTypes.NestedEnum): number {
    switch (i) {
      case \\"ZERO\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (msg: Partial<TestMessageWithDummy>): string {
    return JSON.stringify(TestMessageWithDummy._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: \\"UNKNOWN\\",
    FOO: \\"FOO\\",
    BAR: \\"BAR\\",
    BAZ: \\"BAZ\\",
  } as const,

  NestedEnumFromInt: function (i: number): TestOneof2.NestedEnum {
    switch (i) {
      case 0: {
        return \\"UNKNOWN\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestOneof2.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestOneof2.NestedEnum): number {
    switch (i) {
      case \\"UNKNOWN\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};
",
      ],
      Array [
        "empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { MapMessage, ClientConfiguration } from \\"twirpscript\\";
import {
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//                  Foo                   //
//========================================//

export interface Foo<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFoo<Context>(service: Foo<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (msg: Partial<PublicImportMessage>): Uint8Array {
    return PublicImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (msg: Partial<PublicImportMessage>): string {
    return JSON.stringify(PublicImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json: string): PublicImportMessage {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const _e = json.e;
    if (_e) {
      msg.e = _e;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = \\"IMPORT_FOO\\" | \\"IMPORT_BAR\\" | \\"IMPORT_BAZ\\";

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap = \\"UNKNOWN\\" | \\"FOO\\" | \\"BAR\\";

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: \\"IMPORT_FOO\\",
  IMPORT_BAR: \\"IMPORT_BAR\\",
  IMPORT_BAZ: \\"IMPORT_BAZ\\",
} as const;

const ImportEnumFromInt = function (i: number): ImportEnum {
  switch (i) {
    case 7: {
      return \\"IMPORT_FOO\\";
    }
    case 8: {
      return \\"IMPORT_BAR\\";
    }
    case 9: {
      return \\"IMPORT_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ImportEnum;
    }
  }
};

const ImportEnumToInt = function (i: ImportEnum): number {
  switch (i) {
    case \\"IMPORT_FOO\\": {
      return 7;
    }
    case \\"IMPORT_BAR\\": {
      return 8;
    }
    case \\"IMPORT_BAZ\\": {
      return 9;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const ImportEnumForMap = {
  UNKNOWN: \\"UNKNOWN\\",
  FOO: \\"FOO\\",
  BAR: \\"BAR\\",
} as const;

const ImportEnumForMapFromInt = function (i: number): ImportEnumForMap {
  switch (i) {
    case 0: {
      return \\"UNKNOWN\\";
    }
    case 1: {
      return \\"FOO\\";
    }
    case 2: {
      return \\"BAR\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ImportEnumForMap;
    }
  }
};

const ImportEnumForMapToInt = function (i: ImportEnumForMap): number {
  switch (i) {
    case \\"UNKNOWN\\": {
      return 0;
    }
    case \\"FOO\\": {
      return 1;
    }
    case \\"BAR\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (msg: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json: string): ImportMessage {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ImportMessage, json: any): ImportMessage {
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, MapMessage, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//              TestService               //
//========================================//

export interface TestService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestService<Context>(service: TestService<Context>) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = \\"FOREIGN_FOO\\" | \\"FOREIGN_BAR\\" | \\"FOREIGN_BAZ\\";

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue = \\"FOO1\\" | \\"BAR1\\" | \\"BAZ\\" | \\"FOO2\\" | \\"BAR2\\";

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum =
  | \\"SPARSE_A\\"
  | \\"SPARSE_B\\"
  | \\"SPARSE_C\\"
  | \\"SPARSE_D\\"
  | \\"SPARSE_E\\"
  | \\"SPARSE_F\\"
  | \\"SPARSE_G\\";

export type VeryLargeEnum =
  | \\"ENUM_LABEL_DEFAULT\\"
  | \\"ENUM_LABEL_1\\"
  | \\"ENUM_LABEL_2\\"
  | \\"ENUM_LABEL_3\\"
  | \\"ENUM_LABEL_4\\"
  | \\"ENUM_LABEL_5\\"
  | \\"ENUM_LABEL_6\\"
  | \\"ENUM_LABEL_7\\"
  | \\"ENUM_LABEL_8\\"
  | \\"ENUM_LABEL_9\\"
  | \\"ENUM_LABEL_10\\"
  | \\"ENUM_LABEL_11\\"
  | \\"ENUM_LABEL_12\\"
  | \\"ENUM_LABEL_13\\"
  | \\"ENUM_LABEL_14\\"
  | \\"ENUM_LABEL_15\\"
  | \\"ENUM_LABEL_16\\"
  | \\"ENUM_LABEL_17\\"
  | \\"ENUM_LABEL_18\\"
  | \\"ENUM_LABEL_19\\"
  | \\"ENUM_LABEL_20\\"
  | \\"ENUM_LABEL_21\\"
  | \\"ENUM_LABEL_22\\"
  | \\"ENUM_LABEL_23\\"
  | \\"ENUM_LABEL_24\\"
  | \\"ENUM_LABEL_25\\"
  | \\"ENUM_LABEL_26\\"
  | \\"ENUM_LABEL_27\\"
  | \\"ENUM_LABEL_28\\"
  | \\"ENUM_LABEL_29\\"
  | \\"ENUM_LABEL_30\\"
  | \\"ENUM_LABEL_31\\"
  | \\"ENUM_LABEL_32\\"
  | \\"ENUM_LABEL_33\\"
  | \\"ENUM_LABEL_34\\"
  | \\"ENUM_LABEL_35\\"
  | \\"ENUM_LABEL_36\\"
  | \\"ENUM_LABEL_37\\"
  | \\"ENUM_LABEL_38\\"
  | \\"ENUM_LABEL_39\\"
  | \\"ENUM_LABEL_40\\"
  | \\"ENUM_LABEL_41\\"
  | \\"ENUM_LABEL_42\\"
  | \\"ENUM_LABEL_43\\"
  | \\"ENUM_LABEL_44\\"
  | \\"ENUM_LABEL_45\\"
  | \\"ENUM_LABEL_46\\"
  | \\"ENUM_LABEL_47\\"
  | \\"ENUM_LABEL_48\\"
  | \\"ENUM_LABEL_49\\"
  | \\"ENUM_LABEL_50\\"
  | \\"ENUM_LABEL_51\\"
  | \\"ENUM_LABEL_52\\"
  | \\"ENUM_LABEL_53\\"
  | \\"ENUM_LABEL_54\\"
  | \\"ENUM_LABEL_55\\"
  | \\"ENUM_LABEL_56\\"
  | \\"ENUM_LABEL_57\\"
  | \\"ENUM_LABEL_58\\"
  | \\"ENUM_LABEL_59\\"
  | \\"ENUM_LABEL_60\\"
  | \\"ENUM_LABEL_61\\"
  | \\"ENUM_LABEL_62\\"
  | \\"ENUM_LABEL_63\\"
  | \\"ENUM_LABEL_64\\"
  | \\"ENUM_LABEL_65\\"
  | \\"ENUM_LABEL_66\\"
  | \\"ENUM_LABEL_67\\"
  | \\"ENUM_LABEL_68\\"
  | \\"ENUM_LABEL_69\\"
  | \\"ENUM_LABEL_70\\"
  | \\"ENUM_LABEL_71\\"
  | \\"ENUM_LABEL_72\\"
  | \\"ENUM_LABEL_73\\"
  | \\"ENUM_LABEL_74\\"
  | \\"ENUM_LABEL_75\\"
  | \\"ENUM_LABEL_76\\"
  | \\"ENUM_LABEL_77\\"
  | \\"ENUM_LABEL_78\\"
  | \\"ENUM_LABEL_79\\"
  | \\"ENUM_LABEL_80\\"
  | \\"ENUM_LABEL_81\\"
  | \\"ENUM_LABEL_82\\"
  | \\"ENUM_LABEL_83\\"
  | \\"ENUM_LABEL_84\\"
  | \\"ENUM_LABEL_85\\"
  | \\"ENUM_LABEL_86\\"
  | \\"ENUM_LABEL_87\\"
  | \\"ENUM_LABEL_88\\"
  | \\"ENUM_LABEL_89\\"
  | \\"ENUM_LABEL_90\\"
  | \\"ENUM_LABEL_91\\"
  | \\"ENUM_LABEL_92\\"
  | \\"ENUM_LABEL_93\\"
  | \\"ENUM_LABEL_94\\"
  | \\"ENUM_LABEL_95\\"
  | \\"ENUM_LABEL_96\\"
  | \\"ENUM_LABEL_97\\"
  | \\"ENUM_LABEL_98\\"
  | \\"ENUM_LABEL_99\\"
  | \\"ENUM_LABEL_100\\";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestAllTypes {
  export type NestedEnum = \\"FOO\\" | \\"BAR\\" | \\"BAZ\\" | \\"NEG\\";

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number | null | undefined;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

declare namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

declare namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

declare namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

declare namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

declare namespace TestIsInitialized {
  export interface SubMessage {}

  namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

declare namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

declare namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

declare namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

declare namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestAllTypes | null | undefined;
}

declare namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

declare namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooCord?: string | null | undefined;
  fooStringPiece?: string | null | undefined;
  fooBytes?: Uint8Array | null | undefined;
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
  fooMessage?: TestOneof2.NestedMessage | null | undefined;
  fooLazyMessage?: TestOneof2.NestedMessage | null | undefined;
  barInt?: number | null | undefined;
  barString?: string | null | undefined;
  barCord?: string | null | undefined;
  barStringPiece?: string | null | undefined;
  barBytes?: Uint8Array | null | undefined;
  barEnum?: TestOneof2.NestedEnum | null | undefined;
  barStringWithEmptyDefault?: string | null | undefined;
  barCordWithEmptyDefault?: string | null | undefined;
  barStringPieceWithEmptyDefault?: string | null | undefined;
  barBytesWithEmptyDefault?: Uint8Array | null | undefined;
  bazInt: number;
  bazString: string;
}

declare namespace TestOneof2 {
  export type NestedEnum = \\"FOO\\" | \\"BAR\\" | \\"BAZ\\";

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestRequiredOneof.NestedMessage | null | undefined;
}

declare namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

declare namespace TestDynamicExtensions {
  export type DynamicEnumType = \\"DYNAMIC_FOO\\" | \\"DYNAMIC_BAR\\" | \\"DYNAMIC_BAZ\\";

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

declare namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: TestHugeFieldNumbers.StringStringMap;
  oneofUint32?: number | null | undefined;
  oneofTestAllTypes?: TestAllTypes | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }

  export type StringStringMap = Record<string, string | undefined>;
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
} as const;

const ForeignEnumFromInt = function (i: number): ForeignEnum {
  switch (i) {
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ForeignEnum;
    }
  }
};

const ForeignEnumToInt = function (i: ForeignEnum): number {
  switch (i) {
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestEnumWithDupValue = {
  FOO1: \\"FOO1\\",
  BAR1: \\"BAR1\\",
  BAZ: \\"BAZ\\",
  FOO2: \\"FOO2\\",
  BAR2: \\"BAR2\\",
} as const;

const TestEnumWithDupValueFromInt = function (i: number): TestEnumWithDupValue {
  switch (i) {
    case 1: {
      return \\"FOO1\\";
    }
    case 2: {
      return \\"BAR1\\";
    }
    case 3: {
      return \\"BAZ\\";
    }
    case 1: {
      return \\"FOO2\\";
    }
    case 2: {
      return \\"BAR2\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as TestEnumWithDupValue;
    }
  }
};

const TestEnumWithDupValueToInt = function (i: TestEnumWithDupValue): number {
  switch (i) {
    case \\"FOO1\\": {
      return 1;
    }
    case \\"BAR1\\": {
      return 2;
    }
    case \\"BAZ\\": {
      return 3;
    }
    case \\"FOO2\\": {
      return 1;
    }
    case \\"BAR2\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestSparseEnum = {
  SPARSE_A: \\"SPARSE_A\\",
  SPARSE_B: \\"SPARSE_B\\",
  SPARSE_C: \\"SPARSE_C\\",
  SPARSE_D: \\"SPARSE_D\\",
  SPARSE_E: \\"SPARSE_E\\",
  SPARSE_F: \\"SPARSE_F\\",
  SPARSE_G: \\"SPARSE_G\\",
} as const;

const TestSparseEnumFromInt = function (i: number): TestSparseEnum {
  switch (i) {
    case 123: {
      return \\"SPARSE_A\\";
    }
    case 62374: {
      return \\"SPARSE_B\\";
    }
    case 12589234: {
      return \\"SPARSE_C\\";
    }
    case -15: {
      return \\"SPARSE_D\\";
    }
    case -53452: {
      return \\"SPARSE_E\\";
    }
    case 0: {
      return \\"SPARSE_F\\";
    }
    case 2: {
      return \\"SPARSE_G\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as TestSparseEnum;
    }
  }
};

const TestSparseEnumToInt = function (i: TestSparseEnum): number {
  switch (i) {
    case \\"SPARSE_A\\": {
      return 123;
    }
    case \\"SPARSE_B\\": {
      return 62374;
    }
    case \\"SPARSE_C\\": {
      return 12589234;
    }
    case \\"SPARSE_D\\": {
      return -15;
    }
    case \\"SPARSE_E\\": {
      return -53452;
    }
    case \\"SPARSE_F\\": {
      return 0;
    }
    case \\"SPARSE_G\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: \\"ENUM_LABEL_DEFAULT\\",
  ENUM_LABEL_1: \\"ENUM_LABEL_1\\",
  ENUM_LABEL_2: \\"ENUM_LABEL_2\\",
  ENUM_LABEL_3: \\"ENUM_LABEL_3\\",
  ENUM_LABEL_4: \\"ENUM_LABEL_4\\",
  ENUM_LABEL_5: \\"ENUM_LABEL_5\\",
  ENUM_LABEL_6: \\"ENUM_LABEL_6\\",
  ENUM_LABEL_7: \\"ENUM_LABEL_7\\",
  ENUM_LABEL_8: \\"ENUM_LABEL_8\\",
  ENUM_LABEL_9: \\"ENUM_LABEL_9\\",
  ENUM_LABEL_10: \\"ENUM_LABEL_10\\",
  ENUM_LABEL_11: \\"ENUM_LABEL_11\\",
  ENUM_LABEL_12: \\"ENUM_LABEL_12\\",
  ENUM_LABEL_13: \\"ENUM_LABEL_13\\",
  ENUM_LABEL_14: \\"ENUM_LABEL_14\\",
  ENUM_LABEL_15: \\"ENUM_LABEL_15\\",
  ENUM_LABEL_16: \\"ENUM_LABEL_16\\",
  ENUM_LABEL_17: \\"ENUM_LABEL_17\\",
  ENUM_LABEL_18: \\"ENUM_LABEL_18\\",
  ENUM_LABEL_19: \\"ENUM_LABEL_19\\",
  ENUM_LABEL_20: \\"ENUM_LABEL_20\\",
  ENUM_LABEL_21: \\"ENUM_LABEL_21\\",
  ENUM_LABEL_22: \\"ENUM_LABEL_22\\",
  ENUM_LABEL_23: \\"ENUM_LABEL_23\\",
  ENUM_LABEL_24: \\"ENUM_LABEL_24\\",
  ENUM_LABEL_25: \\"ENUM_LABEL_25\\",
  ENUM_LABEL_26: \\"ENUM_LABEL_26\\",
  ENUM_LABEL_27: \\"ENUM_LABEL_27\\",
  ENUM_LABEL_28: \\"ENUM_LABEL_28\\",
  ENUM_LABEL_29: \\"ENUM_LABEL_29\\",
  ENUM_LABEL_30: \\"ENUM_LABEL_30\\",
  ENUM_LABEL_31: \\"ENUM_LABEL_31\\",
  ENUM_LABEL_32: \\"ENUM_LABEL_32\\",
  ENUM_LABEL_33: \\"ENUM_LABEL_33\\",
  ENUM_LABEL_34: \\"ENUM_LABEL_34\\",
  ENUM_LABEL_35: \\"ENUM_LABEL_35\\",
  ENUM_LABEL_36: \\"ENUM_LABEL_36\\",
  ENUM_LABEL_37: \\"ENUM_LABEL_37\\",
  ENUM_LABEL_38: \\"ENUM_LABEL_38\\",
  ENUM_LABEL_39: \\"ENUM_LABEL_39\\",
  ENUM_LABEL_40: \\"ENUM_LABEL_40\\",
  ENUM_LABEL_41: \\"ENUM_LABEL_41\\",
  ENUM_LABEL_42: \\"ENUM_LABEL_42\\",
  ENUM_LABEL_43: \\"ENUM_LABEL_43\\",
  ENUM_LABEL_44: \\"ENUM_LABEL_44\\",
  ENUM_LABEL_45: \\"ENUM_LABEL_45\\",
  ENUM_LABEL_46: \\"ENUM_LABEL_46\\",
  ENUM_LABEL_47: \\"ENUM_LABEL_47\\",
  ENUM_LABEL_48: \\"ENUM_LABEL_48\\",
  ENUM_LABEL_49: \\"ENUM_LABEL_49\\",
  ENUM_LABEL_50: \\"ENUM_LABEL_50\\",
  ENUM_LABEL_51: \\"ENUM_LABEL_51\\",
  ENUM_LABEL_52: \\"ENUM_LABEL_52\\",
  ENUM_LABEL_53: \\"ENUM_LABEL_53\\",
  ENUM_LABEL_54: \\"ENUM_LABEL_54\\",
  ENUM_LABEL_55: \\"ENUM_LABEL_55\\",
  ENUM_LABEL_56: \\"ENUM_LABEL_56\\",
  ENUM_LABEL_57: \\"ENUM_LABEL_57\\",
  ENUM_LABEL_58: \\"ENUM_LABEL_58\\",
  ENUM_LABEL_59: \\"ENUM_LABEL_59\\",
  ENUM_LABEL_60: \\"ENUM_LABEL_60\\",
  ENUM_LABEL_61: \\"ENUM_LABEL_61\\",
  ENUM_LABEL_62: \\"ENUM_LABEL_62\\",
  ENUM_LABEL_63: \\"ENUM_LABEL_63\\",
  ENUM_LABEL_64: \\"ENUM_LABEL_64\\",
  ENUM_LABEL_65: \\"ENUM_LABEL_65\\",
  ENUM_LABEL_66: \\"ENUM_LABEL_66\\",
  ENUM_LABEL_67: \\"ENUM_LABEL_67\\",
  ENUM_LABEL_68: \\"ENUM_LABEL_68\\",
  ENUM_LABEL_69: \\"ENUM_LABEL_69\\",
  ENUM_LABEL_70: \\"ENUM_LABEL_70\\",
  ENUM_LABEL_71: \\"ENUM_LABEL_71\\",
  ENUM_LABEL_72: \\"ENUM_LABEL_72\\",
  ENUM_LABEL_73: \\"ENUM_LABEL_73\\",
  ENUM_LABEL_74: \\"ENUM_LABEL_74\\",
  ENUM_LABEL_75: \\"ENUM_LABEL_75\\",
  ENUM_LABEL_76: \\"ENUM_LABEL_76\\",
  ENUM_LABEL_77: \\"ENUM_LABEL_77\\",
  ENUM_LABEL_78: \\"ENUM_LABEL_78\\",
  ENUM_LABEL_79: \\"ENUM_LABEL_79\\",
  ENUM_LABEL_80: \\"ENUM_LABEL_80\\",
  ENUM_LABEL_81: \\"ENUM_LABEL_81\\",
  ENUM_LABEL_82: \\"ENUM_LABEL_82\\",
  ENUM_LABEL_83: \\"ENUM_LABEL_83\\",
  ENUM_LABEL_84: \\"ENUM_LABEL_84\\",
  ENUM_LABEL_85: \\"ENUM_LABEL_85\\",
  ENUM_LABEL_86: \\"ENUM_LABEL_86\\",
  ENUM_LABEL_87: \\"ENUM_LABEL_87\\",
  ENUM_LABEL_88: \\"ENUM_LABEL_88\\",
  ENUM_LABEL_89: \\"ENUM_LABEL_89\\",
  ENUM_LABEL_90: \\"ENUM_LABEL_90\\",
  ENUM_LABEL_91: \\"ENUM_LABEL_91\\",
  ENUM_LABEL_92: \\"ENUM_LABEL_92\\",
  ENUM_LABEL_93: \\"ENUM_LABEL_93\\",
  ENUM_LABEL_94: \\"ENUM_LABEL_94\\",
  ENUM_LABEL_95: \\"ENUM_LABEL_95\\",
  ENUM_LABEL_96: \\"ENUM_LABEL_96\\",
  ENUM_LABEL_97: \\"ENUM_LABEL_97\\",
  ENUM_LABEL_98: \\"ENUM_LABEL_98\\",
  ENUM_LABEL_99: \\"ENUM_LABEL_99\\",
  ENUM_LABEL_100: \\"ENUM_LABEL_100\\",
} as const;

const VeryLargeEnumFromInt = function (i: number): VeryLargeEnum {
  switch (i) {
    case 0: {
      return \\"ENUM_LABEL_DEFAULT\\";
    }
    case 1: {
      return \\"ENUM_LABEL_1\\";
    }
    case 2: {
      return \\"ENUM_LABEL_2\\";
    }
    case 3: {
      return \\"ENUM_LABEL_3\\";
    }
    case 4: {
      return \\"ENUM_LABEL_4\\";
    }
    case 5: {
      return \\"ENUM_LABEL_5\\";
    }
    case 6: {
      return \\"ENUM_LABEL_6\\";
    }
    case 7: {
      return \\"ENUM_LABEL_7\\";
    }
    case 8: {
      return \\"ENUM_LABEL_8\\";
    }
    case 9: {
      return \\"ENUM_LABEL_9\\";
    }
    case 10: {
      return \\"ENUM_LABEL_10\\";
    }
    case 11: {
      return \\"ENUM_LABEL_11\\";
    }
    case 12: {
      return \\"ENUM_LABEL_12\\";
    }
    case 13: {
      return \\"ENUM_LABEL_13\\";
    }
    case 14: {
      return \\"ENUM_LABEL_14\\";
    }
    case 15: {
      return \\"ENUM_LABEL_15\\";
    }
    case 16: {
      return \\"ENUM_LABEL_16\\";
    }
    case 17: {
      return \\"ENUM_LABEL_17\\";
    }
    case 18: {
      return \\"ENUM_LABEL_18\\";
    }
    case 19: {
      return \\"ENUM_LABEL_19\\";
    }
    case 20: {
      return \\"ENUM_LABEL_20\\";
    }
    case 21: {
      return \\"ENUM_LABEL_21\\";
    }
    case 22: {
      return \\"ENUM_LABEL_22\\";
    }
    case 23: {
      return \\"ENUM_LABEL_23\\";
    }
    case 24: {
      return \\"ENUM_LABEL_24\\";
    }
    case 25: {
      return \\"ENUM_LABEL_25\\";
    }
    case 26: {
      return \\"ENUM_LABEL_26\\";
    }
    case 27: {
      return \\"ENUM_LABEL_27\\";
    }
    case 28: {
      return \\"ENUM_LABEL_28\\";
    }
    case 29: {
      return \\"ENUM_LABEL_29\\";
    }
    case 30: {
      return \\"ENUM_LABEL_30\\";
    }
    case 31: {
      return \\"ENUM_LABEL_31\\";
    }
    case 32: {
      return \\"ENUM_LABEL_32\\";
    }
    case 33: {
      return \\"ENUM_LABEL_33\\";
    }
    case 34: {
      return \\"ENUM_LABEL_34\\";
    }
    case 35: {
      return \\"ENUM_LABEL_35\\";
    }
    case 36: {
      return \\"ENUM_LABEL_36\\";
    }
    case 37: {
      return \\"ENUM_LABEL_37\\";
    }
    case 38: {
      return \\"ENUM_LABEL_38\\";
    }
    case 39: {
      return \\"ENUM_LABEL_39\\";
    }
    case 40: {
      return \\"ENUM_LABEL_40\\";
    }
    case 41: {
      return \\"ENUM_LABEL_41\\";
    }
    case 42: {
      return \\"ENUM_LABEL_42\\";
    }
    case 43: {
      return \\"ENUM_LABEL_43\\";
    }
    case 44: {
      return \\"ENUM_LABEL_44\\";
    }
    case 45: {
      return \\"ENUM_LABEL_45\\";
    }
    case 46: {
      return \\"ENUM_LABEL_46\\";
    }
    case 47: {
      return \\"ENUM_LABEL_47\\";
    }
    case 48: {
      return \\"ENUM_LABEL_48\\";
    }
    case 49: {
      return \\"ENUM_LABEL_49\\";
    }
    case 50: {
      return \\"ENUM_LABEL_50\\";
    }
    case 51: {
      return \\"ENUM_LABEL_51\\";
    }
    case 52: {
      return \\"ENUM_LABEL_52\\";
    }
    case 53: {
      return \\"ENUM_LABEL_53\\";
    }
    case 54: {
      return \\"ENUM_LABEL_54\\";
    }
    case 55: {
      return \\"ENUM_LABEL_55\\";
    }
    case 56: {
      return \\"ENUM_LABEL_56\\";
    }
    case 57: {
      return \\"ENUM_LABEL_57\\";
    }
    case 58: {
      return \\"ENUM_LABEL_58\\";
    }
    case 59: {
      return \\"ENUM_LABEL_59\\";
    }
    case 60: {
      return \\"ENUM_LABEL_60\\";
    }
    case 61: {
      return \\"ENUM_LABEL_61\\";
    }
    case 62: {
      return \\"ENUM_LABEL_62\\";
    }
    case 63: {
      return \\"ENUM_LABEL_63\\";
    }
    case 64: {
      return \\"ENUM_LABEL_64\\";
    }
    case 65: {
      return \\"ENUM_LABEL_65\\";
    }
    case 66: {
      return \\"ENUM_LABEL_66\\";
    }
    case 67: {
      return \\"ENUM_LABEL_67\\";
    }
    case 68: {
      return \\"ENUM_LABEL_68\\";
    }
    case 69: {
      return \\"ENUM_LABEL_69\\";
    }
    case 70: {
      return \\"ENUM_LABEL_70\\";
    }
    case 71: {
      return \\"ENUM_LABEL_71\\";
    }
    case 72: {
      return \\"ENUM_LABEL_72\\";
    }
    case 73: {
      return \\"ENUM_LABEL_73\\";
    }
    case 74: {
      return \\"ENUM_LABEL_74\\";
    }
    case 75: {
      return \\"ENUM_LABEL_75\\";
    }
    case 76: {
      return \\"ENUM_LABEL_76\\";
    }
    case 77: {
      return \\"ENUM_LABEL_77\\";
    }
    case 78: {
      return \\"ENUM_LABEL_78\\";
    }
    case 79: {
      return \\"ENUM_LABEL_79\\";
    }
    case 80: {
      return \\"ENUM_LABEL_80\\";
    }
    case 81: {
      return \\"ENUM_LABEL_81\\";
    }
    case 82: {
      return \\"ENUM_LABEL_82\\";
    }
    case 83: {
      return \\"ENUM_LABEL_83\\";
    }
    case 84: {
      return \\"ENUM_LABEL_84\\";
    }
    case 85: {
      return \\"ENUM_LABEL_85\\";
    }
    case 86: {
      return \\"ENUM_LABEL_86\\";
    }
    case 87: {
      return \\"ENUM_LABEL_87\\";
    }
    case 88: {
      return \\"ENUM_LABEL_88\\";
    }
    case 89: {
      return \\"ENUM_LABEL_89\\";
    }
    case 90: {
      return \\"ENUM_LABEL_90\\";
    }
    case 91: {
      return \\"ENUM_LABEL_91\\";
    }
    case 92: {
      return \\"ENUM_LABEL_92\\";
    }
    case 93: {
      return \\"ENUM_LABEL_93\\";
    }
    case 94: {
      return \\"ENUM_LABEL_94\\";
    }
    case 95: {
      return \\"ENUM_LABEL_95\\";
    }
    case 96: {
      return \\"ENUM_LABEL_96\\";
    }
    case 97: {
      return \\"ENUM_LABEL_97\\";
    }
    case 98: {
      return \\"ENUM_LABEL_98\\";
    }
    case 99: {
      return \\"ENUM_LABEL_99\\";
    }
    case 100: {
      return \\"ENUM_LABEL_100\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as VeryLargeEnum;
    }
  }
};

const VeryLargeEnumToInt = function (i: VeryLargeEnum): number {
  switch (i) {
    case \\"ENUM_LABEL_DEFAULT\\": {
      return 0;
    }
    case \\"ENUM_LABEL_1\\": {
      return 1;
    }
    case \\"ENUM_LABEL_2\\": {
      return 2;
    }
    case \\"ENUM_LABEL_3\\": {
      return 3;
    }
    case \\"ENUM_LABEL_4\\": {
      return 4;
    }
    case \\"ENUM_LABEL_5\\": {
      return 5;
    }
    case \\"ENUM_LABEL_6\\": {
      return 6;
    }
    case \\"ENUM_LABEL_7\\": {
      return 7;
    }
    case \\"ENUM_LABEL_8\\": {
      return 8;
    }
    case \\"ENUM_LABEL_9\\": {
      return 9;
    }
    case \\"ENUM_LABEL_10\\": {
      return 10;
    }
    case \\"ENUM_LABEL_11\\": {
      return 11;
    }
    case \\"ENUM_LABEL_12\\": {
      return 12;
    }
    case \\"ENUM_LABEL_13\\": {
      return 13;
    }
    case \\"ENUM_LABEL_14\\": {
      return 14;
    }
    case \\"ENUM_LABEL_15\\": {
      return 15;
    }
    case \\"ENUM_LABEL_16\\": {
      return 16;
    }
    case \\"ENUM_LABEL_17\\": {
      return 17;
    }
    case \\"ENUM_LABEL_18\\": {
      return 18;
    }
    case \\"ENUM_LABEL_19\\": {
      return 19;
    }
    case \\"ENUM_LABEL_20\\": {
      return 20;
    }
    case \\"ENUM_LABEL_21\\": {
      return 21;
    }
    case \\"ENUM_LABEL_22\\": {
      return 22;
    }
    case \\"ENUM_LABEL_23\\": {
      return 23;
    }
    case \\"ENUM_LABEL_24\\": {
      return 24;
    }
    case \\"ENUM_LABEL_25\\": {
      return 25;
    }
    case \\"ENUM_LABEL_26\\": {
      return 26;
    }
    case \\"ENUM_LABEL_27\\": {
      return 27;
    }
    case \\"ENUM_LABEL_28\\": {
      return 28;
    }
    case \\"ENUM_LABEL_29\\": {
      return 29;
    }
    case \\"ENUM_LABEL_30\\": {
      return 30;
    }
    case \\"ENUM_LABEL_31\\": {
      return 31;
    }
    case \\"ENUM_LABEL_32\\": {
      return 32;
    }
    case \\"ENUM_LABEL_33\\": {
      return 33;
    }
    case \\"ENUM_LABEL_34\\": {
      return 34;
    }
    case \\"ENUM_LABEL_35\\": {
      return 35;
    }
    case \\"ENUM_LABEL_36\\": {
      return 36;
    }
    case \\"ENUM_LABEL_37\\": {
      return 37;
    }
    case \\"ENUM_LABEL_38\\": {
      return 38;
    }
    case \\"ENUM_LABEL_39\\": {
      return 39;
    }
    case \\"ENUM_LABEL_40\\": {
      return 40;
    }
    case \\"ENUM_LABEL_41\\": {
      return 41;
    }
    case \\"ENUM_LABEL_42\\": {
      return 42;
    }
    case \\"ENUM_LABEL_43\\": {
      return 43;
    }
    case \\"ENUM_LABEL_44\\": {
      return 44;
    }
    case \\"ENUM_LABEL_45\\": {
      return 45;
    }
    case \\"ENUM_LABEL_46\\": {
      return 46;
    }
    case \\"ENUM_LABEL_47\\": {
      return 47;
    }
    case \\"ENUM_LABEL_48\\": {
      return 48;
    }
    case \\"ENUM_LABEL_49\\": {
      return 49;
    }
    case \\"ENUM_LABEL_50\\": {
      return 50;
    }
    case \\"ENUM_LABEL_51\\": {
      return 51;
    }
    case \\"ENUM_LABEL_52\\": {
      return 52;
    }
    case \\"ENUM_LABEL_53\\": {
      return 53;
    }
    case \\"ENUM_LABEL_54\\": {
      return 54;
    }
    case \\"ENUM_LABEL_55\\": {
      return 55;
    }
    case \\"ENUM_LABEL_56\\": {
      return 56;
    }
    case \\"ENUM_LABEL_57\\": {
      return 57;
    }
    case \\"ENUM_LABEL_58\\": {
      return 58;
    }
    case \\"ENUM_LABEL_59\\": {
      return 59;
    }
    case \\"ENUM_LABEL_60\\": {
      return 60;
    }
    case \\"ENUM_LABEL_61\\": {
      return 61;
    }
    case \\"ENUM_LABEL_62\\": {
      return 62;
    }
    case \\"ENUM_LABEL_63\\": {
      return 63;
    }
    case \\"ENUM_LABEL_64\\": {
      return 64;
    }
    case \\"ENUM_LABEL_65\\": {
      return 65;
    }
    case \\"ENUM_LABEL_66\\": {
      return 66;
    }
    case \\"ENUM_LABEL_67\\": {
      return 67;
    }
    case \\"ENUM_LABEL_68\\": {
      return 68;
    }
    case \\"ENUM_LABEL_69\\": {
      return 69;
    }
    case \\"ENUM_LABEL_70\\": {
      return 70;
    }
    case \\"ENUM_LABEL_71\\": {
      return 71;
    }
    case \\"ENUM_LABEL_72\\": {
      return 72;
    }
    case \\"ENUM_LABEL_73\\": {
      return 73;
    }
    case \\"ENUM_LABEL_74\\": {
      return 74;
    }
    case \\"ENUM_LABEL_75\\": {
      return 75;
    }
    case \\"ENUM_LABEL_76\\": {
      return 76;
    }
    case \\"ENUM_LABEL_77\\": {
      return 77;
    }
    case \\"ENUM_LABEL_78\\": {
      return 78;
    }
    case \\"ENUM_LABEL_79\\": {
      return 79;
    }
    case \\"ENUM_LABEL_80\\": {
      return 80;
    }
    case \\"ENUM_LABEL_81\\": {
      return 81;
    }
    case \\"ENUM_LABEL_82\\": {
      return 82;
    }
    case \\"ENUM_LABEL_83\\": {
      return 83;
    }
    case \\"ENUM_LABEL_84\\": {
      return 84;
    }
    case \\"ENUM_LABEL_85\\": {
      return 85;
    }
    case \\"ENUM_LABEL_86\\": {
      return 86;
    }
    case \\"ENUM_LABEL_87\\": {
      return 87;
    }
    case \\"ENUM_LABEL_88\\": {
      return 88;
    }
    case \\"ENUM_LABEL_89\\": {
      return 89;
    }
    case \\"ENUM_LABEL_90\\": {
      return 90;
    }
    case \\"ENUM_LABEL_91\\": {
      return 91;
    }
    case \\"ENUM_LABEL_92\\": {
      return 92;
    }
    case \\"ENUM_LABEL_93\\": {
      return 93;
    }
    case \\"ENUM_LABEL_94\\": {
      return 94;
    }
    case \\"ENUM_LABEL_95\\": {
      return 95;
    }
    case \\"ENUM_LABEL_96\\": {
      return 96;
    }
    case \\"ENUM_LABEL_97\\": {
      return 97;
    }
    case \\"ENUM_LABEL_98\\": {
      return 98;
    }
    case \\"ENUM_LABEL_99\\": {
      return 99;
    }
    case \\"ENUM_LABEL_100\\": {
      return 100;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalImportEnum: ImportEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      defaultForeignEnum: ForeignEnumFromInt(0),
      defaultImportEnum: ImportEnumFromInt(0),
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      writer.writeEnum(23, ImportEnumToInt(msg.optionalImportEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum.map(ImportEnumToInt));
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(81, TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum));
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnumToInt(msg.defaultForeignEnum));
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      writer.writeEnum(83, ImportEnumToInt(msg.defaultImportEnum));
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum && ImportEnumToInt(msg.optionalImportEnum)) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json.defaultBytes = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.defaultNestedEnum)
    ) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum && ForeignEnumToInt(msg.defaultForeignEnum)) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum && ImportEnumToInt(msg.defaultImportEnum)) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(ImportEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum = ImportEnumFromInt(reader.readEnum());
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (_optionalImportEnum) {
      msg.optionalImportEnum = _optionalImportEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (_repeatedImportEnum) {
      msg.repeatedImportEnum = _repeatedImportEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (_defaultInt32) {
      msg.defaultInt32 = _defaultInt32;
    }
    const _defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (_defaultInt64) {
      msg.defaultInt64 = BigInt(_defaultInt64);
    }
    const _defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (_defaultUint32) {
      msg.defaultUint32 = _defaultUint32;
    }
    const _defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (_defaultUint64) {
      msg.defaultUint64 = BigInt(_defaultUint64);
    }
    const _defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (_defaultSint32) {
      msg.defaultSint32 = _defaultSint32;
    }
    const _defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (_defaultSint64) {
      msg.defaultSint64 = BigInt(_defaultSint64);
    }
    const _defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (_defaultFixed32) {
      msg.defaultFixed32 = _defaultFixed32;
    }
    const _defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (_defaultFixed64) {
      msg.defaultFixed64 = BigInt(_defaultFixed64);
    }
    const _defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (_defaultSfixed32) {
      msg.defaultSfixed32 = _defaultSfixed32;
    }
    const _defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (_defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64);
    }
    const _defaultFloat = json.defaultFloat ?? json.default_float;
    if (_defaultFloat) {
      msg.defaultFloat = _defaultFloat;
    }
    const _defaultDouble = json.defaultDouble ?? json.default_double;
    if (_defaultDouble) {
      msg.defaultDouble = _defaultDouble;
    }
    const _defaultBool = json.defaultBool ?? json.default_bool;
    if (_defaultBool) {
      msg.defaultBool = _defaultBool;
    }
    const _defaultString = json.defaultString ?? json.default_string;
    if (_defaultString) {
      msg.defaultString = _defaultString;
    }
    const _defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (_defaultBytes) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes);
    }
    const _defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (_defaultNestedEnum) {
      msg.defaultNestedEnum = _defaultNestedEnum;
    }
    const _defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (_defaultForeignEnum) {
      msg.defaultForeignEnum = _defaultForeignEnum;
    }
    const _defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (_defaultImportEnum) {
      msg.defaultImportEnum = _defaultImportEnum;
    }
    const _defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (_defaultStringPiece) {
      msg.defaultStringPiece = _defaultStringPiece;
    }
    const _defaultCord = json.defaultCord ?? json.default_cord;
    if (_defaultCord) {
      msg.defaultCord = _defaultCord;
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\", NEG: \\"NEG\\" } as const,

  NestedEnumFromInt: function (i: number): TestAllTypes.NestedEnum {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestAllTypes.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestAllTypes.NestedEnum): number {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.OptionalGroup>): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.OptionalGroup>): string {
      return JSON.stringify(TestAllTypes.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.RepeatedGroup>): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.RepeatedGroup>): string {
      return JSON.stringify(TestAllTypes.RepeatedGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    const _repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (_repeatedChild) {
      for (const item of _repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (msg: Partial<TestDeprecatedFields>): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (msg: Partial<TestDeprecatedFields>): string {
    return JSON.stringify(TestDeprecatedFields._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const _deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (_deprecatedInt32) {
      msg.deprecatedInt32 = _deprecatedInt32;
    }
    const _deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (_deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestDeprecatedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestDeprecatedMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    const _d = json.d;
    if (_d) {
      msg.d = _d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */
  encode: function (_msg?: Partial<TestReservedFields>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestReservedFields>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */
  decodeJSON: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestAllExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestAllExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (msg: Partial<OptionalGroup_extension>): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (msg: Partial<OptionalGroup_extension>): string {
    return JSON.stringify(OptionalGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (msg: Partial<RepeatedGroup_extension>): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (msg: Partial<RepeatedGroup_extension>): string {
    return JSON.stringify(RepeatedGroup_extension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (msg: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (msg: Partial<TestGroup>): string {
    return JSON.stringify(TestGroup._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json: string): TestGroup {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestGroup>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestGroup, json: any): TestGroup {
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg: Partial<TestGroup.OptionalGroup>): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestGroup.OptionalGroup>): string {
      return JSON.stringify(TestGroup.OptionalGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestGroupExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestGroupExtension>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */
  decodeJSON: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */
  encode: function (_msg?: Partial<TestNestedExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestNestedExtension>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */
  decodeJSON: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (msg: Partial<TestChildExtension>): Uint8Array {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (msg: Partial<TestChildExtension>): string {
    return JSON.stringify(TestChildExtension._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json: string): TestChildExtension {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _optionalExtension =
      json.optionalExtension ?? json.optional_extension;
    if (_optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, _optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (msg: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequired>): string {
    return JSON.stringify(TestRequired._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json: string): TestRequired {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestRequired, json: any): TestRequired {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _dummy2 = json.dummy2;
    if (_dummy2) {
      msg.dummy2 = _dummy2;
    }
    const _b = json.b;
    if (_b) {
      msg.b = _b;
    }
    const _dummy4 = json.dummy4;
    if (_dummy4) {
      msg.dummy4 = _dummy4;
    }
    const _dummy5 = json.dummy5;
    if (_dummy5) {
      msg.dummy5 = _dummy5;
    }
    const _dummy6 = json.dummy6;
    if (_dummy6) {
      msg.dummy6 = _dummy6;
    }
    const _dummy7 = json.dummy7;
    if (_dummy7) {
      msg.dummy7 = _dummy7;
    }
    const _dummy8 = json.dummy8;
    if (_dummy8) {
      msg.dummy8 = _dummy8;
    }
    const _dummy9 = json.dummy9;
    if (_dummy9) {
      msg.dummy9 = _dummy9;
    }
    const _dummy10 = json.dummy10;
    if (_dummy10) {
      msg.dummy10 = _dummy10;
    }
    const _dummy11 = json.dummy11;
    if (_dummy11) {
      msg.dummy11 = _dummy11;
    }
    const _dummy12 = json.dummy12;
    if (_dummy12) {
      msg.dummy12 = _dummy12;
    }
    const _dummy13 = json.dummy13;
    if (_dummy13) {
      msg.dummy13 = _dummy13;
    }
    const _dummy14 = json.dummy14;
    if (_dummy14) {
      msg.dummy14 = _dummy14;
    }
    const _dummy15 = json.dummy15;
    if (_dummy15) {
      msg.dummy15 = _dummy15;
    }
    const _dummy16 = json.dummy16;
    if (_dummy16) {
      msg.dummy16 = _dummy16;
    }
    const _dummy17 = json.dummy17;
    if (_dummy17) {
      msg.dummy17 = _dummy17;
    }
    const _dummy18 = json.dummy18;
    if (_dummy18) {
      msg.dummy18 = _dummy18;
    }
    const _dummy19 = json.dummy19;
    if (_dummy19) {
      msg.dummy19 = _dummy19;
    }
    const _dummy20 = json.dummy20;
    if (_dummy20) {
      msg.dummy20 = _dummy20;
    }
    const _dummy21 = json.dummy21;
    if (_dummy21) {
      msg.dummy21 = _dummy21;
    }
    const _dummy22 = json.dummy22;
    if (_dummy22) {
      msg.dummy22 = _dummy22;
    }
    const _dummy23 = json.dummy23;
    if (_dummy23) {
      msg.dummy23 = _dummy23;
    }
    const _dummy24 = json.dummy24;
    if (_dummy24) {
      msg.dummy24 = _dummy24;
    }
    const _dummy25 = json.dummy25;
    if (_dummy25) {
      msg.dummy25 = _dummy25;
    }
    const _dummy26 = json.dummy26;
    if (_dummy26) {
      msg.dummy26 = _dummy26;
    }
    const _dummy27 = json.dummy27;
    if (_dummy27) {
      msg.dummy27 = _dummy27;
    }
    const _dummy28 = json.dummy28;
    if (_dummy28) {
      msg.dummy28 = _dummy28;
    }
    const _dummy29 = json.dummy29;
    if (_dummy29) {
      msg.dummy29 = _dummy29;
    }
    const _dummy30 = json.dummy30;
    if (_dummy30) {
      msg.dummy30 = _dummy30;
    }
    const _dummy31 = json.dummy31;
    if (_dummy31) {
      msg.dummy31 = _dummy31;
    }
    const _dummy32 = json.dummy32;
    if (_dummy32) {
      msg.dummy32 = _dummy32;
    }
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (msg: Partial<TestRequiredForeign>): Uint8Array {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredForeign>): string {
    return JSON.stringify(TestRequiredForeign._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json: string): TestRequiredForeign {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessage>): Uint8Array {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredMessage>): string {
    return JSON.stringify(TestRequiredMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessage {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (_repeatedMessage) {
      for (const item of _repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage = json.requiredMessage ?? json.required_message;
    if (_requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, _requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (msg: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (msg: Partial<TestForeignNested>): string {
    return JSON.stringify(TestForeignNested._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json: string): TestForeignNested {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const _foreignNested = json.foreignNested ?? json.foreign_nested;
    if (_foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */
  encodeJSON: function (
    _msg?: Partial<TestEmptyMessageWithExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestPickleNestedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestPickleNestedMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            msg
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const _cc = json.cc;
        if (_cc) {
          msg.cc = _cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg?: Partial<TestMultipleExtensionRanges>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestMultipleExtensionRanges>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */
  decodeJSON: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg: Partial<TestReallyLargeTagNumber>): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (msg: Partial<TestReallyLargeTagNumber>): string {
    return JSON.stringify(TestReallyLargeTagNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    const _bb = json.bb;
    if (_bb) {
      msg.bb = _bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMessage>): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRecursiveMessage>): string {
    return JSON.stringify(TestRecursiveMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const _a = json.a;
    if (_a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _i = json.i;
    if (_i) {
      msg.i = _i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionA>): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (msg: Partial<TestMutualRecursionA>): string {
    return JSON.stringify(TestMutualRecursionA._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const _bb = json.bb;
    if (_bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, _bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const _b = json.b;
      if (_b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, _b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg: Partial<TestMutualRecursionA.SubGroup>): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestMutualRecursionA.SubGroup>): string {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const _subMessage = json.subMessage ?? json.sub_message;
      if (_subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, _subMessage);
        msg.subMessage = m;
      }
      const _notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (_notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (msg: Partial<TestMutualRecursionB>): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (msg: Partial<TestMutualRecursionB>): string {
    return JSON.stringify(TestMutualRecursionB._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const _a = json.a;
    if (_a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, _a);
      msg.a = m;
    }
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (msg: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (msg: Partial<TestIsInitialized>): string {
    return JSON.stringify(TestIsInitialized._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json: string): TestIsInitialized {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */
    encodeJSON: function (
      _msg?: Partial<TestIsInitialized.SubMessage>
    ): string {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */
    decodeJSON: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const _i = json.i;
        if (_i) {
          msg.i = _i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (msg: Partial<TestDupFieldNumber>): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (msg: Partial<TestDupFieldNumber>): string {
    return JSON.stringify(TestDupFieldNumber._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (msg: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (msg: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (msg: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json: string): TestEagerMessage {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEagerMessage,
    json: any
  ): TestEagerMessage {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (msg: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json: string): TestLazyMessage {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestLazyMessage,
    json: any
  ): TestLazyMessage {
    const _subMessage = json.subMessage ?? json.sub_message;
    if (_subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg: Partial<TestNestedMessageHasBits>): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (msg: Partial<TestNestedMessageHasBits>): string {
    return JSON.stringify(TestNestedMessageHasBits._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const _nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (_nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32;
      }
      const _nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (_nestedmessageRepeatedForeignmessage) {
        for (const item of _nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg: Partial<TestCamelCaseFieldNames>): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (msg: Partial<TestCamelCaseFieldNames>): string {
    return JSON.stringify(TestCamelCaseFieldNames._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: ForeignEnumFromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnumToInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField.map(ForeignEnumToInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumToInt(msg.EnumField)) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const _PrimitiveField = json.PrimitiveField;
    if (_PrimitiveField) {
      msg.PrimitiveField = _PrimitiveField;
    }
    const _StringField = json.StringField;
    if (_StringField) {
      msg.StringField = _StringField;
    }
    const _EnumField = json.EnumField;
    if (_EnumField) {
      msg.EnumField = _EnumField;
    }
    const _MessageField = json.MessageField;
    if (_MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _MessageField);
      msg.MessageField = m;
    }
    const _StringPieceField = json.StringPieceField;
    if (_StringPieceField) {
      msg.StringPieceField = _StringPieceField;
    }
    const _CordField = json.CordField;
    if (_CordField) {
      msg.CordField = _CordField;
    }
    const _RepeatedPrimitiveField = json.RepeatedPrimitiveField;
    if (_RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField;
    }
    const _RepeatedStringField = json.RepeatedStringField;
    if (_RepeatedStringField) {
      msg.RepeatedStringField = _RepeatedStringField;
    }
    const _RepeatedEnumField = json.RepeatedEnumField;
    if (_RepeatedEnumField) {
      msg.RepeatedEnumField = _RepeatedEnumField;
    }
    const _RepeatedMessageField = json.RepeatedMessageField;
    if (_RepeatedMessageField) {
      for (const item of _RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField = json.RepeatedStringPieceField;
    if (_RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField;
    }
    const _RepeatedCordField = json.RepeatedCordField;
    if (_RepeatedCordField) {
      msg.RepeatedCordField = _RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (msg: Partial<TestFieldOrderings>): Uint8Array {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (msg: Partial<TestFieldOrderings>): string {
    return JSON.stringify(TestFieldOrderings._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json: string): TestFieldOrderings {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    const _myInt = json.myInt ?? json.my_int;
    if (_myInt) {
      msg.myInt = BigInt(_myInt);
    }
    const _myFloat = json.myFloat ?? json.my_float;
    if (_myFloat) {
      msg.myFloat = _myFloat;
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        _optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): string {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const _oo = json.oo;
      if (_oo) {
        msg.oo = BigInt(_oo);
      }
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings1>): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionOrderings1>): string {
    return JSON.stringify(TestExtensionOrderings1._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg: Partial<TestExtensionOrderings2>): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionOrderings2>): string {
    return JSON.stringify(TestExtensionOrderings2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const _myString = json.myString ?? json.my_string;
    if (_myString) {
      msg.myString = _myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const _myString = json.myString ?? json.my_string;
      if (_myString) {
        msg.myString = _myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg: Partial<TestExtremeDefaultValues>): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtremeDefaultValues>): string {
    return JSON.stringify(TestExtremeDefaultValues._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes?.length) {
      json.escapedBytes = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json.bytesWithZero = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const _escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (_escapedBytes) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes);
    }
    const _largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (_largeUint32) {
      msg.largeUint32 = _largeUint32;
    }
    const _largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (_largeUint64) {
      msg.largeUint64 = BigInt(_largeUint64);
    }
    const _smallInt32 = json.smallInt32 ?? json.small_int32;
    if (_smallInt32) {
      msg.smallInt32 = _smallInt32;
    }
    const _smallInt64 = json.smallInt64 ?? json.small_int64;
    if (_smallInt64) {
      msg.smallInt64 = BigInt(_smallInt64);
    }
    const _reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (_reallySmallInt32) {
      msg.reallySmallInt32 = _reallySmallInt32;
    }
    const _reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (_reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64);
    }
    const _utf8String = json.utf8String ?? json.utf8_string;
    if (_utf8String) {
      msg.utf8String = _utf8String;
    }
    const _zeroFloat = json.zeroFloat ?? json.zero_float;
    if (_zeroFloat) {
      msg.zeroFloat = _zeroFloat;
    }
    const _oneFloat = json.oneFloat ?? json.one_float;
    if (_oneFloat) {
      msg.oneFloat = _oneFloat;
    }
    const _smallFloat = json.smallFloat ?? json.small_float;
    if (_smallFloat) {
      msg.smallFloat = _smallFloat;
    }
    const _negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (_negativeOneFloat) {
      msg.negativeOneFloat = _negativeOneFloat;
    }
    const _negativeFloat = json.negativeFloat ?? json.negative_float;
    if (_negativeFloat) {
      msg.negativeFloat = _negativeFloat;
    }
    const _largeFloat = json.largeFloat ?? json.large_float;
    if (_largeFloat) {
      msg.largeFloat = _largeFloat;
    }
    const _smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (_smallNegativeFloat) {
      msg.smallNegativeFloat = _smallNegativeFloat;
    }
    const _infDouble = json.infDouble ?? json.inf_double;
    if (_infDouble) {
      msg.infDouble = _infDouble;
    }
    const _negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (_negInfDouble) {
      msg.negInfDouble = _negInfDouble;
    }
    const _nanDouble = json.nanDouble ?? json.nan_double;
    if (_nanDouble) {
      msg.nanDouble = _nanDouble;
    }
    const _infFloat = json.infFloat ?? json.inf_float;
    if (_infFloat) {
      msg.infFloat = _infFloat;
    }
    const _negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (_negInfFloat) {
      msg.negInfFloat = _negInfFloat;
    }
    const _nanFloat = json.nanFloat ?? json.nan_float;
    if (_nanFloat) {
      msg.nanFloat = _nanFloat;
    }
    const _cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (_cppTrigraph) {
      msg.cppTrigraph = _cppTrigraph;
    }
    const _stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (_stringWithZero) {
      msg.stringWithZero = _stringWithZero;
    }
    const _bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (_bytesWithZero) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero);
    }
    const _stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (_stringPieceWithZero) {
      msg.stringPieceWithZero = _stringPieceWithZero;
    }
    const _cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (_cordWithZero) {
      msg.cordWithZero = _cordWithZero;
    }
    const _replacementString =
      json.replacementString ?? json.replacement_string;
    if (_replacementString) {
      msg.replacementString = _replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (msg: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (msg: Partial<SparseEnumMessage>): string {
    return JSON.stringify(SparseEnumMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json: string): SparseEnumMessage {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnumFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnumToInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum && TestSparseEnumToInt(msg.sparseEnum)) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const _sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (_sparseEnum) {
      msg.sparseEnum = _sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (msg: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (msg: Partial<OneString>): string {
    return JSON.stringify(OneString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json: string): OneString {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneString, json: any): OneString {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (msg: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (msg: Partial<MoreString>): string {
    return JSON.stringify(MoreString._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json: string): MoreString {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreString, json: any): MoreString {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (msg: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (msg: Partial<OneBytes>): string {
    return JSON.stringify(OneBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json: string): OneBytes {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneBytes, json: any): OneBytes {
    const _data = json.data;
    if (_data) {
      msg.data = decodeBase64Bytes(_data);
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (msg: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (msg: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json: string): MoreBytes {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreBytes, json: any): MoreBytes {
    const _data = json.data;
    if (_data) {
      msg.data = _data.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (msg: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (msg: Partial<Int32Message>): string {
    return JSON.stringify(Int32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json: string): Int32Message {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Message, json: any): Int32Message {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (msg: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (msg: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json: string): Uint32Message {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint32Message, json: any): Uint32Message {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (msg: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (msg: Partial<Int64Message>): string {
    return JSON.stringify(Int64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json: string): Int64Message {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Message, json: any): Int64Message {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (msg: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (msg: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64Message._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json: string): Uint64Message {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint64Message, json: any): Uint64Message {
    const _data = json.data;
    if (_data) {
      msg.data = BigInt(_data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (msg: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (msg: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json: string): BoolMessage {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolMessage, json: any): BoolMessage {
    const _data = json.data;
    if (_data) {
      msg.data = _data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (msg: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof>): string {
    return JSON.stringify(TestOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json: string): TestOneof {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof, json: any): TestOneof {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg: Partial<TestOneofBackwardsCompatible>): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneofBackwardsCompatible>): string {
    return JSON.stringify(TestOneofBackwardsCompatible._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnumToInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json.fooBytes = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json.barBytes = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json.barBytesWithEmptyDefault = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault
      );
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooCord = json.fooCord ?? json.foo_cord;
    if (_fooCord) {
      msg.fooCord = _fooCord;
    }
    const _fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (_fooStringPiece) {
      msg.fooStringPiece = _fooStringPiece;
    }
    const _fooBytes = json.fooBytes ?? json.foo_bytes;
    if (_fooBytes) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes);
    }
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    const _fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (_fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, _fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const _barInt = json.barInt ?? json.bar_int;
    if (_barInt) {
      msg.barInt = _barInt;
    }
    const _barString = json.barString ?? json.bar_string;
    if (_barString) {
      msg.barString = _barString;
    }
    const _barCord = json.barCord ?? json.bar_cord;
    if (_barCord) {
      msg.barCord = _barCord;
    }
    const _barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (_barStringPiece) {
      msg.barStringPiece = _barStringPiece;
    }
    const _barBytes = json.barBytes ?? json.bar_bytes;
    if (_barBytes) {
      msg.barBytes = decodeBase64Bytes(_barBytes);
    }
    const _barEnum = json.barEnum ?? json.bar_enum;
    if (_barEnum) {
      msg.barEnum = _barEnum;
    }
    const _barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (_barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault;
    }
    const _barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (_barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault;
    }
    const _barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (_barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault;
    }
    const _barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (_barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault
      );
    }
    const _bazInt = json.bazInt ?? json.baz_int;
    if (_bazInt) {
      msg.bazInt = _bazInt;
    }
    const _bazString = json.bazString ?? json.baz_string;
    if (_bazString) {
      msg.bazString = _bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: \\"FOO\\", BAR: \\"BAR\\", BAZ: \\"BAZ\\" } as const,

  NestedEnumFromInt: function (i: number): TestOneof2.NestedEnum {
    switch (i) {
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestOneof2.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestOneof2.NestedEnum): number {
    switch (i) {
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const _a = json.a;
      if (_a) {
        msg.a = _a;
      }
      const _b = json.b;
      if (_b) {
        msg.b = _b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestOneof2.NestedMessage>): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestOneof2.NestedMessage>): string {
      return JSON.stringify(TestOneof2.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const _quxInt = json.quxInt ?? json.qux_int;
      if (_quxInt) {
        msg.quxInt = BigInt(_quxInt);
      }
      const _corgeInt = json.corgeInt ?? json.corge_int;
      if (_corgeInt) {
        msg.corgeInt = _corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (msg: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredOneof>): string {
    return JSON.stringify(TestRequiredOneof._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json: string): TestRequiredOneof {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const _fooInt = json.fooInt ?? json.foo_int;
    if (_fooInt) {
      msg.fooInt = _fooInt;
    }
    const _fooString = json.fooString ?? json.foo_string;
    if (_fooString) {
      msg.fooString = _fooString;
    }
    const _fooMessage = json.fooMessage ?? json.foo_message;
    if (_fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, _fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): string {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const _requiredDouble = json.requiredDouble ?? json.required_double;
      if (_requiredDouble) {
        msg.requiredDouble = _requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString())
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.unpackedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (_unpackedInt32) {
      msg.unpackedInt32 = _unpackedInt32;
    }
    const _unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (_unpackedInt64) {
      msg.unpackedInt64 = _unpackedInt64.map(BigInt);
    }
    const _unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (_unpackedUint32) {
      msg.unpackedUint32 = _unpackedUint32;
    }
    const _unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (_unpackedUint64) {
      msg.unpackedUint64 = _unpackedUint64.map(BigInt);
    }
    const _unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (_unpackedSint32) {
      msg.unpackedSint32 = _unpackedSint32;
    }
    const _unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (_unpackedSint64) {
      msg.unpackedSint64 = _unpackedSint64.map(BigInt);
    }
    const _unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (_unpackedFixed32) {
      msg.unpackedFixed32 = _unpackedFixed32;
    }
    const _unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (_unpackedFixed64) {
      msg.unpackedFixed64 = _unpackedFixed64.map(BigInt);
    }
    const _unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (_unpackedSfixed32) {
      msg.unpackedSfixed32 = _unpackedSfixed32;
    }
    const _unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (_unpackedSfixed64) {
      msg.unpackedSfixed64 = _unpackedSfixed64.map(BigInt);
    }
    const _unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (_unpackedFloat) {
      msg.unpackedFloat = _unpackedFloat;
    }
    const _unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (_unpackedDouble) {
      msg.unpackedDouble = _unpackedDouble;
    }
    const _unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (_unpackedBool) {
      msg.unpackedBool = _unpackedBool;
    }
    const _unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (_unpackedEnum) {
      msg.unpackedEnum = _unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestPackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestPackedExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg?: Partial<TestUnpackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestUnpackedExtensions>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */
  decodeJSON: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (msg: Partial<TestDynamicExtensions>): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (msg: Partial<TestDynamicExtensions>): string {
    return JSON.stringify(TestDynamicExtensions._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnumFromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumTypeFromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnumToInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumToInt(msg.enumExtension)) {
      json.enumExtension = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumTypeToInt(msg.dynamicEnumExtension)
    ) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumTypeFromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const _scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (_scalarExtension) {
      msg.scalarExtension = _scalarExtension;
    }
    const _enumExtension = json.enumExtension ?? json.enum_extension;
    if (_enumExtension) {
      msg.enumExtension = _enumExtension;
    }
    const _dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (_dynamicEnumExtension) {
      msg.dynamicEnumExtension = _dynamicEnumExtension;
    }
    const _messageExtension = json.messageExtension ?? json.message_extension;
    if (_messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _messageExtension);
      msg.messageExtension = m;
    }
    const _dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (_dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        _dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const _repeatedExtension =
      json.repeatedExtension ?? json.repeated_extension;
    if (_repeatedExtension) {
      msg.repeatedExtension = _repeatedExtension;
    }
    const _packedExtension = json.packedExtension ?? json.packed_extension;
    if (_packedExtension) {
      msg.packedExtension = _packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: \\"DYNAMIC_FOO\\",
    DYNAMIC_BAR: \\"DYNAMIC_BAR\\",
    DYNAMIC_BAZ: \\"DYNAMIC_BAZ\\",
  } as const,

  DynamicEnumTypeFromInt: function (
    i: number
  ): TestDynamicExtensions.DynamicEnumType {
    switch (i) {
      case 2200: {
        return \\"DYNAMIC_FOO\\";
      }
      case 2201: {
        return \\"DYNAMIC_BAR\\";
      }
      case 2202: {
        return \\"DYNAMIC_BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestDynamicExtensions.DynamicEnumType;
      }
    }
  },

  DynamicEnumTypeToInt: function (
    i: TestDynamicExtensions.DynamicEnumType
  ): number {
    switch (i) {
      case \\"DYNAMIC_FOO\\": {
        return 2200;
      }
      case \\"DYNAMIC_BAR\\": {
        return 2201;
      }
      case \\"DYNAMIC_BAZ\\": {
        return 2202;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const _dynamicField = json.dynamicField ?? json.dynamic_field;
      if (_dynamicField) {
        msg.dynamicField = _dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (msg: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (msg: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json: string): TestParsingMerge {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestParsingMerge,
    json: any
  ): TestParsingMerge {
    const _requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (_requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const _optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (_optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const _repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (_repeatedAllTypes) {
      for (const item of _repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const _field1 = json.field1;
      if (_field1) {
        for (const item of _field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const _field2 = json.field2;
      if (_field2) {
        for (const item of _field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const _field3 = json.field3;
      if (_field3) {
        for (const item of _field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1 = json.ext1;
      if (_ext1) {
        for (const item of _ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2 = json.ext2;
      if (_ext2) {
        for (const item of _ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(msg)
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const _field1 = json.field1;
        if (_field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, _field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const _optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (_optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const _repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (_repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg: Partial<TestCommentInjectionMessage>): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestCommentInjectionMessage>): string {
    return JSON.stringify(TestCommentInjectionMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const _a = json.a;
    if (_a) {
      msg.a = _a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */
  encode: function (_msg?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */
  decodeJSON: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */
  encode: function (_msg?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */
  decodeJSON: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooClientMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */
  decodeJSON: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */
  encode: function (_msg?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<FooServerMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */
  decodeJSON: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */
  encode: function (_msg?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */
  encodeJSON: function (_msg?: Partial<BarRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */
  decodeJSON: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */
  encode: function (_msg?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */
  encodeJSON: function (_msg?: Partial<BarResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */
  decodeJSON: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (msg: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (msg: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonName._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json: string): TestJsonName {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestJsonName, json: any): TestJsonName {
    const _fieldName1 = json.fieldName1 ?? json.field_name1;
    if (_fieldName1) {
      msg.fieldName1 = _fieldName1;
    }
    const _fieldName2 = json.fieldName2;
    if (_fieldName2) {
      msg.fieldName2 = _fieldName2;
    }
    const _FieldName3 = json.FieldName3;
    if (_FieldName3) {
      msg.FieldName3 = _FieldName3;
    }
    const _FieldName4 = json.FieldName4 ?? json._field_name4;
    if (_FieldName4) {
      msg.FieldName4 = _FieldName4;
    }
    const _FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (_FIELDNAME5) {
      msg.FIELDNAME5 = _FIELDNAME5;
    }
    const _fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (_fieldName6) {
      msg.fieldName6 = _fieldName6;
    }
    const _fieldname7 = json.fieldname7;
    if (_fieldname7) {
      msg.fieldname7 = _fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg: Partial<TestHugeFieldNumbers>): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (msg: Partial<TestHugeFieldNumbers>): string {
    return JSON.stringify(TestHugeFieldNumbers._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnumFromInt(0),
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnumToInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries<any>(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestHugeFieldNumbers.StringStringMap._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumToInt(msg.optionalEnum)) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      const stringStringMap = Object.fromEntries(
        Object.entries<any>(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringStringMap).length > 0) {
        json.stringStringMap = stringStringMap;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const stringStringMap =
            {} as MapMessage<TestHugeFieldNumbers.StringStringMap>;
          reader.readMessage(
            stringStringMap,
            TestHugeFieldNumbers.StringStringMap._readMessage
          );
          msg.stringStringMap[stringStringMap.key] = stringStringMap.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _fixed32 = json.fixed32 ?? json.fixed_32;
    if (_fixed32) {
      msg.fixed32 = _fixed32;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (_optionalEnum) {
      msg.optionalEnum = _optionalEnum;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalMessage = json.optionalMessage ?? json.optional_message;
    if (_optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalMessage);
      msg.optionalMessage = m;
    }
    const _stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (_stringStringMap) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries<any>(_stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbers.StringStringMap._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (_oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(msg)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const _groupA = json.groupA ?? json.group_a;
      if (_groupA) {
        msg.groupA = _groupA;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      reader: BinaryReader
    ): MapMessage<TestHugeFieldNumbers.StringStringMap> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestHugeFieldNumbers.StringStringMap>,
      json: any
    ): MapMessage<TestHugeFieldNumbers.StringStringMap> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (msg: Partial<TestExtensionInsideTable>): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionInsideTable>): string {
    return JSON.stringify(TestExtensionInsideTable._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const _field1 = json.field1;
    if (_field1) {
      msg.field1 = _field1;
    }
    const _field2 = json.field2;
    if (_field2) {
      msg.field2 = _field2;
    }
    const _field3 = json.field3;
    if (_field3) {
      msg.field3 = _field3;
    }
    const _field4 = json.field4;
    if (_field4) {
      msg.field4 = _field4;
    }
    const _field6 = json.field6;
    if (_field6) {
      msg.field6 = _field6;
    }
    const _field7 = json.field7;
    if (_field7) {
      msg.field7 = _field7;
    }
    const _field8 = json.field8;
    if (_field8) {
      msg.field8 = _field8;
    }
    const _field9 = json.field9;
    if (_field9) {
      msg.field9 = _field9;
    }
    const _field10 = json.field10;
    if (_field10) {
      msg.field10 = _field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg: Partial<TestExtensionRangeSerialize>): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (msg: Partial<TestExtensionRangeSerialize>): string {
    return JSON.stringify(TestExtensionRangeSerialize._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const _fooOne = json.fooOne ?? json.foo_one;
    if (_fooOne) {
      msg.fooOne = _fooOne;
    }
    const _fooTwo = json.fooTwo ?? json.foo_two;
    if (_fooTwo) {
      msg.fooTwo = _fooTwo;
    }
    const _fooThree = json.fooThree ?? json.foo_three;
    if (_fooThree) {
      msg.fooThree = _fooThree;
    }
    const _fooFour = json.fooFour ?? json.foo_four;
    if (_fooFour) {
      msg.fooFour = _fooFour;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = \\"MAP_ENUM_FOO\\" | \\"MAP_ENUM_BAR\\" | \\"MAP_ENUM_BAZ\\";

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: TestMap.MapInt32Int32;
  mapInt64Int64: TestMap.MapInt64Int64;
  mapUint32Uint32: TestMap.MapUint32Uint32;
  mapUint64Uint64: TestMap.MapUint64Uint64;
  mapSint32Sint32: TestMap.MapSint32Sint32;
  mapSint64Sint64: TestMap.MapSint64Sint64;
  mapFixed32Fixed32: TestMap.MapFixed32Fixed32;
  mapFixed64Fixed64: TestMap.MapFixed64Fixed64;
  mapSfixed32Sfixed32: TestMap.MapSfixed32Sfixed32;
  mapSfixed64Sfixed64: TestMap.MapSfixed64Sfixed64;
  mapInt32Float: TestMap.MapInt32Float;
  mapInt32Double: TestMap.MapInt32Double;
  mapBoolBool: TestMap.MapBoolBool;
  mapStringString: TestMap.MapStringString;
  mapInt32Bytes: TestMap.MapInt32Bytes;
  mapInt32Enum: TestMap.MapInt32Enum;
  mapInt32ForeignMessage: TestMap.MapInt32ForeignMessage;
  mapStringForeignMessage: TestMap.MapStringForeignMessage;
  mapInt32AllTypes: TestMap.MapInt32AllTypes;
}

declare namespace TestMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<bigint, bigint | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<bigint, bigint | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<bigint, bigint | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<bigint, bigint | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<bigint, bigint | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;

  export type MapStringForeignMessage = Record<
    string,
    ForeignMessage | undefined
  >;

  export type MapInt32AllTypes = Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: TestMessageMap.MapInt32Message;
}

declare namespace TestMessageMap {
  export type MapInt32Message = Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: TestSameTypeMap.Map1;
  map2: TestSameTypeMap.Map2;
}

declare namespace TestSameTypeMap {
  export type Map1 = Record<number, number | undefined>;

  export type Map2 = Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: TestRequiredMessageMap.MapField;
}

declare namespace TestRequiredMessageMap {
  export type MapField = Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: TestArenaMap.MapInt32Int32;
  mapInt64Int64: TestArenaMap.MapInt64Int64;
  mapUint32Uint32: TestArenaMap.MapUint32Uint32;
  mapUint64Uint64: TestArenaMap.MapUint64Uint64;
  mapSint32Sint32: TestArenaMap.MapSint32Sint32;
  mapSint64Sint64: TestArenaMap.MapSint64Sint64;
  mapFixed32Fixed32: TestArenaMap.MapFixed32Fixed32;
  mapFixed64Fixed64: TestArenaMap.MapFixed64Fixed64;
  mapSfixed32Sfixed32: TestArenaMap.MapSfixed32Sfixed32;
  mapSfixed64Sfixed64: TestArenaMap.MapSfixed64Sfixed64;
  mapInt32Float: TestArenaMap.MapInt32Float;
  mapInt32Double: TestArenaMap.MapInt32Double;
  mapBoolBool: TestArenaMap.MapBoolBool;
  mapStringString: TestArenaMap.MapStringString;
  mapInt32Bytes: TestArenaMap.MapInt32Bytes;
  mapInt32Enum: TestArenaMap.MapInt32Enum;
  mapInt32ForeignMessage: TestArenaMap.MapInt32ForeignMessage;
}

declare namespace TestArenaMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<bigint, bigint | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<bigint, bigint | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<bigint, bigint | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<bigint, bigint | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<bigint, bigint | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: MessageContainingMapCalledEntry.Entry;
}

declare namespace MessageContainingMapCalledEntry {
  export type Entry = Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: TestRecursiveMapMessage.A;
}

declare namespace TestRecursiveMapMessage {
  export type A = Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: \\"MAP_ENUM_FOO\\",
  MAP_ENUM_BAR: \\"MAP_ENUM_BAR\\",
  MAP_ENUM_BAZ: \\"MAP_ENUM_BAZ\\",
} as const;

const MapEnumFromInt = function (i: number): MapEnum {
  switch (i) {
    case 0: {
      return \\"MAP_ENUM_FOO\\";
    }
    case 1: {
      return \\"MAP_ENUM_BAR\\";
    }
    case 2: {
      return \\"MAP_ENUM_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as MapEnum;
    }
  }
};

const MapEnumToInt = function (i: MapEnum): number {
  switch (i) {
    case \\"MAP_ENUM_FOO\\": {
      return 0;
    }
    case \\"MAP_ENUM_BAR\\": {
      return 1;
    }
    case \\"MAP_ENUM_BAZ\\": {
      return 2;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (msg: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestMap>): string {
    return JSON.stringify(TestMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json: string): TestMap {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32ForeignMessage._writeMessage
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries<any>(msg.mapStringForeignMessage).map(
          ([key, value]) => ({ key: key, value: value })
        ) as any,
        TestMap.MapStringForeignMessage._writeMessage
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries<any>(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMap.MapInt32AllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries<any>(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries<any>(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    if (msg.mapStringForeignMessage) {
      const mapStringForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringForeignMessage).length > 0) {
        json.mapStringForeignMessage = mapStringForeignMessage;
      }
    }
    if (msg.mapInt32AllTypes) {
      const mapInt32AllTypes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32AllTypes).length > 0) {
        json.mapInt32AllTypes = mapInt32AllTypes;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {} as MapMessage<TestMap.MapInt32Int32>;
          reader.readMessage(mapInt32Int32, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {} as MapMessage<TestMap.MapInt64Int64>;
          reader.readMessage(mapInt64Int64, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 = {} as MapMessage<TestMap.MapUint32Uint32>;
          reader.readMessage(
            mapUint32Uint32,
            TestMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 = {} as MapMessage<TestMap.MapUint64Uint64>;
          reader.readMessage(
            mapUint64Uint64,
            TestMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 = {} as MapMessage<TestMap.MapSint32Sint32>;
          reader.readMessage(
            mapSint32Sint32,
            TestMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 = {} as MapMessage<TestMap.MapSint64Sint64>;
          reader.readMessage(
            mapSint64Sint64,
            TestMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 = {} as MapMessage<TestMap.MapFixed32Fixed32>;
          reader.readMessage(
            mapFixed32Fixed32,
            TestMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 = {} as MapMessage<TestMap.MapFixed64Fixed64>;
          reader.readMessage(
            mapFixed64Fixed64,
            TestMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 =
            {} as MapMessage<TestMap.MapSfixed32Sfixed32>;
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 =
            {} as MapMessage<TestMap.MapSfixed64Sfixed64>;
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {} as MapMessage<TestMap.MapInt32Float>;
          reader.readMessage(mapInt32Float, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {} as MapMessage<TestMap.MapInt32Double>;
          reader.readMessage(
            mapInt32Double,
            TestMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {} as MapMessage<TestMap.MapBoolBool>;
          reader.readMessage(mapBoolBool, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString = {} as MapMessage<TestMap.MapStringString>;
          reader.readMessage(
            mapStringString,
            TestMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {} as MapMessage<TestMap.MapInt32Bytes>;
          reader.readMessage(mapInt32Bytes, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {} as MapMessage<TestMap.MapInt32Enum>;
          reader.readMessage(mapInt32Enum, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage =
            {} as MapMessage<TestMap.MapInt32ForeignMessage>;
          reader.readMessage(
            mapInt32ForeignMessage,
            TestMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        case 18: {
          const mapStringForeignMessage =
            {} as MapMessage<TestMap.MapStringForeignMessage>;
          reader.readMessage(
            mapStringForeignMessage,
            TestMap.MapStringForeignMessage._readMessage
          );
          msg.mapStringForeignMessage[mapStringForeignMessage.key] =
            mapStringForeignMessage.value;
          break;
        }
        case 19: {
          const mapInt32AllTypes = {} as MapMessage<TestMap.MapInt32AllTypes>;
          reader.readMessage(
            mapInt32AllTypes,
            TestMap.MapInt32AllTypes._readMessage
          );
          msg.mapInt32AllTypes[mapInt32AllTypes.key] = mapInt32AllTypes.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMap, json: any): TestMap {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries<any>(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries<any>(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries<any>(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries<any>(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries<any>(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (_mapStringForeignMessage) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapStringForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (_mapInt32AllTypes) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries<any>(_mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMap.MapInt32AllTypes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Int32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Int32>,
      json: any
    ): MapMessage<TestMap.MapInt32Int32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt64Int64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt64Int64>,
      json: any
    ): MapMessage<TestMap.MapInt64Int64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapUint32Uint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapUint32Uint32>,
      json: any
    ): MapMessage<TestMap.MapUint32Uint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapUint64Uint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapUint64Uint64>,
      json: any
    ): MapMessage<TestMap.MapUint64Uint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSint32Sint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSint32Sint32>,
      json: any
    ): MapMessage<TestMap.MapSint32Sint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSint64Sint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSint64Sint64>,
      json: any
    ): MapMessage<TestMap.MapSint64Sint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapFixed32Fixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed32Fixed32>,
      json: any
    ): MapMessage<TestMap.MapFixed32Fixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapFixed64Fixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapFixed64Fixed64>,
      json: any
    ): MapMessage<TestMap.MapFixed64Fixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSfixed32Sfixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed32Sfixed32>,
      json: any
    ): MapMessage<TestMap.MapSfixed32Sfixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapSfixed64Sfixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapSfixed64Sfixed64>,
      json: any
    ): MapMessage<TestMap.MapSfixed64Sfixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Float> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Float>,
      json: any
    ): MapMessage<TestMap.MapInt32Float> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Double> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Double>,
      json: any
    ): MapMessage<TestMap.MapInt32Double> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapBoolBool> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapBoolBool>,
      json: any
    ): MapMessage<TestMap.MapBoolBool> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapStringString>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapStringString> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapStringString>,
      json: any
    ): MapMessage<TestMap.MapStringString> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Bytes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Bytes>,
      json: any
    ): MapMessage<TestMap.MapInt32Bytes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32Enum> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32Enum>,
      json: any
    ): MapMessage<TestMap.MapInt32Enum> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32ForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32ForeignMessage>,
      json: any
    ): MapMessage<TestMap.MapInt32ForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapStringForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapStringForeignMessage>,
      json: any
    ): MapMessage<TestMap.MapStringForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      reader: BinaryReader
    ): MapMessage<TestMap.MapInt32AllTypes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMap.MapInt32AllTypes>,
      json: any
    ): MapMessage<TestMap.MapInt32AllTypes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (msg: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestMapSubmessage>): string {
    return JSON.stringify(TestMapSubmessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json: string): TestMapSubmessage {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const _testMap = json.testMap ?? json.test_map;
    if (_testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, _testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestMessageMap {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestMessageMap.MapInt32Message._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      const mapInt32Message = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Message).length > 0) {
        json.mapInt32Message = mapInt32Message;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Message =
            {} as MapMessage<TestMessageMap.MapInt32Message>;
          reader.readMessage(
            mapInt32Message,
            TestMessageMap.MapInt32Message._readMessage
          );
          msg.mapInt32Message[mapInt32Message.key] = mapInt32Message.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMessageMap, json: any): TestMessageMap {
    const _mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (_mapInt32Message) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries<any>(_mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMap.MapInt32Message._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestAllTypes._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      reader: BinaryReader
    ): MapMessage<TestMessageMap.MapInt32Message> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestAllTypes.initialize(),
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestMessageMap.MapInt32Message>,
      json: any
    ): MapMessage<TestMessageMap.MapInt32Message> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (msg: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json: string): TestSameTypeMap {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestSameTypeMap.Map1._writeMessage
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestSameTypeMap.Map2._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      const map1 = Object.fromEntries(
        Object.entries<any>(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map1).length > 0) {
        json.map1 = map1;
      }
    }
    if (msg.map2) {
      const map2 = Object.fromEntries(
        Object.entries<any>(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(map2).length > 0) {
        json.map2 = map2;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map1 = {} as MapMessage<TestSameTypeMap.Map1>;
          reader.readMessage(map1, TestSameTypeMap.Map1._readMessage);
          msg.map1[map1.key] = map1.value;
          break;
        }
        case 2: {
          const map2 = {} as MapMessage<TestSameTypeMap.Map2>;
          reader.readMessage(map2, TestSameTypeMap.Map2._readMessage);
          msg.map2[map2.key] = map2.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestSameTypeMap,
    json: any
  ): TestSameTypeMap {
    const _map1 = json.map1;
    if (_map1) {
      msg.map1 = Object.fromEntries(
        Object.entries<any>(_map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map1._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _map2 = json.map2;
    if (_map2) {
      msg.map2 = Object.fromEntries(
        Object.entries<any>(_map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMap.Map2._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map1>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      reader: BinaryReader
    ): MapMessage<TestSameTypeMap.Map1> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map1>,
      json: any
    ): MapMessage<TestSameTypeMap.Map1> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map2>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      reader: BinaryReader
    ): MapMessage<TestSameTypeMap.Map2> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestSameTypeMap.Map2>,
      json: any
    ): MapMessage<TestSameTypeMap.Map2> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (msg: Partial<TestRequiredMessageMap>): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestRequiredMessageMap>): string {
    return JSON.stringify(TestRequiredMessageMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestRequiredMessageMap.MapField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      const mapField = Object.fromEntries(
        Object.entries<any>(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapField).length > 0) {
        json.mapField = mapField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapField = {} as MapMessage<TestRequiredMessageMap.MapField>;
          reader.readMessage(
            mapField,
            TestRequiredMessageMap.MapField._readMessage
          );
          msg.mapField[mapField.key] = mapField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const _mapField = json.mapField ?? json.map_field;
    if (_mapField) {
      msg.mapField = Object.fromEntries(
        Object.entries<any>(_mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMap.MapField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, TestRequired._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRequired._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      reader: BinaryReader
    ): MapMessage<TestRequiredMessageMap.MapField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRequired.initialize(),
              TestRequired._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestRequiredMessageMap.MapField>,
      json: any
    ): MapMessage<TestRequiredMessageMap.MapField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (msg: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (msg: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMap._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json: string): TestArenaMap {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Int32._writeMessage
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt64Int64._writeMessage
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapUint32Uint32._writeMessage
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapUint64Uint64._writeMessage
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSint32Sint32._writeMessage
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSint64Sint64._writeMessage
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapFixed32Fixed32._writeMessage
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapFixed64Fixed64._writeMessage
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSfixed32Sfixed32._writeMessage
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapSfixed64Sfixed64._writeMessage
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Float._writeMessage
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Double._writeMessage
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapBoolBool._writeMessage
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapStringString._writeMessage
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Bytes._writeMessage
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32Enum._writeMessage
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestArenaMap.MapInt32ForeignMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Int32).length > 0) {
        json.mapInt32Int32 = mapInt32Int32;
      }
    }
    if (msg.mapInt64Int64) {
      const mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt64Int64).length > 0) {
        json.mapInt64Int64 = mapInt64Int64;
      }
    }
    if (msg.mapUint32Uint32) {
      const mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint32Uint32).length > 0) {
        json.mapUint32Uint32 = mapUint32Uint32;
      }
    }
    if (msg.mapUint64Uint64) {
      const mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapUint64Uint64).length > 0) {
        json.mapUint64Uint64 = mapUint64Uint64;
      }
    }
    if (msg.mapSint32Sint32) {
      const mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint32Sint32).length > 0) {
        json.mapSint32Sint32 = mapSint32Sint32;
      }
    }
    if (msg.mapSint64Sint64) {
      const mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSint64Sint64).length > 0) {
        json.mapSint64Sint64 = mapSint64Sint64;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed32Fixed32).length > 0) {
        json.mapFixed32Fixed32 = mapFixed32Fixed32;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapFixed64Fixed64).length > 0) {
        json.mapFixed64Fixed64 = mapFixed64Fixed64;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed32Sfixed32).length > 0) {
        json.mapSfixed32Sfixed32 = mapSfixed32Sfixed32;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapSfixed64Sfixed64).length > 0) {
        json.mapSfixed64Sfixed64 = mapSfixed64Sfixed64;
      }
    }
    if (msg.mapInt32Float) {
      const mapInt32Float = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Float).length > 0) {
        json.mapInt32Float = mapInt32Float;
      }
    }
    if (msg.mapInt32Double) {
      const mapInt32Double = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Double).length > 0) {
        json.mapInt32Double = mapInt32Double;
      }
    }
    if (msg.mapBoolBool) {
      const mapBoolBool = Object.fromEntries(
        Object.entries<any>(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapBoolBool).length > 0) {
        json.mapBoolBool = mapBoolBool;
      }
    }
    if (msg.mapStringString) {
      const mapStringString = Object.fromEntries(
        Object.entries<any>(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapStringString).length > 0) {
        json.mapStringString = mapStringString;
      }
    }
    if (msg.mapInt32Bytes) {
      const mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Bytes).length > 0) {
        json.mapInt32Bytes = mapInt32Bytes;
      }
    }
    if (msg.mapInt32Enum) {
      const mapInt32Enum = Object.fromEntries(
        Object.entries<any>(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32Enum).length > 0) {
        json.mapInt32Enum = mapInt32Enum;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(mapInt32ForeignMessage).length > 0) {
        json.mapInt32ForeignMessage = mapInt32ForeignMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const mapInt32Int32 = {} as MapMessage<TestArenaMap.MapInt32Int32>;
          reader.readMessage(
            mapInt32Int32,
            TestArenaMap.MapInt32Int32._readMessage
          );
          msg.mapInt32Int32[mapInt32Int32.key] = mapInt32Int32.value;
          break;
        }
        case 2: {
          const mapInt64Int64 = {} as MapMessage<TestArenaMap.MapInt64Int64>;
          reader.readMessage(
            mapInt64Int64,
            TestArenaMap.MapInt64Int64._readMessage
          );
          msg.mapInt64Int64[mapInt64Int64.key] = mapInt64Int64.value;
          break;
        }
        case 3: {
          const mapUint32Uint32 =
            {} as MapMessage<TestArenaMap.MapUint32Uint32>;
          reader.readMessage(
            mapUint32Uint32,
            TestArenaMap.MapUint32Uint32._readMessage
          );
          msg.mapUint32Uint32[mapUint32Uint32.key] = mapUint32Uint32.value;
          break;
        }
        case 4: {
          const mapUint64Uint64 =
            {} as MapMessage<TestArenaMap.MapUint64Uint64>;
          reader.readMessage(
            mapUint64Uint64,
            TestArenaMap.MapUint64Uint64._readMessage
          );
          msg.mapUint64Uint64[mapUint64Uint64.key] = mapUint64Uint64.value;
          break;
        }
        case 5: {
          const mapSint32Sint32 =
            {} as MapMessage<TestArenaMap.MapSint32Sint32>;
          reader.readMessage(
            mapSint32Sint32,
            TestArenaMap.MapSint32Sint32._readMessage
          );
          msg.mapSint32Sint32[mapSint32Sint32.key] = mapSint32Sint32.value;
          break;
        }
        case 6: {
          const mapSint64Sint64 =
            {} as MapMessage<TestArenaMap.MapSint64Sint64>;
          reader.readMessage(
            mapSint64Sint64,
            TestArenaMap.MapSint64Sint64._readMessage
          );
          msg.mapSint64Sint64[mapSint64Sint64.key] = mapSint64Sint64.value;
          break;
        }
        case 7: {
          const mapFixed32Fixed32 =
            {} as MapMessage<TestArenaMap.MapFixed32Fixed32>;
          reader.readMessage(
            mapFixed32Fixed32,
            TestArenaMap.MapFixed32Fixed32._readMessage
          );
          msg.mapFixed32Fixed32[mapFixed32Fixed32.key] =
            mapFixed32Fixed32.value;
          break;
        }
        case 8: {
          const mapFixed64Fixed64 =
            {} as MapMessage<TestArenaMap.MapFixed64Fixed64>;
          reader.readMessage(
            mapFixed64Fixed64,
            TestArenaMap.MapFixed64Fixed64._readMessage
          );
          msg.mapFixed64Fixed64[mapFixed64Fixed64.key] =
            mapFixed64Fixed64.value;
          break;
        }
        case 9: {
          const mapSfixed32Sfixed32 =
            {} as MapMessage<TestArenaMap.MapSfixed32Sfixed32>;
          reader.readMessage(
            mapSfixed32Sfixed32,
            TestArenaMap.MapSfixed32Sfixed32._readMessage
          );
          msg.mapSfixed32Sfixed32[mapSfixed32Sfixed32.key] =
            mapSfixed32Sfixed32.value;
          break;
        }
        case 10: {
          const mapSfixed64Sfixed64 =
            {} as MapMessage<TestArenaMap.MapSfixed64Sfixed64>;
          reader.readMessage(
            mapSfixed64Sfixed64,
            TestArenaMap.MapSfixed64Sfixed64._readMessage
          );
          msg.mapSfixed64Sfixed64[mapSfixed64Sfixed64.key] =
            mapSfixed64Sfixed64.value;
          break;
        }
        case 11: {
          const mapInt32Float = {} as MapMessage<TestArenaMap.MapInt32Float>;
          reader.readMessage(
            mapInt32Float,
            TestArenaMap.MapInt32Float._readMessage
          );
          msg.mapInt32Float[mapInt32Float.key] = mapInt32Float.value;
          break;
        }
        case 12: {
          const mapInt32Double = {} as MapMessage<TestArenaMap.MapInt32Double>;
          reader.readMessage(
            mapInt32Double,
            TestArenaMap.MapInt32Double._readMessage
          );
          msg.mapInt32Double[mapInt32Double.key] = mapInt32Double.value;
          break;
        }
        case 13: {
          const mapBoolBool = {} as MapMessage<TestArenaMap.MapBoolBool>;
          reader.readMessage(
            mapBoolBool,
            TestArenaMap.MapBoolBool._readMessage
          );
          msg.mapBoolBool[mapBoolBool.key] = mapBoolBool.value;
          break;
        }
        case 14: {
          const mapStringString =
            {} as MapMessage<TestArenaMap.MapStringString>;
          reader.readMessage(
            mapStringString,
            TestArenaMap.MapStringString._readMessage
          );
          msg.mapStringString[mapStringString.key] = mapStringString.value;
          break;
        }
        case 15: {
          const mapInt32Bytes = {} as MapMessage<TestArenaMap.MapInt32Bytes>;
          reader.readMessage(
            mapInt32Bytes,
            TestArenaMap.MapInt32Bytes._readMessage
          );
          msg.mapInt32Bytes[mapInt32Bytes.key] = mapInt32Bytes.value;
          break;
        }
        case 16: {
          const mapInt32Enum = {} as MapMessage<TestArenaMap.MapInt32Enum>;
          reader.readMessage(
            mapInt32Enum,
            TestArenaMap.MapInt32Enum._readMessage
          );
          msg.mapInt32Enum[mapInt32Enum.key] = mapInt32Enum.value;
          break;
        }
        case 17: {
          const mapInt32ForeignMessage =
            {} as MapMessage<TestArenaMap.MapInt32ForeignMessage>;
          reader.readMessage(
            mapInt32ForeignMessage,
            TestArenaMap.MapInt32ForeignMessage._readMessage
          );
          msg.mapInt32ForeignMessage[mapInt32ForeignMessage.key] =
            mapInt32ForeignMessage.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestArenaMap, json: any): TestArenaMap {
    const _mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (_mapInt32Int32) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries<any>(_mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Int32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (_mapInt64Int64) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries<any>(_mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt64Int64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (_mapUint32Uint32) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries<any>(_mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint32Uint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (_mapUint64Uint64) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries<any>(_mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapUint64Uint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (_mapSint32Sint32) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries<any>(_mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint32Sint32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (_mapSint64Sint64) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries<any>(_mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSint64Sint64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (_mapFixed32Fixed32) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries<any>(_mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed32Fixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (_mapFixed64Fixed64) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries<any>(_mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapFixed64Fixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (_mapSfixed32Sfixed32) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries<any>(_mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed32Sfixed32._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (_mapSfixed64Sfixed64) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries<any>(_mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapSfixed64Sfixed64._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (_mapInt32Float) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries<any>(_mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Float._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (_mapInt32Double) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries<any>(_mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Double._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (_mapBoolBool) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries<any>(_mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapBoolBool._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapStringString = json.mapStringString ?? json.map_string_string;
    if (_mapStringString) {
      msg.mapStringString = Object.fromEntries(
        Object.entries<any>(_mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapStringString._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (_mapInt32Bytes) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries<any>(_mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Bytes._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (_mapInt32Enum) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries<any>(_mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32Enum._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (_mapInt32ForeignMessage) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries<any>(_mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMap.MapInt32ForeignMessage._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Int32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Int32>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Int32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt64Int64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt64Int64>,
      json: any
    ): MapMessage<TestArenaMap.MapInt64Int64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapUint32Uint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint32Uint32>,
      json: any
    ): MapMessage<TestArenaMap.MapUint32Uint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapUint64Uint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapUint64Uint64>,
      json: any
    ): MapMessage<TestArenaMap.MapUint64Uint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSint32Sint32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint32Sint32>,
      json: any
    ): MapMessage<TestArenaMap.MapSint32Sint32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSint64Sint64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSint64Sint64>,
      json: any
    ): MapMessage<TestArenaMap.MapSint64Sint64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapFixed32Fixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed32Fixed32>,
      json: any
    ): MapMessage<TestArenaMap.MapFixed32Fixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapFixed64Fixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapFixed64Fixed64>,
      json: any
    ): MapMessage<TestArenaMap.MapFixed64Fixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSfixed32Sfixed32> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed32Sfixed32>,
      json: any
    ): MapMessage<TestArenaMap.MapSfixed32Sfixed32> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key.toString();
      }
      if (msg.value) {
        json.value = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapSfixed64Sfixed64> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapSfixed64Sfixed64>,
      json: any
    ): MapMessage<TestArenaMap.MapSfixed64Sfixed64> {
      const _key = json.key;
      if (_key) {
        msg.key = BigInt(_key);
      }
      const _value = json.value;
      if (_value) {
        msg.value = BigInt(_value);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Float> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Float>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Float> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Double> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Double>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Double> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapBoolBool> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapBoolBool>,
      json: any
    ): MapMessage<TestArenaMap.MapBoolBool> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapStringString>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapStringString> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapStringString>,
      json: any
    ): MapMessage<TestArenaMap.MapStringString> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value?.length) {
        json.value = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Bytes> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Bytes>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Bytes> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = decodeBase64Bytes(_value);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        writer.writeEnum(2, MapEnumToInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value && MapEnumToInt(msg.value)) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32Enum> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnumFromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32Enum>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32Enum> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, ForeignMessage._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = ForeignMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      reader: BinaryReader
    ): MapMessage<TestArenaMap.MapInt32ForeignMessage> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              ForeignMessage.initialize(),
              ForeignMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestArenaMap.MapInt32ForeignMessage>,
      json: any
    ): MapMessage<TestArenaMap.MapInt32ForeignMessage> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg: Partial<MessageContainingMapCalledEntry>): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (msg: Partial<MessageContainingMapCalledEntry>): string {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(msg)
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MessageContainingMapCalledEntry.Entry._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      const entry = Object.fromEntries(
        Object.entries<any>(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(entry).length > 0) {
        json.entry = entry;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const entry = {} as MapMessage<MessageContainingMapCalledEntry.Entry>;
          reader.readMessage(
            entry,
            MessageContainingMapCalledEntry.Entry._readMessage
          );
          msg.entry[entry.key] = entry.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const _entry = json.entry;
    if (_entry) {
      msg.entry = Object.fromEntries(
        Object.entries<any>(_entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntry.Entry._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        json.value = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      reader: BinaryReader
    ): MapMessage<MessageContainingMapCalledEntry.Entry> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MessageContainingMapCalledEntry.Entry>,
      json: any
    ): MapMessage<MessageContainingMapCalledEntry.Entry> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        msg.value = _value;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg: Partial<TestRecursiveMapMessage>): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (msg: Partial<TestRecursiveMapMessage>): string {
    return JSON.stringify(TestRecursiveMapMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        TestRecursiveMapMessage.A._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = Object.fromEntries(
        Object.entries<any>(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const a = {} as MapMessage<TestRecursiveMapMessage.A>;
          reader.readMessage(a, TestRecursiveMapMessage.A._readMessage);
          msg.a[a.key] = a.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const _a = json.a;
    if (_a) {
      msg.a = Object.fromEntries(
        Object.entries<any>(_a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessage.A._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<TestRecursiveMapMessage.A>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = TestRecursiveMapMessage._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      reader: BinaryReader
    ): MapMessage<TestRecursiveMapMessage.A> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              TestRecursiveMapMessage.initialize(),
              TestRecursiveMapMessage._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<TestRecursiveMapMessage.A>,
      json: any
    ): MapMessage<TestRecursiveMapMessage.A> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = TestRecursiveMapMessage.initialize();
        TestRecursiveMapMessage._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/any.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/any.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`Any\` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 *  Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 *  Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type
 * name \\"y.z\\".
 *
 *
 * JSON
 * ====
 * The JSON representation of an \`Any\` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field \`@type\` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",
 *       \\"firstName\\": <string>,
 *       \\"lastName\\": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * \`value\` which holds the custom JSON in addition to the \`@type\`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",
 *       \\"value\\": \\"1.212s\\"
 *     }
 *
 */
export interface Any {
  /**
   * A URL/resource name that uniquely identifies the type of the serialized
   * protocol buffer message. This string must contain at least
   * one \\"/\\" character. The last segment of the URL's path must represent
   * the fully qualified name of the type (as in
   * \`path/google.protobuf.Duration\`). The name should be in a canonical form
   * (e.g., leading \\".\\" is not accepted).
   *
   * In practice, teams usually precompile into the binary all types that they
   * expect it to use in the context of Any. However, for URLs which use the
   * scheme \`http\`, \`https\`, or no scheme, one can optionally set up a type
   * server that maps type URLs to message definitions as follows:
   *
   * * If no scheme is provided, \`https\` is assumed.
   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
   *   value in binary format, or produce an error.
   * * Applications are allowed to cache lookup results based on the
   *   URL, or have them precompiled into a binary to avoid any
   *   lookup. Therefore, binary compatibility needs to be preserved
   *   on changes to types. (Use versioned type names to manage
   *   breaking changes.)
   *
   * Note: this functionality is not currently available in the official
   * protobuf release, and it is not used for type URLs beginning with
   * type.googleapis.com.
   *
   * Schemes other than \`http\`, \`https\` (or the empty scheme) might be
   * used with implementation specific semantics.
   *
   */
  typeUrl: string;
  /**
   * Must be a valid serialized protocol buffer of the above specified type.
   */
  value: Uint8Array;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Any = {
  /**
   * Serializes a Any to protobuf.
   */
  encode: function (msg: Partial<Any>): Uint8Array {
    return Any._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Any from protobuf.
   */
  decode: function (bytes: ByteSource): Any {
    return Any._readMessage(Any.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Any to JSON.
   */
  encodeJSON: function (msg: Partial<Any>): string {
    return JSON.stringify(Any._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Any from JSON.
   */
  decodeJSON: function (json: string): Any {
    return Any._readMessageJSON(Any.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Any with all fields set to their default value.
   */
  initialize: function (): Any {
    return {
      typeUrl: \\"\\",
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Any>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.typeUrl) {
      writer.writeString(1, msg.typeUrl);
    }
    if (msg.value?.length) {
      writer.writeBytes(2, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Any>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Any, reader: BinaryReader): Any {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 2: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Any, json: any): Any {
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/source_context.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/source_context.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`SourceContext\` represents information about the source of a
 * protobuf element, like the file in which it is defined.
 */
export interface SourceContext {
  /**
   * The path-qualified name of the .proto file that contained the associated
   * protobuf element.  For example: \`\\"google/protobuf/source_context.proto\\"\`.
   */
  fileName: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SourceContext = {
  /**
   * Serializes a SourceContext to protobuf.
   */
  encode: function (msg: Partial<SourceContext>): Uint8Array {
    return SourceContext._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SourceContext from protobuf.
   */
  decode: function (bytes: ByteSource): SourceContext {
    return SourceContext._readMessage(
      SourceContext.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SourceContext to JSON.
   */
  encodeJSON: function (msg: Partial<SourceContext>): string {
    return JSON.stringify(SourceContext._writeMessageJSON(msg));
  },

  /**
   * Deserializes a SourceContext from JSON.
   */
  decodeJSON: function (json: string): SourceContext {
    return SourceContext._readMessageJSON(
      SourceContext.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SourceContext with all fields set to their default value.
   */
  initialize: function (): SourceContext {
    return {
      fileName: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SourceContext>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fileName) {
      writer.writeString(1, msg.fileName);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SourceContext>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fileName) {
      json.fileName = msg.fileName;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SourceContext,
    reader: BinaryReader
  ): SourceContext {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fileName = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: SourceContext, json: any): SourceContext {
    const _fileName = json.fileName ?? json.file_name;
    if (_fileName) {
      msg.fileName = _fileName;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/type.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/type.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { SourceContext } from \\"./source_context.pb\\";
import { Any } from \\"./any.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * The syntax in which a protocol buffer element is defined.
 */
export type Syntax = \\"SYNTAX_PROTO2\\" | \\"SYNTAX_PROTO3\\";

/**
 * A protocol buffer message type.
 */
export interface Type {
  /**
   * The fully qualified message name.
   */
  name: string;
  /**
   * The list of fields.
   */
  fields: Field[];
  /**
   * The list of types appearing in \`oneof\` definitions in this type.
   */
  oneofs: string[];
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * A single field of a message type.
 */
export interface Field {
  /**
   * The field type.
   */
  kind: Field.Kind;
  /**
   * The field cardinality.
   */
  cardinality: Field.Cardinality;
  /**
   * The field number.
   */
  number: number;
  /**
   * The field name.
   */
  name: string;
  /**
   * The field type URL, without the scheme, for message or enumeration
   * types. Example: \`\\"type.googleapis.com/google.protobuf.Timestamp\\"\`.
   */
  typeUrl: string;
  /**
   * The index of the field type in \`Type.oneofs\`, for message or enumeration
   * types. The first type has index 1; zero means the type is not in the list.
   */
  oneofIndex: number;
  /**
   * Whether to use alternative packed wire representation.
   */
  packed: boolean;
  /**
   * The protocol buffer options.
   */
  options: Option[];
  /**
   * The field JSON name.
   */
  jsonName: string;
  /**
   * The string value of the default value of this field. Proto2 syntax only.
   */
  defaultValue: string;
}

declare namespace Field {
  /**
   * Basic field types.
   */
  export type Kind =
    | \\"TYPE_UNKNOWN\\"
    | \\"TYPE_DOUBLE\\"
    | \\"TYPE_FLOAT\\"
    | \\"TYPE_INT64\\"
    | \\"TYPE_UINT64\\"
    | \\"TYPE_INT32\\"
    | \\"TYPE_FIXED64\\"
    | \\"TYPE_FIXED32\\"
    | \\"TYPE_BOOL\\"
    | \\"TYPE_STRING\\"
    | \\"TYPE_GROUP\\"
    | \\"TYPE_MESSAGE\\"
    | \\"TYPE_BYTES\\"
    | \\"TYPE_UINT32\\"
    | \\"TYPE_ENUM\\"
    | \\"TYPE_SFIXED32\\"
    | \\"TYPE_SFIXED64\\"
    | \\"TYPE_SINT32\\"
    | \\"TYPE_SINT64\\";

  /**
   * Whether a field is optional, required, or repeated.
   */
  export type Cardinality =
    | \\"CARDINALITY_UNKNOWN\\"
    | \\"CARDINALITY_OPTIONAL\\"
    | \\"CARDINALITY_REQUIRED\\"
    | \\"CARDINALITY_REPEATED\\";
}

/**
 * Enum type definition.
 */
export interface Enum {
  /**
   * Enum type name.
   */
  name: string;
  /**
   * Enum value definitions.
   */
  enumvalue: EnumValue[];
  /**
   * Protocol buffer options.
   */
  options: Option[];
  /**
   * The source context.
   */
  sourceContext: SourceContext;
  /**
   * The source syntax.
   */
  syntax: Syntax;
}

/**
 * Enum value definition.
 */
export interface EnumValue {
  /**
   * Enum value name.
   */
  name: string;
  /**
   * Enum value number.
   */
  number: number;
  /**
   * Protocol buffer options.
   */
  options: Option[];
}

/**
 * A protocol buffer option, which can be attached to a message, field,
 * enumeration, etc.
 */
export interface Option {
  /**
   * The option's name. For protobuf built-in options (options defined in
   * descriptor.proto), this is the short name. For example, \`\\"map_entry\\"\`.
   * For custom options, it should be the fully-qualified name. For example,
   * \`\\"google.api.http\\"\`.
   */
  name: string;
  /**
   * The option's value packed in an Any message. If the value is a primitive,
   * the corresponding wrapper type defined in google/protobuf/wrappers.proto
   * should be used. If the value is an enum, it should be stored as an int32
   * value using the google.protobuf.Int32Value type.
   */
  value: Any;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Syntax = {
  /**
   * Syntax \`proto2\`.
   */
  SYNTAX_PROTO2: \\"SYNTAX_PROTO2\\",
  /**
   * Syntax \`proto3\`.
   */
  SYNTAX_PROTO3: \\"SYNTAX_PROTO3\\",
} as const;

const SyntaxFromInt = function (i: number): Syntax {
  switch (i) {
    case 0: {
      return \\"SYNTAX_PROTO2\\";
    }
    case 1: {
      return \\"SYNTAX_PROTO3\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as Syntax;
    }
  }
};

const SyntaxToInt = function (i: Syntax): number {
  switch (i) {
    case \\"SYNTAX_PROTO2\\": {
      return 0;
    }
    case \\"SYNTAX_PROTO3\\": {
      return 1;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Type = {
  /**
   * Serializes a Type to protobuf.
   */
  encode: function (msg: Partial<Type>): Uint8Array {
    return Type._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Type from protobuf.
   */
  decode: function (bytes: ByteSource): Type {
    return Type._readMessage(Type.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Type to JSON.
   */
  encodeJSON: function (msg: Partial<Type>): string {
    return JSON.stringify(Type._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Type from JSON.
   */
  decodeJSON: function (json: string): Type {
    return Type._readMessageJSON(Type.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Type with all fields set to their default value.
   */
  initialize: function (): Type {
    return {
      name: \\"\\",
      fields: [],
      oneofs: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Type>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.fields?.length) {
      writer.writeRepeatedMessage(2, msg.fields as any, Field._writeMessage);
    }
    if (msg.oneofs?.length) {
      writer.writeRepeatedString(3, msg.oneofs);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(4, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(6, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Type>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.fields?.length) {
      json.fields = msg.fields.map(Field._writeMessageJSON);
    }
    if (msg.oneofs?.length) {
      json.oneofs = msg.oneofs;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Type, reader: BinaryReader): Type {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Field.initialize();
          reader.readMessage(m, Field._readMessage);
          msg.fields.push(m);
          break;
        }
        case 3: {
          msg.oneofs.push(reader.readString());
          break;
        }
        case 4: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Type, json: any): Type {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _fields = json.fields;
    if (_fields) {
      for (const item of _fields) {
        const m = Field.initialize();
        Field._readMessageJSON(m, item);
        msg.fields.push(m);
      }
    }
    const _oneofs = json.oneofs;
    if (_oneofs) {
      msg.oneofs = _oneofs;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Field = {
  /**
   * Serializes a Field to protobuf.
   */
  encode: function (msg: Partial<Field>): Uint8Array {
    return Field._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Field from protobuf.
   */
  decode: function (bytes: ByteSource): Field {
    return Field._readMessage(Field.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Field to JSON.
   */
  encodeJSON: function (msg: Partial<Field>): string {
    return JSON.stringify(Field._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Field from JSON.
   */
  decodeJSON: function (json: string): Field {
    return Field._readMessageJSON(Field.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Field with all fields set to their default value.
   */
  initialize: function (): Field {
    return {
      kind: Field.KindFromInt(0),
      cardinality: Field.CardinalityFromInt(0),
      number: 0,
      name: \\"\\",
      typeUrl: \\"\\",
      oneofIndex: 0,
      packed: false,
      options: [],
      jsonName: \\"\\",
      defaultValue: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Field>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.kind && Field.KindToInt(msg.kind)) {
      writer.writeEnum(1, Field.KindToInt(msg.kind));
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      writer.writeEnum(2, Field.CardinalityToInt(msg.cardinality));
    }
    if (msg.number) {
      writer.writeInt32(3, msg.number);
    }
    if (msg.name) {
      writer.writeString(4, msg.name);
    }
    if (msg.typeUrl) {
      writer.writeString(6, msg.typeUrl);
    }
    if (msg.oneofIndex) {
      writer.writeInt32(7, msg.oneofIndex);
    }
    if (msg.packed) {
      writer.writeBool(8, msg.packed);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(9, msg.options as any, Option._writeMessage);
    }
    if (msg.jsonName) {
      writer.writeString(10, msg.jsonName);
    }
    if (msg.defaultValue) {
      writer.writeString(11, msg.defaultValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Field>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.kind && Field.KindToInt(msg.kind)) {
      json.kind = msg.kind;
    }
    if (msg.cardinality && Field.CardinalityToInt(msg.cardinality)) {
      json.cardinality = msg.cardinality;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.typeUrl) {
      json.typeUrl = msg.typeUrl;
    }
    if (msg.oneofIndex) {
      json.oneofIndex = msg.oneofIndex;
    }
    if (msg.packed) {
      json.packed = msg.packed;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.jsonName) {
      json.jsonName = msg.jsonName;
    }
    if (msg.defaultValue) {
      json.defaultValue = msg.defaultValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Field, reader: BinaryReader): Field {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.kind = Field.KindFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.cardinality = Field.CardinalityFromInt(reader.readEnum());
          break;
        }
        case 3: {
          msg.number = reader.readInt32();
          break;
        }
        case 4: {
          msg.name = reader.readString();
          break;
        }
        case 6: {
          msg.typeUrl = reader.readString();
          break;
        }
        case 7: {
          msg.oneofIndex = reader.readInt32();
          break;
        }
        case 8: {
          msg.packed = reader.readBool();
          break;
        }
        case 9: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 10: {
          msg.jsonName = reader.readString();
          break;
        }
        case 11: {
          msg.defaultValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Field, json: any): Field {
    const _kind = json.kind;
    if (_kind) {
      msg.kind = _kind;
    }
    const _cardinality = json.cardinality;
    if (_cardinality) {
      msg.cardinality = _cardinality;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _typeUrl = json.typeUrl ?? json.type_url;
    if (_typeUrl) {
      msg.typeUrl = _typeUrl;
    }
    const _oneofIndex = json.oneofIndex ?? json.oneof_index;
    if (_oneofIndex) {
      msg.oneofIndex = _oneofIndex;
    }
    const _packed = json.packed;
    if (_packed) {
      msg.packed = _packed;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _jsonName = json.jsonName ?? json.json_name;
    if (_jsonName) {
      msg.jsonName = _jsonName;
    }
    const _defaultValue = json.defaultValue ?? json.default_value;
    if (_defaultValue) {
      msg.defaultValue = _defaultValue;
    }
    return msg;
  },

  Kind: {
    /**
     * Field type unknown.
     */
    TYPE_UNKNOWN: \\"TYPE_UNKNOWN\\",
    /**
     * Field type double.
     */
    TYPE_DOUBLE: \\"TYPE_DOUBLE\\",
    /**
     * Field type float.
     */
    TYPE_FLOAT: \\"TYPE_FLOAT\\",
    /**
     * Field type int64.
     */
    TYPE_INT64: \\"TYPE_INT64\\",
    /**
     * Field type uint64.
     */
    TYPE_UINT64: \\"TYPE_UINT64\\",
    /**
     * Field type int32.
     */
    TYPE_INT32: \\"TYPE_INT32\\",
    /**
     * Field type fixed64.
     */
    TYPE_FIXED64: \\"TYPE_FIXED64\\",
    /**
     * Field type fixed32.
     */
    TYPE_FIXED32: \\"TYPE_FIXED32\\",
    /**
     * Field type bool.
     */
    TYPE_BOOL: \\"TYPE_BOOL\\",
    /**
     * Field type string.
     */
    TYPE_STRING: \\"TYPE_STRING\\",
    /**
     * Field type group. Proto2 syntax only, and deprecated.
     */
    TYPE_GROUP: \\"TYPE_GROUP\\",
    /**
     * Field type message.
     */
    TYPE_MESSAGE: \\"TYPE_MESSAGE\\",
    /**
     * Field type bytes.
     */
    TYPE_BYTES: \\"TYPE_BYTES\\",
    /**
     * Field type uint32.
     */
    TYPE_UINT32: \\"TYPE_UINT32\\",
    /**
     * Field type enum.
     */
    TYPE_ENUM: \\"TYPE_ENUM\\",
    /**
     * Field type sfixed32.
     */
    TYPE_SFIXED32: \\"TYPE_SFIXED32\\",
    /**
     * Field type sfixed64.
     */
    TYPE_SFIXED64: \\"TYPE_SFIXED64\\",
    /**
     * Field type sint32.
     */
    TYPE_SINT32: \\"TYPE_SINT32\\",
    /**
     * Field type sint64.
     */
    TYPE_SINT64: \\"TYPE_SINT64\\",
  } as const,

  KindFromInt: function (i: number): Field.Kind {
    switch (i) {
      case 0: {
        return \\"TYPE_UNKNOWN\\";
      }
      case 1: {
        return \\"TYPE_DOUBLE\\";
      }
      case 2: {
        return \\"TYPE_FLOAT\\";
      }
      case 3: {
        return \\"TYPE_INT64\\";
      }
      case 4: {
        return \\"TYPE_UINT64\\";
      }
      case 5: {
        return \\"TYPE_INT32\\";
      }
      case 6: {
        return \\"TYPE_FIXED64\\";
      }
      case 7: {
        return \\"TYPE_FIXED32\\";
      }
      case 8: {
        return \\"TYPE_BOOL\\";
      }
      case 9: {
        return \\"TYPE_STRING\\";
      }
      case 10: {
        return \\"TYPE_GROUP\\";
      }
      case 11: {
        return \\"TYPE_MESSAGE\\";
      }
      case 12: {
        return \\"TYPE_BYTES\\";
      }
      case 13: {
        return \\"TYPE_UINT32\\";
      }
      case 14: {
        return \\"TYPE_ENUM\\";
      }
      case 15: {
        return \\"TYPE_SFIXED32\\";
      }
      case 16: {
        return \\"TYPE_SFIXED64\\";
      }
      case 17: {
        return \\"TYPE_SINT32\\";
      }
      case 18: {
        return \\"TYPE_SINT64\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Field.Kind;
      }
    }
  },

  KindToInt: function (i: Field.Kind): number {
    switch (i) {
      case \\"TYPE_UNKNOWN\\": {
        return 0;
      }
      case \\"TYPE_DOUBLE\\": {
        return 1;
      }
      case \\"TYPE_FLOAT\\": {
        return 2;
      }
      case \\"TYPE_INT64\\": {
        return 3;
      }
      case \\"TYPE_UINT64\\": {
        return 4;
      }
      case \\"TYPE_INT32\\": {
        return 5;
      }
      case \\"TYPE_FIXED64\\": {
        return 6;
      }
      case \\"TYPE_FIXED32\\": {
        return 7;
      }
      case \\"TYPE_BOOL\\": {
        return 8;
      }
      case \\"TYPE_STRING\\": {
        return 9;
      }
      case \\"TYPE_GROUP\\": {
        return 10;
      }
      case \\"TYPE_MESSAGE\\": {
        return 11;
      }
      case \\"TYPE_BYTES\\": {
        return 12;
      }
      case \\"TYPE_UINT32\\": {
        return 13;
      }
      case \\"TYPE_ENUM\\": {
        return 14;
      }
      case \\"TYPE_SFIXED32\\": {
        return 15;
      }
      case \\"TYPE_SFIXED64\\": {
        return 16;
      }
      case \\"TYPE_SINT32\\": {
        return 17;
      }
      case \\"TYPE_SINT64\\": {
        return 18;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  Cardinality: {
    /**
     * For fields with unknown cardinality.
     */
    CARDINALITY_UNKNOWN: \\"CARDINALITY_UNKNOWN\\",
    /**
     * For optional fields.
     */
    CARDINALITY_OPTIONAL: \\"CARDINALITY_OPTIONAL\\",
    /**
     * For required fields. Proto2 syntax only.
     */
    CARDINALITY_REQUIRED: \\"CARDINALITY_REQUIRED\\",
    /**
     * For repeated fields.
     */
    CARDINALITY_REPEATED: \\"CARDINALITY_REPEATED\\",
  } as const,

  CardinalityFromInt: function (i: number): Field.Cardinality {
    switch (i) {
      case 0: {
        return \\"CARDINALITY_UNKNOWN\\";
      }
      case 1: {
        return \\"CARDINALITY_OPTIONAL\\";
      }
      case 2: {
        return \\"CARDINALITY_REQUIRED\\";
      }
      case 3: {
        return \\"CARDINALITY_REPEATED\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as Field.Cardinality;
      }
    }
  },

  CardinalityToInt: function (i: Field.Cardinality): number {
    switch (i) {
      case \\"CARDINALITY_UNKNOWN\\": {
        return 0;
      }
      case \\"CARDINALITY_OPTIONAL\\": {
        return 1;
      }
      case \\"CARDINALITY_REQUIRED\\": {
        return 2;
      }
      case \\"CARDINALITY_REPEATED\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};

export const Enum = {
  /**
   * Serializes a Enum to protobuf.
   */
  encode: function (msg: Partial<Enum>): Uint8Array {
    return Enum._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Enum from protobuf.
   */
  decode: function (bytes: ByteSource): Enum {
    return Enum._readMessage(Enum.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Enum to JSON.
   */
  encodeJSON: function (msg: Partial<Enum>): string {
    return JSON.stringify(Enum._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Enum from JSON.
   */
  decodeJSON: function (json: string): Enum {
    return Enum._readMessageJSON(Enum.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Enum with all fields set to their default value.
   */
  initialize: function (): Enum {
    return {
      name: \\"\\",
      enumvalue: [],
      options: [],
      sourceContext: SourceContext.initialize(),
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Enum>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.enumvalue?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.enumvalue as any,
        EnumValue._writeMessage
      );
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    if (msg.sourceContext) {
      writer.writeMessage(4, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(5, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Enum>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.enumvalue?.length) {
      json.enumvalue = msg.enumvalue.map(EnumValue._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Enum, reader: BinaryReader): Enum {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = EnumValue.initialize();
          reader.readMessage(m, EnumValue._readMessage);
          msg.enumvalue.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 5: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Enum, json: any): Enum {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _enumvalue = json.enumvalue;
    if (_enumvalue) {
      for (const item of _enumvalue) {
        const m = EnumValue.initialize();
        EnumValue._readMessageJSON(m, item);
        msg.enumvalue.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const EnumValue = {
  /**
   * Serializes a EnumValue to protobuf.
   */
  encode: function (msg: Partial<EnumValue>): Uint8Array {
    return EnumValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a EnumValue from protobuf.
   */
  decode: function (bytes: ByteSource): EnumValue {
    return EnumValue._readMessage(
      EnumValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a EnumValue to JSON.
   */
  encodeJSON: function (msg: Partial<EnumValue>): string {
    return JSON.stringify(EnumValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a EnumValue from JSON.
   */
  decodeJSON: function (json: string): EnumValue {
    return EnumValue._readMessageJSON(EnumValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a EnumValue with all fields set to their default value.
   */
  initialize: function (): EnumValue {
    return {
      name: \\"\\",
      number: 0,
      options: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<EnumValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.number) {
      writer.writeInt32(2, msg.number);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<EnumValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.number) {
      json.number = msg.number;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: EnumValue, reader: BinaryReader): EnumValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.number = reader.readInt32();
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: EnumValue, json: any): EnumValue {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _number = json.number;
    if (_number) {
      msg.number = _number;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    return msg;
  },
};

export const Option = {
  /**
   * Serializes a Option to protobuf.
   */
  encode: function (msg: Partial<Option>): Uint8Array {
    return Option._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Option from protobuf.
   */
  decode: function (bytes: ByteSource): Option {
    return Option._readMessage(Option.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Option to JSON.
   */
  encodeJSON: function (msg: Partial<Option>): string {
    return JSON.stringify(Option._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Option from JSON.
   */
  decodeJSON: function (json: string): Option {
    return Option._readMessageJSON(Option.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Option with all fields set to their default value.
   */
  initialize: function (): Option {
    return {
      name: \\"\\",
      value: Any.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Option>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.value) {
      writer.writeMessage(2, msg.value, Any._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Option>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.value) {
      const value = Any._writeMessageJSON(msg.value);
      if (Object.keys(value).length > 0) {
        json.value = value;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Option, reader: BinaryReader): Option {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.value, Any._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Option, json: any): Option {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _value = json.value;
    if (_value) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _value);
      msg.value = m;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/api.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/api.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Option, Syntax } from \\"./type.pb\\";
import { SourceContext } from \\"./source_context.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Api is a light-weight descriptor for an API Interface.
 *
 * Interfaces are also described as \\"protocol buffer services\\" in some contexts,
 * such as by the \\"service\\" keyword in a .proto file, but they are different
 * from API Services, which represent a concrete implementation of an interface
 * as opposed to simply a description of methods and bindings. They are also
 * sometimes simply referred to as \\"APIs\\" in other contexts, such as the name of
 * this message itself. See https://cloud.google.com/apis/design/glossary for
 * detailed terminology.
 */
export interface Api {
  /**
   * The fully qualified name of this interface, including package name
   * followed by the interface's simple name.
   */
  name: string;
  /**
   * The methods of this interface, in unspecified order.
   */
  methods: Method[];
  /**
   * Any metadata attached to the interface.
   */
  options: Option[];
  /**
   * A version string for this interface. If specified, must have the form
   * \`major-version.minor-version\`, as in \`1.10\`. If the minor version is
   * omitted, it defaults to zero. If the entire version field is empty, the
   * major version is derived from the package name, as outlined below. If the
   * field is not empty, the version in the package name will be verified to be
   * consistent with what is provided here.
   *
   * The versioning schema uses [semantic
   * versioning](http://semver.org) where the major version number
   * indicates a breaking change and the minor version an additive,
   * non-breaking change. Both version numbers are signals to users
   * what to expect from different versions, and should be carefully
   * chosen based on the product plan.
   *
   * The major version is also reflected in the package name of the
   * interface, which must end in \`v<major-version>\`, as in
   * \`google.feature.v1\`. For major versions 0 and 1, the suffix can
   * be omitted. Zero major versions must only be used for
   * experimental, non-GA interfaces.
   *
   *
   */
  version: string;
  /**
   * Source context for the protocol buffer service represented by this
   * message.
   */
  sourceContext: SourceContext;
  /**
   * Included interfaces. See [Mixin][].
   */
  mixins: Mixin[];
  /**
   * The source syntax of the service.
   */
  syntax: Syntax;
}

/**
 * Method represents a method of an API interface.
 */
export interface Method {
  /**
   * The simple name of this method.
   */
  name: string;
  /**
   * A URL of the input message type.
   */
  requestTypeUrl: string;
  /**
   * If true, the request is streamed.
   */
  requestStreaming: boolean;
  /**
   * The URL of the output message type.
   */
  responseTypeUrl: string;
  /**
   * If true, the response is streamed.
   */
  responseStreaming: boolean;
  /**
   * Any metadata attached to the method.
   */
  options: Option[];
  /**
   * The source syntax of this method.
   */
  syntax: Syntax;
}

/**
 * Declares an API Interface to be included in this interface. The including
 * interface must redeclare all the methods from the included interface, but
 * documentation and options are inherited as follows:
 *
 * - If after comment and whitespace stripping, the documentation
 *   string of the redeclared method is empty, it will be inherited
 *   from the original method.
 *
 * - Each annotation belonging to the service config (http,
 *   visibility) which is not set in the redeclared method will be
 *   inherited.
 *
 * - If an http annotation is inherited, the path pattern will be
 *   modified as follows. Any version prefix will be replaced by the
 *   version of the including interface plus the [root][] path if
 *   specified.
 *
 * Example of a simple mixin:
 *
 *     package google.acl.v1;
 *     service AccessControl {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v1/{resource=**}:getAcl\\";
 *       }
 *     }
 *
 *     package google.storage.v2;
 *     service Storage {
 *       rpc GetAcl(GetAclRequest) returns (Acl);
 *
 *       // Get a data record.
 *       rpc GetData(GetDataRequest) returns (Data) {
 *         option (google.api.http).get = \\"/v2/{resource=**}\\";
 *       }
 *     }
 *
 * Example of a mixin configuration:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *
 * The mixin construct implies that all methods in \`AccessControl\` are
 * also declared with same name and request/response types in
 * \`Storage\`. A documentation generator or annotation processor will
 * see the effective \`Storage.GetAcl\` method after inheriting
 * documentation and annotations as follows:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v2/{resource=**}:getAcl\\";
 *       }
 *       ...
 *     }
 *
 * Note how the version in the path pattern changed from \`v1\` to \`v2\`.
 *
 * If the \`root\` field in the mixin is specified, it should be a
 * relative path under which inherited HTTP paths are placed. Example:
 *
 *     apis:
 *     - name: google.storage.v2.Storage
 *       mixins:
 *       - name: google.acl.v1.AccessControl
 *         root: acls
 *
 * This implies the following inherited HTTP annotation:
 *
 *     service Storage {
 *       // Get the underlying ACL object.
 *       rpc GetAcl(GetAclRequest) returns (Acl) {
 *         option (google.api.http).get = \\"/v2/acls/{resource=**}:getAcl\\";
 *       }
 *       ...
 *     }
 */
export interface Mixin {
  /**
   * The fully qualified name of the interface which is included.
   */
  name: string;
  /**
   * If non-empty specifies a path under which inherited HTTP paths
   * are rooted.
   */
  root: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Api = {
  /**
   * Serializes a Api to protobuf.
   */
  encode: function (msg: Partial<Api>): Uint8Array {
    return Api._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Api from protobuf.
   */
  decode: function (bytes: ByteSource): Api {
    return Api._readMessage(Api.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Api to JSON.
   */
  encodeJSON: function (msg: Partial<Api>): string {
    return JSON.stringify(Api._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Api from JSON.
   */
  decodeJSON: function (json: string): Api {
    return Api._readMessageJSON(Api.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Api with all fields set to their default value.
   */
  initialize: function (): Api {
    return {
      name: \\"\\",
      methods: [],
      options: [],
      version: \\"\\",
      sourceContext: SourceContext.initialize(),
      mixins: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Api>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.methods?.length) {
      writer.writeRepeatedMessage(2, msg.methods as any, Method._writeMessage);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(3, msg.options as any, Option._writeMessage);
    }
    if (msg.version) {
      writer.writeString(4, msg.version);
    }
    if (msg.sourceContext) {
      writer.writeMessage(5, msg.sourceContext, SourceContext._writeMessage);
    }
    if (msg.mixins?.length) {
      writer.writeRepeatedMessage(6, msg.mixins as any, Mixin._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Api>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.methods?.length) {
      json.methods = msg.methods.map(Method._writeMessageJSON);
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.version) {
      json.version = msg.version;
    }
    if (msg.sourceContext) {
      const sourceContext = SourceContext._writeMessageJSON(msg.sourceContext);
      if (Object.keys(sourceContext).length > 0) {
        json.sourceContext = sourceContext;
      }
    }
    if (msg.mixins?.length) {
      json.mixins = msg.mixins.map(Mixin._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Api, reader: BinaryReader): Api {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          const m = Method.initialize();
          reader.readMessage(m, Method._readMessage);
          msg.methods.push(m);
          break;
        }
        case 3: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 4: {
          msg.version = reader.readString();
          break;
        }
        case 5: {
          reader.readMessage(msg.sourceContext, SourceContext._readMessage);
          break;
        }
        case 6: {
          const m = Mixin.initialize();
          reader.readMessage(m, Mixin._readMessage);
          msg.mixins.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Api, json: any): Api {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _methods = json.methods;
    if (_methods) {
      for (const item of _methods) {
        const m = Method.initialize();
        Method._readMessageJSON(m, item);
        msg.methods.push(m);
      }
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _version = json.version;
    if (_version) {
      msg.version = _version;
    }
    const _sourceContext = json.sourceContext ?? json.source_context;
    if (_sourceContext) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContext);
      msg.sourceContext = m;
    }
    const _mixins = json.mixins;
    if (_mixins) {
      for (const item of _mixins) {
        const m = Mixin.initialize();
        Mixin._readMessageJSON(m, item);
        msg.mixins.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Method = {
  /**
   * Serializes a Method to protobuf.
   */
  encode: function (msg: Partial<Method>): Uint8Array {
    return Method._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Method from protobuf.
   */
  decode: function (bytes: ByteSource): Method {
    return Method._readMessage(Method.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Method to JSON.
   */
  encodeJSON: function (msg: Partial<Method>): string {
    return JSON.stringify(Method._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Method from JSON.
   */
  decodeJSON: function (json: string): Method {
    return Method._readMessageJSON(Method.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Method with all fields set to their default value.
   */
  initialize: function (): Method {
    return {
      name: \\"\\",
      requestTypeUrl: \\"\\",
      requestStreaming: false,
      responseTypeUrl: \\"\\",
      responseStreaming: false,
      options: [],
      syntax: SyntaxFromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Method>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.requestTypeUrl) {
      writer.writeString(2, msg.requestTypeUrl);
    }
    if (msg.requestStreaming) {
      writer.writeBool(3, msg.requestStreaming);
    }
    if (msg.responseTypeUrl) {
      writer.writeString(4, msg.responseTypeUrl);
    }
    if (msg.responseStreaming) {
      writer.writeBool(5, msg.responseStreaming);
    }
    if (msg.options?.length) {
      writer.writeRepeatedMessage(6, msg.options as any, Option._writeMessage);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      writer.writeEnum(7, SyntaxToInt(msg.syntax));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Method>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.requestTypeUrl) {
      json.requestTypeUrl = msg.requestTypeUrl;
    }
    if (msg.requestStreaming) {
      json.requestStreaming = msg.requestStreaming;
    }
    if (msg.responseTypeUrl) {
      json.responseTypeUrl = msg.responseTypeUrl;
    }
    if (msg.responseStreaming) {
      json.responseStreaming = msg.responseStreaming;
    }
    if (msg.options?.length) {
      json.options = msg.options.map(Option._writeMessageJSON);
    }
    if (msg.syntax && SyntaxToInt(msg.syntax)) {
      json.syntax = msg.syntax;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Method, reader: BinaryReader): Method {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.requestTypeUrl = reader.readString();
          break;
        }
        case 3: {
          msg.requestStreaming = reader.readBool();
          break;
        }
        case 4: {
          msg.responseTypeUrl = reader.readString();
          break;
        }
        case 5: {
          msg.responseStreaming = reader.readBool();
          break;
        }
        case 6: {
          const m = Option.initialize();
          reader.readMessage(m, Option._readMessage);
          msg.options.push(m);
          break;
        }
        case 7: {
          msg.syntax = SyntaxFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Method, json: any): Method {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _requestTypeUrl = json.requestTypeUrl ?? json.request_type_url;
    if (_requestTypeUrl) {
      msg.requestTypeUrl = _requestTypeUrl;
    }
    const _requestStreaming = json.requestStreaming ?? json.request_streaming;
    if (_requestStreaming) {
      msg.requestStreaming = _requestStreaming;
    }
    const _responseTypeUrl = json.responseTypeUrl ?? json.response_type_url;
    if (_responseTypeUrl) {
      msg.responseTypeUrl = _responseTypeUrl;
    }
    const _responseStreaming =
      json.responseStreaming ?? json.response_streaming;
    if (_responseStreaming) {
      msg.responseStreaming = _responseStreaming;
    }
    const _options = json.options;
    if (_options) {
      for (const item of _options) {
        const m = Option.initialize();
        Option._readMessageJSON(m, item);
        msg.options.push(m);
      }
    }
    const _syntax = json.syntax;
    if (_syntax) {
      msg.syntax = _syntax;
    }
    return msg;
  },
};

export const Mixin = {
  /**
   * Serializes a Mixin to protobuf.
   */
  encode: function (msg: Partial<Mixin>): Uint8Array {
    return Mixin._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Mixin from protobuf.
   */
  decode: function (bytes: ByteSource): Mixin {
    return Mixin._readMessage(Mixin.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Mixin to JSON.
   */
  encodeJSON: function (msg: Partial<Mixin>): string {
    return JSON.stringify(Mixin._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Mixin from JSON.
   */
  decodeJSON: function (json: string): Mixin {
    return Mixin._readMessageJSON(Mixin.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Mixin with all fields set to their default value.
   */
  initialize: function (): Mixin {
    return {
      name: \\"\\",
      root: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Mixin>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.root) {
      writer.writeString(2, msg.root);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Mixin>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json.name = msg.name;
    }
    if (msg.root) {
      json.root = msg.root;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Mixin, reader: BinaryReader): Mixin {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.root = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Mixin, json: any): Mixin {
    const _name = json.name;
    if (_name) {
      msg.name = _name;
    }
    const _root = json.root;
    if (_root) {
      msg.root = _root;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/duration.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/duration.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A Duration represents a signed, fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like \\"day\\"
 * or \\"month\\". It is related to Timestamp in that the difference between
 * two Timestamp values is a Duration and it can be added or subtracted
 * from a Timestamp. Range is approximately +-10,000 years.
 *
 * # Examples
 *
 * Example 1: Compute Duration from two Timestamps in pseudo code.
 *
 *     Timestamp start = ...;
 *     Timestamp end = ...;
 *     Duration duration = ...;
 *
 *     duration.seconds = end.seconds - start.seconds;
 *     duration.nanos = end.nanos - start.nanos;
 *
 *     if (duration.seconds < 0 && duration.nanos > 0) {
 *       duration.seconds += 1;
 *       duration.nanos -= 1000000000;
 *     } else if (duration.seconds > 0 && duration.nanos < 0) {
 *       duration.seconds -= 1;
 *       duration.nanos += 1000000000;
 *     }
 *
 * Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
 *
 *     Timestamp start = ...;
 *     Duration duration = ...;
 *     Timestamp end = ...;
 *
 *     end.seconds = start.seconds + duration.seconds;
 *     end.nanos = start.nanos + duration.nanos;
 *
 *     if (end.nanos < 0) {
 *       end.seconds -= 1;
 *       end.nanos += 1000000000;
 *     } else if (end.nanos >= 1000000000) {
 *       end.seconds += 1;
 *       end.nanos -= 1000000000;
 *     }
 *
 * Example 3: Compute Duration from datetime.timedelta in Python.
 *
 *     td = datetime.timedelta(days=3, minutes=10)
 *     duration = Duration()
 *     duration.FromTimedelta(td)
 *
 * # JSON Mapping
 *
 * In JSON format, the Duration type is encoded as a string rather than an
 * object, where the string ends in the suffix \\"s\\" (indicating seconds) and
 * is preceded by the number of seconds, with nanoseconds expressed as
 * fractional seconds. For example, 3 seconds with 0 nanoseconds should be
 * encoded in JSON format as \\"3s\\", while 3 seconds and 1 nanosecond should
 * be expressed in JSON format as \\"3.000000001s\\", and 3 seconds and 1
 * microsecond should be expressed in JSON format as \\"3.000001s\\".
 *
 *
 */
export interface Duration {
  /**
   * Signed seconds of the span of time. Must be from -315,576,000,000
   * to +315,576,000,000 inclusive. Note: these bounds are computed from:
   * 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
   */
  seconds: bigint;
  /**
   * Signed fractions of a second at nanosecond resolution of the span
   * of time. Durations less than one second are represented with a 0
   * \`seconds\` field and a positive or negative \`nanos\` field. For durations
   * of one second or more, a non-zero value for the \`nanos\` field must be
   * of the same sign as the \`seconds\` field. Must be from -999,999,999
   * to +999,999,999 inclusive.
   */
  nanos: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Duration = {
  /**
   * Serializes a Duration to protobuf.
   */
  encode: function (msg: Partial<Duration>): Uint8Array {
    return Duration._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Duration from protobuf.
   */
  decode: function (bytes: ByteSource): Duration {
    return Duration._readMessage(
      Duration.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Duration to JSON.
   */
  encodeJSON: function (msg: Partial<Duration>): string {
    return JSON.stringify(Duration._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Duration from JSON.
   */
  decodeJSON: function (json: string): Duration {
    return Duration._readMessageJSON(Duration.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Duration with all fields set to their default value.
   */
  initialize: function (): Duration {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Duration>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Duration>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Duration, reader: BinaryReader): Duration {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Duration, json: any): Duration {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */
  encode: function (_msg?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */
  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */
  encodeJSON: function (_msg?: Partial<Empty>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */
  decodeJSON: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/field_mask.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/field_mask.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`FieldMask\` represents a set of symbolic field paths, for example:
 *
 *     paths: \\"f.a\\"
 *     paths: \\"f.b.d\\"
 *
 * Here \`f\` represents a field in some root message, \`a\` and \`b\`
 * fields in the message found in \`f\`, and \`d\` a field found in the
 * message in \`f.b\`.
 *
 * Field masks are used to specify a subset of fields that should be
 * returned by a get operation or modified by an update operation.
 * Field masks also have a custom JSON encoding (see below).
 *
 * # Field Masks in Projections
 *
 * When used in the context of a projection, a response message or
 * sub-message is filtered by the API to only contain those fields as
 * specified in the mask. For example, if the mask in the previous
 * example is applied to a response message as follows:
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *         x : 2
 *       }
 *       y : 13
 *     }
 *     z: 8
 *
 * The result will not contain specific values for fields x,y and z
 * (their value will be set to the default, and omitted in proto text
 * output):
 *
 *
 *     f {
 *       a : 22
 *       b {
 *         d : 1
 *       }
 *     }
 *
 * A repeated field is not allowed except at the last position of a
 * paths string.
 *
 * If a FieldMask object is not present in a get operation, the
 * operation applies to all fields (as if a FieldMask of all fields
 * had been specified).
 *
 * Note that a field mask does not necessarily apply to the
 * top-level response message. In case of a REST get operation, the
 * field mask applies directly to the response, but in case of a REST
 * list operation, the mask instead applies to each individual message
 * in the returned resource list. In case of a REST custom method,
 * other definitions may be used. Where the mask applies will be
 * clearly documented together with its declaration in the API.  In
 * any case, the effect on the returned resource/resources is required
 * behavior for APIs.
 *
 * # Field Masks in Update Operations
 *
 * A field mask in update operations specifies which fields of the
 * targeted resource are going to be updated. The API is required
 * to only change the values of the fields as specified in the mask
 * and leave the others untouched. If a resource is passed in to
 * describe the updated values, the API ignores the values of all
 * fields not covered by the mask.
 *
 * If a repeated field is specified for an update operation, new values will
 * be appended to the existing repeated field in the target resource. Note that
 * a repeated field is only allowed in the last position of a \`paths\` string.
 *
 * If a sub-message is specified in the last position of the field mask for an
 * update operation, then new value will be merged into the existing sub-message
 * in the target resource.
 *
 * For example, given the target message:
 *
 *     f {
 *       b {
 *         d: 1
 *         x: 2
 *       }
 *       c: [1]
 *     }
 *
 * And an update message:
 *
 *     f {
 *       b {
 *         d: 10
 *       }
 *       c: [2]
 *     }
 *
 * then if the field mask is:
 *
 *  paths: [\\"f.b\\", \\"f.c\\"]
 *
 * then the result will be:
 *
 *     f {
 *       b {
 *         d: 10
 *         x: 2
 *       }
 *       c: [1, 2]
 *     }
 *
 * An implementation may provide options to override this default behavior for
 * repeated and message fields.
 *
 * In order to reset a field's value to the default, the field must
 * be in the mask and set to the default value in the provided resource.
 * Hence, in order to reset all fields of a resource, provide a default
 * instance of the resource and set all fields in the mask, or do
 * not provide a mask as described below.
 *
 * If a field mask is not present on update, the operation applies to
 * all fields (as if a field mask of all fields has been specified).
 * Note that in the presence of schema evolution, this may mean that
 * fields the client does not know and has therefore not filled into
 * the request will be reset to their default. If this is unwanted
 * behavior, a specific service may require a client to always specify
 * a field mask, producing an error if not.
 *
 * As with get operations, the location of the resource which
 * describes the updated values in the request message depends on the
 * operation kind. In any case, the effect of the field mask is
 * required to be honored by the API.
 *
 * ## Considerations for HTTP REST
 *
 * The HTTP kind of an update operation which uses a field mask must
 * be set to PATCH instead of PUT in order to satisfy HTTP semantics
 * (PUT must only be used for full updates).
 *
 * # JSON Encoding of Field Masks
 *
 * In JSON, a field mask is encoded as a single string where paths are
 * separated by a comma. Fields name in each path are converted
 * to/from lower-camel naming conventions.
 *
 * As an example, consider the following message declarations:
 *
 *     message Profile {
 *       User user = 1;
 *       Photo photo = 2;
 *     }
 *     message User {
 *       string display_name = 1;
 *       string address = 2;
 *     }
 *
 * In proto a field mask for \`Profile\` may look as such:
 *
 *     mask {
 *       paths: \\"user.display_name\\"
 *       paths: \\"photo\\"
 *     }
 *
 * In JSON, the same mask is represented as below:
 *
 *     {
 *       mask: \\"user.displayName,photo\\"
 *     }
 *
 * # Field Masks and Oneof Fields
 *
 * Field masks treat fields in oneofs just as regular fields. Consider the
 * following message:
 *
 *     message SampleMessage {
 *       oneof test_oneof {
 *         string name = 4;
 *         SubMessage sub_message = 9;
 *       }
 *     }
 *
 * The field mask can be:
 *
 *     mask {
 *       paths: \\"name\\"
 *     }
 *
 * Or:
 *
 *     mask {
 *       paths: \\"sub_message\\"
 *     }
 *
 * Note that oneof type names (\\"test_oneof\\" in this case) cannot be used in
 * paths.
 *
 * ## Field Mask Verification
 *
 * The implementation of any API method which has a FieldMask type field in the
 * request should verify the included field paths, and return an
 * \`INVALID_ARGUMENT\` error if any path is unmappable.
 */
export interface FieldMask {
  /**
   * The set of field mask paths.
   */
  paths: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const FieldMask = {
  /**
   * Serializes a FieldMask to protobuf.
   */
  encode: function (msg: Partial<FieldMask>): Uint8Array {
    return FieldMask._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FieldMask from protobuf.
   */
  decode: function (bytes: ByteSource): FieldMask {
    return FieldMask._readMessage(
      FieldMask.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FieldMask to JSON.
   */
  encodeJSON: function (msg: Partial<FieldMask>): string {
    return JSON.stringify(FieldMask._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FieldMask from JSON.
   */
  decodeJSON: function (json: string): FieldMask {
    return FieldMask._readMessageJSON(FieldMask.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a FieldMask with all fields set to their default value.
   */
  initialize: function (): FieldMask {
    return {
      paths: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FieldMask>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.paths?.length) {
      writer.writeRepeatedString(1, msg.paths);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FieldMask>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.paths?.length) {
      json.paths = msg.paths;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FieldMask, reader: BinaryReader): FieldMask {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.paths.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FieldMask, json: any): FieldMask {
    const _paths = json.paths;
    if (_paths) {
      msg.paths = _paths;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/struct.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/struct.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * \`NullValue\` is a singleton enumeration to represent the null value for the
 * \`Value\` type union.
 *
 *  The JSON representation for \`NullValue\` is JSON \`null\`.
 */
export type NullValue = \\"NULL_VALUE\\";

/**
 * \`Struct\` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, \`Struct\`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for \`Struct\` is JSON object.
 */
export interface Struct {
  /**
   * Unordered map of dynamically typed values.
   */
  fields: Struct.Fields;
}

declare namespace Struct {
  export type Fields = Record<string, Value | undefined>;
}

/**
 * \`Value\` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of these
 * variants. Absence of any variant indicates an error.
 *
 * The JSON representation for \`Value\` is JSON value.
 */
export interface Value {
  /**
   * Represents a null value.
   */
  nullValue?: NullValue | null | undefined;
  /**
   * Represents a double value.
   */
  numberValue?: number | null | undefined;
  /**
   * Represents a string value.
   */
  stringValue?: string | null | undefined;
  /**
   * Represents a boolean value.
   */
  boolValue?: boolean | null | undefined;
  /**
   * Represents a structured value.
   */
  structValue?: Struct | null | undefined;
  /**
   * Represents a repeated \`Value\`.
   */
  listValue?: ListValue | null | undefined;
}

/**
 * \`ListValue\` is a wrapper around a repeated field of values.
 *
 * The JSON representation for \`ListValue\` is JSON array.
 */
export interface ListValue {
  /**
   * Repeated field of dynamically typed values.
   */
  values: Value[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const NullValue = {
  /**
   * Null value.
   */
  NULL_VALUE: \\"NULL_VALUE\\",
} as const;

const NullValueFromInt = function (i: number): NullValue {
  switch (i) {
    case 0: {
      return \\"NULL_VALUE\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as NullValue;
    }
  }
};

const NullValueToInt = function (i: NullValue): number {
  switch (i) {
    case \\"NULL_VALUE\\": {
      return 0;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const Struct = {
  /**
   * Serializes a Struct to protobuf.
   */
  encode: function (msg: Partial<Struct>): Uint8Array {
    return Struct._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Struct from protobuf.
   */
  decode: function (bytes: ByteSource): Struct {
    return Struct._readMessage(Struct.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Struct to JSON.
   */
  encodeJSON: function (msg: Partial<Struct>): string {
    return JSON.stringify(Struct._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Struct from JSON.
   */
  decodeJSON: function (json: string): Struct {
    return Struct._readMessageJSON(Struct.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Struct with all fields set to their default value.
   */
  initialize: function (): Struct {
    return {
      fields: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Struct>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fields) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.fields).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        Struct.Fields._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Struct>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fields) {
      const fields = Object.fromEntries(
        Object.entries<any>(msg.fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fields).length > 0) {
        json.fields = fields;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Struct, reader: BinaryReader): Struct {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const fields = {} as MapMessage<Struct.Fields>;
          reader.readMessage(fields, Struct.Fields._readMessage);
          msg.fields[fields.key] = fields.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Struct, json: any): Struct {
    const _fields = json.fields;
    if (_fields) {
      msg.fields = Object.fromEntries(
        Object.entries<any>(_fields)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(Struct.Fields._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Fields: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<Struct.Fields>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<Struct.Fields>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<Struct.Fields>,
      reader: BinaryReader
    ): MapMessage<Struct.Fields> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(Value.initialize(), Value._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<Struct.Fields>,
      json: any
    ): MapMessage<Struct.Fields> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Value.initialize();
        Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const Value = {
  /**
   * Serializes a Value to protobuf.
   */
  encode: function (msg: Partial<Value>): Uint8Array {
    return Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Value from protobuf.
   */
  decode: function (bytes: ByteSource): Value {
    return Value._readMessage(Value.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a Value to JSON.
   */
  encodeJSON: function (msg: Partial<Value>): string {
    return JSON.stringify(Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Value from JSON.
   */
  decodeJSON: function (json: string): Value {
    return Value._readMessageJSON(Value.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Value with all fields set to their default value.
   */
  initialize: function (): Value {
    return {
      structValue: Struct.initialize(),
      listValue: ListValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.nullValue != undefined) {
      writer.writeEnum(1, NullValueToInt(msg.nullValue));
    }
    if (msg.numberValue != undefined) {
      writer.writeDouble(2, msg.numberValue);
    }
    if (msg.stringValue != undefined) {
      writer.writeString(3, msg.stringValue);
    }
    if (msg.boolValue != undefined) {
      writer.writeBool(4, msg.boolValue);
    }
    if (msg.structValue != undefined) {
      writer.writeMessage(5, msg.structValue, Struct._writeMessage);
    }
    if (msg.listValue != undefined) {
      writer.writeMessage(6, msg.listValue, ListValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<Value>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.nullValue != undefined) {
      json.nullValue = msg.nullValue;
    }
    if (msg.numberValue != undefined) {
      json.numberValue = msg.numberValue;
    }
    if (msg.stringValue != undefined) {
      json.stringValue = msg.stringValue;
    }
    if (msg.boolValue != undefined) {
      json.boolValue = msg.boolValue;
    }
    if (msg.structValue != undefined) {
      const structValue = Struct._writeMessageJSON(msg.structValue);
      if (Object.keys(structValue).length > 0) {
        json.structValue = structValue;
      }
    }
    if (msg.listValue != undefined) {
      const listValue = ListValue._writeMessageJSON(msg.listValue);
      if (Object.keys(listValue).length > 0) {
        json.listValue = listValue;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Value, reader: BinaryReader): Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.nullValue = NullValueFromInt(reader.readEnum());
          break;
        }
        case 2: {
          msg.numberValue = reader.readDouble();
          break;
        }
        case 3: {
          msg.stringValue = reader.readString();
          break;
        }
        case 4: {
          msg.boolValue = reader.readBool();
          break;
        }
        case 5: {
          reader.readMessage(msg.structValue, Struct._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(msg.listValue, ListValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Value, json: any): Value {
    const _nullValue = json.nullValue ?? json.null_value;
    if (_nullValue) {
      msg.nullValue = _nullValue;
    }
    const _numberValue = json.numberValue ?? json.number_value;
    if (_numberValue) {
      msg.numberValue = _numberValue;
    }
    const _stringValue = json.stringValue ?? json.string_value;
    if (_stringValue) {
      msg.stringValue = _stringValue;
    }
    const _boolValue = json.boolValue ?? json.bool_value;
    if (_boolValue) {
      msg.boolValue = _boolValue;
    }
    const _structValue = json.structValue ?? json.struct_value;
    if (_structValue) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structValue);
      msg.structValue = m;
    }
    const _listValue = json.listValue ?? json.list_value;
    if (_listValue) {
      const m = ListValue.initialize();
      ListValue._readMessageJSON(m, _listValue);
      msg.listValue = m;
    }
    return msg;
  },
};

export const ListValue = {
  /**
   * Serializes a ListValue to protobuf.
   */
  encode: function (msg: Partial<ListValue>): Uint8Array {
    return ListValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a ListValue from protobuf.
   */
  decode: function (bytes: ByteSource): ListValue {
    return ListValue._readMessage(
      ListValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ListValue to JSON.
   */
  encodeJSON: function (msg: Partial<ListValue>): string {
    return JSON.stringify(ListValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ListValue from JSON.
   */
  decodeJSON: function (json: string): ListValue {
    return ListValue._readMessageJSON(ListValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a ListValue with all fields set to their default value.
   */
  initialize: function (): ListValue {
    return {
      values: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ListValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.values?.length) {
      writer.writeRepeatedMessage(1, msg.values as any, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ListValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.values?.length) {
      json.values = msg.values.map(Value._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ListValue, reader: BinaryReader): ListValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Value.initialize();
          reader.readMessage(m, Value._readMessage);
          msg.values.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ListValue, json: any): ListValue {
    const _values = json.values;
    if (_values) {
      for (const item of _values) {
        const m = Value.initialize();
        Value._readMessageJSON(m, item);
        msg.values.push(m);
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/timestamp.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/timestamp.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A Timestamp represents a point in time independent of any time zone or local
 * calendar, encoded as a count of seconds and fractions of seconds at
 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
 * January 1, 1970, in the proleptic Gregorian calendar which extends the
 * Gregorian calendar backwards to year one.
 *
 * All minutes are 60 seconds long. Leap seconds are \\"smeared\\" so that no leap
 * second table is needed for interpretation, using a [24-hour linear
 * smear](https://developers.google.com/time/smear).
 *
 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 * restricting to that range, we ensure that we can convert to and from [RFC
 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
 *
 * # Examples
 *
 * Example 1: Compute Timestamp from POSIX \`time()\`.
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(time(NULL));
 *     timestamp.set_nanos(0);
 *
 * Example 2: Compute Timestamp from POSIX \`gettimeofday()\`.
 *
 *     struct timeval tv;
 *     gettimeofday(&tv, NULL);
 *
 *     Timestamp timestamp;
 *     timestamp.set_seconds(tv.tv_sec);
 *     timestamp.set_nanos(tv.tv_usec * 1000);
 *
 * Example 3: Compute Timestamp from Win32 \`GetSystemTimeAsFileTime()\`.
 *
 *     FILETIME ft;
 *     GetSystemTimeAsFileTime(&ft);
 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
 *
 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
 *     Timestamp timestamp;
 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
 *
 * Example 4: Compute Timestamp from Java \`System.currentTimeMillis()\`.
 *
 *     long millis = System.currentTimeMillis();
 *
 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
 *
 *
 * Example 5: Compute Timestamp from Java \`Instant.now()\`.
 *
 *     Instant now = Instant.now();
 *
 *     Timestamp timestamp =
 *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
 *             .setNanos(now.getNano()).build();
 *
 *
 * Example 6: Compute Timestamp from current time in Python.
 *
 *     timestamp = Timestamp()
 *     timestamp.GetCurrentTime()
 *
 * # JSON Mapping
 *
 * In JSON format, the Timestamp type is encoded as a string in the
 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 * format is \\"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\\"
 * where {year} is always expressed using four digits while {month}, {day},
 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 * are optional. The \\"Z\\" suffix indicates the timezone (\\"UTC\\"); the timezone
 * is required. A proto3 JSON serializer should always use UTC (as indicated by
 * \\"Z\\") when printing the Timestamp type and a proto3 JSON parser should be
 * able to accept both UTC and other timezones (as indicated by an offset).
 *
 * For example, \\"2017-01-15T01:30:15.01Z\\" encodes 15.01 seconds past
 * 01:30 UTC on January 15, 2017.
 *
 * In JavaScript, one can convert a Date object to this format using the
 * standard
 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 * method. In Python, a standard \`datetime.datetime\` object can be converted
 * to this format using
 * [\`strftime\`](https://docs.python.org/2/library/time.html#time.strftime) with
 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 * the Joda Time's [\`ISODateTimeFormat.dateTime()\`](
 * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
 * ) to obtain a formatter capable of generating timestamps in this format.
 *
 *
 */
export interface Timestamp {
  /**
   * Represents seconds of UTC time since Unix epoch
   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   * 9999-12-31T23:59:59Z inclusive.
   */
  seconds: bigint;
  /**
   * Non-negative fractions of a second at nanosecond resolution. Negative
   * second values with fractions must still have non-negative nanos values
   * that count forward in time. Must be from 0 to 999,999,999
   * inclusive.
   */
  nanos: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Timestamp = {
  /**
   * Serializes a Timestamp to protobuf.
   */
  encode: function (msg: Partial<Timestamp>): Uint8Array {
    return Timestamp._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Timestamp from protobuf.
   */
  decode: function (bytes: ByteSource): Timestamp {
    return Timestamp._readMessage(
      Timestamp.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Timestamp to JSON.
   */
  encodeJSON: function (msg: Partial<Timestamp>): string {
    return JSON.stringify(Timestamp._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Timestamp from JSON.
   */
  decodeJSON: function (json: string): Timestamp {
    return Timestamp._readMessageJSON(Timestamp.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a Timestamp with all fields set to their default value.
   */
  initialize: function (): Timestamp {
    return {
      seconds: 0n,
      nanos: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Timestamp>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.seconds) {
      writer.writeInt64String(1, msg.seconds.toString());
    }
    if (msg.nanos) {
      writer.writeInt32(2, msg.nanos);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Timestamp>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.seconds) {
      json.seconds = msg.seconds.toString();
    }
    if (msg.nanos) {
      json.nanos = msg.nanos;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Timestamp, reader: BinaryReader): Timestamp {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.seconds = BigInt(reader.readInt64String());
          break;
        }
        case 2: {
          msg.nanos = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Timestamp, json: any): Timestamp {
    const _seconds = json.seconds;
    if (_seconds) {
      msg.seconds = BigInt(_seconds);
    }
    const _nanos = json.nanos;
    if (_nanos) {
      msg.nanos = _nanos;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/wrappers.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/wrappers.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Wrapper message for \`double\`.
 *
 * The JSON representation for \`DoubleValue\` is JSON number.
 */
export interface DoubleValue {
  /**
   * The double value.
   */
  value: number;
}

/**
 * Wrapper message for \`float\`.
 *
 * The JSON representation for \`FloatValue\` is JSON number.
 */
export interface FloatValue {
  /**
   * The float value.
   */
  value: number;
}

/**
 * Wrapper message for \`int64\`.
 *
 * The JSON representation for \`Int64Value\` is JSON string.
 */
export interface Int64Value {
  /**
   * The int64 value.
   */
  value: bigint;
}

/**
 * Wrapper message for \`uint64\`.
 *
 * The JSON representation for \`UInt64Value\` is JSON string.
 */
export interface UInt64Value {
  /**
   * The uint64 value.
   */
  value: bigint;
}

/**
 * Wrapper message for \`int32\`.
 *
 * The JSON representation for \`Int32Value\` is JSON number.
 */
export interface Int32Value {
  /**
   * The int32 value.
   */
  value: number;
}

/**
 * Wrapper message for \`uint32\`.
 *
 * The JSON representation for \`UInt32Value\` is JSON number.
 */
export interface UInt32Value {
  /**
   * The uint32 value.
   */
  value: number;
}

/**
 * Wrapper message for \`bool\`.
 *
 * The JSON representation for \`BoolValue\` is JSON \`true\` and \`false\`.
 */
export interface BoolValue {
  /**
   * The bool value.
   */
  value: boolean;
}

/**
 * Wrapper message for \`string\`.
 *
 * The JSON representation for \`StringValue\` is JSON string.
 */
export interface StringValue {
  /**
   * The string value.
   */
  value: string;
}

/**
 * Wrapper message for \`bytes\`.
 *
 * The JSON representation for \`BytesValue\` is JSON string.
 */
export interface BytesValue {
  /**
   * The bytes value.
   */
  value: Uint8Array;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const DoubleValue = {
  /**
   * Serializes a DoubleValue to protobuf.
   */
  encode: function (msg: Partial<DoubleValue>): Uint8Array {
    return DoubleValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a DoubleValue from protobuf.
   */
  decode: function (bytes: ByteSource): DoubleValue {
    return DoubleValue._readMessage(
      DoubleValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a DoubleValue to JSON.
   */
  encodeJSON: function (msg: Partial<DoubleValue>): string {
    return JSON.stringify(DoubleValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a DoubleValue from JSON.
   */
  decodeJSON: function (json: string): DoubleValue {
    return DoubleValue._readMessageJSON(
      DoubleValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a DoubleValue with all fields set to their default value.
   */
  initialize: function (): DoubleValue {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<DoubleValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeDouble(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<DoubleValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: DoubleValue, reader: BinaryReader): DoubleValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: DoubleValue, json: any): DoubleValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const FloatValue = {
  /**
   * Serializes a FloatValue to protobuf.
   */
  encode: function (msg: Partial<FloatValue>): Uint8Array {
    return FloatValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a FloatValue from protobuf.
   */
  decode: function (bytes: ByteSource): FloatValue {
    return FloatValue._readMessage(
      FloatValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a FloatValue to JSON.
   */
  encodeJSON: function (msg: Partial<FloatValue>): string {
    return JSON.stringify(FloatValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a FloatValue from JSON.
   */
  decodeJSON: function (json: string): FloatValue {
    return FloatValue._readMessageJSON(
      FloatValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a FloatValue with all fields set to their default value.
   */
  initialize: function (): FloatValue {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<FloatValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeFloat(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<FloatValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FloatValue, reader: BinaryReader): FloatValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readFloat();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FloatValue, json: any): FloatValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const Int64Value = {
  /**
   * Serializes a Int64Value to protobuf.
   */
  encode: function (msg: Partial<Int64Value>): Uint8Array {
    return Int64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int64Value from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Value {
    return Int64Value._readMessage(
      Int64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Value to JSON.
   */
  encodeJSON: function (msg: Partial<Int64Value>): string {
    return JSON.stringify(Int64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int64Value from JSON.
   */
  decodeJSON: function (json: string): Int64Value {
    return Int64Value._readMessageJSON(
      Int64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Value with all fields set to their default value.
   */
  initialize: function (): Int64Value {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeInt64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int64Value, reader: BinaryReader): Int64Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Value, json: any): Int64Value {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const UInt64Value = {
  /**
   * Serializes a UInt64Value to protobuf.
   */
  encode: function (msg: Partial<UInt64Value>): Uint8Array {
    return UInt64Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt64Value from protobuf.
   */
  decode: function (bytes: ByteSource): UInt64Value {
    return UInt64Value._readMessage(
      UInt64Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt64Value to JSON.
   */
  encodeJSON: function (msg: Partial<UInt64Value>): string {
    return JSON.stringify(UInt64Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt64Value from JSON.
   */
  decodeJSON: function (json: string): UInt64Value {
    return UInt64Value._readMessageJSON(
      UInt64Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt64Value with all fields set to their default value.
   */
  initialize: function (): UInt64Value {
    return {
      value: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UInt64Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeUint64String(1, msg.value.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UInt64Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: UInt64Value, reader: BinaryReader): UInt64Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UInt64Value, json: any): UInt64Value {
    const _value = json.value;
    if (_value) {
      msg.value = BigInt(_value);
    }
    return msg;
  },
};

export const Int32Value = {
  /**
   * Serializes a Int32Value to protobuf.
   */
  encode: function (msg: Partial<Int32Value>): Uint8Array {
    return Int32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a Int32Value from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Value {
    return Int32Value._readMessage(
      Int32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Value to JSON.
   */
  encodeJSON: function (msg: Partial<Int32Value>): string {
    return JSON.stringify(Int32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a Int32Value from JSON.
   */
  decodeJSON: function (json: string): Int32Value {
    return Int32Value._readMessageJSON(
      Int32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Value with all fields set to their default value.
   */
  initialize: function (): Int32Value {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeInt32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int32Value, reader: BinaryReader): Int32Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Value, json: any): Int32Value {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const UInt32Value = {
  /**
   * Serializes a UInt32Value to protobuf.
   */
  encode: function (msg: Partial<UInt32Value>): Uint8Array {
    return UInt32Value._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a UInt32Value from protobuf.
   */
  decode: function (bytes: ByteSource): UInt32Value {
    return UInt32Value._readMessage(
      UInt32Value.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UInt32Value to JSON.
   */
  encodeJSON: function (msg: Partial<UInt32Value>): string {
    return JSON.stringify(UInt32Value._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UInt32Value from JSON.
   */
  decodeJSON: function (json: string): UInt32Value {
    return UInt32Value._readMessageJSON(
      UInt32Value.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UInt32Value with all fields set to their default value.
   */
  initialize: function (): UInt32Value {
    return {
      value: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<UInt32Value>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeUint32(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<UInt32Value>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: UInt32Value, reader: BinaryReader): UInt32Value {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: UInt32Value, json: any): UInt32Value {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BoolValue = {
  /**
   * Serializes a BoolValue to protobuf.
   */
  encode: function (msg: Partial<BoolValue>): Uint8Array {
    return BoolValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BoolValue from protobuf.
   */
  decode: function (bytes: ByteSource): BoolValue {
    return BoolValue._readMessage(
      BoolValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolValue to JSON.
   */
  encodeJSON: function (msg: Partial<BoolValue>): string {
    return JSON.stringify(BoolValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BoolValue from JSON.
   */
  decodeJSON: function (json: string): BoolValue {
    return BoolValue._readMessageJSON(BoolValue.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a BoolValue with all fields set to their default value.
   */
  initialize: function (): BoolValue {
    return {
      value: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeBool(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolValue, reader: BinaryReader): BoolValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolValue, json: any): BoolValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const StringValue = {
  /**
   * Serializes a StringValue to protobuf.
   */
  encode: function (msg: Partial<StringValue>): Uint8Array {
    return StringValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a StringValue from protobuf.
   */
  decode: function (bytes: ByteSource): StringValue {
    return StringValue._readMessage(
      StringValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a StringValue to JSON.
   */
  encodeJSON: function (msg: Partial<StringValue>): string {
    return JSON.stringify(StringValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a StringValue from JSON.
   */
  decodeJSON: function (json: string): StringValue {
    return StringValue._readMessageJSON(
      StringValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a StringValue with all fields set to their default value.
   */
  initialize: function (): StringValue {
    return {
      value: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<StringValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value) {
      writer.writeString(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<StringValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value) {
      json.value = msg.value;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: StringValue, reader: BinaryReader): StringValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: StringValue, json: any): StringValue {
    const _value = json.value;
    if (_value) {
      msg.value = _value;
    }
    return msg;
  },
};

export const BytesValue = {
  /**
   * Serializes a BytesValue to protobuf.
   */
  encode: function (msg: Partial<BytesValue>): Uint8Array {
    return BytesValue._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a BytesValue from protobuf.
   */
  decode: function (bytes: ByteSource): BytesValue {
    return BytesValue._readMessage(
      BytesValue.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BytesValue to JSON.
   */
  encodeJSON: function (msg: Partial<BytesValue>): string {
    return JSON.stringify(BytesValue._writeMessageJSON(msg));
  },

  /**
   * Deserializes a BytesValue from JSON.
   */
  decodeJSON: function (json: string): BytesValue {
    return BytesValue._readMessageJSON(
      BytesValue.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BytesValue with all fields set to their default value.
   */
  initialize: function (): BytesValue {
    return {
      value: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BytesValue>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.value?.length) {
      writer.writeBytes(1, msg.value);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BytesValue>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.value?.length) {
      json.value = encodeBase64Bytes(msg.value);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BytesValue, reader: BinaryReader): BytesValue {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.value = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BytesValue, json: any): BytesValue {
    const _value = json.value;
    if (_value) {
      msg.value = decodeBase64Bytes(_value);
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_well_known_types.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_well_known_types.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { Any } from \\"./any.pb\\";
import { Api } from \\"./api.pb\\";
import { Duration } from \\"./duration.pb\\";
import { Empty } from \\"./empty.pb\\";
import { FieldMask } from \\"./field_mask.pb\\";
import { SourceContext } from \\"./source_context.pb\\";
import { Struct, Value } from \\"./struct.pb\\";
import { Timestamp } from \\"./timestamp.pb\\";
import { Type } from \\"./type.pb\\";
import {
  DoubleValue,
  FloatValue,
  Int64Value,
  UInt64Value,
  Int32Value,
  UInt32Value,
  BoolValue,
  StringValue,
  BytesValue,
} from \\"./wrappers.pb\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * Test that we can include all well-known types.
 * Each wrapper type is included separately, as languages
 * map handle different wrappers in different ways.
 */
export interface TestWellKnownTypes {
  anyField: Any;
  apiField: Api;
  durationField: Duration;
  emptyField: Empty;
  fieldMaskField: FieldMask;
  sourceContextField: SourceContext;
  structField: Struct;
  timestampField: Timestamp;
  typeField: Type;
  doubleField: DoubleValue;
  floatField: FloatValue;
  int64Field: Int64Value;
  uint64Field: UInt64Value;
  int32Field: Int32Value;
  uint32Field: UInt32Value;
  boolField: BoolValue;
  stringField: StringValue;
  bytesField: BytesValue;
  /**
   * Part of struct, but useful to be able to test separately
   */
  valueField: Value;
}

/**
 * A repeated field for each well-known type.
 */
export interface RepeatedWellKnownTypes {
  anyField: Any[];
  apiField: Api[];
  durationField: Duration[];
  emptyField: Empty[];
  fieldMaskField: FieldMask[];
  sourceContextField: SourceContext[];
  structField: Struct[];
  timestampField: Timestamp[];
  typeField: Type[];
  /**
   * These don't actually make a lot of sense, but they're not prohibited...
   */
  doubleField: DoubleValue[];
  floatField: FloatValue[];
  int64Field: Int64Value[];
  uint64Field: UInt64Value[];
  int32Field: Int32Value[];
  uint32Field: UInt32Value[];
  boolField: BoolValue[];
  stringField: StringValue[];
  bytesField: BytesValue[];
}

export interface OneofWellKnownTypes {
  anyField?: Any | null | undefined;
  apiField?: Api | null | undefined;
  durationField?: Duration | null | undefined;
  emptyField?: Empty | null | undefined;
  fieldMaskField?: FieldMask | null | undefined;
  sourceContextField?: SourceContext | null | undefined;
  structField?: Struct | null | undefined;
  timestampField?: Timestamp | null | undefined;
  typeField?: Type | null | undefined;
  doubleField?: DoubleValue | null | undefined;
  floatField?: FloatValue | null | undefined;
  int64Field?: Int64Value | null | undefined;
  uint64Field?: UInt64Value | null | undefined;
  int32Field?: Int32Value | null | undefined;
  uint32Field?: UInt32Value | null | undefined;
  boolField?: BoolValue | null | undefined;
  stringField?: StringValue | null | undefined;
  bytesField?: BytesValue | null | undefined;
}

/**
 * A map field for each well-known type. We only
 * need to worry about the value part of the map being the
 * well-known types, as messages can't be map keys.
 */
export interface MapWellKnownTypes {
  anyField: MapWellKnownTypes.AnyField;
  apiField: MapWellKnownTypes.ApiField;
  durationField: MapWellKnownTypes.DurationField;
  emptyField: MapWellKnownTypes.EmptyField;
  fieldMaskField: MapWellKnownTypes.FieldMaskField;
  sourceContextField: MapWellKnownTypes.SourceContextField;
  structField: MapWellKnownTypes.StructField;
  timestampField: MapWellKnownTypes.TimestampField;
  typeField: MapWellKnownTypes.TypeField;
  doubleField: MapWellKnownTypes.DoubleField;
  floatField: MapWellKnownTypes.FloatField;
  int64Field: MapWellKnownTypes.Int64Field;
  uint64Field: MapWellKnownTypes.Uint64Field;
  int32Field: MapWellKnownTypes.Int32Field;
  uint32Field: MapWellKnownTypes.Uint32Field;
  boolField: MapWellKnownTypes.BoolField;
  stringField: MapWellKnownTypes.StringField;
  bytesField: MapWellKnownTypes.BytesField;
}

declare namespace MapWellKnownTypes {
  export type AnyField = Record<number, Any | undefined>;

  export type ApiField = Record<number, Api | undefined>;

  export type DurationField = Record<number, Duration | undefined>;

  export type EmptyField = Record<number, Empty | undefined>;

  export type FieldMaskField = Record<number, FieldMask | undefined>;

  export type SourceContextField = Record<number, SourceContext | undefined>;

  export type StructField = Record<number, Struct | undefined>;

  export type TimestampField = Record<number, Timestamp | undefined>;

  export type TypeField = Record<number, Type | undefined>;

  export type DoubleField = Record<number, DoubleValue | undefined>;

  export type FloatField = Record<number, FloatValue | undefined>;

  export type Int64Field = Record<number, Int64Value | undefined>;

  export type Uint64Field = Record<number, UInt64Value | undefined>;

  export type Int32Field = Record<number, Int32Value | undefined>;

  export type Uint32Field = Record<number, UInt32Value | undefined>;

  export type BoolField = Record<number, BoolValue | undefined>;

  export type StringField = Record<number, StringValue | undefined>;

  export type BytesField = Record<number, BytesValue | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const TestWellKnownTypes = {
  /**
   * Serializes a TestWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<TestWellKnownTypes>): Uint8Array {
    return TestWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestWellKnownTypes {
    return TestWellKnownTypes._readMessage(
      TestWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestWellKnownTypes>): string {
    return JSON.stringify(TestWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): TestWellKnownTypes {
    return TestWellKnownTypes._readMessageJSON(
      TestWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): TestWellKnownTypes {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
      valueField: Value.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    if (msg.valueField) {
      writer.writeMessage(19, msg.valueField, Value._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    if (msg.valueField) {
      const valueField = Value._writeMessageJSON(msg.valueField);
      if (Object.keys(valueField).length > 0) {
        json.valueField = valueField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestWellKnownTypes,
    reader: BinaryReader
  ): TestWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        case 19: {
          reader.readMessage(msg.valueField, Value._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestWellKnownTypes,
    json: any
  ): TestWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    const _valueField = json.valueField ?? json.value_field;
    if (_valueField) {
      const m = Value.initialize();
      Value._readMessageJSON(m, _valueField);
      msg.valueField = m;
    }
    return msg;
  },
};

export const RepeatedWellKnownTypes = {
  /**
   * Serializes a RepeatedWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<RepeatedWellKnownTypes>): Uint8Array {
    return RepeatedWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessage(
      RepeatedWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<RepeatedWellKnownTypes>): string {
    return JSON.stringify(RepeatedWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a RepeatedWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): RepeatedWellKnownTypes {
    return RepeatedWellKnownTypes._readMessageJSON(
      RepeatedWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): RepeatedWellKnownTypes {
    return {
      anyField: [],
      apiField: [],
      durationField: [],
      emptyField: [],
      fieldMaskField: [],
      sourceContextField: [],
      structField: [],
      timestampField: [],
      typeField: [],
      doubleField: [],
      floatField: [],
      int64Field: [],
      uint64Field: [],
      int32Field: [],
      uint32Field: [],
      boolField: [],
      stringField: [],
      bytesField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField?.length) {
      writer.writeRepeatedMessage(1, msg.anyField as any, Any._writeMessage);
    }
    if (msg.apiField?.length) {
      writer.writeRepeatedMessage(2, msg.apiField as any, Api._writeMessage);
    }
    if (msg.durationField?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.durationField as any,
        Duration._writeMessage
      );
    }
    if (msg.emptyField?.length) {
      writer.writeRepeatedMessage(
        4,
        msg.emptyField as any,
        Empty._writeMessage
      );
    }
    if (msg.fieldMaskField?.length) {
      writer.writeRepeatedMessage(
        5,
        msg.fieldMaskField as any,
        FieldMask._writeMessage
      );
    }
    if (msg.sourceContextField?.length) {
      writer.writeRepeatedMessage(
        6,
        msg.sourceContextField as any,
        SourceContext._writeMessage
      );
    }
    if (msg.structField?.length) {
      writer.writeRepeatedMessage(
        7,
        msg.structField as any,
        Struct._writeMessage
      );
    }
    if (msg.timestampField?.length) {
      writer.writeRepeatedMessage(
        8,
        msg.timestampField as any,
        Timestamp._writeMessage
      );
    }
    if (msg.typeField?.length) {
      writer.writeRepeatedMessage(9, msg.typeField as any, Type._writeMessage);
    }
    if (msg.doubleField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.doubleField as any,
        DoubleValue._writeMessage
      );
    }
    if (msg.floatField?.length) {
      writer.writeRepeatedMessage(
        11,
        msg.floatField as any,
        FloatValue._writeMessage
      );
    }
    if (msg.int64Field?.length) {
      writer.writeRepeatedMessage(
        12,
        msg.int64Field as any,
        Int64Value._writeMessage
      );
    }
    if (msg.uint64Field?.length) {
      writer.writeRepeatedMessage(
        13,
        msg.uint64Field as any,
        UInt64Value._writeMessage
      );
    }
    if (msg.int32Field?.length) {
      writer.writeRepeatedMessage(
        14,
        msg.int32Field as any,
        Int32Value._writeMessage
      );
    }
    if (msg.uint32Field?.length) {
      writer.writeRepeatedMessage(
        15,
        msg.uint32Field as any,
        UInt32Value._writeMessage
      );
    }
    if (msg.boolField?.length) {
      writer.writeRepeatedMessage(
        16,
        msg.boolField as any,
        BoolValue._writeMessage
      );
    }
    if (msg.stringField?.length) {
      writer.writeRepeatedMessage(
        17,
        msg.stringField as any,
        StringValue._writeMessage
      );
    }
    if (msg.bytesField?.length) {
      writer.writeRepeatedMessage(
        18,
        msg.bytesField as any,
        BytesValue._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField?.length) {
      json.anyField = msg.anyField.map(Any._writeMessageJSON);
    }
    if (msg.apiField?.length) {
      json.apiField = msg.apiField.map(Api._writeMessageJSON);
    }
    if (msg.durationField?.length) {
      json.durationField = msg.durationField.map(Duration._writeMessageJSON);
    }
    if (msg.emptyField?.length) {
      json.emptyField = msg.emptyField.map(Empty._writeMessageJSON);
    }
    if (msg.fieldMaskField?.length) {
      json.fieldMaskField = msg.fieldMaskField.map(FieldMask._writeMessageJSON);
    }
    if (msg.sourceContextField?.length) {
      json.sourceContextField = msg.sourceContextField.map(
        SourceContext._writeMessageJSON
      );
    }
    if (msg.structField?.length) {
      json.structField = msg.structField.map(Struct._writeMessageJSON);
    }
    if (msg.timestampField?.length) {
      json.timestampField = msg.timestampField.map(Timestamp._writeMessageJSON);
    }
    if (msg.typeField?.length) {
      json.typeField = msg.typeField.map(Type._writeMessageJSON);
    }
    if (msg.doubleField?.length) {
      json.doubleField = msg.doubleField.map(DoubleValue._writeMessageJSON);
    }
    if (msg.floatField?.length) {
      json.floatField = msg.floatField.map(FloatValue._writeMessageJSON);
    }
    if (msg.int64Field?.length) {
      json.int64Field = msg.int64Field.map(Int64Value._writeMessageJSON);
    }
    if (msg.uint64Field?.length) {
      json.uint64Field = msg.uint64Field.map(UInt64Value._writeMessageJSON);
    }
    if (msg.int32Field?.length) {
      json.int32Field = msg.int32Field.map(Int32Value._writeMessageJSON);
    }
    if (msg.uint32Field?.length) {
      json.uint32Field = msg.uint32Field.map(UInt32Value._writeMessageJSON);
    }
    if (msg.boolField?.length) {
      json.boolField = msg.boolField.map(BoolValue._writeMessageJSON);
    }
    if (msg.stringField?.length) {
      json.stringField = msg.stringField.map(StringValue._writeMessageJSON);
    }
    if (msg.bytesField?.length) {
      json.bytesField = msg.bytesField.map(BytesValue._writeMessageJSON);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedWellKnownTypes,
    reader: BinaryReader
  ): RepeatedWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Any.initialize();
          reader.readMessage(m, Any._readMessage);
          msg.anyField.push(m);
          break;
        }
        case 2: {
          const m = Api.initialize();
          reader.readMessage(m, Api._readMessage);
          msg.apiField.push(m);
          break;
        }
        case 3: {
          const m = Duration.initialize();
          reader.readMessage(m, Duration._readMessage);
          msg.durationField.push(m);
          break;
        }
        case 4: {
          const m = Empty.initialize();
          reader.readMessage(m, Empty._readMessage);
          msg.emptyField.push(m);
          break;
        }
        case 5: {
          const m = FieldMask.initialize();
          reader.readMessage(m, FieldMask._readMessage);
          msg.fieldMaskField.push(m);
          break;
        }
        case 6: {
          const m = SourceContext.initialize();
          reader.readMessage(m, SourceContext._readMessage);
          msg.sourceContextField.push(m);
          break;
        }
        case 7: {
          const m = Struct.initialize();
          reader.readMessage(m, Struct._readMessage);
          msg.structField.push(m);
          break;
        }
        case 8: {
          const m = Timestamp.initialize();
          reader.readMessage(m, Timestamp._readMessage);
          msg.timestampField.push(m);
          break;
        }
        case 9: {
          const m = Type.initialize();
          reader.readMessage(m, Type._readMessage);
          msg.typeField.push(m);
          break;
        }
        case 10: {
          const m = DoubleValue.initialize();
          reader.readMessage(m, DoubleValue._readMessage);
          msg.doubleField.push(m);
          break;
        }
        case 11: {
          const m = FloatValue.initialize();
          reader.readMessage(m, FloatValue._readMessage);
          msg.floatField.push(m);
          break;
        }
        case 12: {
          const m = Int64Value.initialize();
          reader.readMessage(m, Int64Value._readMessage);
          msg.int64Field.push(m);
          break;
        }
        case 13: {
          const m = UInt64Value.initialize();
          reader.readMessage(m, UInt64Value._readMessage);
          msg.uint64Field.push(m);
          break;
        }
        case 14: {
          const m = Int32Value.initialize();
          reader.readMessage(m, Int32Value._readMessage);
          msg.int32Field.push(m);
          break;
        }
        case 15: {
          const m = UInt32Value.initialize();
          reader.readMessage(m, UInt32Value._readMessage);
          msg.uint32Field.push(m);
          break;
        }
        case 16: {
          const m = BoolValue.initialize();
          reader.readMessage(m, BoolValue._readMessage);
          msg.boolField.push(m);
          break;
        }
        case 17: {
          const m = StringValue.initialize();
          reader.readMessage(m, StringValue._readMessage);
          msg.stringField.push(m);
          break;
        }
        case 18: {
          const m = BytesValue.initialize();
          reader.readMessage(m, BytesValue._readMessage);
          msg.bytesField.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedWellKnownTypes,
    json: any
  ): RepeatedWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      for (const item of _anyField) {
        const m = Any.initialize();
        Any._readMessageJSON(m, item);
        msg.anyField.push(m);
      }
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      for (const item of _apiField) {
        const m = Api.initialize();
        Api._readMessageJSON(m, item);
        msg.apiField.push(m);
      }
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      for (const item of _durationField) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, item);
        msg.durationField.push(m);
      }
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      for (const item of _emptyField) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, item);
        msg.emptyField.push(m);
      }
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      for (const item of _fieldMaskField) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, item);
        msg.fieldMaskField.push(m);
      }
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      for (const item of _sourceContextField) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, item);
        msg.sourceContextField.push(m);
      }
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      for (const item of _structField) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, item);
        msg.structField.push(m);
      }
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      for (const item of _timestampField) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, item);
        msg.timestampField.push(m);
      }
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      for (const item of _typeField) {
        const m = Type.initialize();
        Type._readMessageJSON(m, item);
        msg.typeField.push(m);
      }
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      for (const item of _doubleField) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, item);
        msg.doubleField.push(m);
      }
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      for (const item of _floatField) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, item);
        msg.floatField.push(m);
      }
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      for (const item of _int64Field) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, item);
        msg.int64Field.push(m);
      }
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      for (const item of _uint64Field) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, item);
        msg.uint64Field.push(m);
      }
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      for (const item of _int32Field) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, item);
        msg.int32Field.push(m);
      }
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      for (const item of _uint32Field) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, item);
        msg.uint32Field.push(m);
      }
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      for (const item of _boolField) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, item);
        msg.boolField.push(m);
      }
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      for (const item of _stringField) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, item);
        msg.stringField.push(m);
      }
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      for (const item of _bytesField) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, item);
        msg.bytesField.push(m);
      }
    }
    return msg;
  },
};

export const OneofWellKnownTypes = {
  /**
   * Serializes a OneofWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<OneofWellKnownTypes>): Uint8Array {
    return OneofWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneofWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessage(
      OneofWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneofWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<OneofWellKnownTypes>): string {
    return JSON.stringify(OneofWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a OneofWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): OneofWellKnownTypes {
    return OneofWellKnownTypes._readMessageJSON(
      OneofWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OneofWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): OneofWellKnownTypes {
    return {
      anyField: Any.initialize(),
      apiField: Api.initialize(),
      durationField: Duration.initialize(),
      emptyField: Empty.initialize(),
      fieldMaskField: FieldMask.initialize(),
      sourceContextField: SourceContext.initialize(),
      structField: Struct.initialize(),
      timestampField: Timestamp.initialize(),
      typeField: Type.initialize(),
      doubleField: DoubleValue.initialize(),
      floatField: FloatValue.initialize(),
      int64Field: Int64Value.initialize(),
      uint64Field: UInt64Value.initialize(),
      int32Field: Int32Value.initialize(),
      uint32Field: UInt32Value.initialize(),
      boolField: BoolValue.initialize(),
      stringField: StringValue.initialize(),
      bytesField: BytesValue.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneofWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField != undefined) {
      writer.writeMessage(1, msg.anyField, Any._writeMessage);
    }
    if (msg.apiField != undefined) {
      writer.writeMessage(2, msg.apiField, Api._writeMessage);
    }
    if (msg.durationField != undefined) {
      writer.writeMessage(3, msg.durationField, Duration._writeMessage);
    }
    if (msg.emptyField != undefined) {
      writer.writeMessage(4, msg.emptyField, Empty._writeMessage);
    }
    if (msg.fieldMaskField != undefined) {
      writer.writeMessage(5, msg.fieldMaskField, FieldMask._writeMessage);
    }
    if (msg.sourceContextField != undefined) {
      writer.writeMessage(
        6,
        msg.sourceContextField,
        SourceContext._writeMessage
      );
    }
    if (msg.structField != undefined) {
      writer.writeMessage(7, msg.structField, Struct._writeMessage);
    }
    if (msg.timestampField != undefined) {
      writer.writeMessage(8, msg.timestampField, Timestamp._writeMessage);
    }
    if (msg.typeField != undefined) {
      writer.writeMessage(9, msg.typeField, Type._writeMessage);
    }
    if (msg.doubleField != undefined) {
      writer.writeMessage(10, msg.doubleField, DoubleValue._writeMessage);
    }
    if (msg.floatField != undefined) {
      writer.writeMessage(11, msg.floatField, FloatValue._writeMessage);
    }
    if (msg.int64Field != undefined) {
      writer.writeMessage(12, msg.int64Field, Int64Value._writeMessage);
    }
    if (msg.uint64Field != undefined) {
      writer.writeMessage(13, msg.uint64Field, UInt64Value._writeMessage);
    }
    if (msg.int32Field != undefined) {
      writer.writeMessage(14, msg.int32Field, Int32Value._writeMessage);
    }
    if (msg.uint32Field != undefined) {
      writer.writeMessage(15, msg.uint32Field, UInt32Value._writeMessage);
    }
    if (msg.boolField != undefined) {
      writer.writeMessage(16, msg.boolField, BoolValue._writeMessage);
    }
    if (msg.stringField != undefined) {
      writer.writeMessage(17, msg.stringField, StringValue._writeMessage);
    }
    if (msg.bytesField != undefined) {
      writer.writeMessage(18, msg.bytesField, BytesValue._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneofWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField != undefined) {
      const anyField = Any._writeMessageJSON(msg.anyField);
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField != undefined) {
      const apiField = Api._writeMessageJSON(msg.apiField);
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField != undefined) {
      const durationField = Duration._writeMessageJSON(msg.durationField);
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField != undefined) {
      const emptyField = Empty._writeMessageJSON(msg.emptyField);
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField != undefined) {
      const fieldMaskField = FieldMask._writeMessageJSON(msg.fieldMaskField);
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField != undefined) {
      const sourceContextField = SourceContext._writeMessageJSON(
        msg.sourceContextField
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField != undefined) {
      const structField = Struct._writeMessageJSON(msg.structField);
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField != undefined) {
      const timestampField = Timestamp._writeMessageJSON(msg.timestampField);
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField != undefined) {
      const typeField = Type._writeMessageJSON(msg.typeField);
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField != undefined) {
      const doubleField = DoubleValue._writeMessageJSON(msg.doubleField);
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField != undefined) {
      const floatField = FloatValue._writeMessageJSON(msg.floatField);
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field != undefined) {
      const int64Field = Int64Value._writeMessageJSON(msg.int64Field);
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field != undefined) {
      const uint64Field = UInt64Value._writeMessageJSON(msg.uint64Field);
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field != undefined) {
      const int32Field = Int32Value._writeMessageJSON(msg.int32Field);
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field != undefined) {
      const uint32Field = UInt32Value._writeMessageJSON(msg.uint32Field);
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField != undefined) {
      const boolField = BoolValue._writeMessageJSON(msg.boolField);
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField != undefined) {
      const stringField = StringValue._writeMessageJSON(msg.stringField);
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField != undefined) {
      const bytesField = BytesValue._writeMessageJSON(msg.bytesField);
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OneofWellKnownTypes,
    reader: BinaryReader
  ): OneofWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.anyField, Any._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.apiField, Api._readMessage);
          break;
        }
        case 3: {
          reader.readMessage(msg.durationField, Duration._readMessage);
          break;
        }
        case 4: {
          reader.readMessage(msg.emptyField, Empty._readMessage);
          break;
        }
        case 5: {
          reader.readMessage(msg.fieldMaskField, FieldMask._readMessage);
          break;
        }
        case 6: {
          reader.readMessage(
            msg.sourceContextField,
            SourceContext._readMessage
          );
          break;
        }
        case 7: {
          reader.readMessage(msg.structField, Struct._readMessage);
          break;
        }
        case 8: {
          reader.readMessage(msg.timestampField, Timestamp._readMessage);
          break;
        }
        case 9: {
          reader.readMessage(msg.typeField, Type._readMessage);
          break;
        }
        case 10: {
          reader.readMessage(msg.doubleField, DoubleValue._readMessage);
          break;
        }
        case 11: {
          reader.readMessage(msg.floatField, FloatValue._readMessage);
          break;
        }
        case 12: {
          reader.readMessage(msg.int64Field, Int64Value._readMessage);
          break;
        }
        case 13: {
          reader.readMessage(msg.uint64Field, UInt64Value._readMessage);
          break;
        }
        case 14: {
          reader.readMessage(msg.int32Field, Int32Value._readMessage);
          break;
        }
        case 15: {
          reader.readMessage(msg.uint32Field, UInt32Value._readMessage);
          break;
        }
        case 16: {
          reader.readMessage(msg.boolField, BoolValue._readMessage);
          break;
        }
        case 17: {
          reader.readMessage(msg.stringField, StringValue._readMessage);
          break;
        }
        case 18: {
          reader.readMessage(msg.bytesField, BytesValue._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OneofWellKnownTypes,
    json: any
  ): OneofWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      const m = Any.initialize();
      Any._readMessageJSON(m, _anyField);
      msg.anyField = m;
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      const m = Api.initialize();
      Api._readMessageJSON(m, _apiField);
      msg.apiField = m;
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      const m = Duration.initialize();
      Duration._readMessageJSON(m, _durationField);
      msg.durationField = m;
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      const m = Empty.initialize();
      Empty._readMessageJSON(m, _emptyField);
      msg.emptyField = m;
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      const m = FieldMask.initialize();
      FieldMask._readMessageJSON(m, _fieldMaskField);
      msg.fieldMaskField = m;
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      const m = SourceContext.initialize();
      SourceContext._readMessageJSON(m, _sourceContextField);
      msg.sourceContextField = m;
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      const m = Struct.initialize();
      Struct._readMessageJSON(m, _structField);
      msg.structField = m;
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      const m = Timestamp.initialize();
      Timestamp._readMessageJSON(m, _timestampField);
      msg.timestampField = m;
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      const m = Type.initialize();
      Type._readMessageJSON(m, _typeField);
      msg.typeField = m;
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      const m = DoubleValue.initialize();
      DoubleValue._readMessageJSON(m, _doubleField);
      msg.doubleField = m;
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      const m = FloatValue.initialize();
      FloatValue._readMessageJSON(m, _floatField);
      msg.floatField = m;
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      const m = Int64Value.initialize();
      Int64Value._readMessageJSON(m, _int64Field);
      msg.int64Field = m;
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      const m = UInt64Value.initialize();
      UInt64Value._readMessageJSON(m, _uint64Field);
      msg.uint64Field = m;
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      const m = Int32Value.initialize();
      Int32Value._readMessageJSON(m, _int32Field);
      msg.int32Field = m;
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      const m = UInt32Value.initialize();
      UInt32Value._readMessageJSON(m, _uint32Field);
      msg.uint32Field = m;
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      const m = BoolValue.initialize();
      BoolValue._readMessageJSON(m, _boolField);
      msg.boolField = m;
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      const m = StringValue.initialize();
      StringValue._readMessageJSON(m, _stringField);
      msg.stringField = m;
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      const m = BytesValue.initialize();
      BytesValue._readMessageJSON(m, _bytesField);
      msg.bytesField = m;
    }
    return msg;
  },
};

export const MapWellKnownTypes = {
  /**
   * Serializes a MapWellKnownTypes to protobuf.
   */
  encode: function (msg: Partial<MapWellKnownTypes>): Uint8Array {
    return MapWellKnownTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MapWellKnownTypes from protobuf.
   */
  decode: function (bytes: ByteSource): MapWellKnownTypes {
    return MapWellKnownTypes._readMessage(
      MapWellKnownTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MapWellKnownTypes to JSON.
   */
  encodeJSON: function (msg: Partial<MapWellKnownTypes>): string {
    return JSON.stringify(MapWellKnownTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a MapWellKnownTypes from JSON.
   */
  decodeJSON: function (json: string): MapWellKnownTypes {
    return MapWellKnownTypes._readMessageJSON(
      MapWellKnownTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MapWellKnownTypes with all fields set to their default value.
   */
  initialize: function (): MapWellKnownTypes {
    return {
      anyField: {},
      apiField: {},
      durationField: {},
      emptyField: {},
      fieldMaskField: {},
      sourceContextField: {},
      structField: {},
      timestampField: {},
      typeField: {},
      doubleField: {},
      floatField: {},
      int64Field: {},
      uint64Field: {},
      int32Field: {},
      uint32Field: {},
      boolField: {},
      stringField: {},
      bytesField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MapWellKnownTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.anyField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries<any>(msg.anyField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.AnyField._writeMessage
      );
    }
    if (msg.apiField) {
      writer.writeRepeatedMessage(
        2,
        Object.entries<any>(msg.apiField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.ApiField._writeMessage
      );
    }
    if (msg.durationField) {
      writer.writeRepeatedMessage(
        3,
        Object.entries<any>(msg.durationField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.DurationField._writeMessage
      );
    }
    if (msg.emptyField) {
      writer.writeRepeatedMessage(
        4,
        Object.entries<any>(msg.emptyField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.EmptyField._writeMessage
      );
    }
    if (msg.fieldMaskField) {
      writer.writeRepeatedMessage(
        5,
        Object.entries<any>(msg.fieldMaskField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.FieldMaskField._writeMessage
      );
    }
    if (msg.sourceContextField) {
      writer.writeRepeatedMessage(
        6,
        Object.entries<any>(msg.sourceContextField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.SourceContextField._writeMessage
      );
    }
    if (msg.structField) {
      writer.writeRepeatedMessage(
        7,
        Object.entries<any>(msg.structField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.StructField._writeMessage
      );
    }
    if (msg.timestampField) {
      writer.writeRepeatedMessage(
        8,
        Object.entries<any>(msg.timestampField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.TimestampField._writeMessage
      );
    }
    if (msg.typeField) {
      writer.writeRepeatedMessage(
        9,
        Object.entries<any>(msg.typeField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.TypeField._writeMessage
      );
    }
    if (msg.doubleField) {
      writer.writeRepeatedMessage(
        10,
        Object.entries<any>(msg.doubleField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.DoubleField._writeMessage
      );
    }
    if (msg.floatField) {
      writer.writeRepeatedMessage(
        11,
        Object.entries<any>(msg.floatField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.FloatField._writeMessage
      );
    }
    if (msg.int64Field) {
      writer.writeRepeatedMessage(
        12,
        Object.entries<any>(msg.int64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Int64Field._writeMessage
      );
    }
    if (msg.uint64Field) {
      writer.writeRepeatedMessage(
        13,
        Object.entries<any>(msg.uint64Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Uint64Field._writeMessage
      );
    }
    if (msg.int32Field) {
      writer.writeRepeatedMessage(
        14,
        Object.entries<any>(msg.int32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Int32Field._writeMessage
      );
    }
    if (msg.uint32Field) {
      writer.writeRepeatedMessage(
        15,
        Object.entries<any>(msg.uint32Field).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.Uint32Field._writeMessage
      );
    }
    if (msg.boolField) {
      writer.writeRepeatedMessage(
        16,
        Object.entries<any>(msg.boolField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.BoolField._writeMessage
      );
    }
    if (msg.stringField) {
      writer.writeRepeatedMessage(
        17,
        Object.entries<any>(msg.stringField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.StringField._writeMessage
      );
    }
    if (msg.bytesField) {
      writer.writeRepeatedMessage(
        18,
        Object.entries<any>(msg.bytesField).map(([key, value]) => ({
          key: key,
          value: value,
        })) as any,
        MapWellKnownTypes.BytesField._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MapWellKnownTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.anyField) {
      const anyField = Object.fromEntries(
        Object.entries<any>(msg.anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(anyField).length > 0) {
        json.anyField = anyField;
      }
    }
    if (msg.apiField) {
      const apiField = Object.fromEntries(
        Object.entries<any>(msg.apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(apiField).length > 0) {
        json.apiField = apiField;
      }
    }
    if (msg.durationField) {
      const durationField = Object.fromEntries(
        Object.entries<any>(msg.durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(durationField).length > 0) {
        json.durationField = durationField;
      }
    }
    if (msg.emptyField) {
      const emptyField = Object.fromEntries(
        Object.entries<any>(msg.emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(emptyField).length > 0) {
        json.emptyField = emptyField;
      }
    }
    if (msg.fieldMaskField) {
      const fieldMaskField = Object.fromEntries(
        Object.entries<any>(msg.fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(fieldMaskField).length > 0) {
        json.fieldMaskField = fieldMaskField;
      }
    }
    if (msg.sourceContextField) {
      const sourceContextField = Object.fromEntries(
        Object.entries<any>(msg.sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(sourceContextField).length > 0) {
        json.sourceContextField = sourceContextField;
      }
    }
    if (msg.structField) {
      const structField = Object.fromEntries(
        Object.entries<any>(msg.structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(structField).length > 0) {
        json.structField = structField;
      }
    }
    if (msg.timestampField) {
      const timestampField = Object.fromEntries(
        Object.entries<any>(msg.timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(timestampField).length > 0) {
        json.timestampField = timestampField;
      }
    }
    if (msg.typeField) {
      const typeField = Object.fromEntries(
        Object.entries<any>(msg.typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(typeField).length > 0) {
        json.typeField = typeField;
      }
    }
    if (msg.doubleField) {
      const doubleField = Object.fromEntries(
        Object.entries<any>(msg.doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(doubleField).length > 0) {
        json.doubleField = doubleField;
      }
    }
    if (msg.floatField) {
      const floatField = Object.fromEntries(
        Object.entries<any>(msg.floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(floatField).length > 0) {
        json.floatField = floatField;
      }
    }
    if (msg.int64Field) {
      const int64Field = Object.fromEntries(
        Object.entries<any>(msg.int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int64Field).length > 0) {
        json.int64Field = int64Field;
      }
    }
    if (msg.uint64Field) {
      const uint64Field = Object.fromEntries(
        Object.entries<any>(msg.uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint64Field).length > 0) {
        json.uint64Field = uint64Field;
      }
    }
    if (msg.int32Field) {
      const int32Field = Object.fromEntries(
        Object.entries<any>(msg.int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(int32Field).length > 0) {
        json.int32Field = int32Field;
      }
    }
    if (msg.uint32Field) {
      const uint32Field = Object.fromEntries(
        Object.entries<any>(msg.uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(uint32Field).length > 0) {
        json.uint32Field = uint32Field;
      }
    }
    if (msg.boolField) {
      const boolField = Object.fromEntries(
        Object.entries<any>(msg.boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(boolField).length > 0) {
        json.boolField = boolField;
      }
    }
    if (msg.stringField) {
      const stringField = Object.fromEntries(
        Object.entries<any>(msg.stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(stringField).length > 0) {
        json.stringField = stringField;
      }
    }
    if (msg.bytesField) {
      const bytesField = Object.fromEntries(
        Object.entries<any>(msg.bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(bytesField).length > 0) {
        json.bytesField = bytesField;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MapWellKnownTypes,
    reader: BinaryReader
  ): MapWellKnownTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const anyField = {} as MapMessage<MapWellKnownTypes.AnyField>;
          reader.readMessage(anyField, MapWellKnownTypes.AnyField._readMessage);
          msg.anyField[anyField.key] = anyField.value;
          break;
        }
        case 2: {
          const apiField = {} as MapMessage<MapWellKnownTypes.ApiField>;
          reader.readMessage(apiField, MapWellKnownTypes.ApiField._readMessage);
          msg.apiField[apiField.key] = apiField.value;
          break;
        }
        case 3: {
          const durationField =
            {} as MapMessage<MapWellKnownTypes.DurationField>;
          reader.readMessage(
            durationField,
            MapWellKnownTypes.DurationField._readMessage
          );
          msg.durationField[durationField.key] = durationField.value;
          break;
        }
        case 4: {
          const emptyField = {} as MapMessage<MapWellKnownTypes.EmptyField>;
          reader.readMessage(
            emptyField,
            MapWellKnownTypes.EmptyField._readMessage
          );
          msg.emptyField[emptyField.key] = emptyField.value;
          break;
        }
        case 5: {
          const fieldMaskField =
            {} as MapMessage<MapWellKnownTypes.FieldMaskField>;
          reader.readMessage(
            fieldMaskField,
            MapWellKnownTypes.FieldMaskField._readMessage
          );
          msg.fieldMaskField[fieldMaskField.key] = fieldMaskField.value;
          break;
        }
        case 6: {
          const sourceContextField =
            {} as MapMessage<MapWellKnownTypes.SourceContextField>;
          reader.readMessage(
            sourceContextField,
            MapWellKnownTypes.SourceContextField._readMessage
          );
          msg.sourceContextField[sourceContextField.key] =
            sourceContextField.value;
          break;
        }
        case 7: {
          const structField = {} as MapMessage<MapWellKnownTypes.StructField>;
          reader.readMessage(
            structField,
            MapWellKnownTypes.StructField._readMessage
          );
          msg.structField[structField.key] = structField.value;
          break;
        }
        case 8: {
          const timestampField =
            {} as MapMessage<MapWellKnownTypes.TimestampField>;
          reader.readMessage(
            timestampField,
            MapWellKnownTypes.TimestampField._readMessage
          );
          msg.timestampField[timestampField.key] = timestampField.value;
          break;
        }
        case 9: {
          const typeField = {} as MapMessage<MapWellKnownTypes.TypeField>;
          reader.readMessage(
            typeField,
            MapWellKnownTypes.TypeField._readMessage
          );
          msg.typeField[typeField.key] = typeField.value;
          break;
        }
        case 10: {
          const doubleField = {} as MapMessage<MapWellKnownTypes.DoubleField>;
          reader.readMessage(
            doubleField,
            MapWellKnownTypes.DoubleField._readMessage
          );
          msg.doubleField[doubleField.key] = doubleField.value;
          break;
        }
        case 11: {
          const floatField = {} as MapMessage<MapWellKnownTypes.FloatField>;
          reader.readMessage(
            floatField,
            MapWellKnownTypes.FloatField._readMessage
          );
          msg.floatField[floatField.key] = floatField.value;
          break;
        }
        case 12: {
          const int64Field = {} as MapMessage<MapWellKnownTypes.Int64Field>;
          reader.readMessage(
            int64Field,
            MapWellKnownTypes.Int64Field._readMessage
          );
          msg.int64Field[int64Field.key] = int64Field.value;
          break;
        }
        case 13: {
          const uint64Field = {} as MapMessage<MapWellKnownTypes.Uint64Field>;
          reader.readMessage(
            uint64Field,
            MapWellKnownTypes.Uint64Field._readMessage
          );
          msg.uint64Field[uint64Field.key] = uint64Field.value;
          break;
        }
        case 14: {
          const int32Field = {} as MapMessage<MapWellKnownTypes.Int32Field>;
          reader.readMessage(
            int32Field,
            MapWellKnownTypes.Int32Field._readMessage
          );
          msg.int32Field[int32Field.key] = int32Field.value;
          break;
        }
        case 15: {
          const uint32Field = {} as MapMessage<MapWellKnownTypes.Uint32Field>;
          reader.readMessage(
            uint32Field,
            MapWellKnownTypes.Uint32Field._readMessage
          );
          msg.uint32Field[uint32Field.key] = uint32Field.value;
          break;
        }
        case 16: {
          const boolField = {} as MapMessage<MapWellKnownTypes.BoolField>;
          reader.readMessage(
            boolField,
            MapWellKnownTypes.BoolField._readMessage
          );
          msg.boolField[boolField.key] = boolField.value;
          break;
        }
        case 17: {
          const stringField = {} as MapMessage<MapWellKnownTypes.StringField>;
          reader.readMessage(
            stringField,
            MapWellKnownTypes.StringField._readMessage
          );
          msg.stringField[stringField.key] = stringField.value;
          break;
        }
        case 18: {
          const bytesField = {} as MapMessage<MapWellKnownTypes.BytesField>;
          reader.readMessage(
            bytesField,
            MapWellKnownTypes.BytesField._readMessage
          );
          msg.bytesField[bytesField.key] = bytesField.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MapWellKnownTypes,
    json: any
  ): MapWellKnownTypes {
    const _anyField = json.anyField ?? json.any_field;
    if (_anyField) {
      msg.anyField = Object.fromEntries(
        Object.entries<any>(_anyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.AnyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _apiField = json.apiField ?? json.api_field;
    if (_apiField) {
      msg.apiField = Object.fromEntries(
        Object.entries<any>(_apiField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.ApiField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _durationField = json.durationField ?? json.duration_field;
    if (_durationField) {
      msg.durationField = Object.fromEntries(
        Object.entries<any>(_durationField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DurationField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _emptyField = json.emptyField ?? json.empty_field;
    if (_emptyField) {
      msg.emptyField = Object.fromEntries(
        Object.entries<any>(_emptyField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.EmptyField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _fieldMaskField = json.fieldMaskField ?? json.field_mask_field;
    if (_fieldMaskField) {
      msg.fieldMaskField = Object.fromEntries(
        Object.entries<any>(_fieldMaskField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FieldMaskField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _sourceContextField =
      json.sourceContextField ?? json.source_context_field;
    if (_sourceContextField) {
      msg.sourceContextField = Object.fromEntries(
        Object.entries<any>(_sourceContextField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.SourceContextField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _structField = json.structField ?? json.struct_field;
    if (_structField) {
      msg.structField = Object.fromEntries(
        Object.entries<any>(_structField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StructField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _timestampField = json.timestampField ?? json.timestamp_field;
    if (_timestampField) {
      msg.timestampField = Object.fromEntries(
        Object.entries<any>(_timestampField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TimestampField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _typeField = json.typeField ?? json.type_field;
    if (_typeField) {
      msg.typeField = Object.fromEntries(
        Object.entries<any>(_typeField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.TypeField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _doubleField = json.doubleField ?? json.double_field;
    if (_doubleField) {
      msg.doubleField = Object.fromEntries(
        Object.entries<any>(_doubleField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.DoubleField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _floatField = json.floatField ?? json.float_field;
    if (_floatField) {
      msg.floatField = Object.fromEntries(
        Object.entries<any>(_floatField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.FloatField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int64Field = json.int64Field ?? json.int64_field;
    if (_int64Field) {
      msg.int64Field = Object.fromEntries(
        Object.entries<any>(_int64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint64Field = json.uint64Field ?? json.uint64_field;
    if (_uint64Field) {
      msg.uint64Field = Object.fromEntries(
        Object.entries<any>(_uint64Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint64Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _int32Field = json.int32Field ?? json.int32_field;
    if (_int32Field) {
      msg.int32Field = Object.fromEntries(
        Object.entries<any>(_int32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Int32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _uint32Field = json.uint32Field ?? json.uint32_field;
    if (_uint32Field) {
      msg.uint32Field = Object.fromEntries(
        Object.entries<any>(_uint32Field)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.Uint32Field._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _boolField = json.boolField ?? json.bool_field;
    if (_boolField) {
      msg.boolField = Object.fromEntries(
        Object.entries<any>(_boolField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BoolField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _stringField = json.stringField ?? json.string_field;
    if (_stringField) {
      msg.stringField = Object.fromEntries(
        Object.entries<any>(_stringField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.StringField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    const _bytesField = json.bytesField ?? json.bytes_field;
    if (_bytesField) {
      msg.bytesField = Object.fromEntries(
        Object.entries<any>(_bytesField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MapWellKnownTypes.BytesField._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  AnyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Any._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Any._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.AnyField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Any.initialize(), Any._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.AnyField>,
      json: any
    ): MapMessage<MapWellKnownTypes.AnyField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Any.initialize();
        Any._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  ApiField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Api._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Api._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.ApiField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Api.initialize(), Api._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.ApiField>,
      json: any
    ): MapMessage<MapWellKnownTypes.ApiField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Api.initialize();
        Api._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DurationField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Duration._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Duration._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.DurationField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Duration.initialize(), Duration._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DurationField>,
      json: any
    ): MapMessage<MapWellKnownTypes.DurationField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Duration.initialize();
        Duration._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  EmptyField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Empty._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Empty._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.EmptyField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Empty.initialize(), Empty._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.EmptyField>,
      json: any
    ): MapMessage<MapWellKnownTypes.EmptyField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Empty.initialize();
        Empty._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FieldMaskField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FieldMask._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FieldMask._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.FieldMaskField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(FieldMask.initialize(), FieldMask._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FieldMaskField>,
      json: any
    ): MapMessage<MapWellKnownTypes.FieldMaskField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FieldMask.initialize();
        FieldMask._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  SourceContextField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, SourceContext._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = SourceContext._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.SourceContextField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              SourceContext.initialize(),
              SourceContext._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.SourceContextField>,
      json: any
    ): MapMessage<MapWellKnownTypes.SourceContextField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = SourceContext.initialize();
        SourceContext._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StructField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Struct._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StructField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Struct._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.StructField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Struct.initialize(), Struct._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StructField>,
      json: any
    ): MapMessage<MapWellKnownTypes.StructField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Struct.initialize();
        Struct._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TimestampField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Timestamp._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Timestamp._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.TimestampField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Timestamp.initialize(), Timestamp._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TimestampField>,
      json: any
    ): MapMessage<MapWellKnownTypes.TimestampField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Timestamp.initialize();
        Timestamp._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  TypeField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Type._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Type._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.TypeField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(Type.initialize(), Type._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.TypeField>,
      json: any
    ): MapMessage<MapWellKnownTypes.TypeField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Type.initialize();
        Type._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  DoubleField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, DoubleValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = DoubleValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.DoubleField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              DoubleValue.initialize(),
              DoubleValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.DoubleField>,
      json: any
    ): MapMessage<MapWellKnownTypes.DoubleField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = DoubleValue.initialize();
        DoubleValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  FloatField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, FloatValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = FloatValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.FloatField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              FloatValue.initialize(),
              FloatValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.FloatField>,
      json: any
    ): MapMessage<MapWellKnownTypes.FloatField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = FloatValue.initialize();
        FloatValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Int64Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int64Value.initialize(),
              Int64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int64Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Int64Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int64Value.initialize();
        Int64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint64Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt64Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt64Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Uint64Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt64Value.initialize(),
              UInt64Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint64Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Uint64Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt64Value.initialize();
        UInt64Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Int32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, Int32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = Int32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Int32Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              Int32Value.initialize(),
              Int32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Int32Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Int32Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = Int32Value.initialize();
        Int32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  Uint32Field: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, UInt32Value._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = UInt32Value._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.Uint32Field> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              UInt32Value.initialize(),
              UInt32Value._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.Uint32Field>,
      json: any
    ): MapMessage<MapWellKnownTypes.Uint32Field> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = UInt32Value.initialize();
        UInt32Value._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BoolField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BoolValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BoolValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.BoolField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(BoolValue.initialize(), BoolValue._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BoolField>,
      json: any
    ): MapMessage<MapWellKnownTypes.BoolField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BoolValue.initialize();
        BoolValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  StringField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StringField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = StringValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.StringField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              StringValue.initialize(),
              StringValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.StringField>,
      json: any
    ): MapMessage<MapWellKnownTypes.StringField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = StringValue.initialize();
        StringValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },

  BytesField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, BytesValue._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = BytesValue._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      reader: BinaryReader
    ): MapMessage<MapWellKnownTypes.BytesField> {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            reader.readMessage(
              BytesValue.initialize(),
              BytesValue._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: MapMessage<MapWellKnownTypes.BytesField>,
      json: any
    ): MapMessage<MapWellKnownTypes.BytesField> {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = BytesValue.initialize();
        BytesValue._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource, MapMessage } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum =
  | \\"FOREIGN_ZERO\\"
  | \\"FOREIGN_FOO\\"
  | \\"FOREIGN_BAR\\"
  | \\"FOREIGN_BAZ\\";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

declare namespace TestAllTypes {
  export type NestedEnum = \\"ZERO\\" | \\"FOO\\" | \\"BAR\\" | \\"BAZ\\" | \\"NEG\\";

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
}

declare namespace TestOneof2 {
  export type NestedEnum = \\"UNKNOWN\\" | \\"FOO\\" | \\"BAR\\" | \\"BAZ\\";
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: \\"FOREIGN_ZERO\\",
  FOREIGN_FOO: \\"FOREIGN_FOO\\",
  FOREIGN_BAR: \\"FOREIGN_BAR\\",
  FOREIGN_BAZ: \\"FOREIGN_BAZ\\",
} as const;

const ForeignEnumFromInt = function (i: number): ForeignEnum {
  switch (i) {
    case 0: {
      return \\"FOREIGN_ZERO\\";
    }
    case 4: {
      return \\"FOREIGN_FOO\\";
    }
    case 5: {
      return \\"FOREIGN_BAR\\";
    }
    case 6: {
      return \\"FOREIGN_BAZ\\";
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as ForeignEnum;
    }
  }
};

const ForeignEnumToInt = function (i: ForeignEnum): number {
  switch (i) {
    case \\"FOREIGN_ZERO\\": {
      return 0;
    }
    case \\"FOREIGN_FOO\\": {
      return 4;
    }
    case \\"FOREIGN_BAR\\": {
      return 5;
    }
    case \\"FOREIGN_BAZ\\": {
      return 6;
    }
    // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
    default: {
      return i as unknown as number;
    }
  }
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (msg: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnumFromInt(0),
      optionalForeignEnum: ForeignEnumFromInt(0),
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
      );
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      writer.writeEnum(22, ForeignEnumToInt(msg.optionalForeignEnum));
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        40,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnumToInt)
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json.optionalBytes = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnumToInt(msg.optionalNestedEnum)
    ) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum && ForeignEnumToInt(msg.optionalForeignEnum)) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json.oneofBytes = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnumFromInt(
            reader.readEnum()
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnumFromInt(reader.readEnum());
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (_optionalInt32) {
      msg.optionalInt32 = _optionalInt32;
    }
    const _optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (_optionalInt64) {
      msg.optionalInt64 = BigInt(_optionalInt64);
    }
    const _optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (_optionalUint32) {
      msg.optionalUint32 = _optionalUint32;
    }
    const _optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (_optionalUint64) {
      msg.optionalUint64 = BigInt(_optionalUint64);
    }
    const _optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (_optionalSint32) {
      msg.optionalSint32 = _optionalSint32;
    }
    const _optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (_optionalSint64) {
      msg.optionalSint64 = BigInt(_optionalSint64);
    }
    const _optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (_optionalFixed32) {
      msg.optionalFixed32 = _optionalFixed32;
    }
    const _optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (_optionalFixed64) {
      msg.optionalFixed64 = BigInt(_optionalFixed64);
    }
    const _optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (_optionalSfixed32) {
      msg.optionalSfixed32 = _optionalSfixed32;
    }
    const _optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (_optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64);
    }
    const _optionalFloat = json.optionalFloat ?? json.optional_float;
    if (_optionalFloat) {
      msg.optionalFloat = _optionalFloat;
    }
    const _optionalDouble = json.optionalDouble ?? json.optional_double;
    if (_optionalDouble) {
      msg.optionalDouble = _optionalDouble;
    }
    const _optionalBool = json.optionalBool ?? json.optional_bool;
    if (_optionalBool) {
      msg.optionalBool = _optionalBool;
    }
    const _optionalString = json.optionalString ?? json.optional_string;
    if (_optionalString) {
      msg.optionalString = _optionalString;
    }
    const _optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (_optionalBytes) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes);
    }
    const _optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (_optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const _optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (_optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, _optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const _optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (_optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const _optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (_optionalNestedEnum) {
      msg.optionalNestedEnum = _optionalNestedEnum;
    }
    const _optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (_optionalForeignEnum) {
      msg.optionalForeignEnum = _optionalForeignEnum;
    }
    const _optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (_optionalStringPiece) {
      msg.optionalStringPiece = _optionalStringPiece;
    }
    const _optionalCord = json.optionalCord ?? json.optional_cord;
    if (_optionalCord) {
      msg.optionalCord = _optionalCord;
    }
    const _optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (_optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, _optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const _optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (_optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const _optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (_optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, _optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedString = json.repeatedString ?? json.repeated_string;
    if (_repeatedString) {
      msg.repeatedString = _repeatedString;
    }
    const _repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (_repeatedBytes) {
      msg.repeatedBytes = _repeatedBytes.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (_repeatedNestedMessage) {
      for (const item of _repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (_repeatedForeignMessage) {
      for (const item of _repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (_repeatedImportMessage) {
      for (const item of _repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    const _repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (_repeatedForeignEnum) {
      msg.repeatedForeignEnum = _repeatedForeignEnum;
    }
    const _repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (_repeatedStringPiece) {
      msg.repeatedStringPiece = _repeatedStringPiece;
    }
    const _repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (_repeatedCord) {
      msg.repeatedCord = _repeatedCord;
    }
    const _repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (_repeatedLazyMessage) {
      for (const item of _repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (_oneofUint32) {
      msg.oneofUint32 = _oneofUint32;
    }
    const _oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (_oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, _oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const _oneofString = json.oneofString ?? json.oneof_string;
    if (_oneofString) {
      msg.oneofString = _oneofString;
    }
    const _oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (_oneofBytes) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes);
    }
    return msg;
  },

  NestedEnum: {
    ZERO: \\"ZERO\\",
    FOO: \\"FOO\\",
    BAR: \\"BAR\\",
    BAZ: \\"BAZ\\",
    NEG: \\"NEG\\",
  } as const,

  NestedEnumFromInt: function (i: number): TestAllTypes.NestedEnum {
    switch (i) {
      case 0: {
        return \\"ZERO\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      case -1: {
        return \\"NEG\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestAllTypes.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestAllTypes.NestedEnum): number {
    switch (i) {
      case \\"ZERO\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      case \\"NEG\\": {
        return -1;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg: Partial<TestAllTypes.NestedMessage>): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (msg: Partial<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypes.NestedMessage._writeMessageJSON(msg));
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const _bb = json.bb;
      if (_bb) {
        msg.bb = _bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString())
      );
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString())
      );
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString())
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString())
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        99,
        msg.packedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum.map(ForeignEnumToInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(ForeignEnumFromInt(reader.readEnum()));
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const _packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (_packedInt32) {
      msg.packedInt32 = _packedInt32;
    }
    const _packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (_packedInt64) {
      msg.packedInt64 = _packedInt64.map(BigInt);
    }
    const _packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (_packedUint32) {
      msg.packedUint32 = _packedUint32;
    }
    const _packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (_packedUint64) {
      msg.packedUint64 = _packedUint64.map(BigInt);
    }
    const _packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (_packedSint32) {
      msg.packedSint32 = _packedSint32;
    }
    const _packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (_packedSint64) {
      msg.packedSint64 = _packedSint64.map(BigInt);
    }
    const _packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (_packedFixed32) {
      msg.packedFixed32 = _packedFixed32;
    }
    const _packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (_packedFixed64) {
      msg.packedFixed64 = _packedFixed64.map(BigInt);
    }
    const _packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (_packedSfixed32) {
      msg.packedSfixed32 = _packedSfixed32;
    }
    const _packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (_packedSfixed64) {
      msg.packedSfixed64 = _packedSfixed64.map(BigInt);
    }
    const _packedFloat = json.packedFloat ?? json.packed_float;
    if (_packedFloat) {
      msg.packedFloat = _packedFloat;
    }
    const _packedDouble = json.packedDouble ?? json.packed_double;
    if (_packedDouble) {
      msg.packedDouble = _packedDouble;
    }
    const _packedBool = json.packedBool ?? json.packed_bool;
    if (_packedBool) {
      msg.packedBool = _packedBool;
    }
    const _packedEnum = json.packedEnum ?? json.packed_enum;
    if (_packedEnum) {
      msg.packedEnum = _packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (msg: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (msg: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(
        2,
        msg.repeatedInt64.map((x) => x.toString())
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(
        4,
        msg.repeatedUint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(
        6,
        msg.repeatedSint64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(
        8,
        msg.repeatedFixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(
        10,
        msg.repeatedSfixed64.map((x) => x.toString())
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(
        14,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnumToInt)
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(BigInt(reader.readSint64()));
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(BigInt(reader.readSfixed64()));
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            TestAllTypes.NestedEnumFromInt(reader.readEnum())
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const _repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (_repeatedInt32) {
      msg.repeatedInt32 = _repeatedInt32;
    }
    const _repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (_repeatedInt64) {
      msg.repeatedInt64 = _repeatedInt64.map(BigInt);
    }
    const _repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (_repeatedUint32) {
      msg.repeatedUint32 = _repeatedUint32;
    }
    const _repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (_repeatedUint64) {
      msg.repeatedUint64 = _repeatedUint64.map(BigInt);
    }
    const _repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (_repeatedSint32) {
      msg.repeatedSint32 = _repeatedSint32;
    }
    const _repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (_repeatedSint64) {
      msg.repeatedSint64 = _repeatedSint64.map(BigInt);
    }
    const _repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (_repeatedFixed32) {
      msg.repeatedFixed32 = _repeatedFixed32;
    }
    const _repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (_repeatedFixed64) {
      msg.repeatedFixed64 = _repeatedFixed64.map(BigInt);
    }
    const _repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (_repeatedSfixed32) {
      msg.repeatedSfixed32 = _repeatedSfixed32;
    }
    const _repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (_repeatedSfixed64) {
      msg.repeatedSfixed64 = _repeatedSfixed64.map(BigInt);
    }
    const _repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (_repeatedFloat) {
      msg.repeatedFloat = _repeatedFloat;
    }
    const _repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (_repeatedDouble) {
      msg.repeatedDouble = _repeatedDouble;
    }
    const _repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (_repeatedBool) {
      msg.repeatedBool = _repeatedBool;
    }
    const _repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (_repeatedNestedEnum) {
      msg.repeatedNestedEnum = _repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (msg: Partial<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (msg: Partial<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const _child = json.child;
    if (_child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, _child);
      msg.child = m;
    }
    const _payload = json.payload;
    if (_payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, _payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (msg: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (msg: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(msg));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c = json.c;
    if (_c) {
      msg.c = _c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */
  encodeJSON: function (_msg?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */
  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (msg: Partial<TestMessageWithDummy>): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (msg: Partial<TestMessageWithDummy>): string {
    return JSON.stringify(TestMessageWithDummy._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const _dummy = json.dummy;
    if (_dummy) {
      msg.dummy = _dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (msg: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (msg: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(msg));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnumToInt(msg.fooEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnumFromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooEnum = json.fooEnum ?? json.foo_enum;
    if (_fooEnum) {
      msg.fooEnum = _fooEnum;
    }
    return msg;
  },

  NestedEnum: {
    UNKNOWN: \\"UNKNOWN\\",
    FOO: \\"FOO\\",
    BAR: \\"BAR\\",
    BAZ: \\"BAZ\\",
  } as const,

  NestedEnumFromInt: function (i: number): TestOneof2.NestedEnum {
    switch (i) {
      case 0: {
        return \\"UNKNOWN\\";
      }
      case 1: {
        return \\"FOO\\";
      }
      case 2: {
        return \\"BAR\\";
      }
      case 3: {
        return \\"BAZ\\";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestOneof2.NestedEnum;
      }
    }
  },

  NestedEnumToInt: function (i: TestOneof2.NestedEnum): number {
    switch (i) {
      case \\"UNKNOWN\\": {
        return 0;
      }
      case \\"FOO\\": {
        return 1;
      }
      case \\"BAR\\": {
        return 2;
      }
      case \\"BAZ\\": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { MapMessage, ClientConfiguration } from \\"twirpscript\\";
import {
  encodeBase64Bytes,
  decodeBase64Bytes,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//                  Foo                   //
//========================================//

export interface Foo<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFoo<Context>(service: Foo<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
