// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (publicImportMessage) {
    return JSON.stringify(
      PublicImportMessage._writeMessageJSON(publicImportMessage)
    );
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const e = json.e ?? json.e;
    if (e) {
      msg.e = e;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (importMessage) {
    return JSON.stringify(ImportMessage._writeMessageJSON(importMessage));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes) {
      json.defaultBytes = msg.defaultBytes;
    }
    if (msg.defaultNestedEnum) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum();
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum();
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum();
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (optionalImportEnum) {
      msg.optionalImportEnum = optionalImportEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (repeatedImportEnum) {
      msg.repeatedImportEnum = repeatedImportEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (defaultInt32) {
      msg.defaultInt32 = defaultInt32;
    }
    const defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (defaultInt64) {
      msg.defaultInt64 = BigInt(defaultInt64);
    }
    const defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (defaultUint32) {
      msg.defaultUint32 = defaultUint32;
    }
    const defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (defaultUint64) {
      msg.defaultUint64 = BigInt(defaultUint64);
    }
    const defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (defaultSint32) {
      msg.defaultSint32 = defaultSint32;
    }
    const defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (defaultSint64) {
      msg.defaultSint64 = BigInt(defaultSint64);
    }
    const defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (defaultFixed32) {
      msg.defaultFixed32 = defaultFixed32;
    }
    const defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (defaultFixed64) {
      msg.defaultFixed64 = BigInt(defaultFixed64);
    }
    const defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (defaultSfixed32) {
      msg.defaultSfixed32 = defaultSfixed32;
    }
    const defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(defaultSfixed64);
    }
    const defaultFloat = json.defaultFloat ?? json.default_float;
    if (defaultFloat) {
      msg.defaultFloat = defaultFloat;
    }
    const defaultDouble = json.defaultDouble ?? json.default_double;
    if (defaultDouble) {
      msg.defaultDouble = defaultDouble;
    }
    const defaultBool = json.defaultBool ?? json.default_bool;
    if (defaultBool) {
      msg.defaultBool = defaultBool;
    }
    const defaultString = json.defaultString ?? json.default_string;
    if (defaultString) {
      msg.defaultString = defaultString;
    }
    const defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (defaultBytes) {
      msg.defaultBytes = defaultBytes;
    }
    const defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (defaultNestedEnum) {
      msg.defaultNestedEnum = defaultNestedEnum;
    }
    const defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (defaultForeignEnum) {
      msg.defaultForeignEnum = defaultForeignEnum;
    }
    const defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (defaultImportEnum) {
      msg.defaultImportEnum = defaultImportEnum;
    }
    const defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (defaultStringPiece) {
      msg.defaultStringPiece = defaultStringPiece;
    }
    const defaultCord = json.defaultCord ?? json.default_cord;
    if (defaultCord) {
      msg.defaultCord = defaultCord;
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestAllTypes.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (repeatedGroup) {
      return JSON.stringify(
        TestAllTypes.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (nestedTestAllTypes) {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    const repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (repeatedChild) {
      for (const item of repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (testDeprecatedFields) {
    return JSON.stringify(
      TestDeprecatedFields._writeMessageJSON(testDeprecatedFields)
    );
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json) {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (deprecatedInt32) {
      msg.deprecatedInt32 = deprecatedInt32;
    }
    const deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (_testDeprecatedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */

  encodeJSON: function (_testDeprecatedMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (_testReservedFields) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */

  encodeJSON: function (_testReservedFields) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (_testAllExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */

  encodeJSON: function (_testAllExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (optionalGroup_extension) {
    return JSON.stringify(
      OptionalGroup_extension._writeMessageJSON(optionalGroup_extension)
    );
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (repeatedGroup_extension) {
    return JSON.stringify(
      RepeatedGroup_extension._writeMessageJSON(repeatedGroup_extension)
    );
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (testGroup) {
    return JSON.stringify(TestGroup._writeMessageJSON(testGroup));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json) {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestGroup.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (_testGroupExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */

  encodeJSON: function (_testGroupExtension) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (_testNestedExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */

  encodeJSON: function (_testNestedExtension) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (optionalGroup_extension) {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(
          optionalGroup_extension
        )
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (testChildExtension) {
    return JSON.stringify(
      TestChildExtension._writeMessageJSON(testChildExtension)
    );
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json) {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const optionalExtension = json.optionalExtension ?? json.optional_extension;
    if (optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (testRequired) {
    return JSON.stringify(TestRequired._writeMessageJSON(testRequired));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json) {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const dummy2 = json.dummy2 ?? json.dummy2;
    if (dummy2) {
      msg.dummy2 = dummy2;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const dummy4 = json.dummy4 ?? json.dummy4;
    if (dummy4) {
      msg.dummy4 = dummy4;
    }
    const dummy5 = json.dummy5 ?? json.dummy5;
    if (dummy5) {
      msg.dummy5 = dummy5;
    }
    const dummy6 = json.dummy6 ?? json.dummy6;
    if (dummy6) {
      msg.dummy6 = dummy6;
    }
    const dummy7 = json.dummy7 ?? json.dummy7;
    if (dummy7) {
      msg.dummy7 = dummy7;
    }
    const dummy8 = json.dummy8 ?? json.dummy8;
    if (dummy8) {
      msg.dummy8 = dummy8;
    }
    const dummy9 = json.dummy9 ?? json.dummy9;
    if (dummy9) {
      msg.dummy9 = dummy9;
    }
    const dummy10 = json.dummy10 ?? json.dummy10;
    if (dummy10) {
      msg.dummy10 = dummy10;
    }
    const dummy11 = json.dummy11 ?? json.dummy11;
    if (dummy11) {
      msg.dummy11 = dummy11;
    }
    const dummy12 = json.dummy12 ?? json.dummy12;
    if (dummy12) {
      msg.dummy12 = dummy12;
    }
    const dummy13 = json.dummy13 ?? json.dummy13;
    if (dummy13) {
      msg.dummy13 = dummy13;
    }
    const dummy14 = json.dummy14 ?? json.dummy14;
    if (dummy14) {
      msg.dummy14 = dummy14;
    }
    const dummy15 = json.dummy15 ?? json.dummy15;
    if (dummy15) {
      msg.dummy15 = dummy15;
    }
    const dummy16 = json.dummy16 ?? json.dummy16;
    if (dummy16) {
      msg.dummy16 = dummy16;
    }
    const dummy17 = json.dummy17 ?? json.dummy17;
    if (dummy17) {
      msg.dummy17 = dummy17;
    }
    const dummy18 = json.dummy18 ?? json.dummy18;
    if (dummy18) {
      msg.dummy18 = dummy18;
    }
    const dummy19 = json.dummy19 ?? json.dummy19;
    if (dummy19) {
      msg.dummy19 = dummy19;
    }
    const dummy20 = json.dummy20 ?? json.dummy20;
    if (dummy20) {
      msg.dummy20 = dummy20;
    }
    const dummy21 = json.dummy21 ?? json.dummy21;
    if (dummy21) {
      msg.dummy21 = dummy21;
    }
    const dummy22 = json.dummy22 ?? json.dummy22;
    if (dummy22) {
      msg.dummy22 = dummy22;
    }
    const dummy23 = json.dummy23 ?? json.dummy23;
    if (dummy23) {
      msg.dummy23 = dummy23;
    }
    const dummy24 = json.dummy24 ?? json.dummy24;
    if (dummy24) {
      msg.dummy24 = dummy24;
    }
    const dummy25 = json.dummy25 ?? json.dummy25;
    if (dummy25) {
      msg.dummy25 = dummy25;
    }
    const dummy26 = json.dummy26 ?? json.dummy26;
    if (dummy26) {
      msg.dummy26 = dummy26;
    }
    const dummy27 = json.dummy27 ?? json.dummy27;
    if (dummy27) {
      msg.dummy27 = dummy27;
    }
    const dummy28 = json.dummy28 ?? json.dummy28;
    if (dummy28) {
      msg.dummy28 = dummy28;
    }
    const dummy29 = json.dummy29 ?? json.dummy29;
    if (dummy29) {
      msg.dummy29 = dummy29;
    }
    const dummy30 = json.dummy30 ?? json.dummy30;
    if (dummy30) {
      msg.dummy30 = dummy30;
    }
    const dummy31 = json.dummy31 ?? json.dummy31;
    if (dummy31) {
      msg.dummy31 = dummy31;
    }
    const dummy32 = json.dummy32 ?? json.dummy32;
    if (dummy32) {
      msg.dummy32 = dummy32;
    }
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (testRequiredForeign) {
    return JSON.stringify(
      TestRequiredForeign._writeMessageJSON(testRequiredForeign)
    );
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (testRequiredMessage) {
    return JSON.stringify(
      TestRequiredMessage._writeMessageJSON(testRequiredMessage)
    );
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const requiredMessage = json.requiredMessage ?? json.required_message;
    if (requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (testForeignNested) {
    return JSON.stringify(
      TestForeignNested._writeMessageJSON(testForeignNested)
    );
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json) {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const foreignNested = json.foreignNested ?? json.foreign_nested;
    if (foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (_testEmptyMessageWithExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */

  encodeJSON: function (_testEmptyMessageWithExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (_testPickleNestedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */

  encodeJSON: function (_testPickleNestedMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (nestedNestedMessage) {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            nestedNestedMessage
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (json) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const cc = json.cc ?? json.cc;
        if (cc) {
          msg.cc = cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (_testMultipleExtensionRanges) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */

  encodeJSON: function (_testMultipleExtensionRanges) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (testReallyLargeTagNumber) {
    return JSON.stringify(
      TestReallyLargeTagNumber._writeMessageJSON(testReallyLargeTagNumber)
    );
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const bb = json.bb ?? json.bb;
    if (bb) {
      msg.bb = bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (testRecursiveMessage) {
    return JSON.stringify(
      TestRecursiveMessage._writeMessageJSON(testRecursiveMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, a);
      msg.a = m;
    }
    const i = json.i ?? json.i;
    if (i) {
      msg.i = i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (testMutualRecursionA) {
    return JSON.stringify(
      TestMutualRecursionA._writeMessageJSON(testMutualRecursionA)
    );
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const bb = json.bb ?? json.bb;
    if (bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (subMessage) {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(subMessage)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const b = json.b ?? json.b;
      if (b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (subGroup) {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(subGroup)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const subMessage = json.subMessage ?? json.sub_message;
      if (subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, subMessage);
        msg.subMessage = m;
      }
      const notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (testMutualRecursionB) {
    return JSON.stringify(
      TestMutualRecursionB._writeMessageJSON(testMutualRecursionB)
    );
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, a);
      msg.a = m;
    }
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (testIsInitialized) {
    return JSON.stringify(
      TestIsInitialized._writeMessageJSON(testIsInitialized)
    );
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json) {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (_subMessage) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes) {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */

    encodeJSON: function (_subMessage) {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */

    decodeJSON: function (_json) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (subGroup) {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(subGroup)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (json) {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const i = json.i ?? json.i;
        if (i) {
          msg.i = i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (testDupFieldNumber) {
    return JSON.stringify(
      TestDupFieldNumber._writeMessageJSON(testDupFieldNumber)
    );
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (foo) {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(foo));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (bar) {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(bar));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (testEagerMessage) {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(testEagerMessage));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (testLazyMessage) {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(testLazyMessage));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (testNestedMessageHasBits) {
    return JSON.stringify(
      TestNestedMessageHasBits._writeMessageJSON(testNestedMessageHasBits)
    );
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json) {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = nestedmessageRepeatedInt32;
      }
      const nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (nestedmessageRepeatedForeignmessage) {
        for (const item of nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (testCamelCaseFieldNames) {
    return JSON.stringify(
      TestCamelCaseFieldNames._writeMessageJSON(testCamelCaseFieldNames)
    );
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json) {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const PrimitiveField = json.PrimitiveField ?? json.PrimitiveField;
    if (PrimitiveField) {
      msg.PrimitiveField = PrimitiveField;
    }
    const StringField = json.StringField ?? json.StringField;
    if (StringField) {
      msg.StringField = StringField;
    }
    const EnumField = json.EnumField ?? json.EnumField;
    if (EnumField) {
      msg.EnumField = EnumField;
    }
    const MessageField = json.MessageField ?? json.MessageField;
    if (MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, MessageField);
      msg.MessageField = m;
    }
    const StringPieceField = json.StringPieceField ?? json.StringPieceField;
    if (StringPieceField) {
      msg.StringPieceField = StringPieceField;
    }
    const CordField = json.CordField ?? json.CordField;
    if (CordField) {
      msg.CordField = CordField;
    }
    const RepeatedPrimitiveField =
      json.RepeatedPrimitiveField ?? json.RepeatedPrimitiveField;
    if (RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = RepeatedPrimitiveField;
    }
    const RepeatedStringField =
      json.RepeatedStringField ?? json.RepeatedStringField;
    if (RepeatedStringField) {
      msg.RepeatedStringField = RepeatedStringField;
    }
    const RepeatedEnumField = json.RepeatedEnumField ?? json.RepeatedEnumField;
    if (RepeatedEnumField) {
      msg.RepeatedEnumField = RepeatedEnumField;
    }
    const RepeatedMessageField =
      json.RepeatedMessageField ?? json.RepeatedMessageField;
    if (RepeatedMessageField) {
      for (const item of RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const RepeatedStringPieceField =
      json.RepeatedStringPieceField ?? json.RepeatedStringPieceField;
    if (RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = RepeatedStringPieceField;
    }
    const RepeatedCordField = json.RepeatedCordField ?? json.RepeatedCordField;
    if (RepeatedCordField) {
      msg.RepeatedCordField = RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (testFieldOrderings) {
    return JSON.stringify(
      TestFieldOrderings._writeMessageJSON(testFieldOrderings)
    );
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json) {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    const myInt = json.myInt ?? json.my_int;
    if (myInt) {
      msg.myInt = BigInt(myInt);
    }
    const myFloat = json.myFloat ?? json.my_float;
    if (myFloat) {
      msg.myFloat = myFloat;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const oo = json.oo ?? json.oo;
      if (oo) {
        msg.oo = BigInt(oo);
      }
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (testExtensionOrderings1) {
    return JSON.stringify(
      TestExtensionOrderings1._writeMessageJSON(testExtensionOrderings1)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (testExtensionOrderings2) {
    return JSON.stringify(
      TestExtensionOrderings2._writeMessageJSON(testExtensionOrderings2)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (testExtensionOrderings3) {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(
          testExtensionOrderings3
        )
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (json) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const myString = json.myString ?? json.my_string;
      if (myString) {
        msg.myString = myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (testExtremeDefaultValues) {
    return JSON.stringify(
      TestExtremeDefaultValues._writeMessageJSON(testExtremeDefaultValues)
    );
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json) {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.escapedBytes) {
      json.escapedBytes = msg.escapedBytes;
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero) {
      json.bytesWithZero = msg.bytesWithZero;
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (escapedBytes) {
      msg.escapedBytes = escapedBytes;
    }
    const largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (largeUint32) {
      msg.largeUint32 = largeUint32;
    }
    const largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (largeUint64) {
      msg.largeUint64 = BigInt(largeUint64);
    }
    const smallInt32 = json.smallInt32 ?? json.small_int32;
    if (smallInt32) {
      msg.smallInt32 = smallInt32;
    }
    const smallInt64 = json.smallInt64 ?? json.small_int64;
    if (smallInt64) {
      msg.smallInt64 = BigInt(smallInt64);
    }
    const reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (reallySmallInt32) {
      msg.reallySmallInt32 = reallySmallInt32;
    }
    const reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(reallySmallInt64);
    }
    const utf8String = json.utf8String ?? json.utf8_string;
    if (utf8String) {
      msg.utf8String = utf8String;
    }
    const zeroFloat = json.zeroFloat ?? json.zero_float;
    if (zeroFloat) {
      msg.zeroFloat = zeroFloat;
    }
    const oneFloat = json.oneFloat ?? json.one_float;
    if (oneFloat) {
      msg.oneFloat = oneFloat;
    }
    const smallFloat = json.smallFloat ?? json.small_float;
    if (smallFloat) {
      msg.smallFloat = smallFloat;
    }
    const negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (negativeOneFloat) {
      msg.negativeOneFloat = negativeOneFloat;
    }
    const negativeFloat = json.negativeFloat ?? json.negative_float;
    if (negativeFloat) {
      msg.negativeFloat = negativeFloat;
    }
    const largeFloat = json.largeFloat ?? json.large_float;
    if (largeFloat) {
      msg.largeFloat = largeFloat;
    }
    const smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (smallNegativeFloat) {
      msg.smallNegativeFloat = smallNegativeFloat;
    }
    const infDouble = json.infDouble ?? json.inf_double;
    if (infDouble) {
      msg.infDouble = infDouble;
    }
    const negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (negInfDouble) {
      msg.negInfDouble = negInfDouble;
    }
    const nanDouble = json.nanDouble ?? json.nan_double;
    if (nanDouble) {
      msg.nanDouble = nanDouble;
    }
    const infFloat = json.infFloat ?? json.inf_float;
    if (infFloat) {
      msg.infFloat = infFloat;
    }
    const negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (negInfFloat) {
      msg.negInfFloat = negInfFloat;
    }
    const nanFloat = json.nanFloat ?? json.nan_float;
    if (nanFloat) {
      msg.nanFloat = nanFloat;
    }
    const cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (cppTrigraph) {
      msg.cppTrigraph = cppTrigraph;
    }
    const stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (stringWithZero) {
      msg.stringWithZero = stringWithZero;
    }
    const bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (bytesWithZero) {
      msg.bytesWithZero = bytesWithZero;
    }
    const stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (stringPieceWithZero) {
      msg.stringPieceWithZero = stringPieceWithZero;
    }
    const cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (cordWithZero) {
      msg.cordWithZero = cordWithZero;
    }
    const replacementString = json.replacementString ?? json.replacement_string;
    if (replacementString) {
      msg.replacementString = replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (sparseEnumMessage) {
    return JSON.stringify(
      SparseEnumMessage._writeMessageJSON(sparseEnumMessage)
    );
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json) {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.sparseEnum) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (sparseEnum) {
      msg.sparseEnum = sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (oneString) {
    return JSON.stringify(OneString._writeMessageJSON(oneString));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json) {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (moreString) {
    return JSON.stringify(MoreString._writeMessageJSON(moreString));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json) {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (oneBytes) {
    return JSON.stringify(OneBytes._writeMessageJSON(oneBytes));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json) {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (moreBytes) {
    return JSON.stringify(MoreBytes._writeMessageJSON(moreBytes));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json) {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (int32Message) {
    return JSON.stringify(Int32Message._writeMessageJSON(int32Message));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json) {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (uint32Message) {
    return JSON.stringify(Uint32Message._writeMessageJSON(uint32Message));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (int64Message) {
    return JSON.stringify(Int64Message._writeMessageJSON(int64Message));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json) {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (uint64Message) {
    return JSON.stringify(Uint64Message._writeMessageJSON(uint64Message));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (boolMessage) {
    return JSON.stringify(BoolMessage._writeMessageJSON(boolMessage));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json) {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (testOneof) {
    return JSON.stringify(TestOneof._writeMessageJSON(testOneof));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (testOneofBackwardsCompatible) {
    return JSON.stringify(
      TestOneofBackwardsCompatible._writeMessageJSON(
        testOneofBackwardsCompatible
      )
    );
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json) {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(fooGroup)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2) {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes != undefined) {
      json.fooBytes = msg.fooBytes;
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes != undefined) {
      json.barBytes = msg.barBytes;
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      json.barBytesWithEmptyDefault = msg.barBytesWithEmptyDefault;
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum();
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooCord = json.fooCord ?? json.foo_cord;
    if (fooCord) {
      msg.fooCord = fooCord;
    }
    const fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (fooStringPiece) {
      msg.fooStringPiece = fooStringPiece;
    }
    const fooBytes = json.fooBytes ?? json.foo_bytes;
    if (fooBytes) {
      msg.fooBytes = fooBytes;
    }
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    const fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const barInt = json.barInt ?? json.bar_int;
    if (barInt) {
      msg.barInt = barInt;
    }
    const barString = json.barString ?? json.bar_string;
    if (barString) {
      msg.barString = barString;
    }
    const barCord = json.barCord ?? json.bar_cord;
    if (barCord) {
      msg.barCord = barCord;
    }
    const barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (barStringPiece) {
      msg.barStringPiece = barStringPiece;
    }
    const barBytes = json.barBytes ?? json.bar_bytes;
    if (barBytes) {
      msg.barBytes = barBytes;
    }
    const barEnum = json.barEnum ?? json.bar_enum;
    if (barEnum) {
      msg.barEnum = barEnum;
    }
    const barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = barStringWithEmptyDefault;
    }
    const barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = barCordWithEmptyDefault;
    }
    const barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = barStringPieceWithEmptyDefault;
    }
    const barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = barBytesWithEmptyDefault;
    }
    const bazInt = json.bazInt ?? json.baz_int;
    if (bazInt) {
      msg.bazInt = bazInt;
    }
    const bazString = json.bazString ?? json.baz_string;
    if (bazString) {
      msg.bazString = bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestOneof2.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const quxInt = json.quxInt ?? json.qux_int;
      if (quxInt) {
        msg.quxInt = BigInt(quxInt);
      }
      const corgeInt = json.corgeInt ?? json.corge_int;
      if (corgeInt) {
        msg.corgeInt = corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (testRequiredOneof) {
    return JSON.stringify(
      TestRequiredOneof._writeMessageJSON(testRequiredOneof)
    );
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const requiredDouble = json.requiredDouble ?? json.required_double;
      if (requiredDouble) {
        msg.requiredDouble = requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes) {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64.toString());
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64.toString());
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64.toString());
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64.toString());
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (unpackedInt32) {
      msg.unpackedInt32 = unpackedInt32;
    }
    const unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (unpackedInt64) {
      msg.unpackedInt64 = unpackedInt64.map(BigInt);
    }
    const unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (unpackedUint32) {
      msg.unpackedUint32 = unpackedUint32;
    }
    const unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (unpackedUint64) {
      msg.unpackedUint64 = unpackedUint64.map(BigInt);
    }
    const unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (unpackedSint32) {
      msg.unpackedSint32 = unpackedSint32;
    }
    const unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (unpackedSint64) {
      msg.unpackedSint64 = unpackedSint64.map(BigInt);
    }
    const unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (unpackedFixed32) {
      msg.unpackedFixed32 = unpackedFixed32;
    }
    const unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (unpackedFixed64) {
      msg.unpackedFixed64 = unpackedFixed64.map(BigInt);
    }
    const unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (unpackedSfixed32) {
      msg.unpackedSfixed32 = unpackedSfixed32;
    }
    const unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (unpackedSfixed64) {
      msg.unpackedSfixed64 = unpackedSfixed64.map(BigInt);
    }
    const unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (unpackedFloat) {
      msg.unpackedFloat = unpackedFloat;
    }
    const unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (unpackedDouble) {
      msg.unpackedDouble = unpackedDouble;
    }
    const unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (unpackedBool) {
      msg.unpackedBool = unpackedBool;
    }
    const unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (unpackedEnum) {
      msg.unpackedEnum = unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (_testPackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */

  encodeJSON: function (_testPackedExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (_testUnpackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */

  encodeJSON: function (_testUnpackedExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (testDynamicExtensions) {
    return JSON.stringify(
      TestDynamicExtensions._writeMessageJSON(testDynamicExtensions)
    );
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json) {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension) {
      json.enumExtension = msg.enumExtension;
    }
    if (msg.dynamicEnumExtension) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (scalarExtension) {
      msg.scalarExtension = scalarExtension;
    }
    const enumExtension = json.enumExtension ?? json.enum_extension;
    if (enumExtension) {
      msg.enumExtension = enumExtension;
    }
    const dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (dynamicEnumExtension) {
      msg.dynamicEnumExtension = dynamicEnumExtension;
    }
    const messageExtension = json.messageExtension ?? json.message_extension;
    if (messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, messageExtension);
      msg.messageExtension = m;
    }
    const dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const repeatedExtension = json.repeatedExtension ?? json.repeated_extension;
    if (repeatedExtension) {
      msg.repeatedExtension = repeatedExtension;
    }
    const packedExtension = json.packedExtension ?? json.packed_extension;
    if (packedExtension) {
      msg.packedExtension = packedExtension;
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (dynamicMessageType) {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          dynamicMessageType
        )
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (json) {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const dynamicField = json.dynamicField ?? json.dynamic_field;
      if (dynamicField) {
        msg.dynamicField = dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (testRepeatedScalarDifferentTagSizes) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(
        testRepeatedScalarDifferentTagSizes
      )
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json) {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 2047: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (testParsingMerge) {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(testParsingMerge));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json) {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (repeatedAllTypes) {
      for (const item of repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (repeatedFieldsGenerator) {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(
          repeatedFieldsGenerator
        )
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const field1 = json.field1 ?? json.field1;
      if (field1) {
        for (const item of field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const field2 = json.field2 ?? json.field2;
      if (field2) {
        for (const item of field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const field3 = json.field3 ?? json.field3;
      if (field3) {
        for (const item of field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const ext1 = json.ext1 ?? json.ext1;
      if (ext1) {
        for (const item of ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const ext2 = json.ext2 ?? json.ext2;
      if (ext2) {
        for (const item of ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (group1) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(
            group1
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (group2) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(
            group2
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (repeatedGroup) {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (testCommentInjectionMessage) {
    return JSON.stringify(
      TestCommentInjectionMessage._writeMessageJSON(testCommentInjectionMessage)
    );
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */

  encodeJSON: function (_fooRequest) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */

  encodeJSON: function (_fooResponse) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */

  encodeJSON: function (_fooClientMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */

  encodeJSON: function (_fooServerMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */

  encodeJSON: function (_barRequest) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */

  encodeJSON: function (_barResponse) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (testJsonName) {
    return JSON.stringify(TestJsonName._writeMessageJSON(testJsonName));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json) {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fieldName1 = json.fieldName1 ?? json.field_name1;
    if (fieldName1) {
      msg.fieldName1 = fieldName1;
    }
    const fieldName2 = json.fieldName2 ?? json.fieldName2;
    if (fieldName2) {
      msg.fieldName2 = fieldName2;
    }
    const FieldName3 = json.FieldName3 ?? json.FieldName3;
    if (FieldName3) {
      msg.FieldName3 = FieldName3;
    }
    const FieldName4 = json.FieldName4 ?? json._field_name4;
    if (FieldName4) {
      msg.FieldName4 = FieldName4;
    }
    const FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (FIELDNAME5) {
      msg.FIELDNAME5 = FIELDNAME5;
    }
    const fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (fieldName6) {
      msg.fieldName6 = fieldName6;
    }
    const fieldname7 = json.fieldname7 ?? json.fieldname7;
    if (fieldname7) {
      msg.fieldname7 = fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (testHugeFieldNumbers) {
    return JSON.stringify(
      TestHugeFieldNumbers._writeMessageJSON(testHugeFieldNumbers)
    );
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json) {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const [key, value] of Object.entries(msg.stringStringMap)) {
        if (key && value) {
          writer.writeMessage(536870010, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      if (msg.stringStringMap) {
        const map = {};
        for (const [key, value] of Object.entries(msg.stringStringMap)) {
          if (key && value) {
            map[key] = value;
            json.stringStringMap = map;
          }
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const fixed32 = json.fixed32 ?? json.fixed_32;
    if (fixed32) {
      msg.fixed32 = fixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (optionalEnum) {
      msg.optionalEnum = optionalEnum;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (stringStringMap) {
      for (const [key, value] of Object.entries(stringStringMap)) {
        msg.stringStringMap[key] = value;
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const groupA = json.groupA ?? json.group_a;
      if (groupA) {
        msg.groupA = groupA;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (testExtensionInsideTable) {
    return JSON.stringify(
      TestExtensionInsideTable._writeMessageJSON(testExtensionInsideTable)
    );
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const field1 = json.field1 ?? json.field1;
    if (field1) {
      msg.field1 = field1;
    }
    const field2 = json.field2 ?? json.field2;
    if (field2) {
      msg.field2 = field2;
    }
    const field3 = json.field3 ?? json.field3;
    if (field3) {
      msg.field3 = field3;
    }
    const field4 = json.field4 ?? json.field4;
    if (field4) {
      msg.field4 = field4;
    }
    const field6 = json.field6 ?? json.field6;
    if (field6) {
      msg.field6 = field6;
    }
    const field7 = json.field7 ?? json.field7;
    if (field7) {
      msg.field7 = field7;
    }
    const field8 = json.field8 ?? json.field8;
    if (field8) {
      msg.field8 = field8;
    }
    const field9 = json.field9 ?? json.field9;
    if (field9) {
      msg.field9 = field9;
    }
    const field10 = json.field10 ?? json.field10;
    if (field10) {
      msg.field10 = field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (testExtensionRangeSerialize) {
    return JSON.stringify(
      TestExtensionRangeSerialize._writeMessageJSON(testExtensionRangeSerialize)
    );
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooOne = json.fooOne ?? json.foo_one;
    if (fooOne) {
      msg.fooOne = fooOne;
    }
    const fooTwo = json.fooTwo ?? json.foo_two;
    if (fooTwo) {
      msg.fooTwo = fooTwo;
    }
    const fooThree = json.fooThree ?? json.foo_three;
    if (fooThree) {
      msg.fooThree = fooThree;
    }
    const fooFour = json.fooFour ?? json.foo_four;
    if (fooFour) {
      msg.fooFour = fooFour;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (testMap) {
    return JSON.stringify(TestMap._writeMessageJSON(testMap));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeEnum(2, value);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapStringForeignMessage)) {
        if (key && value) {
          writer.writeMessage(18, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
        if (key && value) {
          writer.writeMessage(19, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      if (msg.mapStringForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(
          msg.mapStringForeignMessage
        )) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapStringForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      if (msg.mapInt32AllTypes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32AllTypes = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (mapStringForeignMessage) {
      for (const [key, value] of Object.entries(mapStringForeignMessage)) {
        msg.mapStringForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (mapInt32AllTypes) {
      for (const [key, value] of Object.entries(mapInt32AllTypes)) {
        msg.mapInt32AllTypes[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (testMapSubmessage) {
    return JSON.stringify(
      TestMapSubmessage._writeMessageJSON(testMapSubmessage)
    );
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json) {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const testMap = json.testMap ?? json.test_map;
    if (testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (testMessageMap) {
    return JSON.stringify(TestMessageMap._writeMessageJSON(testMessageMap));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      for (const [key, value] of Object.entries(msg.mapInt32Message)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      if (msg.mapInt32Message) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Message)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32Message = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (mapInt32Message) {
      for (const [key, value] of Object.entries(mapInt32Message)) {
        msg.mapInt32Message[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (testSameTypeMap) {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(testSameTypeMap));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json) {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const [key, value] of Object.entries(msg.map1)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.map2) {
      for (const [key, value] of Object.entries(msg.map2)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.map1) {
      if (msg.map1) {
        const map = {};
        for (const [key, value] of Object.entries(msg.map1)) {
          if (key && value) {
            map[key] = value;
            json.map1 = map;
          }
        }
      }
    }
    if (msg.map2) {
      if (msg.map2) {
        const map = {};
        for (const [key, value] of Object.entries(msg.map2)) {
          if (key && value) {
            map[key] = value;
            json.map2 = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const map1 = json.map1 ?? json.map1;
    if (map1) {
      for (const [key, value] of Object.entries(map1)) {
        msg.map1[key] = value;
      }
    }
    const map2 = json.map2 ?? json.map2;
    if (map2) {
      for (const [key, value] of Object.entries(map2)) {
        msg.map2[key] = value;
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (testRequiredMessageMap) {
    return JSON.stringify(
      TestRequiredMessageMap._writeMessageJSON(testRequiredMessageMap)
    );
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      for (const [key, value] of Object.entries(msg.mapField)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestRequired._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapField) {
      if (msg.mapField) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapField)) {
          if (key && value) {
            map[key] = TestRequired._writeMessageJSON(value);
            json.mapField = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRequired.initialize(),
                    TestRequired._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapField = json.mapField ?? json.map_field;
    if (mapField) {
      for (const [key, value] of Object.entries(mapField)) {
        msg.mapField[key] = TestRequired._readMessageJSON(
          TestRequired.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (testArenaMap) {
    return JSON.stringify(TestArenaMap._writeMessageJSON(testArenaMap));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json) {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeEnum(2, value);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (messageContainingMapCalledEntry) {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(
        messageContainingMapCalledEntry
      )
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json) {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const [key, value] of Object.entries(msg.entry)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.entry) {
      if (msg.entry) {
        const map = {};
        for (const [key, value] of Object.entries(msg.entry)) {
          if (key && value) {
            map[key] = value;
            json.entry = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const entry = json.entry ?? json.entry;
    if (entry) {
      for (const [key, value] of Object.entries(entry)) {
        msg.entry[key] = value;
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (testRecursiveMapMessage) {
    return JSON.stringify(
      TestRecursiveMapMessage._writeMessageJSON(testRecursiveMapMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const [key, value] of Object.entries(msg.a)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeMessage(
              2,
              value,
              TestRecursiveMapMessage._writeMessage
            );
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      if (msg.a) {
        const map = {};
        for (const [key, value] of Object.entries(msg.a)) {
          if (key && value) {
            map[key] = TestRecursiveMapMessage._writeMessageJSON(value);
            json.a = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRecursiveMapMessage.initialize(),
                    TestRecursiveMapMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      for (const [key, value] of Object.entries(a)) {
        msg.a[key] = TestRecursiveMapMessage._readMessageJSON(
          TestRecursiveMapMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes) {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (nestedTestAllTypes) {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (testMessageWithDummy) {
    return JSON.stringify(
      TestMessageWithDummy._writeMessageJSON(testMessageWithDummy)
    );
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2) {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
      ],
      Array [
        "google/protobuf/empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */

  encodeJSON: function (_empty) {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};
",
      ],
      Array [
        "empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFooHandler(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (publicImportMessage) {
    return JSON.stringify(
      PublicImportMessage._writeMessageJSON(publicImportMessage)
    );
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const e = json.e ?? json.e;
    if (e) {
      msg.e = e;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (importMessage) {
    return JSON.stringify(ImportMessage._writeMessageJSON(importMessage));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json) {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes) {
      json.defaultBytes = msg.defaultBytes;
    }
    if (msg.defaultNestedEnum) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum();
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum();
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum();
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (optionalImportEnum) {
      msg.optionalImportEnum = optionalImportEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (repeatedImportEnum) {
      msg.repeatedImportEnum = repeatedImportEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (defaultInt32) {
      msg.defaultInt32 = defaultInt32;
    }
    const defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (defaultInt64) {
      msg.defaultInt64 = BigInt(defaultInt64);
    }
    const defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (defaultUint32) {
      msg.defaultUint32 = defaultUint32;
    }
    const defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (defaultUint64) {
      msg.defaultUint64 = BigInt(defaultUint64);
    }
    const defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (defaultSint32) {
      msg.defaultSint32 = defaultSint32;
    }
    const defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (defaultSint64) {
      msg.defaultSint64 = BigInt(defaultSint64);
    }
    const defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (defaultFixed32) {
      msg.defaultFixed32 = defaultFixed32;
    }
    const defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (defaultFixed64) {
      msg.defaultFixed64 = BigInt(defaultFixed64);
    }
    const defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (defaultSfixed32) {
      msg.defaultSfixed32 = defaultSfixed32;
    }
    const defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(defaultSfixed64);
    }
    const defaultFloat = json.defaultFloat ?? json.default_float;
    if (defaultFloat) {
      msg.defaultFloat = defaultFloat;
    }
    const defaultDouble = json.defaultDouble ?? json.default_double;
    if (defaultDouble) {
      msg.defaultDouble = defaultDouble;
    }
    const defaultBool = json.defaultBool ?? json.default_bool;
    if (defaultBool) {
      msg.defaultBool = defaultBool;
    }
    const defaultString = json.defaultString ?? json.default_string;
    if (defaultString) {
      msg.defaultString = defaultString;
    }
    const defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (defaultBytes) {
      msg.defaultBytes = defaultBytes;
    }
    const defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (defaultNestedEnum) {
      msg.defaultNestedEnum = defaultNestedEnum;
    }
    const defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (defaultForeignEnum) {
      msg.defaultForeignEnum = defaultForeignEnum;
    }
    const defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (defaultImportEnum) {
      msg.defaultImportEnum = defaultImportEnum;
    }
    const defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (defaultStringPiece) {
      msg.defaultStringPiece = defaultStringPiece;
    }
    const defaultCord = json.defaultCord ?? json.default_cord;
    if (defaultCord) {
      msg.defaultCord = defaultCord;
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestAllTypes.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (repeatedGroup) {
      return JSON.stringify(
        TestAllTypes.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (nestedTestAllTypes) {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    const repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (repeatedChild) {
      for (const item of repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (testDeprecatedFields) {
    return JSON.stringify(
      TestDeprecatedFields._writeMessageJSON(testDeprecatedFields)
    );
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json) {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (deprecatedInt32) {
      msg.deprecatedInt32 = deprecatedInt32;
    }
    const deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (_testDeprecatedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */

  encodeJSON: function (_testDeprecatedMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (_testReservedFields) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */

  encodeJSON: function (_testReservedFields) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (_testAllExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */

  encodeJSON: function (_testAllExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (optionalGroup_extension) {
    return JSON.stringify(
      OptionalGroup_extension._writeMessageJSON(optionalGroup_extension)
    );
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (repeatedGroup_extension) {
    return JSON.stringify(
      RepeatedGroup_extension._writeMessageJSON(repeatedGroup_extension)
    );
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json) {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (testGroup) {
    return JSON.stringify(TestGroup._writeMessageJSON(testGroup));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json) {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestGroup.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (_testGroupExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */

  encodeJSON: function (_testGroupExtension) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (_testNestedExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */

  encodeJSON: function (_testNestedExtension) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (optionalGroup_extension) {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(
          optionalGroup_extension
        )
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (testChildExtension) {
    return JSON.stringify(
      TestChildExtension._writeMessageJSON(testChildExtension)
    );
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json) {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const optionalExtension = json.optionalExtension ?? json.optional_extension;
    if (optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (testRequired) {
    return JSON.stringify(TestRequired._writeMessageJSON(testRequired));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json) {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const dummy2 = json.dummy2 ?? json.dummy2;
    if (dummy2) {
      msg.dummy2 = dummy2;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const dummy4 = json.dummy4 ?? json.dummy4;
    if (dummy4) {
      msg.dummy4 = dummy4;
    }
    const dummy5 = json.dummy5 ?? json.dummy5;
    if (dummy5) {
      msg.dummy5 = dummy5;
    }
    const dummy6 = json.dummy6 ?? json.dummy6;
    if (dummy6) {
      msg.dummy6 = dummy6;
    }
    const dummy7 = json.dummy7 ?? json.dummy7;
    if (dummy7) {
      msg.dummy7 = dummy7;
    }
    const dummy8 = json.dummy8 ?? json.dummy8;
    if (dummy8) {
      msg.dummy8 = dummy8;
    }
    const dummy9 = json.dummy9 ?? json.dummy9;
    if (dummy9) {
      msg.dummy9 = dummy9;
    }
    const dummy10 = json.dummy10 ?? json.dummy10;
    if (dummy10) {
      msg.dummy10 = dummy10;
    }
    const dummy11 = json.dummy11 ?? json.dummy11;
    if (dummy11) {
      msg.dummy11 = dummy11;
    }
    const dummy12 = json.dummy12 ?? json.dummy12;
    if (dummy12) {
      msg.dummy12 = dummy12;
    }
    const dummy13 = json.dummy13 ?? json.dummy13;
    if (dummy13) {
      msg.dummy13 = dummy13;
    }
    const dummy14 = json.dummy14 ?? json.dummy14;
    if (dummy14) {
      msg.dummy14 = dummy14;
    }
    const dummy15 = json.dummy15 ?? json.dummy15;
    if (dummy15) {
      msg.dummy15 = dummy15;
    }
    const dummy16 = json.dummy16 ?? json.dummy16;
    if (dummy16) {
      msg.dummy16 = dummy16;
    }
    const dummy17 = json.dummy17 ?? json.dummy17;
    if (dummy17) {
      msg.dummy17 = dummy17;
    }
    const dummy18 = json.dummy18 ?? json.dummy18;
    if (dummy18) {
      msg.dummy18 = dummy18;
    }
    const dummy19 = json.dummy19 ?? json.dummy19;
    if (dummy19) {
      msg.dummy19 = dummy19;
    }
    const dummy20 = json.dummy20 ?? json.dummy20;
    if (dummy20) {
      msg.dummy20 = dummy20;
    }
    const dummy21 = json.dummy21 ?? json.dummy21;
    if (dummy21) {
      msg.dummy21 = dummy21;
    }
    const dummy22 = json.dummy22 ?? json.dummy22;
    if (dummy22) {
      msg.dummy22 = dummy22;
    }
    const dummy23 = json.dummy23 ?? json.dummy23;
    if (dummy23) {
      msg.dummy23 = dummy23;
    }
    const dummy24 = json.dummy24 ?? json.dummy24;
    if (dummy24) {
      msg.dummy24 = dummy24;
    }
    const dummy25 = json.dummy25 ?? json.dummy25;
    if (dummy25) {
      msg.dummy25 = dummy25;
    }
    const dummy26 = json.dummy26 ?? json.dummy26;
    if (dummy26) {
      msg.dummy26 = dummy26;
    }
    const dummy27 = json.dummy27 ?? json.dummy27;
    if (dummy27) {
      msg.dummy27 = dummy27;
    }
    const dummy28 = json.dummy28 ?? json.dummy28;
    if (dummy28) {
      msg.dummy28 = dummy28;
    }
    const dummy29 = json.dummy29 ?? json.dummy29;
    if (dummy29) {
      msg.dummy29 = dummy29;
    }
    const dummy30 = json.dummy30 ?? json.dummy30;
    if (dummy30) {
      msg.dummy30 = dummy30;
    }
    const dummy31 = json.dummy31 ?? json.dummy31;
    if (dummy31) {
      msg.dummy31 = dummy31;
    }
    const dummy32 = json.dummy32 ?? json.dummy32;
    if (dummy32) {
      msg.dummy32 = dummy32;
    }
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (testRequiredForeign) {
    return JSON.stringify(
      TestRequiredForeign._writeMessageJSON(testRequiredForeign)
    );
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (testRequiredMessage) {
    return JSON.stringify(
      TestRequiredMessage._writeMessageJSON(testRequiredMessage)
    );
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const requiredMessage = json.requiredMessage ?? json.required_message;
    if (requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (testForeignNested) {
    return JSON.stringify(
      TestForeignNested._writeMessageJSON(testForeignNested)
    );
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json) {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const foreignNested = json.foreignNested ?? json.foreign_nested;
    if (foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (_testEmptyMessageWithExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */

  encodeJSON: function (_testEmptyMessageWithExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (_testPickleNestedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */

  encodeJSON: function (_testPickleNestedMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (nestedNestedMessage) {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            nestedNestedMessage
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (json) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const cc = json.cc ?? json.cc;
        if (cc) {
          msg.cc = cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (_testMultipleExtensionRanges) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */

  encodeJSON: function (_testMultipleExtensionRanges) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (testReallyLargeTagNumber) {
    return JSON.stringify(
      TestReallyLargeTagNumber._writeMessageJSON(testReallyLargeTagNumber)
    );
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const bb = json.bb ?? json.bb;
    if (bb) {
      msg.bb = bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (testRecursiveMessage) {
    return JSON.stringify(
      TestRecursiveMessage._writeMessageJSON(testRecursiveMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, a);
      msg.a = m;
    }
    const i = json.i ?? json.i;
    if (i) {
      msg.i = i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (testMutualRecursionA) {
    return JSON.stringify(
      TestMutualRecursionA._writeMessageJSON(testMutualRecursionA)
    );
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const bb = json.bb ?? json.bb;
    if (bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (subMessage) {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(subMessage)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const b = json.b ?? json.b;
      if (b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (subGroup) {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(subGroup)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const subMessage = json.subMessage ?? json.sub_message;
      if (subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, subMessage);
        msg.subMessage = m;
      }
      const notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (testMutualRecursionB) {
    return JSON.stringify(
      TestMutualRecursionB._writeMessageJSON(testMutualRecursionB)
    );
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json) {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, a);
      msg.a = m;
    }
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (testIsInitialized) {
    return JSON.stringify(
      TestIsInitialized._writeMessageJSON(testIsInitialized)
    );
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json) {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (_subMessage) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes) {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */

    encodeJSON: function (_subMessage) {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */

    decodeJSON: function (_json) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (subGroup) {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(subGroup)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (json) {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const i = json.i ?? json.i;
        if (i) {
          msg.i = i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (testDupFieldNumber) {
    return JSON.stringify(
      TestDupFieldNumber._writeMessageJSON(testDupFieldNumber)
    );
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json) {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (foo) {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(foo));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (bar) {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(bar));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json) {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (testEagerMessage) {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(testEagerMessage));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (testLazyMessage) {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(testLazyMessage));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (testNestedMessageHasBits) {
    return JSON.stringify(
      TestNestedMessageHasBits._writeMessageJSON(testNestedMessageHasBits)
    );
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json) {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = nestedmessageRepeatedInt32;
      }
      const nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (nestedmessageRepeatedForeignmessage) {
        for (const item of nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (testCamelCaseFieldNames) {
    return JSON.stringify(
      TestCamelCaseFieldNames._writeMessageJSON(testCamelCaseFieldNames)
    );
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json) {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const PrimitiveField = json.PrimitiveField ?? json.PrimitiveField;
    if (PrimitiveField) {
      msg.PrimitiveField = PrimitiveField;
    }
    const StringField = json.StringField ?? json.StringField;
    if (StringField) {
      msg.StringField = StringField;
    }
    const EnumField = json.EnumField ?? json.EnumField;
    if (EnumField) {
      msg.EnumField = EnumField;
    }
    const MessageField = json.MessageField ?? json.MessageField;
    if (MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, MessageField);
      msg.MessageField = m;
    }
    const StringPieceField = json.StringPieceField ?? json.StringPieceField;
    if (StringPieceField) {
      msg.StringPieceField = StringPieceField;
    }
    const CordField = json.CordField ?? json.CordField;
    if (CordField) {
      msg.CordField = CordField;
    }
    const RepeatedPrimitiveField =
      json.RepeatedPrimitiveField ?? json.RepeatedPrimitiveField;
    if (RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = RepeatedPrimitiveField;
    }
    const RepeatedStringField =
      json.RepeatedStringField ?? json.RepeatedStringField;
    if (RepeatedStringField) {
      msg.RepeatedStringField = RepeatedStringField;
    }
    const RepeatedEnumField = json.RepeatedEnumField ?? json.RepeatedEnumField;
    if (RepeatedEnumField) {
      msg.RepeatedEnumField = RepeatedEnumField;
    }
    const RepeatedMessageField =
      json.RepeatedMessageField ?? json.RepeatedMessageField;
    if (RepeatedMessageField) {
      for (const item of RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const RepeatedStringPieceField =
      json.RepeatedStringPieceField ?? json.RepeatedStringPieceField;
    if (RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = RepeatedStringPieceField;
    }
    const RepeatedCordField = json.RepeatedCordField ?? json.RepeatedCordField;
    if (RepeatedCordField) {
      msg.RepeatedCordField = RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (testFieldOrderings) {
    return JSON.stringify(
      TestFieldOrderings._writeMessageJSON(testFieldOrderings)
    );
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json) {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    const myInt = json.myInt ?? json.my_int;
    if (myInt) {
      msg.myInt = BigInt(myInt);
    }
    const myFloat = json.myFloat ?? json.my_float;
    if (myFloat) {
      msg.myFloat = myFloat;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const oo = json.oo ?? json.oo;
      if (oo) {
        msg.oo = BigInt(oo);
      }
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (testExtensionOrderings1) {
    return JSON.stringify(
      TestExtensionOrderings1._writeMessageJSON(testExtensionOrderings1)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (testExtensionOrderings2) {
    return JSON.stringify(
      TestExtensionOrderings2._writeMessageJSON(testExtensionOrderings2)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (testExtensionOrderings3) {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(
          testExtensionOrderings3
        )
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (json) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const myString = json.myString ?? json.my_string;
      if (myString) {
        msg.myString = myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (testExtremeDefaultValues) {
    return JSON.stringify(
      TestExtremeDefaultValues._writeMessageJSON(testExtremeDefaultValues)
    );
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json) {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.escapedBytes) {
      json.escapedBytes = msg.escapedBytes;
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero) {
      json.bytesWithZero = msg.bytesWithZero;
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (escapedBytes) {
      msg.escapedBytes = escapedBytes;
    }
    const largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (largeUint32) {
      msg.largeUint32 = largeUint32;
    }
    const largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (largeUint64) {
      msg.largeUint64 = BigInt(largeUint64);
    }
    const smallInt32 = json.smallInt32 ?? json.small_int32;
    if (smallInt32) {
      msg.smallInt32 = smallInt32;
    }
    const smallInt64 = json.smallInt64 ?? json.small_int64;
    if (smallInt64) {
      msg.smallInt64 = BigInt(smallInt64);
    }
    const reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (reallySmallInt32) {
      msg.reallySmallInt32 = reallySmallInt32;
    }
    const reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(reallySmallInt64);
    }
    const utf8String = json.utf8String ?? json.utf8_string;
    if (utf8String) {
      msg.utf8String = utf8String;
    }
    const zeroFloat = json.zeroFloat ?? json.zero_float;
    if (zeroFloat) {
      msg.zeroFloat = zeroFloat;
    }
    const oneFloat = json.oneFloat ?? json.one_float;
    if (oneFloat) {
      msg.oneFloat = oneFloat;
    }
    const smallFloat = json.smallFloat ?? json.small_float;
    if (smallFloat) {
      msg.smallFloat = smallFloat;
    }
    const negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (negativeOneFloat) {
      msg.negativeOneFloat = negativeOneFloat;
    }
    const negativeFloat = json.negativeFloat ?? json.negative_float;
    if (negativeFloat) {
      msg.negativeFloat = negativeFloat;
    }
    const largeFloat = json.largeFloat ?? json.large_float;
    if (largeFloat) {
      msg.largeFloat = largeFloat;
    }
    const smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (smallNegativeFloat) {
      msg.smallNegativeFloat = smallNegativeFloat;
    }
    const infDouble = json.infDouble ?? json.inf_double;
    if (infDouble) {
      msg.infDouble = infDouble;
    }
    const negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (negInfDouble) {
      msg.negInfDouble = negInfDouble;
    }
    const nanDouble = json.nanDouble ?? json.nan_double;
    if (nanDouble) {
      msg.nanDouble = nanDouble;
    }
    const infFloat = json.infFloat ?? json.inf_float;
    if (infFloat) {
      msg.infFloat = infFloat;
    }
    const negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (negInfFloat) {
      msg.negInfFloat = negInfFloat;
    }
    const nanFloat = json.nanFloat ?? json.nan_float;
    if (nanFloat) {
      msg.nanFloat = nanFloat;
    }
    const cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (cppTrigraph) {
      msg.cppTrigraph = cppTrigraph;
    }
    const stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (stringWithZero) {
      msg.stringWithZero = stringWithZero;
    }
    const bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (bytesWithZero) {
      msg.bytesWithZero = bytesWithZero;
    }
    const stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (stringPieceWithZero) {
      msg.stringPieceWithZero = stringPieceWithZero;
    }
    const cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (cordWithZero) {
      msg.cordWithZero = cordWithZero;
    }
    const replacementString = json.replacementString ?? json.replacement_string;
    if (replacementString) {
      msg.replacementString = replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (sparseEnumMessage) {
    return JSON.stringify(
      SparseEnumMessage._writeMessageJSON(sparseEnumMessage)
    );
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json) {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.sparseEnum) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (sparseEnum) {
      msg.sparseEnum = sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (oneString) {
    return JSON.stringify(OneString._writeMessageJSON(oneString));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json) {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (moreString) {
    return JSON.stringify(MoreString._writeMessageJSON(moreString));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json) {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (oneBytes) {
    return JSON.stringify(OneBytes._writeMessageJSON(oneBytes));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json) {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (moreBytes) {
    return JSON.stringify(MoreBytes._writeMessageJSON(moreBytes));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json) {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (int32Message) {
    return JSON.stringify(Int32Message._writeMessageJSON(int32Message));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json) {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (uint32Message) {
    return JSON.stringify(Uint32Message._writeMessageJSON(uint32Message));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (int64Message) {
    return JSON.stringify(Int64Message._writeMessageJSON(int64Message));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json) {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (uint64Message) {
    return JSON.stringify(Uint64Message._writeMessageJSON(uint64Message));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json) {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (boolMessage) {
    return JSON.stringify(BoolMessage._writeMessageJSON(boolMessage));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json) {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (testOneof) {
    return JSON.stringify(TestOneof._writeMessageJSON(testOneof));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (testOneofBackwardsCompatible) {
    return JSON.stringify(
      TestOneofBackwardsCompatible._writeMessageJSON(
        testOneofBackwardsCompatible
      )
    );
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json) {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(fooGroup)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2) {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes != undefined) {
      json.fooBytes = msg.fooBytes;
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes != undefined) {
      json.barBytes = msg.barBytes;
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      json.barBytesWithEmptyDefault = msg.barBytesWithEmptyDefault;
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum();
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooCord = json.fooCord ?? json.foo_cord;
    if (fooCord) {
      msg.fooCord = fooCord;
    }
    const fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (fooStringPiece) {
      msg.fooStringPiece = fooStringPiece;
    }
    const fooBytes = json.fooBytes ?? json.foo_bytes;
    if (fooBytes) {
      msg.fooBytes = fooBytes;
    }
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    const fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const barInt = json.barInt ?? json.bar_int;
    if (barInt) {
      msg.barInt = barInt;
    }
    const barString = json.barString ?? json.bar_string;
    if (barString) {
      msg.barString = barString;
    }
    const barCord = json.barCord ?? json.bar_cord;
    if (barCord) {
      msg.barCord = barCord;
    }
    const barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (barStringPiece) {
      msg.barStringPiece = barStringPiece;
    }
    const barBytes = json.barBytes ?? json.bar_bytes;
    if (barBytes) {
      msg.barBytes = barBytes;
    }
    const barEnum = json.barEnum ?? json.bar_enum;
    if (barEnum) {
      msg.barEnum = barEnum;
    }
    const barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = barStringWithEmptyDefault;
    }
    const barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = barCordWithEmptyDefault;
    }
    const barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = barStringPieceWithEmptyDefault;
    }
    const barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = barBytesWithEmptyDefault;
    }
    const bazInt = json.bazInt ?? json.baz_int;
    if (bazInt) {
      msg.bazInt = bazInt;
    }
    const bazString = json.bazString ?? json.baz_string;
    if (bazString) {
      msg.bazString = bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup) {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestOneof2.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const quxInt = json.quxInt ?? json.qux_int;
      if (quxInt) {
        msg.quxInt = BigInt(quxInt);
      }
      const corgeInt = json.corgeInt ?? json.corge_int;
      if (corgeInt) {
        msg.corgeInt = corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (testRequiredOneof) {
    return JSON.stringify(
      TestRequiredOneof._writeMessageJSON(testRequiredOneof)
    );
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const requiredDouble = json.requiredDouble ?? json.required_double;
      if (requiredDouble) {
        msg.requiredDouble = requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes) {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64.toString());
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64.toString());
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64.toString());
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64.toString());
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (unpackedInt32) {
      msg.unpackedInt32 = unpackedInt32;
    }
    const unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (unpackedInt64) {
      msg.unpackedInt64 = unpackedInt64.map(BigInt);
    }
    const unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (unpackedUint32) {
      msg.unpackedUint32 = unpackedUint32;
    }
    const unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (unpackedUint64) {
      msg.unpackedUint64 = unpackedUint64.map(BigInt);
    }
    const unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (unpackedSint32) {
      msg.unpackedSint32 = unpackedSint32;
    }
    const unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (unpackedSint64) {
      msg.unpackedSint64 = unpackedSint64.map(BigInt);
    }
    const unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (unpackedFixed32) {
      msg.unpackedFixed32 = unpackedFixed32;
    }
    const unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (unpackedFixed64) {
      msg.unpackedFixed64 = unpackedFixed64.map(BigInt);
    }
    const unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (unpackedSfixed32) {
      msg.unpackedSfixed32 = unpackedSfixed32;
    }
    const unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (unpackedSfixed64) {
      msg.unpackedSfixed64 = unpackedSfixed64.map(BigInt);
    }
    const unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (unpackedFloat) {
      msg.unpackedFloat = unpackedFloat;
    }
    const unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (unpackedDouble) {
      msg.unpackedDouble = unpackedDouble;
    }
    const unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (unpackedBool) {
      msg.unpackedBool = unpackedBool;
    }
    const unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (unpackedEnum) {
      msg.unpackedEnum = unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (_testPackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */

  encodeJSON: function (_testPackedExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (_testUnpackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */

  encodeJSON: function (_testUnpackedExtensions) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (testDynamicExtensions) {
    return JSON.stringify(
      TestDynamicExtensions._writeMessageJSON(testDynamicExtensions)
    );
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json) {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension) {
      json.enumExtension = msg.enumExtension;
    }
    if (msg.dynamicEnumExtension) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (scalarExtension) {
      msg.scalarExtension = scalarExtension;
    }
    const enumExtension = json.enumExtension ?? json.enum_extension;
    if (enumExtension) {
      msg.enumExtension = enumExtension;
    }
    const dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (dynamicEnumExtension) {
      msg.dynamicEnumExtension = dynamicEnumExtension;
    }
    const messageExtension = json.messageExtension ?? json.message_extension;
    if (messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, messageExtension);
      msg.messageExtension = m;
    }
    const dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const repeatedExtension = json.repeatedExtension ?? json.repeated_extension;
    if (repeatedExtension) {
      msg.repeatedExtension = repeatedExtension;
    }
    const packedExtension = json.packedExtension ?? json.packed_extension;
    if (packedExtension) {
      msg.packedExtension = packedExtension;
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (dynamicMessageType) {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          dynamicMessageType
        )
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (json) {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const dynamicField = json.dynamicField ?? json.dynamic_field;
      if (dynamicField) {
        msg.dynamicField = dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (testRepeatedScalarDifferentTagSizes) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(
        testRepeatedScalarDifferentTagSizes
      )
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json) {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 2047: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (testParsingMerge) {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(testParsingMerge));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json) {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (repeatedAllTypes) {
      for (const item of repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (repeatedFieldsGenerator) {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(
          repeatedFieldsGenerator
        )
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const field1 = json.field1 ?? json.field1;
      if (field1) {
        for (const item of field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const field2 = json.field2 ?? json.field2;
      if (field2) {
        for (const item of field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const field3 = json.field3 ?? json.field3;
      if (field3) {
        for (const item of field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const ext1 = json.ext1 ?? json.ext1;
      if (ext1) {
        for (const item of ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const ext2 = json.ext2 ?? json.ext2;
      if (ext2) {
        for (const item of ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (group1) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(
            group1
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (group2) {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(
            group2
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (json) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (msg) {
        const json = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (msg, json) {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (repeatedGroup) {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (testCommentInjectionMessage) {
    return JSON.stringify(
      TestCommentInjectionMessage._writeMessageJSON(testCommentInjectionMessage)
    );
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */

  encodeJSON: function (_fooRequest) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */

  encodeJSON: function (_fooResponse) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */

  encodeJSON: function (_fooClientMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */

  encodeJSON: function (_fooServerMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */

  encodeJSON: function (_barRequest) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */

  encodeJSON: function (_barResponse) {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (testJsonName) {
    return JSON.stringify(TestJsonName._writeMessageJSON(testJsonName));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json) {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fieldName1 = json.fieldName1 ?? json.field_name1;
    if (fieldName1) {
      msg.fieldName1 = fieldName1;
    }
    const fieldName2 = json.fieldName2 ?? json.fieldName2;
    if (fieldName2) {
      msg.fieldName2 = fieldName2;
    }
    const FieldName3 = json.FieldName3 ?? json.FieldName3;
    if (FieldName3) {
      msg.FieldName3 = FieldName3;
    }
    const FieldName4 = json.FieldName4 ?? json._field_name4;
    if (FieldName4) {
      msg.FieldName4 = FieldName4;
    }
    const FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (FIELDNAME5) {
      msg.FIELDNAME5 = FIELDNAME5;
    }
    const fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (fieldName6) {
      msg.fieldName6 = fieldName6;
    }
    const fieldname7 = json.fieldname7 ?? json.fieldname7;
    if (fieldname7) {
      msg.fieldname7 = fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (testHugeFieldNumbers) {
    return JSON.stringify(
      TestHugeFieldNumbers._writeMessageJSON(testHugeFieldNumbers)
    );
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json) {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const [key, value] of Object.entries(msg.stringStringMap)) {
        if (key && value) {
          writer.writeMessage(536870010, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      if (msg.stringStringMap) {
        const map = {};
        for (const [key, value] of Object.entries(msg.stringStringMap)) {
          if (key && value) {
            map[key] = value;
            json.stringStringMap = map;
          }
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const fixed32 = json.fixed32 ?? json.fixed_32;
    if (fixed32) {
      msg.fixed32 = fixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (optionalEnum) {
      msg.optionalEnum = optionalEnum;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (stringStringMap) {
      for (const [key, value] of Object.entries(stringStringMap)) {
        msg.stringStringMap[key] = value;
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (optionalGroup) {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json) {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const groupA = json.groupA ?? json.group_a;
      if (groupA) {
        msg.groupA = groupA;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (testExtensionInsideTable) {
    return JSON.stringify(
      TestExtensionInsideTable._writeMessageJSON(testExtensionInsideTable)
    );
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const field1 = json.field1 ?? json.field1;
    if (field1) {
      msg.field1 = field1;
    }
    const field2 = json.field2 ?? json.field2;
    if (field2) {
      msg.field2 = field2;
    }
    const field3 = json.field3 ?? json.field3;
    if (field3) {
      msg.field3 = field3;
    }
    const field4 = json.field4 ?? json.field4;
    if (field4) {
      msg.field4 = field4;
    }
    const field6 = json.field6 ?? json.field6;
    if (field6) {
      msg.field6 = field6;
    }
    const field7 = json.field7 ?? json.field7;
    if (field7) {
      msg.field7 = field7;
    }
    const field8 = json.field8 ?? json.field8;
    if (field8) {
      msg.field8 = field8;
    }
    const field9 = json.field9 ?? json.field9;
    if (field9) {
      msg.field9 = field9;
    }
    const field10 = json.field10 ?? json.field10;
    if (field10) {
      msg.field10 = field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (testExtensionRangeSerialize) {
    return JSON.stringify(
      TestExtensionRangeSerialize._writeMessageJSON(testExtensionRangeSerialize)
    );
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json) {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooOne = json.fooOne ?? json.foo_one;
    if (fooOne) {
      msg.fooOne = fooOne;
    }
    const fooTwo = json.fooTwo ?? json.foo_two;
    if (fooTwo) {
      msg.fooTwo = fooTwo;
    }
    const fooThree = json.fooThree ?? json.foo_three;
    if (fooThree) {
      msg.fooThree = fooThree;
    }
    const fooFour = json.fooFour ?? json.foo_four;
    if (fooFour) {
      msg.fooFour = fooFour;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (testMap) {
    return JSON.stringify(TestMap._writeMessageJSON(testMap));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeEnum(2, value);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapStringForeignMessage)) {
        if (key && value) {
          writer.writeMessage(18, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
        if (key && value) {
          writer.writeMessage(19, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      if (msg.mapStringForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(
          msg.mapStringForeignMessage
        )) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapStringForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      if (msg.mapInt32AllTypes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32AllTypes = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (mapStringForeignMessage) {
      for (const [key, value] of Object.entries(mapStringForeignMessage)) {
        msg.mapStringForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (mapInt32AllTypes) {
      for (const [key, value] of Object.entries(mapInt32AllTypes)) {
        msg.mapInt32AllTypes[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (testMapSubmessage) {
    return JSON.stringify(
      TestMapSubmessage._writeMessageJSON(testMapSubmessage)
    );
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json) {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const testMap = json.testMap ?? json.test_map;
    if (testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (testMessageMap) {
    return JSON.stringify(TestMessageMap._writeMessageJSON(testMessageMap));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      for (const [key, value] of Object.entries(msg.mapInt32Message)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      if (msg.mapInt32Message) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Message)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32Message = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (mapInt32Message) {
      for (const [key, value] of Object.entries(mapInt32Message)) {
        msg.mapInt32Message[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (testSameTypeMap) {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(testSameTypeMap));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json) {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const [key, value] of Object.entries(msg.map1)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.map2) {
      for (const [key, value] of Object.entries(msg.map2)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.map1) {
      if (msg.map1) {
        const map = {};
        for (const [key, value] of Object.entries(msg.map1)) {
          if (key && value) {
            map[key] = value;
            json.map1 = map;
          }
        }
      }
    }
    if (msg.map2) {
      if (msg.map2) {
        const map = {};
        for (const [key, value] of Object.entries(msg.map2)) {
          if (key && value) {
            map[key] = value;
            json.map2 = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const map1 = json.map1 ?? json.map1;
    if (map1) {
      for (const [key, value] of Object.entries(map1)) {
        msg.map1[key] = value;
      }
    }
    const map2 = json.map2 ?? json.map2;
    if (map2) {
      for (const [key, value] of Object.entries(map2)) {
        msg.map2[key] = value;
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (testRequiredMessageMap) {
    return JSON.stringify(
      TestRequiredMessageMap._writeMessageJSON(testRequiredMessageMap)
    );
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json) {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      for (const [key, value] of Object.entries(msg.mapField)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, TestRequired._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapField) {
      if (msg.mapField) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapField)) {
          if (key && value) {
            map[key] = TestRequired._writeMessageJSON(value);
            json.mapField = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRequired.initialize(),
                    TestRequired._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapField = json.mapField ?? json.map_field;
    if (mapField) {
      for (const [key, value] of Object.entries(mapField)) {
        msg.mapField[key] = TestRequired._readMessageJSON(
          TestRequired.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (testArenaMap) {
    return JSON.stringify(TestArenaMap._writeMessageJSON(testArenaMap));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json) {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeEnum(2, value);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (messageContainingMapCalledEntry) {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(
        messageContainingMapCalledEntry
      )
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json) {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const [key, value] of Object.entries(msg.entry)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.entry) {
      if (msg.entry) {
        const map = {};
        for (const [key, value] of Object.entries(msg.entry)) {
          if (key && value) {
            map[key] = value;
            json.entry = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const entry = json.entry ?? json.entry;
    if (entry) {
      for (const [key, value] of Object.entries(entry)) {
        msg.entry[key] = value;
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (testRecursiveMapMessage) {
    return JSON.stringify(
      TestRecursiveMapMessage._writeMessageJSON(testRecursiveMapMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json) {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const [key, value] of Object.entries(msg.a)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key);
            mapWriter.writeMessage(
              2,
              value,
              TestRecursiveMapMessage._writeMessage
            );
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.a) {
      if (msg.a) {
        const map = {};
        for (const [key, value] of Object.entries(msg.a)) {
          if (key && value) {
            map[key] = TestRecursiveMapMessage._writeMessageJSON(value);
            json.a = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRecursiveMapMessage.initialize(),
                    TestRecursiveMapMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const a = json.a ?? json.a;
    if (a) {
      for (const [key, value] of Object.entries(a)) {
        msg.a[key] = TestRecursiveMapMessage._readMessageJSON(
          TestRecursiveMapMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes) {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (nestedMessage) {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json) {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes) {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes) {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json) {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (nestedTestAllTypes) {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json) {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage) {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json) {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage) {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (testMessageWithDummy) {
    return JSON.stringify(
      TestMessageWithDummy._writeMessageJSON(testMessageWithDummy)
    );
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json) {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2) {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json) {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */

  encodeJSON: function (_empty) {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */

  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFooHandler(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): string {
    return JSON.stringify(
      PublicImportMessage._writeMessageJSON(publicImportMessage)
    );
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json: string): PublicImportMessage {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const e = json.e ?? json.e;
    if (e) {
      msg.e = e;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (importMessage: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessage._writeMessageJSON(importMessage));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json: string): ImportMessage {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ImportMessage, json: any): ImportMessage {
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number;
  fooString?: string;
  fooCord?: string;
  fooStringPiece?: string;
  fooBytes?: Uint8Array;
  fooEnum?: TestOneof2.NestedEnum;
  fooMessage?: TestOneof2.NestedMessage;
  fooLazyMessage?: TestOneof2.NestedMessage;
  barInt?: number;
  barString?: string;
  barCord?: string;
  barStringPiece?: string;
  barBytes?: Uint8Array;
  barEnum?: TestOneof2.NestedEnum;
  barStringWithEmptyDefault?: string;
  barCordWithEmptyDefault?: string;
  barStringPieceWithEmptyDefault?: string;
  barBytesWithEmptyDefault?: Uint8Array;
  bazInt: number;
  bazString: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<string, string | undefined>;
  oneofUint32?: number;
  oneofTestAllTypes?: TestAllTypes;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes) {
      json.defaultBytes = msg.defaultBytes;
    }
    if (msg.defaultNestedEnum) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (optionalImportEnum) {
      msg.optionalImportEnum = optionalImportEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (repeatedImportEnum) {
      msg.repeatedImportEnum = repeatedImportEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (defaultInt32) {
      msg.defaultInt32 = defaultInt32;
    }
    const defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (defaultInt64) {
      msg.defaultInt64 = BigInt(defaultInt64);
    }
    const defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (defaultUint32) {
      msg.defaultUint32 = defaultUint32;
    }
    const defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (defaultUint64) {
      msg.defaultUint64 = BigInt(defaultUint64);
    }
    const defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (defaultSint32) {
      msg.defaultSint32 = defaultSint32;
    }
    const defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (defaultSint64) {
      msg.defaultSint64 = BigInt(defaultSint64);
    }
    const defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (defaultFixed32) {
      msg.defaultFixed32 = defaultFixed32;
    }
    const defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (defaultFixed64) {
      msg.defaultFixed64 = BigInt(defaultFixed64);
    }
    const defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (defaultSfixed32) {
      msg.defaultSfixed32 = defaultSfixed32;
    }
    const defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(defaultSfixed64);
    }
    const defaultFloat = json.defaultFloat ?? json.default_float;
    if (defaultFloat) {
      msg.defaultFloat = defaultFloat;
    }
    const defaultDouble = json.defaultDouble ?? json.default_double;
    if (defaultDouble) {
      msg.defaultDouble = defaultDouble;
    }
    const defaultBool = json.defaultBool ?? json.default_bool;
    if (defaultBool) {
      msg.defaultBool = defaultBool;
    }
    const defaultString = json.defaultString ?? json.default_string;
    if (defaultString) {
      msg.defaultString = defaultString;
    }
    const defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (defaultBytes) {
      msg.defaultBytes = defaultBytes;
    }
    const defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (defaultNestedEnum) {
      msg.defaultNestedEnum = defaultNestedEnum;
    }
    const defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (defaultForeignEnum) {
      msg.defaultForeignEnum = defaultForeignEnum;
    }
    const defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (defaultImportEnum) {
      msg.defaultImportEnum = defaultImportEnum;
    }
    const defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (defaultStringPiece) {
      msg.defaultStringPiece = defaultStringPiece;
    }
    const defaultCord = json.defaultCord ?? json.default_cord;
    if (defaultCord) {
      msg.defaultCord = defaultCord;
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): string {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestAllTypes.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestAllTypes.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): string {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    const repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (repeatedChild) {
      for (const item of repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): string {
    return JSON.stringify(
      TestDeprecatedFields._writeMessageJSON(testDeprecatedFields)
    );
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (deprecatedInt32) {
      msg.deprecatedInt32 = deprecatedInt32;
    }
    const deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */

  encodeJSON: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedMessage,
    json: any
  ): TestDeprecatedMessage {
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */

  encodeJSON: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */

  decodeJSON: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReservedFields,
    json: any
  ): TestReservedFields {
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */

  encodeJSON: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestAllExtensions,
    json: any
  ): TestAllExtensions {
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): string {
    return JSON.stringify(
      OptionalGroup_extension._writeMessageJSON(optionalGroup_extension)
    );
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): string {
    return JSON.stringify(
      RepeatedGroup_extension._writeMessageJSON(repeatedGroup_extension)
    );
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (testGroup: Partial<TestGroup>): string {
    return JSON.stringify(TestGroup._writeMessageJSON(testGroup));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json: string): TestGroup {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestGroup>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestGroup, json: any): TestGroup {
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestGroup.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */

  encodeJSON: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */

  decodeJSON: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestGroupExtension,
    json: any
  ): TestGroupExtension {
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */

  encodeJSON: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */

  decodeJSON: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedExtension,
    json: any
  ): TestNestedExtension {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(
          optionalGroup_extension
        )
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (
    testChildExtension: Partial<TestChildExtension>
  ): string {
    return JSON.stringify(
      TestChildExtension._writeMessageJSON(testChildExtension)
    );
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json: string): TestChildExtension {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const optionalExtension = json.optionalExtension ?? json.optional_extension;
    if (optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (testRequired: Partial<TestRequired>): string {
    return JSON.stringify(TestRequired._writeMessageJSON(testRequired));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json: string): TestRequired {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestRequired, json: any): TestRequired {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const dummy2 = json.dummy2 ?? json.dummy2;
    if (dummy2) {
      msg.dummy2 = dummy2;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const dummy4 = json.dummy4 ?? json.dummy4;
    if (dummy4) {
      msg.dummy4 = dummy4;
    }
    const dummy5 = json.dummy5 ?? json.dummy5;
    if (dummy5) {
      msg.dummy5 = dummy5;
    }
    const dummy6 = json.dummy6 ?? json.dummy6;
    if (dummy6) {
      msg.dummy6 = dummy6;
    }
    const dummy7 = json.dummy7 ?? json.dummy7;
    if (dummy7) {
      msg.dummy7 = dummy7;
    }
    const dummy8 = json.dummy8 ?? json.dummy8;
    if (dummy8) {
      msg.dummy8 = dummy8;
    }
    const dummy9 = json.dummy9 ?? json.dummy9;
    if (dummy9) {
      msg.dummy9 = dummy9;
    }
    const dummy10 = json.dummy10 ?? json.dummy10;
    if (dummy10) {
      msg.dummy10 = dummy10;
    }
    const dummy11 = json.dummy11 ?? json.dummy11;
    if (dummy11) {
      msg.dummy11 = dummy11;
    }
    const dummy12 = json.dummy12 ?? json.dummy12;
    if (dummy12) {
      msg.dummy12 = dummy12;
    }
    const dummy13 = json.dummy13 ?? json.dummy13;
    if (dummy13) {
      msg.dummy13 = dummy13;
    }
    const dummy14 = json.dummy14 ?? json.dummy14;
    if (dummy14) {
      msg.dummy14 = dummy14;
    }
    const dummy15 = json.dummy15 ?? json.dummy15;
    if (dummy15) {
      msg.dummy15 = dummy15;
    }
    const dummy16 = json.dummy16 ?? json.dummy16;
    if (dummy16) {
      msg.dummy16 = dummy16;
    }
    const dummy17 = json.dummy17 ?? json.dummy17;
    if (dummy17) {
      msg.dummy17 = dummy17;
    }
    const dummy18 = json.dummy18 ?? json.dummy18;
    if (dummy18) {
      msg.dummy18 = dummy18;
    }
    const dummy19 = json.dummy19 ?? json.dummy19;
    if (dummy19) {
      msg.dummy19 = dummy19;
    }
    const dummy20 = json.dummy20 ?? json.dummy20;
    if (dummy20) {
      msg.dummy20 = dummy20;
    }
    const dummy21 = json.dummy21 ?? json.dummy21;
    if (dummy21) {
      msg.dummy21 = dummy21;
    }
    const dummy22 = json.dummy22 ?? json.dummy22;
    if (dummy22) {
      msg.dummy22 = dummy22;
    }
    const dummy23 = json.dummy23 ?? json.dummy23;
    if (dummy23) {
      msg.dummy23 = dummy23;
    }
    const dummy24 = json.dummy24 ?? json.dummy24;
    if (dummy24) {
      msg.dummy24 = dummy24;
    }
    const dummy25 = json.dummy25 ?? json.dummy25;
    if (dummy25) {
      msg.dummy25 = dummy25;
    }
    const dummy26 = json.dummy26 ?? json.dummy26;
    if (dummy26) {
      msg.dummy26 = dummy26;
    }
    const dummy27 = json.dummy27 ?? json.dummy27;
    if (dummy27) {
      msg.dummy27 = dummy27;
    }
    const dummy28 = json.dummy28 ?? json.dummy28;
    if (dummy28) {
      msg.dummy28 = dummy28;
    }
    const dummy29 = json.dummy29 ?? json.dummy29;
    if (dummy29) {
      msg.dummy29 = dummy29;
    }
    const dummy30 = json.dummy30 ?? json.dummy30;
    if (dummy30) {
      msg.dummy30 = dummy30;
    }
    const dummy31 = json.dummy31 ?? json.dummy31;
    if (dummy31) {
      msg.dummy31 = dummy31;
    }
    const dummy32 = json.dummy32 ?? json.dummy32;
    if (dummy32) {
      msg.dummy32 = dummy32;
    }
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): string {
    return JSON.stringify(
      TestRequiredForeign._writeMessageJSON(testRequiredForeign)
    );
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json: string): TestRequiredForeign {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): string {
    return JSON.stringify(
      TestRequiredMessage._writeMessageJSON(testRequiredMessage)
    );
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessage {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const requiredMessage = json.requiredMessage ?? json.required_message;
    if (requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (testForeignNested: Partial<TestForeignNested>): string {
    return JSON.stringify(
      TestForeignNested._writeMessageJSON(testForeignNested)
    );
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json: string): TestForeignNested {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const foreignNested = json.foreignNested ?? json.foreign_nested;
    if (foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessage,
    json: any
  ): TestEmptyMessage {
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */

  encodeJSON: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessageWithExtensions,
    json: any
  ): TestEmptyMessageWithExtensions {
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */

  encodeJSON: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPickleNestedMessage,
    json: any
  ): TestPickleNestedMessage {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            nestedNestedMessage
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const cc = json.cc ?? json.cc;
        if (cc) {
          msg.cc = cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */

  encodeJSON: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */

  decodeJSON: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMultipleExtensionRanges,
    json: any
  ): TestMultipleExtensionRanges {
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): string {
    return JSON.stringify(
      TestReallyLargeTagNumber._writeMessageJSON(testReallyLargeTagNumber)
    );
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const bb = json.bb ?? json.bb;
    if (bb) {
      msg.bb = bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): string {
    return JSON.stringify(
      TestRecursiveMessage._writeMessageJSON(testRecursiveMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, a);
      msg.a = m;
    }
    const i = json.i ?? json.i;
    if (i) {
      msg.i = i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): string {
    return JSON.stringify(
      TestMutualRecursionA._writeMessageJSON(testMutualRecursionA)
    );
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const bb = json.bb ?? json.bb;
    if (bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(subMessage)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const b = json.b ?? json.b;
      if (b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(subGroup)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const subMessage = json.subMessage ?? json.sub_message;
      if (subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, subMessage);
        msg.subMessage = m;
      }
      const notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): string {
    return JSON.stringify(
      TestMutualRecursionB._writeMessageJSON(testMutualRecursionB)
    );
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, a);
      msg.a = m;
    }
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (testIsInitialized: Partial<TestIsInitialized>): string {
    return JSON.stringify(
      TestIsInitialized._writeMessageJSON(testIsInitialized)
    );
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json: string): TestIsInitialized {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */

    encodeJSON: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): string {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */

    decodeJSON: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestIsInitialized.SubMessage,
      json: any
    ): TestIsInitialized.SubMessage {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(subGroup)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const i = json.i ?? json.i;
        if (i) {
          msg.i = i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): string {
    return JSON.stringify(
      TestDupFieldNumber._writeMessageJSON(testDupFieldNumber)
    );
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (foo: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(foo));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (bar: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(bar));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (testEagerMessage: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(testEagerMessage));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json: string): TestEagerMessage {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEagerMessage,
    json: any
  ): TestEagerMessage {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (testLazyMessage: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(testLazyMessage));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json: string): TestLazyMessage {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestLazyMessage,
    json: any
  ): TestLazyMessage {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): string {
    return JSON.stringify(
      TestNestedMessageHasBits._writeMessageJSON(testNestedMessageHasBits)
    );
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = nestedmessageRepeatedInt32;
      }
      const nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (nestedmessageRepeatedForeignmessage) {
        for (const item of nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): string {
    return JSON.stringify(
      TestCamelCaseFieldNames._writeMessageJSON(testCamelCaseFieldNames)
    );
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const PrimitiveField = json.PrimitiveField ?? json.PrimitiveField;
    if (PrimitiveField) {
      msg.PrimitiveField = PrimitiveField;
    }
    const StringField = json.StringField ?? json.StringField;
    if (StringField) {
      msg.StringField = StringField;
    }
    const EnumField = json.EnumField ?? json.EnumField;
    if (EnumField) {
      msg.EnumField = EnumField;
    }
    const MessageField = json.MessageField ?? json.MessageField;
    if (MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, MessageField);
      msg.MessageField = m;
    }
    const StringPieceField = json.StringPieceField ?? json.StringPieceField;
    if (StringPieceField) {
      msg.StringPieceField = StringPieceField;
    }
    const CordField = json.CordField ?? json.CordField;
    if (CordField) {
      msg.CordField = CordField;
    }
    const RepeatedPrimitiveField =
      json.RepeatedPrimitiveField ?? json.RepeatedPrimitiveField;
    if (RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = RepeatedPrimitiveField;
    }
    const RepeatedStringField =
      json.RepeatedStringField ?? json.RepeatedStringField;
    if (RepeatedStringField) {
      msg.RepeatedStringField = RepeatedStringField;
    }
    const RepeatedEnumField = json.RepeatedEnumField ?? json.RepeatedEnumField;
    if (RepeatedEnumField) {
      msg.RepeatedEnumField = RepeatedEnumField;
    }
    const RepeatedMessageField =
      json.RepeatedMessageField ?? json.RepeatedMessageField;
    if (RepeatedMessageField) {
      for (const item of RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const RepeatedStringPieceField =
      json.RepeatedStringPieceField ?? json.RepeatedStringPieceField;
    if (RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = RepeatedStringPieceField;
    }
    const RepeatedCordField = json.RepeatedCordField ?? json.RepeatedCordField;
    if (RepeatedCordField) {
      msg.RepeatedCordField = RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): string {
    return JSON.stringify(
      TestFieldOrderings._writeMessageJSON(testFieldOrderings)
    );
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json: string): TestFieldOrderings {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    const myInt = json.myInt ?? json.my_int;
    if (myInt) {
      msg.myInt = BigInt(myInt);
    }
    const myFloat = json.myFloat ?? json.my_float;
    if (myFloat) {
      msg.myFloat = myFloat;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): string {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const oo = json.oo ?? json.oo;
      if (oo) {
        msg.oo = BigInt(oo);
      }
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): string {
    return JSON.stringify(
      TestExtensionOrderings1._writeMessageJSON(testExtensionOrderings1)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): string {
    return JSON.stringify(
      TestExtensionOrderings2._writeMessageJSON(testExtensionOrderings2)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(
          testExtensionOrderings3
        )
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const myString = json.myString ?? json.my_string;
      if (myString) {
        msg.myString = myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): string {
    return JSON.stringify(
      TestExtremeDefaultValues._writeMessageJSON(testExtremeDefaultValues)
    );
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes) {
      json.escapedBytes = msg.escapedBytes;
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero) {
      json.bytesWithZero = msg.bytesWithZero;
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (escapedBytes) {
      msg.escapedBytes = escapedBytes;
    }
    const largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (largeUint32) {
      msg.largeUint32 = largeUint32;
    }
    const largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (largeUint64) {
      msg.largeUint64 = BigInt(largeUint64);
    }
    const smallInt32 = json.smallInt32 ?? json.small_int32;
    if (smallInt32) {
      msg.smallInt32 = smallInt32;
    }
    const smallInt64 = json.smallInt64 ?? json.small_int64;
    if (smallInt64) {
      msg.smallInt64 = BigInt(smallInt64);
    }
    const reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (reallySmallInt32) {
      msg.reallySmallInt32 = reallySmallInt32;
    }
    const reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(reallySmallInt64);
    }
    const utf8String = json.utf8String ?? json.utf8_string;
    if (utf8String) {
      msg.utf8String = utf8String;
    }
    const zeroFloat = json.zeroFloat ?? json.zero_float;
    if (zeroFloat) {
      msg.zeroFloat = zeroFloat;
    }
    const oneFloat = json.oneFloat ?? json.one_float;
    if (oneFloat) {
      msg.oneFloat = oneFloat;
    }
    const smallFloat = json.smallFloat ?? json.small_float;
    if (smallFloat) {
      msg.smallFloat = smallFloat;
    }
    const negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (negativeOneFloat) {
      msg.negativeOneFloat = negativeOneFloat;
    }
    const negativeFloat = json.negativeFloat ?? json.negative_float;
    if (negativeFloat) {
      msg.negativeFloat = negativeFloat;
    }
    const largeFloat = json.largeFloat ?? json.large_float;
    if (largeFloat) {
      msg.largeFloat = largeFloat;
    }
    const smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (smallNegativeFloat) {
      msg.smallNegativeFloat = smallNegativeFloat;
    }
    const infDouble = json.infDouble ?? json.inf_double;
    if (infDouble) {
      msg.infDouble = infDouble;
    }
    const negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (negInfDouble) {
      msg.negInfDouble = negInfDouble;
    }
    const nanDouble = json.nanDouble ?? json.nan_double;
    if (nanDouble) {
      msg.nanDouble = nanDouble;
    }
    const infFloat = json.infFloat ?? json.inf_float;
    if (infFloat) {
      msg.infFloat = infFloat;
    }
    const negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (negInfFloat) {
      msg.negInfFloat = negInfFloat;
    }
    const nanFloat = json.nanFloat ?? json.nan_float;
    if (nanFloat) {
      msg.nanFloat = nanFloat;
    }
    const cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (cppTrigraph) {
      msg.cppTrigraph = cppTrigraph;
    }
    const stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (stringWithZero) {
      msg.stringWithZero = stringWithZero;
    }
    const bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (bytesWithZero) {
      msg.bytesWithZero = bytesWithZero;
    }
    const stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (stringPieceWithZero) {
      msg.stringPieceWithZero = stringPieceWithZero;
    }
    const cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (cordWithZero) {
      msg.cordWithZero = cordWithZero;
    }
    const replacementString = json.replacementString ?? json.replacement_string;
    if (replacementString) {
      msg.replacementString = replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (sparseEnumMessage: Partial<SparseEnumMessage>): string {
    return JSON.stringify(
      SparseEnumMessage._writeMessageJSON(sparseEnumMessage)
    );
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json: string): SparseEnumMessage {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (sparseEnum) {
      msg.sparseEnum = sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (oneString: Partial<OneString>): string {
    return JSON.stringify(OneString._writeMessageJSON(oneString));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json: string): OneString {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneString, json: any): OneString {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (moreString: Partial<MoreString>): string {
    return JSON.stringify(MoreString._writeMessageJSON(moreString));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json: string): MoreString {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreString, json: any): MoreString {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (oneBytes: Partial<OneBytes>): string {
    return JSON.stringify(OneBytes._writeMessageJSON(oneBytes));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json: string): OneBytes {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneBytes, json: any): OneBytes {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (moreBytes: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytes._writeMessageJSON(moreBytes));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json: string): MoreBytes {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreBytes, json: any): MoreBytes {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (int32Message: Partial<Int32Message>): string {
    return JSON.stringify(Int32Message._writeMessageJSON(int32Message));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json: string): Int32Message {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Message, json: any): Int32Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (uint32Message: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32Message._writeMessageJSON(uint32Message));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json: string): Uint32Message {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint32Message, json: any): Uint32Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (int64Message: Partial<Int64Message>): string {
    return JSON.stringify(Int64Message._writeMessageJSON(int64Message));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json: string): Int64Message {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Message, json: any): Int64Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (uint64Message: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64Message._writeMessageJSON(uint64Message));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json: string): Uint64Message {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint64Message, json: any): Uint64Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (boolMessage: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessage._writeMessageJSON(boolMessage));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json: string): BoolMessage {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolMessage, json: any): BoolMessage {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (testOneof: Partial<TestOneof>): string {
    return JSON.stringify(TestOneof._writeMessageJSON(testOneof));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json: string): TestOneof {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof, json: any): TestOneof {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): string {
    return JSON.stringify(
      TestOneofBackwardsCompatible._writeMessageJSON(
        testOneofBackwardsCompatible
      )
    );
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(fooGroup)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes != undefined) {
      json.fooBytes = msg.fooBytes;
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes != undefined) {
      json.barBytes = msg.barBytes;
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      json.barBytesWithEmptyDefault = msg.barBytesWithEmptyDefault;
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooCord = json.fooCord ?? json.foo_cord;
    if (fooCord) {
      msg.fooCord = fooCord;
    }
    const fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (fooStringPiece) {
      msg.fooStringPiece = fooStringPiece;
    }
    const fooBytes = json.fooBytes ?? json.foo_bytes;
    if (fooBytes) {
      msg.fooBytes = fooBytes;
    }
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    const fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const barInt = json.barInt ?? json.bar_int;
    if (barInt) {
      msg.barInt = barInt;
    }
    const barString = json.barString ?? json.bar_string;
    if (barString) {
      msg.barString = barString;
    }
    const barCord = json.barCord ?? json.bar_cord;
    if (barCord) {
      msg.barCord = barCord;
    }
    const barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (barStringPiece) {
      msg.barStringPiece = barStringPiece;
    }
    const barBytes = json.barBytes ?? json.bar_bytes;
    if (barBytes) {
      msg.barBytes = barBytes;
    }
    const barEnum = json.barEnum ?? json.bar_enum;
    if (barEnum) {
      msg.barEnum = barEnum;
    }
    const barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = barStringWithEmptyDefault;
    }
    const barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = barCordWithEmptyDefault;
    }
    const barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = barStringPieceWithEmptyDefault;
    }
    const barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = barBytesWithEmptyDefault;
    }
    const bazInt = json.bazInt ?? json.baz_int;
    if (bazInt) {
      msg.bazInt = bazInt;
    }
    const bazString = json.bazString ?? json.baz_string;
    if (bazString) {
      msg.bazString = bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): string {
      return JSON.stringify(
        TestOneof2.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const quxInt = json.quxInt ?? json.qux_int;
      if (quxInt) {
        msg.quxInt = BigInt(quxInt);
      }
      const corgeInt = json.corgeInt ?? json.corge_int;
      if (corgeInt) {
        msg.corgeInt = corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (testRequiredOneof: Partial<TestRequiredOneof>): string {
    return JSON.stringify(
      TestRequiredOneof._writeMessageJSON(testRequiredOneof)
    );
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json: string): TestRequiredOneof {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): string {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const requiredDouble = json.requiredDouble ?? json.required_double;
      if (requiredDouble) {
        msg.requiredDouble = requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64.toString());
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64.toString());
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64.toString());
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64.toString());
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (unpackedInt32) {
      msg.unpackedInt32 = unpackedInt32;
    }
    const unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (unpackedInt64) {
      msg.unpackedInt64 = unpackedInt64.map(BigInt);
    }
    const unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (unpackedUint32) {
      msg.unpackedUint32 = unpackedUint32;
    }
    const unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (unpackedUint64) {
      msg.unpackedUint64 = unpackedUint64.map(BigInt);
    }
    const unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (unpackedSint32) {
      msg.unpackedSint32 = unpackedSint32;
    }
    const unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (unpackedSint64) {
      msg.unpackedSint64 = unpackedSint64.map(BigInt);
    }
    const unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (unpackedFixed32) {
      msg.unpackedFixed32 = unpackedFixed32;
    }
    const unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (unpackedFixed64) {
      msg.unpackedFixed64 = unpackedFixed64.map(BigInt);
    }
    const unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (unpackedSfixed32) {
      msg.unpackedSfixed32 = unpackedSfixed32;
    }
    const unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (unpackedSfixed64) {
      msg.unpackedSfixed64 = unpackedSfixed64.map(BigInt);
    }
    const unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (unpackedFloat) {
      msg.unpackedFloat = unpackedFloat;
    }
    const unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (unpackedDouble) {
      msg.unpackedDouble = unpackedDouble;
    }
    const unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (unpackedBool) {
      msg.unpackedBool = unpackedBool;
    }
    const unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (unpackedEnum) {
      msg.unpackedEnum = unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */

  encodeJSON: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedExtensions,
    json: any
  ): TestPackedExtensions {
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */

  encodeJSON: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedExtensions,
    json: any
  ): TestUnpackedExtensions {
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): string {
    return JSON.stringify(
      TestDynamicExtensions._writeMessageJSON(testDynamicExtensions)
    );
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension) {
      json.enumExtension = msg.enumExtension;
    }
    if (msg.dynamicEnumExtension) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (scalarExtension) {
      msg.scalarExtension = scalarExtension;
    }
    const enumExtension = json.enumExtension ?? json.enum_extension;
    if (enumExtension) {
      msg.enumExtension = enumExtension;
    }
    const dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (dynamicEnumExtension) {
      msg.dynamicEnumExtension = dynamicEnumExtension;
    }
    const messageExtension = json.messageExtension ?? json.message_extension;
    if (messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, messageExtension);
      msg.messageExtension = m;
    }
    const dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const repeatedExtension = json.repeatedExtension ?? json.repeated_extension;
    if (repeatedExtension) {
      msg.repeatedExtension = repeatedExtension;
    }
    const packedExtension = json.packedExtension ?? json.packed_extension;
    if (packedExtension) {
      msg.packedExtension = packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          dynamicMessageType
        )
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const dynamicField = json.dynamicField ?? json.dynamic_field;
      if (dynamicField) {
        msg.dynamicField = dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(
        testRepeatedScalarDifferentTagSizes
      )
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 2047: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (testParsingMerge: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(testParsingMerge));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json: string): TestParsingMerge {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestParsingMerge,
    json: any
  ): TestParsingMerge {
    const requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (repeatedAllTypes) {
      for (const item of repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(
          repeatedFieldsGenerator
        )
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const field1 = json.field1 ?? json.field1;
      if (field1) {
        for (const item of field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const field2 = json.field2 ?? json.field2;
      if (field2) {
        for (const item of field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const field3 = json.field3 ?? json.field3;
      if (field3) {
        for (const item of field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const ext1 = json.ext1 ?? json.ext1;
      if (ext1) {
        for (const item of ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const ext2 = json.ext2 ?? json.ext2;
      if (ext2) {
        for (const item of ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(
            group1
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(
            group2
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): string {
    return JSON.stringify(
      TestCommentInjectionMessage._writeMessageJSON(testCommentInjectionMessage)
    );
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */

  encodeJSON: function (_fooRequest?: Partial<FooRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */

  decodeJSON: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FooRequest, json: any): FooRequest {
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */

  encodeJSON: function (_fooResponse?: Partial<FooResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */

  decodeJSON: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FooResponse, json: any): FooResponse {
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */

  encodeJSON: function (_fooClientMessage?: Partial<FooClientMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */

  decodeJSON: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: FooClientMessage,
    json: any
  ): FooClientMessage {
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */

  encodeJSON: function (_fooServerMessage?: Partial<FooServerMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */

  decodeJSON: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: FooServerMessage,
    json: any
  ): FooServerMessage {
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */

  encodeJSON: function (_barRequest?: Partial<BarRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */

  decodeJSON: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BarRequest, json: any): BarRequest {
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */

  encodeJSON: function (_barResponse?: Partial<BarResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */

  decodeJSON: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BarResponse, json: any): BarResponse {
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (testJsonName: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonName._writeMessageJSON(testJsonName));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json: string): TestJsonName {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestJsonName, json: any): TestJsonName {
    const fieldName1 = json.fieldName1 ?? json.field_name1;
    if (fieldName1) {
      msg.fieldName1 = fieldName1;
    }
    const fieldName2 = json.fieldName2 ?? json.fieldName2;
    if (fieldName2) {
      msg.fieldName2 = fieldName2;
    }
    const FieldName3 = json.FieldName3 ?? json.FieldName3;
    if (FieldName3) {
      msg.FieldName3 = FieldName3;
    }
    const FieldName4 = json.FieldName4 ?? json._field_name4;
    if (FieldName4) {
      msg.FieldName4 = FieldName4;
    }
    const FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (FIELDNAME5) {
      msg.FIELDNAME5 = FIELDNAME5;
    }
    const fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (fieldName6) {
      msg.fieldName6 = fieldName6;
    }
    const fieldname7 = json.fieldname7 ?? json.fieldname7;
    if (fieldname7) {
      msg.fieldname7 = fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): string {
    return JSON.stringify(
      TestHugeFieldNumbers._writeMessageJSON(testHugeFieldNumbers)
    );
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const [key, value] of Object.entries(msg.stringStringMap)) {
        if (key && value) {
          writer.writeMessage(536870010, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      if (msg.stringStringMap) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.stringStringMap)) {
          if (key && value) {
            map[key] = value;
            json.stringStringMap = map;
          }
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const fixed32 = json.fixed32 ?? json.fixed_32;
    if (fixed32) {
      msg.fixed32 = fixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (optionalEnum) {
      msg.optionalEnum = optionalEnum;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (stringStringMap) {
      for (const [key, value] of Object.entries(stringStringMap)) {
        msg.stringStringMap[key] = value;
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const groupA = json.groupA ?? json.group_a;
      if (groupA) {
        msg.groupA = groupA;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): string {
    return JSON.stringify(
      TestExtensionInsideTable._writeMessageJSON(testExtensionInsideTable)
    );
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const field1 = json.field1 ?? json.field1;
    if (field1) {
      msg.field1 = field1;
    }
    const field2 = json.field2 ?? json.field2;
    if (field2) {
      msg.field2 = field2;
    }
    const field3 = json.field3 ?? json.field3;
    if (field3) {
      msg.field3 = field3;
    }
    const field4 = json.field4 ?? json.field4;
    if (field4) {
      msg.field4 = field4;
    }
    const field6 = json.field6 ?? json.field6;
    if (field6) {
      msg.field6 = field6;
    }
    const field7 = json.field7 ?? json.field7;
    if (field7) {
      msg.field7 = field7;
    }
    const field8 = json.field8 ?? json.field8;
    if (field8) {
      msg.field8 = field8;
    }
    const field9 = json.field9 ?? json.field9;
    if (field9) {
      msg.field9 = field9;
    }
    const field10 = json.field10 ?? json.field10;
    if (field10) {
      msg.field10 = field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): string {
    return JSON.stringify(
      TestExtensionRangeSerialize._writeMessageJSON(testExtensionRangeSerialize)
    );
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const fooOne = json.fooOne ?? json.foo_one;
    if (fooOne) {
      msg.fooOne = fooOne;
    }
    const fooTwo = json.fooTwo ?? json.foo_two;
    if (fooTwo) {
      msg.fooTwo = fooTwo;
    }
    const fooThree = json.fooThree ?? json.foo_three;
    if (fooThree) {
      msg.fooThree = fooThree;
    }
    const fooFour = json.fooFour ?? json.foo_four;
    if (fooFour) {
      msg.fooFour = fooFour;
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<bigint, bigint | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<bigint, bigint | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<bigint, bigint | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<bigint, bigint | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<bigint, bigint | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
  mapStringForeignMessage: Record<string, ForeignMessage | undefined>;
  mapInt32AllTypes: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<bigint, bigint | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<bigint, bigint | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<bigint, bigint | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<bigint, bigint | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<bigint, bigint | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (testMap: Partial<TestMap>): string {
    return JSON.stringify(TestMap._writeMessageJSON(testMap));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json: string): TestMap {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key as any);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key as any);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key as any);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key as any);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key as any);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key as any);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key as any);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key as any);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key as any);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key as any);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeEnum(2, value as MapEnum);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapStringForeignMessage)) {
        if (key && value) {
          writer.writeMessage(18, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
        if (key && value) {
          writer.writeMessage(19, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      if (msg.mapStringForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(
          msg.mapStringForeignMessage
        )) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapStringForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      if (msg.mapInt32AllTypes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32AllTypes = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum() as MapEnum;
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMap, json: any): TestMap {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value as string);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value as string);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value as string);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value as string);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value as string);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value as MapEnum;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (mapStringForeignMessage) {
      for (const [key, value] of Object.entries(mapStringForeignMessage)) {
        msg.mapStringForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (mapInt32AllTypes) {
      for (const [key, value] of Object.entries(mapInt32AllTypes)) {
        msg.mapInt32AllTypes[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (testMapSubmessage: Partial<TestMapSubmessage>): string {
    return JSON.stringify(
      TestMapSubmessage._writeMessageJSON(testMapSubmessage)
    );
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json: string): TestMapSubmessage {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const testMap = json.testMap ?? json.test_map;
    if (testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (testMessageMap: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMap._writeMessageJSON(testMessageMap));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestMessageMap {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      for (const [key, value] of Object.entries(msg.mapInt32Message)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      if (msg.mapInt32Message) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Message)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32Message = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMessageMap, json: any): TestMessageMap {
    const mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (mapInt32Message) {
      for (const [key, value] of Object.entries(mapInt32Message)) {
        msg.mapInt32Message[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (testSameTypeMap: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(testSameTypeMap));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json: string): TestSameTypeMap {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const [key, value] of Object.entries(msg.map1)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.map2) {
      for (const [key, value] of Object.entries(msg.map2)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      if (msg.map1) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.map1)) {
          if (key && value) {
            map[key] = value;
            json.map1 = map;
          }
        }
      }
    }
    if (msg.map2) {
      if (msg.map2) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.map2)) {
          if (key && value) {
            map[key] = value;
            json.map2 = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestSameTypeMap,
    json: any
  ): TestSameTypeMap {
    const map1 = json.map1 ?? json.map1;
    if (map1) {
      for (const [key, value] of Object.entries(map1)) {
        msg.map1[key] = value;
      }
    }
    const map2 = json.map2 ?? json.map2;
    if (map2) {
      for (const [key, value] of Object.entries(map2)) {
        msg.map2[key] = value;
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): string {
    return JSON.stringify(
      TestRequiredMessageMap._writeMessageJSON(testRequiredMessageMap)
    );
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      for (const [key, value] of Object.entries(msg.mapField)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestRequired._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      if (msg.mapField) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapField)) {
          if (key && value) {
            map[key] = TestRequired._writeMessageJSON(value);
            json.mapField = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRequired.initialize(),
                    TestRequired._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const mapField = json.mapField ?? json.map_field;
    if (mapField) {
      for (const [key, value] of Object.entries(mapField)) {
        msg.mapField[key] = TestRequired._readMessageJSON(
          TestRequired.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (testArenaMap: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMap._writeMessageJSON(testArenaMap));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json: string): TestArenaMap {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key as any);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key as any);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key as any);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key as any);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key as any);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key as any);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key as any);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key as any);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key as any);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key as any);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeEnum(2, value as MapEnum);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum() as MapEnum;
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestArenaMap, json: any): TestArenaMap {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value as string);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value as string);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value as string);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value as string);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value as string);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value as MapEnum;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): string {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(
        messageContainingMapCalledEntry
      )
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const [key, value] of Object.entries(msg.entry)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      if (msg.entry) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.entry)) {
          if (key && value) {
            map[key] = value;
            json.entry = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const entry = json.entry ?? json.entry;
    if (entry) {
      for (const [key, value] of Object.entries(entry)) {
        msg.entry[key] = value;
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): string {
    return JSON.stringify(
      TestRecursiveMapMessage._writeMessageJSON(testRecursiveMapMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const [key, value] of Object.entries(msg.a)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeMessage(
              2,
              value,
              TestRecursiveMapMessage._writeMessage
            );
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      if (msg.a) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.a)) {
          if (key && value) {
            map[key] = TestRecursiveMapMessage._writeMessageJSON(value);
            json.a = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRecursiveMapMessage.initialize(),
                    TestRecursiveMapMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const a = json.a ?? json.a;
    if (a) {
      for (const [key, value] of Object.entries(a)) {
        msg.a[key] = TestRecursiveMapMessage._readMessageJSON(
          TestRecursiveMapMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): string {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): string {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessage,
    json: any
  ): TestEmptyMessage {
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): string {
    return JSON.stringify(
      TestMessageWithDummy._writeMessageJSON(testMessageWithDummy)
    );
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
      ],
      Array [
        "google/protobuf/empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */

  encodeJSON: function (_empty?: Partial<Empty>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */

  decodeJSON: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Empty, json: any): Empty {
    return msg;
  },
};
",
      ],
      Array [
        "empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { ClientConfiguration } from \\"twirpscript\\";
import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//              Foo Service               //
//========================================//

export interface FooService<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFooHandler<Context>(service: FooService<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a PublicImportMessage to JSON.
   */
  encodeJSON: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): string {
    return JSON.stringify(
      PublicImportMessage._writeMessageJSON(publicImportMessage)
    );
  },

  /**
   * Deserializes a PublicImportMessage from JSON.
   */
  decodeJSON: function (json: string): PublicImportMessage {
    return PublicImportMessage._readMessageJSON(
      PublicImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<PublicImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.e) {
      json.e = msg.e;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: PublicImportMessage,
    json: any
  ): PublicImportMessage {
    const e = json.e ?? json.e;
    if (e) {
      msg.e = e;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ImportMessage to JSON.
   */
  encodeJSON: function (importMessage: Partial<ImportMessage>): string {
    return JSON.stringify(ImportMessage._writeMessageJSON(importMessage));
  },

  /**
   * Deserializes a ImportMessage from JSON.
   */
  decodeJSON: function (json: string): ImportMessage {
    return ImportMessage._readMessageJSON(
      ImportMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ImportMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ImportMessage, json: any): ImportMessage {
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number;
  fooString?: string;
  fooCord?: string;
  fooStringPiece?: string;
  fooBytes?: Uint8Array;
  fooEnum?: TestOneof2.NestedEnum;
  fooMessage?: TestOneof2.NestedMessage;
  fooLazyMessage?: TestOneof2.NestedMessage;
  barInt?: number;
  barString?: string;
  barCord?: string;
  barStringPiece?: string;
  barBytes?: Uint8Array;
  barEnum?: TestOneof2.NestedEnum;
  barStringWithEmptyDefault?: string;
  barCordWithEmptyDefault?: string;
  barStringPieceWithEmptyDefault?: string;
  barBytesWithEmptyDefault?: Uint8Array;
  bazInt: number;
  bazString: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<string, string | undefined>;
  oneofUint32?: number;
  oneofTestAllTypes?: TestAllTypes;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalImportEnum) {
      json.optionalImportEnum = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json.repeatedImportEnum = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.defaultInt32) {
      json.defaultInt32 = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json.defaultInt64 = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json.defaultUint32 = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json.defaultUint64 = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json.defaultSint32 = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json.defaultSint64 = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json.defaultFixed32 = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json.defaultFixed64 = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json.defaultSfixed32 = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json.defaultSfixed64 = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json.defaultFloat = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json.defaultDouble = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json.defaultBool = msg.defaultBool;
    }
    if (msg.defaultString) {
      json.defaultString = msg.defaultString;
    }
    if (msg.defaultBytes) {
      json.defaultBytes = msg.defaultBytes;
    }
    if (msg.defaultNestedEnum) {
      json.defaultNestedEnum = msg.defaultNestedEnum;
    }
    if (msg.defaultForeignEnum) {
      json.defaultForeignEnum = msg.defaultForeignEnum;
    }
    if (msg.defaultImportEnum) {
      json.defaultImportEnum = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json.defaultStringPiece = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json.defaultCord = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalImportEnum =
      json.optionalImportEnum ?? json.optional_import_enum;
    if (optionalImportEnum) {
      msg.optionalImportEnum = optionalImportEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedImportEnum =
      json.repeatedImportEnum ?? json.repeated_import_enum;
    if (repeatedImportEnum) {
      msg.repeatedImportEnum = repeatedImportEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const defaultInt32 = json.defaultInt32 ?? json.default_int32;
    if (defaultInt32) {
      msg.defaultInt32 = defaultInt32;
    }
    const defaultInt64 = json.defaultInt64 ?? json.default_int64;
    if (defaultInt64) {
      msg.defaultInt64 = BigInt(defaultInt64);
    }
    const defaultUint32 = json.defaultUint32 ?? json.default_uint32;
    if (defaultUint32) {
      msg.defaultUint32 = defaultUint32;
    }
    const defaultUint64 = json.defaultUint64 ?? json.default_uint64;
    if (defaultUint64) {
      msg.defaultUint64 = BigInt(defaultUint64);
    }
    const defaultSint32 = json.defaultSint32 ?? json.default_sint32;
    if (defaultSint32) {
      msg.defaultSint32 = defaultSint32;
    }
    const defaultSint64 = json.defaultSint64 ?? json.default_sint64;
    if (defaultSint64) {
      msg.defaultSint64 = BigInt(defaultSint64);
    }
    const defaultFixed32 = json.defaultFixed32 ?? json.default_fixed32;
    if (defaultFixed32) {
      msg.defaultFixed32 = defaultFixed32;
    }
    const defaultFixed64 = json.defaultFixed64 ?? json.default_fixed64;
    if (defaultFixed64) {
      msg.defaultFixed64 = BigInt(defaultFixed64);
    }
    const defaultSfixed32 = json.defaultSfixed32 ?? json.default_sfixed32;
    if (defaultSfixed32) {
      msg.defaultSfixed32 = defaultSfixed32;
    }
    const defaultSfixed64 = json.defaultSfixed64 ?? json.default_sfixed64;
    if (defaultSfixed64) {
      msg.defaultSfixed64 = BigInt(defaultSfixed64);
    }
    const defaultFloat = json.defaultFloat ?? json.default_float;
    if (defaultFloat) {
      msg.defaultFloat = defaultFloat;
    }
    const defaultDouble = json.defaultDouble ?? json.default_double;
    if (defaultDouble) {
      msg.defaultDouble = defaultDouble;
    }
    const defaultBool = json.defaultBool ?? json.default_bool;
    if (defaultBool) {
      msg.defaultBool = defaultBool;
    }
    const defaultString = json.defaultString ?? json.default_string;
    if (defaultString) {
      msg.defaultString = defaultString;
    }
    const defaultBytes = json.defaultBytes ?? json.default_bytes;
    if (defaultBytes) {
      msg.defaultBytes = defaultBytes;
    }
    const defaultNestedEnum =
      json.defaultNestedEnum ?? json.default_nested_enum;
    if (defaultNestedEnum) {
      msg.defaultNestedEnum = defaultNestedEnum;
    }
    const defaultForeignEnum =
      json.defaultForeignEnum ?? json.default_foreign_enum;
    if (defaultForeignEnum) {
      msg.defaultForeignEnum = defaultForeignEnum;
    }
    const defaultImportEnum =
      json.defaultImportEnum ?? json.default_import_enum;
    if (defaultImportEnum) {
      msg.defaultImportEnum = defaultImportEnum;
    }
    const defaultStringPiece =
      json.defaultStringPiece ?? json.default_string_piece;
    if (defaultStringPiece) {
      msg.defaultStringPiece = defaultStringPiece;
    }
    const defaultCord = json.defaultCord ?? json.default_cord;
    if (defaultCord) {
      msg.defaultCord = defaultCord;
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): string {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestAllTypes.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessageJSON(
        TestAllTypes.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.OptionalGroup,
      json: any
    ): TestAllTypes.OptionalGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestAllTypes.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessageJSON(
        TestAllTypes.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any
    ): TestAllTypes.RepeatedGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): string {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    if (msg.repeatedChild?.length) {
      json.repeatedChild = msg.repeatedChild.map(
        NestedTestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    const repeatedChild = json.repeatedChild ?? json.repeated_child;
    if (repeatedChild) {
      for (const item of repeatedChild) {
        const m = NestedTestAllTypes.initialize();
        NestedTestAllTypes._readMessageJSON(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDeprecatedFields to JSON.
   */
  encodeJSON: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): string {
    return JSON.stringify(
      TestDeprecatedFields._writeMessageJSON(testDeprecatedFields)
    );
  },

  /**
   * Deserializes a TestDeprecatedFields from JSON.
   */
  decodeJSON: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFields._readMessageJSON(
      TestDeprecatedFields.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDeprecatedFields>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json.deprecatedInt32 = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json.deprecatedInt32InOneof = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedFields,
    json: any
  ): TestDeprecatedFields {
    const deprecatedInt32 = json.deprecatedInt32 ?? json.deprecated_int32;
    if (deprecatedInt32) {
      msg.deprecatedInt32 = deprecatedInt32;
    }
    const deprecatedInt32InOneof =
      json.deprecatedInt32InOneof ?? json.deprecated_int32_in_oneof;
    if (deprecatedInt32InOneof) {
      msg.deprecatedInt32InOneof = deprecatedInt32InOneof;
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Serializes a TestDeprecatedMessage to JSON.
   */

  encodeJSON: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestDeprecatedMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDeprecatedMessage,
    json: any
  ): TestDeprecatedMessage {
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    if (msg.d) {
      json.d = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    const d = json.d ?? json.d;
    if (d) {
      msg.d = d;
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Serializes a TestReservedFields to JSON.
   */

  encodeJSON: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestReservedFields from JSON.
   */

  decodeJSON: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReservedFields,
    json: any
  ): TestReservedFields {
    return msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Serializes a TestAllExtensions to JSON.
   */

  encodeJSON: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestAllExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestAllExtensions,
    json: any
  ): TestAllExtensions {
    return msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OptionalGroup_extension to JSON.
   */
  encodeJSON: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): string {
    return JSON.stringify(
      OptionalGroup_extension._writeMessageJSON(optionalGroup_extension)
    );
  },

  /**
   * Deserializes a OptionalGroup_extension from JSON.
   */
  decodeJSON: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extension._readMessageJSON(
      OptionalGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OptionalGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: OptionalGroup_extension,
    json: any
  ): OptionalGroup_extension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a RepeatedGroup_extension to JSON.
   */
  encodeJSON: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): string {
    return JSON.stringify(
      RepeatedGroup_extension._writeMessageJSON(repeatedGroup_extension)
    );
  },

  /**
   * Deserializes a RepeatedGroup_extension from JSON.
   */
  decodeJSON: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessageJSON(
      RepeatedGroup_extension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<RepeatedGroup_extension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: RepeatedGroup_extension,
    json: any
  ): RepeatedGroup_extension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestGroup to JSON.
   */
  encodeJSON: function (testGroup: Partial<TestGroup>): string {
    return JSON.stringify(TestGroup._writeMessageJSON(testGroup));
  },

  /**
   * Deserializes a TestGroup from JSON.
   */
  decodeJSON: function (json: string): TestGroup {
    return TestGroup._readMessageJSON(TestGroup.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestGroup>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestGroup, json: any): TestGroup {
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestGroup.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestGroup.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessageJSON(
        TestGroup.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestGroup.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestGroup.OptionalGroup,
      json: any
    ): TestGroup.OptionalGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Serializes a TestGroupExtension to JSON.
   */

  encodeJSON: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestGroupExtension from JSON.
   */

  decodeJSON: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestGroupExtension,
    json: any
  ): TestGroupExtension {
    return msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Serializes a TestNestedExtension to JSON.
   */

  encodeJSON: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestNestedExtension from JSON.
   */

  decodeJSON: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedExtension,
    json: any
  ): TestNestedExtension {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encodeJSON: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): string {
      return JSON.stringify(
        TestNestedExtension.OptionalGroup_extension._writeMessageJSON(
          optionalGroup_extension
        )
      );
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessageJSON(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any
    ): TestNestedExtension.OptionalGroup_extension {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestChildExtension to JSON.
   */
  encodeJSON: function (
    testChildExtension: Partial<TestChildExtension>
  ): string {
    return JSON.stringify(
      TestChildExtension._writeMessageJSON(testChildExtension)
    );
  },

  /**
   * Deserializes a TestChildExtension from JSON.
   */
  decodeJSON: function (json: string): TestChildExtension {
    return TestChildExtension._readMessageJSON(
      TestChildExtension.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestChildExtension>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.optionalExtension) {
      const optionalExtension = TestAllExtensions._writeMessageJSON(
        msg.optionalExtension
      );
      if (Object.keys(optionalExtension).length > 0) {
        json.optionalExtension = optionalExtension;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestChildExtension,
    json: any
  ): TestChildExtension {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const optionalExtension = json.optionalExtension ?? json.optional_extension;
    if (optionalExtension) {
      const m = TestAllExtensions.initialize();
      TestAllExtensions._readMessageJSON(m, optionalExtension);
      msg.optionalExtension = m;
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequired to JSON.
   */
  encodeJSON: function (testRequired: Partial<TestRequired>): string {
    return JSON.stringify(TestRequired._writeMessageJSON(testRequired));
  },

  /**
   * Deserializes a TestRequired from JSON.
   */
  decodeJSON: function (json: string): TestRequired {
    return TestRequired._readMessageJSON(
      TestRequired.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequired>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.dummy2) {
      json.dummy2 = msg.dummy2;
    }
    if (msg.b) {
      json.b = msg.b;
    }
    if (msg.dummy4) {
      json.dummy4 = msg.dummy4;
    }
    if (msg.dummy5) {
      json.dummy5 = msg.dummy5;
    }
    if (msg.dummy6) {
      json.dummy6 = msg.dummy6;
    }
    if (msg.dummy7) {
      json.dummy7 = msg.dummy7;
    }
    if (msg.dummy8) {
      json.dummy8 = msg.dummy8;
    }
    if (msg.dummy9) {
      json.dummy9 = msg.dummy9;
    }
    if (msg.dummy10) {
      json.dummy10 = msg.dummy10;
    }
    if (msg.dummy11) {
      json.dummy11 = msg.dummy11;
    }
    if (msg.dummy12) {
      json.dummy12 = msg.dummy12;
    }
    if (msg.dummy13) {
      json.dummy13 = msg.dummy13;
    }
    if (msg.dummy14) {
      json.dummy14 = msg.dummy14;
    }
    if (msg.dummy15) {
      json.dummy15 = msg.dummy15;
    }
    if (msg.dummy16) {
      json.dummy16 = msg.dummy16;
    }
    if (msg.dummy17) {
      json.dummy17 = msg.dummy17;
    }
    if (msg.dummy18) {
      json.dummy18 = msg.dummy18;
    }
    if (msg.dummy19) {
      json.dummy19 = msg.dummy19;
    }
    if (msg.dummy20) {
      json.dummy20 = msg.dummy20;
    }
    if (msg.dummy21) {
      json.dummy21 = msg.dummy21;
    }
    if (msg.dummy22) {
      json.dummy22 = msg.dummy22;
    }
    if (msg.dummy23) {
      json.dummy23 = msg.dummy23;
    }
    if (msg.dummy24) {
      json.dummy24 = msg.dummy24;
    }
    if (msg.dummy25) {
      json.dummy25 = msg.dummy25;
    }
    if (msg.dummy26) {
      json.dummy26 = msg.dummy26;
    }
    if (msg.dummy27) {
      json.dummy27 = msg.dummy27;
    }
    if (msg.dummy28) {
      json.dummy28 = msg.dummy28;
    }
    if (msg.dummy29) {
      json.dummy29 = msg.dummy29;
    }
    if (msg.dummy30) {
      json.dummy30 = msg.dummy30;
    }
    if (msg.dummy31) {
      json.dummy31 = msg.dummy31;
    }
    if (msg.dummy32) {
      json.dummy32 = msg.dummy32;
    }
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestRequired, json: any): TestRequired {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const dummy2 = json.dummy2 ?? json.dummy2;
    if (dummy2) {
      msg.dummy2 = dummy2;
    }
    const b = json.b ?? json.b;
    if (b) {
      msg.b = b;
    }
    const dummy4 = json.dummy4 ?? json.dummy4;
    if (dummy4) {
      msg.dummy4 = dummy4;
    }
    const dummy5 = json.dummy5 ?? json.dummy5;
    if (dummy5) {
      msg.dummy5 = dummy5;
    }
    const dummy6 = json.dummy6 ?? json.dummy6;
    if (dummy6) {
      msg.dummy6 = dummy6;
    }
    const dummy7 = json.dummy7 ?? json.dummy7;
    if (dummy7) {
      msg.dummy7 = dummy7;
    }
    const dummy8 = json.dummy8 ?? json.dummy8;
    if (dummy8) {
      msg.dummy8 = dummy8;
    }
    const dummy9 = json.dummy9 ?? json.dummy9;
    if (dummy9) {
      msg.dummy9 = dummy9;
    }
    const dummy10 = json.dummy10 ?? json.dummy10;
    if (dummy10) {
      msg.dummy10 = dummy10;
    }
    const dummy11 = json.dummy11 ?? json.dummy11;
    if (dummy11) {
      msg.dummy11 = dummy11;
    }
    const dummy12 = json.dummy12 ?? json.dummy12;
    if (dummy12) {
      msg.dummy12 = dummy12;
    }
    const dummy13 = json.dummy13 ?? json.dummy13;
    if (dummy13) {
      msg.dummy13 = dummy13;
    }
    const dummy14 = json.dummy14 ?? json.dummy14;
    if (dummy14) {
      msg.dummy14 = dummy14;
    }
    const dummy15 = json.dummy15 ?? json.dummy15;
    if (dummy15) {
      msg.dummy15 = dummy15;
    }
    const dummy16 = json.dummy16 ?? json.dummy16;
    if (dummy16) {
      msg.dummy16 = dummy16;
    }
    const dummy17 = json.dummy17 ?? json.dummy17;
    if (dummy17) {
      msg.dummy17 = dummy17;
    }
    const dummy18 = json.dummy18 ?? json.dummy18;
    if (dummy18) {
      msg.dummy18 = dummy18;
    }
    const dummy19 = json.dummy19 ?? json.dummy19;
    if (dummy19) {
      msg.dummy19 = dummy19;
    }
    const dummy20 = json.dummy20 ?? json.dummy20;
    if (dummy20) {
      msg.dummy20 = dummy20;
    }
    const dummy21 = json.dummy21 ?? json.dummy21;
    if (dummy21) {
      msg.dummy21 = dummy21;
    }
    const dummy22 = json.dummy22 ?? json.dummy22;
    if (dummy22) {
      msg.dummy22 = dummy22;
    }
    const dummy23 = json.dummy23 ?? json.dummy23;
    if (dummy23) {
      msg.dummy23 = dummy23;
    }
    const dummy24 = json.dummy24 ?? json.dummy24;
    if (dummy24) {
      msg.dummy24 = dummy24;
    }
    const dummy25 = json.dummy25 ?? json.dummy25;
    if (dummy25) {
      msg.dummy25 = dummy25;
    }
    const dummy26 = json.dummy26 ?? json.dummy26;
    if (dummy26) {
      msg.dummy26 = dummy26;
    }
    const dummy27 = json.dummy27 ?? json.dummy27;
    if (dummy27) {
      msg.dummy27 = dummy27;
    }
    const dummy28 = json.dummy28 ?? json.dummy28;
    if (dummy28) {
      msg.dummy28 = dummy28;
    }
    const dummy29 = json.dummy29 ?? json.dummy29;
    if (dummy29) {
      msg.dummy29 = dummy29;
    }
    const dummy30 = json.dummy30 ?? json.dummy30;
    if (dummy30) {
      msg.dummy30 = dummy30;
    }
    const dummy31 = json.dummy31 ?? json.dummy31;
    if (dummy31) {
      msg.dummy31 = dummy31;
    }
    const dummy32 = json.dummy32 ?? json.dummy32;
    if (dummy32) {
      msg.dummy32 = dummy32;
    }
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredForeign to JSON.
   */
  encodeJSON: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): string {
    return JSON.stringify(
      TestRequiredForeign._writeMessageJSON(testRequiredForeign)
    );
  },

  /**
   * Deserializes a TestRequiredForeign from JSON.
   */
  decodeJSON: function (json: string): TestRequiredForeign {
    return TestRequiredForeign._readMessageJSON(
      TestRequiredForeign.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredForeign>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredForeign,
    json: any
  ): TestRequiredForeign {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessage to JSON.
   */
  encodeJSON: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): string {
    return JSON.stringify(
      TestRequiredMessage._writeMessageJSON(testRequiredMessage)
    );
  },

  /**
   * Deserializes a TestRequiredMessage from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessage {
    return TestRequiredMessage._readMessageJSON(
      TestRequiredMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const optionalMessage = TestRequired._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.repeatedMessage?.length) {
      json.repeatedMessage = msg.repeatedMessage.map(
        TestRequired._writeMessageJSON
      );
    }
    if (msg.requiredMessage) {
      const requiredMessage = TestRequired._writeMessageJSON(
        msg.requiredMessage
      );
      if (Object.keys(requiredMessage).length > 0) {
        json.requiredMessage = requiredMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessage,
    json: any
  ): TestRequiredMessage {
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const repeatedMessage = json.repeatedMessage ?? json.repeated_message;
    if (repeatedMessage) {
      for (const item of repeatedMessage) {
        const m = TestRequired.initialize();
        TestRequired._readMessageJSON(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const requiredMessage = json.requiredMessage ?? json.required_message;
    if (requiredMessage) {
      const m = TestRequired.initialize();
      TestRequired._readMessageJSON(m, requiredMessage);
      msg.requiredMessage = m;
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestForeignNested to JSON.
   */
  encodeJSON: function (testForeignNested: Partial<TestForeignNested>): string {
    return JSON.stringify(
      TestForeignNested._writeMessageJSON(testForeignNested)
    );
  },

  /**
   * Deserializes a TestForeignNested from JSON.
   */
  decodeJSON: function (json: string): TestForeignNested {
    return TestForeignNested._readMessageJSON(
      TestForeignNested.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestForeignNested>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const foreignNested = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.foreignNested
      );
      if (Object.keys(foreignNested).length > 0) {
        json.foreignNested = foreignNested;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestForeignNested,
    json: any
  ): TestForeignNested {
    const foreignNested = json.foreignNested ?? json.foreign_nested;
    if (foreignNested) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, foreignNested);
      msg.foreignNested = m;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessage,
    json: any
  ): TestEmptyMessage {
    return msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Serializes a TestEmptyMessageWithExtensions to JSON.
   */

  encodeJSON: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessageWithExtensions,
    json: any
  ): TestEmptyMessageWithExtensions {
    return msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Serializes a TestPickleNestedMessage to JSON.
   */

  encodeJSON: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPickleNestedMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPickleNestedMessage,
    json: any
  ): TestPickleNestedMessage {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): string {
      return JSON.stringify(
        TestPickleNestedMessage.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessageJSON(
        TestPickleNestedMessage.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any
    ): TestPickleNestedMessage.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encodeJSON: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): string {
        return JSON.stringify(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessageJSON(
            nestedNestedMessage
          )
        );
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessageJSON(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json.cc = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const cc = json.cc ?? json.cc;
        if (cc) {
          msg.cc = cc;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Serializes a TestMultipleExtensionRanges to JSON.
   */

  encodeJSON: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from JSON.
   */

  decodeJSON: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMultipleExtensionRanges,
    json: any
  ): TestMultipleExtensionRanges {
    return msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestReallyLargeTagNumber to JSON.
   */
  encodeJSON: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): string {
    return JSON.stringify(
      TestReallyLargeTagNumber._writeMessageJSON(testReallyLargeTagNumber)
    );
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from JSON.
   */
  decodeJSON: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessageJSON(
      TestReallyLargeTagNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestReallyLargeTagNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    if (msg.bb) {
      json.bb = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestReallyLargeTagNumber,
    json: any
  ): TestReallyLargeTagNumber {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    const bb = json.bb ?? json.bb;
    if (bb) {
      msg.bb = bb;
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMessage to JSON.
   */
  encodeJSON: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): string {
    return JSON.stringify(
      TestRecursiveMessage._writeMessageJSON(testRecursiveMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessage._readMessageJSON(
      TestRecursiveMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestRecursiveMessage._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.i) {
      json.i = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMessage,
    json: any
  ): TestRecursiveMessage {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestRecursiveMessage.initialize();
      TestRecursiveMessage._readMessageJSON(m, a);
      msg.a = m;
    }
    const i = json.i ?? json.i;
    if (i) {
      msg.i = i;
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionA to JSON.
   */
  encodeJSON: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): string {
    return JSON.stringify(
      TestMutualRecursionA._writeMessageJSON(testMutualRecursionA)
    );
  },

  /**
   * Deserializes a TestMutualRecursionA from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionA._readMessageJSON(
      TestMutualRecursionA.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionA>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const bb = TestMutualRecursionB._writeMessageJSON(msg.bb);
      if (Object.keys(bb).length > 0) {
        json.bb = bb;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionA,
    json: any
  ): TestMutualRecursionA {
    const bb = json.bb ?? json.bb;
    if (bb) {
      const m = TestMutualRecursionB.initialize();
      TestMutualRecursionB._readMessageJSON(m, bb);
      msg.bb = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubMessage to JSON.
     */
    encodeJSON: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubMessage._writeMessageJSON(subMessage)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessageJSON(
        TestMutualRecursionA.SubMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const b = TestMutualRecursionB._writeMessageJSON(msg.b);
        if (Object.keys(b).length > 0) {
          json.b = b;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any
    ): TestMutualRecursionA.SubMessage {
      const b = json.b ?? json.b;
      if (b) {
        const m = TestMutualRecursionB.initialize();
        TestMutualRecursionB._readMessageJSON(m, b);
        msg.b = m;
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestMutualRecursionA.SubGroup to JSON.
     */
    encodeJSON: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): string {
      return JSON.stringify(
        TestMutualRecursionA.SubGroup._writeMessageJSON(subGroup)
      );
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from JSON.
     */
    decodeJSON: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessageJSON(
        TestMutualRecursionA.SubGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestMutualRecursionA.SubGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const subMessage = TestMutualRecursionA.SubMessage._writeMessageJSON(
          msg.subMessage
        );
        if (Object.keys(subMessage).length > 0) {
          json.subMessage = subMessage;
        }
      }
      if (msg.notInThisScc) {
        const notInThisScc = TestAllTypes._writeMessageJSON(msg.notInThisScc);
        if (Object.keys(notInThisScc).length > 0) {
          json.notInThisScc = notInThisScc;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any
    ): TestMutualRecursionA.SubGroup {
      const subMessage = json.subMessage ?? json.sub_message;
      if (subMessage) {
        const m = TestMutualRecursionA.SubMessage.initialize();
        TestMutualRecursionA.SubMessage._readMessageJSON(m, subMessage);
        msg.subMessage = m;
      }
      const notInThisScc = json.notInThisScc ?? json.not_in_this_scc;
      if (notInThisScc) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, notInThisScc);
        msg.notInThisScc = m;
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMutualRecursionB to JSON.
   */
  encodeJSON: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): string {
    return JSON.stringify(
      TestMutualRecursionB._writeMessageJSON(testMutualRecursionB)
    );
  },

  /**
   * Deserializes a TestMutualRecursionB from JSON.
   */
  decodeJSON: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionB._readMessageJSON(
      TestMutualRecursionB.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMutualRecursionB>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const a = TestMutualRecursionA._writeMessageJSON(msg.a);
      if (Object.keys(a).length > 0) {
        json.a = a;
      }
    }
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMutualRecursionB,
    json: any
  ): TestMutualRecursionB {
    const a = json.a ?? json.a;
    if (a) {
      const m = TestMutualRecursionA.initialize();
      TestMutualRecursionA._readMessageJSON(m, a);
      msg.a = m;
    }
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestIsInitialized to JSON.
   */
  encodeJSON: function (testIsInitialized: Partial<TestIsInitialized>): string {
    return JSON.stringify(
      TestIsInitialized._writeMessageJSON(testIsInitialized)
    );
  },

  /**
   * Deserializes a TestIsInitialized from JSON.
   */
  decodeJSON: function (json: string): TestIsInitialized {
    return TestIsInitialized._readMessageJSON(
      TestIsInitialized.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestIsInitialized>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestIsInitialized.SubMessage._writeMessageJSON(
        msg.subMessage
      );
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestIsInitialized,
    json: any
  ): TestIsInitialized {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestIsInitialized.SubMessage.initialize();
      TestIsInitialized.SubMessage._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Serializes a TestIsInitialized.SubMessage to JSON.
     */

    encodeJSON: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): string {
      return \\"{}\\";
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from JSON.
     */

    decodeJSON: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestIsInitialized.SubMessage,
      json: any
    ): TestIsInitialized.SubMessage {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encodeJSON: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): string {
        return JSON.stringify(
          TestIsInitialized.SubMessage.SubGroup._writeMessageJSON(subGroup)
        );
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessageJSON(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json.i = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any
      ): TestIsInitialized.SubMessage.SubGroup {
        const i = json.i ?? json.i;
        if (i) {
          msg.i = i;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDupFieldNumber to JSON.
   */
  encodeJSON: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): string {
    return JSON.stringify(
      TestDupFieldNumber._writeMessageJSON(testDupFieldNumber)
    );
  },

  /**
   * Deserializes a TestDupFieldNumber from JSON.
   */
  decodeJSON: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumber._readMessageJSON(
      TestDupFieldNumber.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDupFieldNumber>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDupFieldNumber,
    json: any
  ): TestDupFieldNumber {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Foo to JSON.
     */
    encodeJSON: function (foo: Partial<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumber.Foo._writeMessageJSON(foo));
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessageJSON(
        TestDupFieldNumber.Foo.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Foo>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Foo,
      json: any
    ): TestDupFieldNumber.Foo {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDupFieldNumber.Bar to JSON.
     */
    encodeJSON: function (bar: Partial<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumber.Bar._writeMessageJSON(bar));
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from JSON.
     */
    decodeJSON: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessageJSON(
        TestDupFieldNumber.Bar.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDupFieldNumber.Bar>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDupFieldNumber.Bar,
      json: any
    ): TestDupFieldNumber.Bar {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestEagerMessage to JSON.
   */
  encodeJSON: function (testEagerMessage: Partial<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessage._writeMessageJSON(testEagerMessage));
  },

  /**
   * Deserializes a TestEagerMessage from JSON.
   */
  decodeJSON: function (json: string): TestEagerMessage {
    return TestEagerMessage._readMessageJSON(
      TestEagerMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestEagerMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEagerMessage,
    json: any
  ): TestEagerMessage {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestLazyMessage to JSON.
   */
  encodeJSON: function (testLazyMessage: Partial<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessage._writeMessageJSON(testLazyMessage));
  },

  /**
   * Deserializes a TestLazyMessage from JSON.
   */
  decodeJSON: function (json: string): TestLazyMessage {
    return TestLazyMessage._readMessageJSON(
      TestLazyMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestLazyMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const subMessage = TestAllTypes._writeMessageJSON(msg.subMessage);
      if (Object.keys(subMessage).length > 0) {
        json.subMessage = subMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestLazyMessage,
    json: any
  ): TestLazyMessage {
    const subMessage = json.subMessage ?? json.sub_message;
    if (subMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, subMessage);
      msg.subMessage = m;
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestNestedMessageHasBits to JSON.
   */
  encodeJSON: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): string {
    return JSON.stringify(
      TestNestedMessageHasBits._writeMessageJSON(testNestedMessageHasBits)
    );
  },

  /**
   * Deserializes a TestNestedMessageHasBits from JSON.
   */
  decodeJSON: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessageJSON(
      TestNestedMessageHasBits.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestNestedMessageHasBits>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestNestedMessageHasBits,
    json: any
  ): TestNestedMessageHasBits {
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestNestedMessageHasBits.NestedMessage.initialize();
      TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBits.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessageJSON(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json.nestedmessageRepeatedInt32 = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json.nestedmessageRepeatedForeignmessage =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessage._writeMessageJSON
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any
    ): TestNestedMessageHasBits.NestedMessage {
      const nestedmessageRepeatedInt32 =
        json.nestedmessageRepeatedInt32 ?? json.nestedmessage_repeated_int32;
      if (nestedmessageRepeatedInt32) {
        msg.nestedmessageRepeatedInt32 = nestedmessageRepeatedInt32;
      }
      const nestedmessageRepeatedForeignmessage =
        json.nestedmessageRepeatedForeignmessage ??
        json.nestedmessage_repeated_foreignmessage;
      if (nestedmessageRepeatedForeignmessage) {
        for (const item of nestedmessageRepeatedForeignmessage) {
          const m = ForeignMessage.initialize();
          ForeignMessage._readMessageJSON(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCamelCaseFieldNames to JSON.
   */
  encodeJSON: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): string {
    return JSON.stringify(
      TestCamelCaseFieldNames._writeMessageJSON(testCamelCaseFieldNames)
    );
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from JSON.
   */
  decodeJSON: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessageJSON(
      TestCamelCaseFieldNames.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCamelCaseFieldNames>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json.PrimitiveField = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json.StringField = msg.StringField;
    }
    if (msg.EnumField) {
      json.EnumField = msg.EnumField;
    }
    if (msg.MessageField) {
      const MessageField = ForeignMessage._writeMessageJSON(msg.MessageField);
      if (Object.keys(MessageField).length > 0) {
        json.MessageField = MessageField;
      }
    }
    if (msg.StringPieceField) {
      json.StringPieceField = msg.StringPieceField;
    }
    if (msg.CordField) {
      json.CordField = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json.RepeatedPrimitiveField = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json.RepeatedStringField = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json.RepeatedEnumField = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json.RepeatedMessageField = msg.RepeatedMessageField.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json.RepeatedStringPieceField = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json.RepeatedCordField = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCamelCaseFieldNames,
    json: any
  ): TestCamelCaseFieldNames {
    const PrimitiveField = json.PrimitiveField ?? json.PrimitiveField;
    if (PrimitiveField) {
      msg.PrimitiveField = PrimitiveField;
    }
    const StringField = json.StringField ?? json.StringField;
    if (StringField) {
      msg.StringField = StringField;
    }
    const EnumField = json.EnumField ?? json.EnumField;
    if (EnumField) {
      msg.EnumField = EnumField;
    }
    const MessageField = json.MessageField ?? json.MessageField;
    if (MessageField) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, MessageField);
      msg.MessageField = m;
    }
    const StringPieceField = json.StringPieceField ?? json.StringPieceField;
    if (StringPieceField) {
      msg.StringPieceField = StringPieceField;
    }
    const CordField = json.CordField ?? json.CordField;
    if (CordField) {
      msg.CordField = CordField;
    }
    const RepeatedPrimitiveField =
      json.RepeatedPrimitiveField ?? json.RepeatedPrimitiveField;
    if (RepeatedPrimitiveField) {
      msg.RepeatedPrimitiveField = RepeatedPrimitiveField;
    }
    const RepeatedStringField =
      json.RepeatedStringField ?? json.RepeatedStringField;
    if (RepeatedStringField) {
      msg.RepeatedStringField = RepeatedStringField;
    }
    const RepeatedEnumField = json.RepeatedEnumField ?? json.RepeatedEnumField;
    if (RepeatedEnumField) {
      msg.RepeatedEnumField = RepeatedEnumField;
    }
    const RepeatedMessageField =
      json.RepeatedMessageField ?? json.RepeatedMessageField;
    if (RepeatedMessageField) {
      for (const item of RepeatedMessageField) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const RepeatedStringPieceField =
      json.RepeatedStringPieceField ?? json.RepeatedStringPieceField;
    if (RepeatedStringPieceField) {
      msg.RepeatedStringPieceField = RepeatedStringPieceField;
    }
    const RepeatedCordField = json.RepeatedCordField ?? json.RepeatedCordField;
    if (RepeatedCordField) {
      msg.RepeatedCordField = RepeatedCordField;
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestFieldOrderings to JSON.
   */
  encodeJSON: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): string {
    return JSON.stringify(
      TestFieldOrderings._writeMessageJSON(testFieldOrderings)
    );
  },

  /**
   * Deserializes a TestFieldOrderings from JSON.
   */
  decodeJSON: function (json: string): TestFieldOrderings {
    return TestFieldOrderings._readMessageJSON(
      TestFieldOrderings.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestFieldOrderings>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    if (msg.myInt) {
      json.myInt = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json.myFloat = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestFieldOrderings.NestedMessage._writeMessageJSON(
          msg.optionalNestedMessage
        );
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestFieldOrderings,
    json: any
  ): TestFieldOrderings {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    const myInt = json.myInt ?? json.my_int;
    if (myInt) {
      msg.myInt = BigInt(myInt);
    }
    const myFloat = json.myFloat ?? json.my_float;
    if (myFloat) {
      msg.myFloat = myFloat;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestFieldOrderings.NestedMessage.initialize();
      TestFieldOrderings.NestedMessage._readMessageJSON(
        m,
        optionalNestedMessage
      );
      msg.optionalNestedMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestFieldOrderings.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): string {
      return JSON.stringify(
        TestFieldOrderings.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessageJSON(
        TestFieldOrderings.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestFieldOrderings.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json.oo = msg.oo.toString();
      }
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any
    ): TestFieldOrderings.NestedMessage {
      const oo = json.oo ?? json.oo;
      if (oo) {
        msg.oo = BigInt(oo);
      }
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings1 to JSON.
   */
  encodeJSON: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): string {
    return JSON.stringify(
      TestExtensionOrderings1._writeMessageJSON(testExtensionOrderings1)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings1 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessageJSON(
      TestExtensionOrderings1.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings1>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings1,
    json: any
  ): TestExtensionOrderings1 {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionOrderings2 to JSON.
   */
  encodeJSON: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): string {
    return JSON.stringify(
      TestExtensionOrderings2._writeMessageJSON(testExtensionOrderings2)
    );
  },

  /**
   * Deserializes a TestExtensionOrderings2 from JSON.
   */
  decodeJSON: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessageJSON(
      TestExtensionOrderings2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionOrderings2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json.myString = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionOrderings2,
    json: any
  ): TestExtensionOrderings2 {
    const myString = json.myString ?? json.my_string;
    if (myString) {
      msg.myString = myString;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encodeJSON: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2.TestExtensionOrderings3._writeMessageJSON(
          testExtensionOrderings3
        )
      );
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessageJSON(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json.myString = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const myString = json.myString ?? json.my_string;
      if (myString) {
        msg.myString = myString;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtremeDefaultValues to JSON.
   */
  encodeJSON: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): string {
    return JSON.stringify(
      TestExtremeDefaultValues._writeMessageJSON(testExtremeDefaultValues)
    );
  },

  /**
   * Deserializes a TestExtremeDefaultValues from JSON.
   */
  decodeJSON: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessageJSON(
      TestExtremeDefaultValues.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtremeDefaultValues>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes) {
      json.escapedBytes = msg.escapedBytes;
    }
    if (msg.largeUint32) {
      json.largeUint32 = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json.largeUint64 = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json.smallInt32 = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json.smallInt64 = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json.reallySmallInt32 = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json.reallySmallInt64 = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json.utf8String = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json.zeroFloat = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json.oneFloat = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json.smallFloat = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json.negativeOneFloat = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json.negativeFloat = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json.largeFloat = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json.smallNegativeFloat = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json.infDouble = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json.negInfDouble = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json.nanDouble = msg.nanDouble;
    }
    if (msg.infFloat) {
      json.infFloat = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json.negInfFloat = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json.nanFloat = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json.cppTrigraph = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json.stringWithZero = msg.stringWithZero;
    }
    if (msg.bytesWithZero) {
      json.bytesWithZero = msg.bytesWithZero;
    }
    if (msg.stringPieceWithZero) {
      json.stringPieceWithZero = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json.cordWithZero = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json.replacementString = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtremeDefaultValues,
    json: any
  ): TestExtremeDefaultValues {
    const escapedBytes = json.escapedBytes ?? json.escaped_bytes;
    if (escapedBytes) {
      msg.escapedBytes = escapedBytes;
    }
    const largeUint32 = json.largeUint32 ?? json.large_uint32;
    if (largeUint32) {
      msg.largeUint32 = largeUint32;
    }
    const largeUint64 = json.largeUint64 ?? json.large_uint64;
    if (largeUint64) {
      msg.largeUint64 = BigInt(largeUint64);
    }
    const smallInt32 = json.smallInt32 ?? json.small_int32;
    if (smallInt32) {
      msg.smallInt32 = smallInt32;
    }
    const smallInt64 = json.smallInt64 ?? json.small_int64;
    if (smallInt64) {
      msg.smallInt64 = BigInt(smallInt64);
    }
    const reallySmallInt32 = json.reallySmallInt32 ?? json.really_small_int32;
    if (reallySmallInt32) {
      msg.reallySmallInt32 = reallySmallInt32;
    }
    const reallySmallInt64 = json.reallySmallInt64 ?? json.really_small_int64;
    if (reallySmallInt64) {
      msg.reallySmallInt64 = BigInt(reallySmallInt64);
    }
    const utf8String = json.utf8String ?? json.utf8_string;
    if (utf8String) {
      msg.utf8String = utf8String;
    }
    const zeroFloat = json.zeroFloat ?? json.zero_float;
    if (zeroFloat) {
      msg.zeroFloat = zeroFloat;
    }
    const oneFloat = json.oneFloat ?? json.one_float;
    if (oneFloat) {
      msg.oneFloat = oneFloat;
    }
    const smallFloat = json.smallFloat ?? json.small_float;
    if (smallFloat) {
      msg.smallFloat = smallFloat;
    }
    const negativeOneFloat = json.negativeOneFloat ?? json.negative_one_float;
    if (negativeOneFloat) {
      msg.negativeOneFloat = negativeOneFloat;
    }
    const negativeFloat = json.negativeFloat ?? json.negative_float;
    if (negativeFloat) {
      msg.negativeFloat = negativeFloat;
    }
    const largeFloat = json.largeFloat ?? json.large_float;
    if (largeFloat) {
      msg.largeFloat = largeFloat;
    }
    const smallNegativeFloat =
      json.smallNegativeFloat ?? json.small_negative_float;
    if (smallNegativeFloat) {
      msg.smallNegativeFloat = smallNegativeFloat;
    }
    const infDouble = json.infDouble ?? json.inf_double;
    if (infDouble) {
      msg.infDouble = infDouble;
    }
    const negInfDouble = json.negInfDouble ?? json.neg_inf_double;
    if (negInfDouble) {
      msg.negInfDouble = negInfDouble;
    }
    const nanDouble = json.nanDouble ?? json.nan_double;
    if (nanDouble) {
      msg.nanDouble = nanDouble;
    }
    const infFloat = json.infFloat ?? json.inf_float;
    if (infFloat) {
      msg.infFloat = infFloat;
    }
    const negInfFloat = json.negInfFloat ?? json.neg_inf_float;
    if (negInfFloat) {
      msg.negInfFloat = negInfFloat;
    }
    const nanFloat = json.nanFloat ?? json.nan_float;
    if (nanFloat) {
      msg.nanFloat = nanFloat;
    }
    const cppTrigraph = json.cppTrigraph ?? json.cpp_trigraph;
    if (cppTrigraph) {
      msg.cppTrigraph = cppTrigraph;
    }
    const stringWithZero = json.stringWithZero ?? json.string_with_zero;
    if (stringWithZero) {
      msg.stringWithZero = stringWithZero;
    }
    const bytesWithZero = json.bytesWithZero ?? json.bytes_with_zero;
    if (bytesWithZero) {
      msg.bytesWithZero = bytesWithZero;
    }
    const stringPieceWithZero =
      json.stringPieceWithZero ?? json.string_piece_with_zero;
    if (stringPieceWithZero) {
      msg.stringPieceWithZero = stringPieceWithZero;
    }
    const cordWithZero = json.cordWithZero ?? json.cord_with_zero;
    if (cordWithZero) {
      msg.cordWithZero = cordWithZero;
    }
    const replacementString = json.replacementString ?? json.replacement_string;
    if (replacementString) {
      msg.replacementString = replacementString;
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a SparseEnumMessage to JSON.
   */
  encodeJSON: function (sparseEnumMessage: Partial<SparseEnumMessage>): string {
    return JSON.stringify(
      SparseEnumMessage._writeMessageJSON(sparseEnumMessage)
    );
  },

  /**
   * Deserializes a SparseEnumMessage from JSON.
   */
  decodeJSON: function (json: string): SparseEnumMessage {
    return SparseEnumMessage._readMessageJSON(
      SparseEnumMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<SparseEnumMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum) {
      json.sparseEnum = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: SparseEnumMessage,
    json: any
  ): SparseEnumMessage {
    const sparseEnum = json.sparseEnum ?? json.sparse_enum;
    if (sparseEnum) {
      msg.sparseEnum = sparseEnum;
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneString to JSON.
   */
  encodeJSON: function (oneString: Partial<OneString>): string {
    return JSON.stringify(OneString._writeMessageJSON(oneString));
  },

  /**
   * Deserializes a OneString from JSON.
   */
  decodeJSON: function (json: string): OneString {
    return OneString._readMessageJSON(OneString.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneString, json: any): OneString {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreString to JSON.
   */
  encodeJSON: function (moreString: Partial<MoreString>): string {
    return JSON.stringify(MoreString._writeMessageJSON(moreString));
  },

  /**
   * Deserializes a MoreString from JSON.
   */
  decodeJSON: function (json: string): MoreString {
    return MoreString._readMessageJSON(
      MoreString.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreString>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreString, json: any): MoreString {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a OneBytes to JSON.
   */
  encodeJSON: function (oneBytes: Partial<OneBytes>): string {
    return JSON.stringify(OneBytes._writeMessageJSON(oneBytes));
  },

  /**
   * Deserializes a OneBytes from JSON.
   */
  decodeJSON: function (json: string): OneBytes {
    return OneBytes._readMessageJSON(OneBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<OneBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: OneBytes, json: any): OneBytes {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MoreBytes to JSON.
   */
  encodeJSON: function (moreBytes: Partial<MoreBytes>): string {
    return JSON.stringify(MoreBytes._writeMessageJSON(moreBytes));
  },

  /**
   * Deserializes a MoreBytes from JSON.
   */
  decodeJSON: function (json: string): MoreBytes {
    return MoreBytes._readMessageJSON(MoreBytes.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MoreBytes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: MoreBytes, json: any): MoreBytes {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int32Message to JSON.
   */
  encodeJSON: function (int32Message: Partial<Int32Message>): string {
    return JSON.stringify(Int32Message._writeMessageJSON(int32Message));
  },

  /**
   * Deserializes a Int32Message from JSON.
   */
  decodeJSON: function (json: string): Int32Message {
    return Int32Message._readMessageJSON(
      Int32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int32Message, json: any): Int32Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint32Message to JSON.
   */
  encodeJSON: function (uint32Message: Partial<Uint32Message>): string {
    return JSON.stringify(Uint32Message._writeMessageJSON(uint32Message));
  },

  /**
   * Deserializes a Uint32Message from JSON.
   */
  decodeJSON: function (json: string): Uint32Message {
    return Uint32Message._readMessageJSON(
      Uint32Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint32Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint32Message, json: any): Uint32Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Int64Message to JSON.
   */
  encodeJSON: function (int64Message: Partial<Int64Message>): string {
    return JSON.stringify(Int64Message._writeMessageJSON(int64Message));
  },

  /**
   * Deserializes a Int64Message from JSON.
   */
  decodeJSON: function (json: string): Int64Message {
    return Int64Message._readMessageJSON(
      Int64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Int64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Int64Message, json: any): Int64Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a Uint64Message to JSON.
   */
  encodeJSON: function (uint64Message: Partial<Uint64Message>): string {
    return JSON.stringify(Uint64Message._writeMessageJSON(uint64Message));
  },

  /**
   * Deserializes a Uint64Message from JSON.
   */
  decodeJSON: function (json: string): Uint64Message {
    return Uint64Message._readMessageJSON(
      Uint64Message.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<Uint64Message>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Uint64Message, json: any): Uint64Message {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = BigInt(data);
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a BoolMessage to JSON.
   */
  encodeJSON: function (boolMessage: Partial<BoolMessage>): string {
    return JSON.stringify(BoolMessage._writeMessageJSON(boolMessage));
  },

  /**
   * Deserializes a BoolMessage from JSON.
   */
  decodeJSON: function (json: string): BoolMessage {
    return BoolMessage._readMessageJSON(
      BoolMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<BoolMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json.data = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BoolMessage, json: any): BoolMessage {
    const data = json.data ?? json.data;
    if (data) {
      msg.data = data;
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof to JSON.
   */
  encodeJSON: function (testOneof: Partial<TestOneof>): string {
    return JSON.stringify(TestOneof._writeMessageJSON(testOneof));
  },

  /**
   * Deserializes a TestOneof from JSON.
   */
  decodeJSON: function (json: string): TestOneof {
    return TestOneof._readMessageJSON(TestOneof.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof, json: any): TestOneof {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup: Partial<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneof.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessageJSON(
        TestOneof.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof.FooGroup,
      json: any
    ): TestOneof.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneofBackwardsCompatible to JSON.
   */
  encodeJSON: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): string {
    return JSON.stringify(
      TestOneofBackwardsCompatible._writeMessageJSON(
        testOneofBackwardsCompatible
      )
    );
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from JSON.
   */
  decodeJSON: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessageJSON(
      TestOneofBackwardsCompatible.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneofBackwardsCompatible>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage) {
      const fooMessage = TestAllTypes._writeMessageJSON(msg.fooMessage);
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestOneofBackwardsCompatible,
    json: any
  ): TestOneofBackwardsCompatible {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encodeJSON: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatible.FooGroup._writeMessageJSON(fooGroup)
      );
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessageJSON(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any
    ): TestOneofBackwardsCompatible.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json.fooCord = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json.fooStringPiece = msg.fooStringPiece;
    }
    if (msg.fooBytes != undefined) {
      json.fooBytes = msg.fooBytes;
    }
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    if (msg.fooLazyMessage != undefined) {
      const fooLazyMessage = TestOneof2.NestedMessage._writeMessageJSON(
        msg.fooLazyMessage
      );
      if (Object.keys(fooLazyMessage).length > 0) {
        json.fooLazyMessage = fooLazyMessage;
      }
    }
    if (msg.barInt != undefined) {
      json.barInt = msg.barInt;
    }
    if (msg.barString != undefined) {
      json.barString = msg.barString;
    }
    if (msg.barCord != undefined) {
      json.barCord = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json.barStringPiece = msg.barStringPiece;
    }
    if (msg.barBytes != undefined) {
      json.barBytes = msg.barBytes;
    }
    if (msg.barEnum != undefined) {
      json.barEnum = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json.barStringWithEmptyDefault = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json.barCordWithEmptyDefault = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json.barStringPieceWithEmptyDefault = msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      json.barBytesWithEmptyDefault = msg.barBytesWithEmptyDefault;
    }
    if (msg.bazInt) {
      json.bazInt = msg.bazInt;
    }
    if (msg.bazString) {
      json.bazString = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooCord = json.fooCord ?? json.foo_cord;
    if (fooCord) {
      msg.fooCord = fooCord;
    }
    const fooStringPiece = json.fooStringPiece ?? json.foo_string_piece;
    if (fooStringPiece) {
      msg.fooStringPiece = fooStringPiece;
    }
    const fooBytes = json.fooBytes ?? json.foo_bytes;
    if (fooBytes) {
      msg.fooBytes = fooBytes;
    }
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    const fooLazyMessage = json.fooLazyMessage ?? json.foo_lazy_message;
    if (fooLazyMessage) {
      const m = TestOneof2.NestedMessage.initialize();
      TestOneof2.NestedMessage._readMessageJSON(m, fooLazyMessage);
      msg.fooLazyMessage = m;
    }
    const barInt = json.barInt ?? json.bar_int;
    if (barInt) {
      msg.barInt = barInt;
    }
    const barString = json.barString ?? json.bar_string;
    if (barString) {
      msg.barString = barString;
    }
    const barCord = json.barCord ?? json.bar_cord;
    if (barCord) {
      msg.barCord = barCord;
    }
    const barStringPiece = json.barStringPiece ?? json.bar_string_piece;
    if (barStringPiece) {
      msg.barStringPiece = barStringPiece;
    }
    const barBytes = json.barBytes ?? json.bar_bytes;
    if (barBytes) {
      msg.barBytes = barBytes;
    }
    const barEnum = json.barEnum ?? json.bar_enum;
    if (barEnum) {
      msg.barEnum = barEnum;
    }
    const barStringWithEmptyDefault =
      json.barStringWithEmptyDefault ?? json.bar_string_with_empty_default;
    if (barStringWithEmptyDefault) {
      msg.barStringWithEmptyDefault = barStringWithEmptyDefault;
    }
    const barCordWithEmptyDefault =
      json.barCordWithEmptyDefault ?? json.bar_cord_with_empty_default;
    if (barCordWithEmptyDefault) {
      msg.barCordWithEmptyDefault = barCordWithEmptyDefault;
    }
    const barStringPieceWithEmptyDefault =
      json.barStringPieceWithEmptyDefault ??
      json.bar_string_piece_with_empty_default;
    if (barStringPieceWithEmptyDefault) {
      msg.barStringPieceWithEmptyDefault = barStringPieceWithEmptyDefault;
    }
    const barBytesWithEmptyDefault =
      json.barBytesWithEmptyDefault ?? json.bar_bytes_with_empty_default;
    if (barBytesWithEmptyDefault) {
      msg.barBytesWithEmptyDefault = barBytesWithEmptyDefault;
    }
    const bazInt = json.bazInt ?? json.baz_int;
    if (bazInt) {
      msg.bazInt = bazInt;
    }
    const bazString = json.bazString ?? json.baz_string;
    if (bazString) {
      msg.bazString = bazString;
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.FooGroup to JSON.
     */
    encodeJSON: function (fooGroup: Partial<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2.FooGroup._writeMessageJSON(fooGroup));
    },

    /**
     * Deserializes a TestOneof2.FooGroup from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessageJSON(
        TestOneof2.FooGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.FooGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json.a = msg.a;
      }
      if (msg.b) {
        json.b = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.FooGroup,
      json: any
    ): TestOneof2.FooGroup {
      const a = json.a ?? json.a;
      if (a) {
        msg.a = a;
      }
      const b = json.b ?? json.b;
      if (b) {
        msg.b = b;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestOneof2.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): string {
      return JSON.stringify(
        TestOneof2.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessageJSON(
        TestOneof2.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestOneof2.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json.quxInt = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json.corgeInt = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestOneof2.NestedMessage,
      json: any
    ): TestOneof2.NestedMessage {
      const quxInt = json.quxInt ?? json.qux_int;
      if (quxInt) {
        msg.quxInt = BigInt(quxInt);
      }
      const corgeInt = json.corgeInt ?? json.corge_int;
      if (corgeInt) {
        msg.corgeInt = corgeInt;
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredOneof to JSON.
   */
  encodeJSON: function (testRequiredOneof: Partial<TestRequiredOneof>): string {
    return JSON.stringify(
      TestRequiredOneof._writeMessageJSON(testRequiredOneof)
    );
  },

  /**
   * Deserializes a TestRequiredOneof from JSON.
   */
  decodeJSON: function (json: string): TestRequiredOneof {
    return TestRequiredOneof._readMessageJSON(
      TestRequiredOneof.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredOneof>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json.fooInt = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json.fooString = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const fooMessage = TestRequiredOneof.NestedMessage._writeMessageJSON(
        msg.fooMessage
      );
      if (Object.keys(fooMessage).length > 0) {
        json.fooMessage = fooMessage;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredOneof,
    json: any
  ): TestRequiredOneof {
    const fooInt = json.fooInt ?? json.foo_int;
    if (fooInt) {
      msg.fooInt = fooInt;
    }
    const fooString = json.fooString ?? json.foo_string;
    if (fooString) {
      msg.fooString = fooString;
    }
    const fooMessage = json.fooMessage ?? json.foo_message;
    if (fooMessage) {
      const m = TestRequiredOneof.NestedMessage.initialize();
      TestRequiredOneof.NestedMessage._readMessageJSON(m, fooMessage);
      msg.fooMessage = m;
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestRequiredOneof.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): string {
      return JSON.stringify(
        TestRequiredOneof.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessageJSON(
        TestRequiredOneof.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestRequiredOneof.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json.requiredDouble = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any
    ): TestRequiredOneof.NestedMessage {
      const requiredDouble = json.requiredDouble ?? json.required_double;
      if (requiredDouble) {
        msg.requiredDouble = requiredDouble;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64.toString());
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64.toString());
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64.toString());
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64.toString());
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json.unpackedInt32 = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json.unpackedInt64 = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json.unpackedUint32 = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json.unpackedUint64 = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json.unpackedSint32 = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json.unpackedSint64 = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json.unpackedFixed32 = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json.unpackedFixed64 = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json.unpackedSfixed32 = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json.unpackedSfixed64 = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json.unpackedFloat = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json.unpackedDouble = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json.unpackedBool = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json.unpackedEnum = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const unpackedInt32 = json.unpackedInt32 ?? json.unpacked_int32;
    if (unpackedInt32) {
      msg.unpackedInt32 = unpackedInt32;
    }
    const unpackedInt64 = json.unpackedInt64 ?? json.unpacked_int64;
    if (unpackedInt64) {
      msg.unpackedInt64 = unpackedInt64.map(BigInt);
    }
    const unpackedUint32 = json.unpackedUint32 ?? json.unpacked_uint32;
    if (unpackedUint32) {
      msg.unpackedUint32 = unpackedUint32;
    }
    const unpackedUint64 = json.unpackedUint64 ?? json.unpacked_uint64;
    if (unpackedUint64) {
      msg.unpackedUint64 = unpackedUint64.map(BigInt);
    }
    const unpackedSint32 = json.unpackedSint32 ?? json.unpacked_sint32;
    if (unpackedSint32) {
      msg.unpackedSint32 = unpackedSint32;
    }
    const unpackedSint64 = json.unpackedSint64 ?? json.unpacked_sint64;
    if (unpackedSint64) {
      msg.unpackedSint64 = unpackedSint64.map(BigInt);
    }
    const unpackedFixed32 = json.unpackedFixed32 ?? json.unpacked_fixed32;
    if (unpackedFixed32) {
      msg.unpackedFixed32 = unpackedFixed32;
    }
    const unpackedFixed64 = json.unpackedFixed64 ?? json.unpacked_fixed64;
    if (unpackedFixed64) {
      msg.unpackedFixed64 = unpackedFixed64.map(BigInt);
    }
    const unpackedSfixed32 = json.unpackedSfixed32 ?? json.unpacked_sfixed32;
    if (unpackedSfixed32) {
      msg.unpackedSfixed32 = unpackedSfixed32;
    }
    const unpackedSfixed64 = json.unpackedSfixed64 ?? json.unpacked_sfixed64;
    if (unpackedSfixed64) {
      msg.unpackedSfixed64 = unpackedSfixed64.map(BigInt);
    }
    const unpackedFloat = json.unpackedFloat ?? json.unpacked_float;
    if (unpackedFloat) {
      msg.unpackedFloat = unpackedFloat;
    }
    const unpackedDouble = json.unpackedDouble ?? json.unpacked_double;
    if (unpackedDouble) {
      msg.unpackedDouble = unpackedDouble;
    }
    const unpackedBool = json.unpackedBool ?? json.unpacked_bool;
    if (unpackedBool) {
      msg.unpackedBool = unpackedBool;
    }
    const unpackedEnum = json.unpackedEnum ?? json.unpacked_enum;
    if (unpackedEnum) {
      msg.unpackedEnum = unpackedEnum;
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Serializes a TestPackedExtensions to JSON.
   */

  encodeJSON: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestPackedExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedExtensions,
    json: any
  ): TestPackedExtensions {
    return msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Serializes a TestUnpackedExtensions to JSON.
   */

  encodeJSON: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestUnpackedExtensions from JSON.
   */

  decodeJSON: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedExtensions,
    json: any
  ): TestUnpackedExtensions {
    return msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestDynamicExtensions to JSON.
   */
  encodeJSON: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): string {
    return JSON.stringify(
      TestDynamicExtensions._writeMessageJSON(testDynamicExtensions)
    );
  },

  /**
   * Deserializes a TestDynamicExtensions from JSON.
   */
  decodeJSON: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensions._readMessageJSON(
      TestDynamicExtensions.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestDynamicExtensions>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json.scalarExtension = msg.scalarExtension;
    }
    if (msg.enumExtension) {
      json.enumExtension = msg.enumExtension;
    }
    if (msg.dynamicEnumExtension) {
      json.dynamicEnumExtension = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const messageExtension = ForeignMessage._writeMessageJSON(
        msg.messageExtension
      );
      if (Object.keys(messageExtension).length > 0) {
        json.messageExtension = messageExtension;
      }
    }
    if (msg.dynamicMessageExtension) {
      const dynamicMessageExtension =
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          msg.dynamicMessageExtension
        );
      if (Object.keys(dynamicMessageExtension).length > 0) {
        json.dynamicMessageExtension = dynamicMessageExtension;
      }
    }
    if (msg.repeatedExtension?.length) {
      json.repeatedExtension = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json.packedExtension = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestDynamicExtensions,
    json: any
  ): TestDynamicExtensions {
    const scalarExtension = json.scalarExtension ?? json.scalar_extension;
    if (scalarExtension) {
      msg.scalarExtension = scalarExtension;
    }
    const enumExtension = json.enumExtension ?? json.enum_extension;
    if (enumExtension) {
      msg.enumExtension = enumExtension;
    }
    const dynamicEnumExtension =
      json.dynamicEnumExtension ?? json.dynamic_enum_extension;
    if (dynamicEnumExtension) {
      msg.dynamicEnumExtension = dynamicEnumExtension;
    }
    const messageExtension = json.messageExtension ?? json.message_extension;
    if (messageExtension) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, messageExtension);
      msg.messageExtension = m;
    }
    const dynamicMessageExtension =
      json.dynamicMessageExtension ?? json.dynamic_message_extension;
    if (dynamicMessageExtension) {
      const m = TestDynamicExtensions.DynamicMessageType.initialize();
      TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        m,
        dynamicMessageExtension
      );
      msg.dynamicMessageExtension = m;
    }
    const repeatedExtension = json.repeatedExtension ?? json.repeated_extension;
    if (repeatedExtension) {
      msg.repeatedExtension = repeatedExtension;
    }
    const packedExtension = json.packedExtension ?? json.packed_extension;
    if (packedExtension) {
      msg.packedExtension = packedExtension;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encodeJSON: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): string {
      return JSON.stringify(
        TestDynamicExtensions.DynamicMessageType._writeMessageJSON(
          dynamicMessageType
        )
      );
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessageJSON(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json.dynamicField = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any
    ): TestDynamicExtensions.DynamicMessageType {
      const dynamicField = json.dynamicField ?? json.dynamic_field;
      if (dynamicField) {
        msg.dynamicField = dynamicField;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encodeJSON: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizes._writeMessageJSON(
        testRepeatedScalarDifferentTagSizes
      )
    );
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decodeJSON: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessageJSON(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 2047: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any
  ): TestRepeatedScalarDifferentTagSizes {
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestParsingMerge to JSON.
   */
  encodeJSON: function (testParsingMerge: Partial<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMerge._writeMessageJSON(testParsingMerge));
  },

  /**
   * Deserializes a TestParsingMerge from JSON.
   */
  decodeJSON: function (json: string): TestParsingMerge {
    return TestParsingMerge._readMessageJSON(
      TestParsingMerge.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestParsingMerge>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const requiredAllTypes = TestAllTypes._writeMessageJSON(
        msg.requiredAllTypes
      );
      if (Object.keys(requiredAllTypes).length > 0) {
        json.requiredAllTypes = requiredAllTypes;
      }
    }
    if (msg.optionalAllTypes) {
      const optionalAllTypes = TestAllTypes._writeMessageJSON(
        msg.optionalAllTypes
      );
      if (Object.keys(optionalAllTypes).length > 0) {
        json.optionalAllTypes = optionalAllTypes;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json.repeatedAllTypes = msg.repeatedAllTypes.map(
        TestAllTypes._writeMessageJSON
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestParsingMerge,
    json: any
  ): TestParsingMerge {
    const requiredAllTypes = json.requiredAllTypes ?? json.required_all_types;
    if (requiredAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, requiredAllTypes);
      msg.requiredAllTypes = m;
    }
    const optionalAllTypes = json.optionalAllTypes ?? json.optional_all_types;
    if (optionalAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, optionalAllTypes);
      msg.optionalAllTypes = m;
    }
    const repeatedAllTypes = json.repeatedAllTypes ?? json.repeated_all_types;
    if (repeatedAllTypes) {
      for (const item of repeatedAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encodeJSON: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedFieldsGenerator._writeMessageJSON(
          repeatedFieldsGenerator
        )
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decodeJSON: function (
      json: string
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessageJSON(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json.field1 = msg.field1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field2?.length) {
        json.field2 = msg.field2.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.field3?.length) {
        json.field3 = msg.field3.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext1?.length) {
        json.ext1 = msg.ext1.map(TestAllTypes._writeMessageJSON);
      }
      if (msg.ext2?.length) {
        json.ext2 = msg.ext2.map(TestAllTypes._writeMessageJSON);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const field1 = json.field1 ?? json.field1;
      if (field1) {
        for (const item of field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field1.push(m);
        }
      }
      const field2 = json.field2 ?? json.field2;
      if (field2) {
        for (const item of field2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field2.push(m);
        }
      }
      const field3 = json.field3 ?? json.field3;
      if (field3) {
        for (const item of field3) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.field3.push(m);
        }
      }
      const ext1 = json.ext1 ?? json.ext1;
      if (ext1) {
        for (const item of ext1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext1.push(m);
        }
      }
      const ext2 = json.ext2 ?? json.ext2;
      if (ext2) {
        for (const item of ext2) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encodeJSON: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessageJSON(
            group1
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encodeJSON: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): string {
        return JSON.stringify(
          TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessageJSON(
            group2
          )
        );
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decodeJSON: function (
        json: string
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessageJSON(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _writeMessageJSON: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const field1 = TestAllTypes._writeMessageJSON(msg.field1);
          if (Object.keys(field1).length > 0) {
            json.field1 = field1;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },

      /**
       * @private
       */
      _readMessageJSON: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const field1 = json.field1 ?? json.field1;
        if (field1) {
          const m = TestAllTypes.initialize();
          TestAllTypes._readMessageJSON(m, field1);
          msg.field1 = m;
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessageJSON(
        TestParsingMerge.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const optionalGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.optionalGroupAllTypes
        );
        if (Object.keys(optionalGroupAllTypes).length > 0) {
          json.optionalGroupAllTypes = optionalGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any
    ): TestParsingMerge.OptionalGroup {
      const optionalGroupAllTypes =
        json.optionalGroupAllTypes ?? json.optional_group_all_types;
      if (optionalGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, optionalGroupAllTypes);
        msg.optionalGroupAllTypes = m;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestParsingMerge.RepeatedGroup to JSON.
     */
    encodeJSON: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): string {
      return JSON.stringify(
        TestParsingMerge.RepeatedGroup._writeMessageJSON(repeatedGroup)
      );
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from JSON.
     */
    decodeJSON: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessageJSON(
        TestParsingMerge.RepeatedGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const repeatedGroupAllTypes = TestAllTypes._writeMessageJSON(
          msg.repeatedGroupAllTypes
        );
        if (Object.keys(repeatedGroupAllTypes).length > 0) {
          json.repeatedGroupAllTypes = repeatedGroupAllTypes;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any
    ): TestParsingMerge.RepeatedGroup {
      const repeatedGroupAllTypes =
        json.repeatedGroupAllTypes ?? json.repeated_group_all_types;
      if (repeatedGroupAllTypes) {
        const m = TestAllTypes.initialize();
        TestAllTypes._readMessageJSON(m, repeatedGroupAllTypes);
        msg.repeatedGroupAllTypes = m;
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestCommentInjectionMessage to JSON.
   */
  encodeJSON: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): string {
    return JSON.stringify(
      TestCommentInjectionMessage._writeMessageJSON(testCommentInjectionMessage)
    );
  },

  /**
   * Deserializes a TestCommentInjectionMessage from JSON.
   */
  decodeJSON: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessageJSON(
      TestCommentInjectionMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestCommentInjectionMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json.a = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestCommentInjectionMessage,
    json: any
  ): TestCommentInjectionMessage {
    const a = json.a ?? json.a;
    if (a) {
      msg.a = a;
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Serializes a FooRequest to JSON.
   */

  encodeJSON: function (_fooRequest?: Partial<FooRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooRequest from JSON.
   */

  decodeJSON: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FooRequest, json: any): FooRequest {
    return msg;
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Serializes a FooResponse to JSON.
   */

  encodeJSON: function (_fooResponse?: Partial<FooResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooResponse from JSON.
   */

  decodeJSON: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: FooResponse, json: any): FooResponse {
    return msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Serializes a FooClientMessage to JSON.
   */

  encodeJSON: function (_fooClientMessage?: Partial<FooClientMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooClientMessage from JSON.
   */

  decodeJSON: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: FooClientMessage,
    json: any
  ): FooClientMessage {
    return msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Serializes a FooServerMessage to JSON.
   */

  encodeJSON: function (_fooServerMessage?: Partial<FooServerMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a FooServerMessage from JSON.
   */

  decodeJSON: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: FooServerMessage,
    json: any
  ): FooServerMessage {
    return msg;
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Serializes a BarRequest to JSON.
   */

  encodeJSON: function (_barRequest?: Partial<BarRequest>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarRequest from JSON.
   */

  decodeJSON: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BarRequest, json: any): BarRequest {
    return msg;
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Serializes a BarResponse to JSON.
   */

  encodeJSON: function (_barResponse?: Partial<BarResponse>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a BarResponse from JSON.
   */

  decodeJSON: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: BarResponse, json: any): BarResponse {
    return msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestJsonName to JSON.
   */
  encodeJSON: function (testJsonName: Partial<TestJsonName>): string {
    return JSON.stringify(TestJsonName._writeMessageJSON(testJsonName));
  },

  /**
   * Deserializes a TestJsonName from JSON.
   */
  decodeJSON: function (json: string): TestJsonName {
    return TestJsonName._readMessageJSON(
      TestJsonName.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestJsonName>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json.fieldName1 = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json.fieldName2 = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json.FieldName3 = msg.FieldName3;
    }
    if (msg.FieldName4) {
      json.FieldName4 = msg.FieldName4;
    }
    if (msg.FIELDNAME5) {
      json.FIELDNAME5 = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json[\\"@type\\"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json.fieldname7 = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestJsonName, json: any): TestJsonName {
    const fieldName1 = json.fieldName1 ?? json.field_name1;
    if (fieldName1) {
      msg.fieldName1 = fieldName1;
    }
    const fieldName2 = json.fieldName2 ?? json.fieldName2;
    if (fieldName2) {
      msg.fieldName2 = fieldName2;
    }
    const FieldName3 = json.FieldName3 ?? json.FieldName3;
    if (FieldName3) {
      msg.FieldName3 = FieldName3;
    }
    const FieldName4 = json.FieldName4 ?? json._field_name4;
    if (FieldName4) {
      msg.FieldName4 = FieldName4;
    }
    const FIELDNAME5 = json.FIELDNAME5 ?? json.FIELD_NAME5;
    if (FIELDNAME5) {
      msg.FIELDNAME5 = FIELDNAME5;
    }
    const fieldName6 = json[\\"@type\\"] ?? json.field_name6;
    if (fieldName6) {
      msg.fieldName6 = fieldName6;
    }
    const fieldname7 = json.fieldname7 ?? json.fieldname7;
    if (fieldname7) {
      msg.fieldname7 = fieldname7;
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestHugeFieldNumbers to JSON.
   */
  encodeJSON: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): string {
    return JSON.stringify(
      TestHugeFieldNumbers._writeMessageJSON(testHugeFieldNumbers)
    );
  },

  /**
   * Deserializes a TestHugeFieldNumbers from JSON.
   */
  decodeJSON: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessageJSON(
      TestHugeFieldNumbers.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const [key, value] of Object.entries(msg.stringStringMap)) {
        if (key && value) {
          writer.writeMessage(536870010, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestHugeFieldNumbers>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json.fixed32 = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.optionalEnum) {
      json.optionalEnum = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalMessage) {
      const optionalMessage = ForeignMessage._writeMessageJSON(
        msg.optionalMessage
      );
      if (Object.keys(optionalMessage).length > 0) {
        json.optionalMessage = optionalMessage;
      }
    }
    if (msg.stringStringMap) {
      if (msg.stringStringMap) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.stringStringMap)) {
          if (key && value) {
            map[key] = value;
            json.stringStringMap = map;
          }
        }
      }
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const oneofTestAllTypes = TestAllTypes._writeMessageJSON(
        msg.oneofTestAllTypes
      );
      if (Object.keys(oneofTestAllTypes).length > 0) {
        json.oneofTestAllTypes = oneofTestAllTypes;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestHugeFieldNumbers,
    json: any
  ): TestHugeFieldNumbers {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const fixed32 = json.fixed32 ?? json.fixed_32;
    if (fixed32) {
      msg.fixed32 = fixed32;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const optionalEnum = json.optionalEnum ?? json.optional_enum;
    if (optionalEnum) {
      msg.optionalEnum = optionalEnum;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalMessage = json.optionalMessage ?? json.optional_message;
    if (optionalMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalMessage);
      msg.optionalMessage = m;
    }
    const stringStringMap = json.stringStringMap ?? json.string_string_map;
    if (stringStringMap) {
      for (const [key, value] of Object.entries(stringStringMap)) {
        msg.stringStringMap[key] = value;
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofTestAllTypes =
      json.oneofTestAllTypes ?? json.oneof_test_all_types;
    if (oneofTestAllTypes) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, oneofTestAllTypes);
      msg.oneofTestAllTypes = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encodeJSON: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbers.OptionalGroup._writeMessageJSON(optionalGroup)
      );
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decodeJSON: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessageJSON(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json.groupA = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any
    ): TestHugeFieldNumbers.OptionalGroup {
      const groupA = json.groupA ?? json.group_a;
      if (groupA) {
        msg.groupA = groupA;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionInsideTable to JSON.
   */
  encodeJSON: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): string {
    return JSON.stringify(
      TestExtensionInsideTable._writeMessageJSON(testExtensionInsideTable)
    );
  },

  /**
   * Deserializes a TestExtensionInsideTable from JSON.
   */
  decodeJSON: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessageJSON(
      TestExtensionInsideTable.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionInsideTable>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json.field1 = msg.field1;
    }
    if (msg.field2) {
      json.field2 = msg.field2;
    }
    if (msg.field3) {
      json.field3 = msg.field3;
    }
    if (msg.field4) {
      json.field4 = msg.field4;
    }
    if (msg.field6) {
      json.field6 = msg.field6;
    }
    if (msg.field7) {
      json.field7 = msg.field7;
    }
    if (msg.field8) {
      json.field8 = msg.field8;
    }
    if (msg.field9) {
      json.field9 = msg.field9;
    }
    if (msg.field10) {
      json.field10 = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionInsideTable,
    json: any
  ): TestExtensionInsideTable {
    const field1 = json.field1 ?? json.field1;
    if (field1) {
      msg.field1 = field1;
    }
    const field2 = json.field2 ?? json.field2;
    if (field2) {
      msg.field2 = field2;
    }
    const field3 = json.field3 ?? json.field3;
    if (field3) {
      msg.field3 = field3;
    }
    const field4 = json.field4 ?? json.field4;
    if (field4) {
      msg.field4 = field4;
    }
    const field6 = json.field6 ?? json.field6;
    if (field6) {
      msg.field6 = field6;
    }
    const field7 = json.field7 ?? json.field7;
    if (field7) {
      msg.field7 = field7;
    }
    const field8 = json.field8 ?? json.field8;
    if (field8) {
      msg.field8 = field8;
    }
    const field9 = json.field9 ?? json.field9;
    if (field9) {
      msg.field9 = field9;
    }
    const field10 = json.field10 ?? json.field10;
    if (field10) {
      msg.field10 = field10;
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestExtensionRangeSerialize to JSON.
   */
  encodeJSON: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): string {
    return JSON.stringify(
      TestExtensionRangeSerialize._writeMessageJSON(testExtensionRangeSerialize)
    );
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from JSON.
   */
  decodeJSON: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessageJSON(
      TestExtensionRangeSerialize.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestExtensionRangeSerialize>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json.fooOne = msg.fooOne;
    }
    if (msg.fooTwo) {
      json.fooTwo = msg.fooTwo;
    }
    if (msg.fooThree) {
      json.fooThree = msg.fooThree;
    }
    if (msg.fooFour) {
      json.fooFour = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestExtensionRangeSerialize,
    json: any
  ): TestExtensionRangeSerialize {
    const fooOne = json.fooOne ?? json.foo_one;
    if (fooOne) {
      msg.fooOne = fooOne;
    }
    const fooTwo = json.fooTwo ?? json.foo_two;
    if (fooTwo) {
      msg.fooTwo = fooTwo;
    }
    const fooThree = json.fooThree ?? json.foo_three;
    if (fooThree) {
      msg.fooThree = fooThree;
    }
    const fooFour = json.fooFour ?? json.foo_four;
    if (fooFour) {
      msg.fooFour = fooFour;
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<bigint, bigint | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<bigint, bigint | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<bigint, bigint | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<bigint, bigint | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<bigint, bigint | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
  mapStringForeignMessage: Record<string, ForeignMessage | undefined>;
  mapInt32AllTypes: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<bigint, bigint | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<bigint, bigint | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<bigint, bigint | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<bigint, bigint | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<bigint, bigint | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Serializes a TestMap to JSON.
   */
  encodeJSON: function (testMap: Partial<TestMap>): string {
    return JSON.stringify(TestMap._writeMessageJSON(testMap));
  },

  /**
   * Deserializes a TestMap from JSON.
   */
  decodeJSON: function (json: string): TestMap {
    return TestMap._readMessageJSON(TestMap.initialize(), JSON.parse(json));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key as any);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key as any);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key as any);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key as any);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key as any);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key as any);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key as any);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key as any);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key as any);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key as any);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeEnum(2, value as MapEnum);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapStringForeignMessage)) {
        if (key && value) {
          writer.writeMessage(18, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
        if (key && value) {
          writer.writeMessage(19, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg: Partial<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapStringForeignMessage) {
      if (msg.mapStringForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(
          msg.mapStringForeignMessage
        )) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapStringForeignMessage = map;
          }
        }
      }
    }
    if (msg.mapInt32AllTypes) {
      if (msg.mapInt32AllTypes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32AllTypes)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32AllTypes = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum() as MapEnum;
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMap, json: any): TestMap {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value as string);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value as string);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value as string);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value as string);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value as string);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value as MapEnum;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapStringForeignMessage =
      json.mapStringForeignMessage ?? json.map_string_foreign_message;
    if (mapStringForeignMessage) {
      for (const [key, value] of Object.entries(mapStringForeignMessage)) {
        msg.mapStringForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    const mapInt32AllTypes = json.mapInt32AllTypes ?? json.map_int32_all_types;
    if (mapInt32AllTypes) {
      for (const [key, value] of Object.entries(mapInt32AllTypes)) {
        msg.mapInt32AllTypes[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMapSubmessage to JSON.
   */
  encodeJSON: function (testMapSubmessage: Partial<TestMapSubmessage>): string {
    return JSON.stringify(
      TestMapSubmessage._writeMessageJSON(testMapSubmessage)
    );
  },

  /**
   * Deserializes a TestMapSubmessage from JSON.
   */
  decodeJSON: function (json: string): TestMapSubmessage {
    return TestMapSubmessage._readMessageJSON(
      TestMapSubmessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMapSubmessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const testMap = TestMap._writeMessageJSON(msg.testMap);
      if (Object.keys(testMap).length > 0) {
        json.testMap = testMap;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMapSubmessage,
    json: any
  ): TestMapSubmessage {
    const testMap = json.testMap ?? json.test_map;
    if (testMap) {
      const m = TestMap.initialize();
      TestMap._readMessageJSON(m, testMap);
      msg.testMap = m;
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageMap to JSON.
   */
  encodeJSON: function (testMessageMap: Partial<TestMessageMap>): string {
    return JSON.stringify(TestMessageMap._writeMessageJSON(testMessageMap));
  },

  /**
   * Deserializes a TestMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestMessageMap {
    return TestMessageMap._readMessageJSON(
      TestMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      for (const [key, value] of Object.entries(msg.mapInt32Message)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestAllTypes._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      if (msg.mapInt32Message) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Message)) {
          if (key && value) {
            map[key] = TestAllTypes._writeMessageJSON(value);
            json.mapInt32Message = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestAllTypes.initialize(),
                    TestAllTypes._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestMessageMap, json: any): TestMessageMap {
    const mapInt32Message = json.mapInt32Message ?? json.map_int32_message;
    if (mapInt32Message) {
      for (const [key, value] of Object.entries(mapInt32Message)) {
        msg.mapInt32Message[key] = TestAllTypes._readMessageJSON(
          TestAllTypes.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestSameTypeMap to JSON.
   */
  encodeJSON: function (testSameTypeMap: Partial<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMap._writeMessageJSON(testSameTypeMap));
  },

  /**
   * Deserializes a TestSameTypeMap from JSON.
   */
  decodeJSON: function (json: string): TestSameTypeMap {
    return TestSameTypeMap._readMessageJSON(
      TestSameTypeMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const [key, value] of Object.entries(msg.map1)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.map2) {
      for (const [key, value] of Object.entries(msg.map2)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestSameTypeMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      if (msg.map1) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.map1)) {
          if (key && value) {
            map[key] = value;
            json.map1 = map;
          }
        }
      }
    }
    if (msg.map2) {
      if (msg.map2) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.map2)) {
          if (key && value) {
            map[key] = value;
            json.map2 = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestSameTypeMap,
    json: any
  ): TestSameTypeMap {
    const map1 = json.map1 ?? json.map1;
    if (map1) {
      for (const [key, value] of Object.entries(map1)) {
        msg.map1[key] = value;
      }
    }
    const map2 = json.map2 ?? json.map2;
    if (map2) {
      for (const [key, value] of Object.entries(map2)) {
        msg.map2[key] = value;
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRequiredMessageMap to JSON.
   */
  encodeJSON: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): string {
    return JSON.stringify(
      TestRequiredMessageMap._writeMessageJSON(testRequiredMessageMap)
    );
  },

  /**
   * Deserializes a TestRequiredMessageMap from JSON.
   */
  decodeJSON: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessageJSON(
      TestRequiredMessageMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      for (const [key, value] of Object.entries(msg.mapField)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, TestRequired._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRequiredMessageMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      if (msg.mapField) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapField)) {
          if (key && value) {
            map[key] = TestRequired._writeMessageJSON(value);
            json.mapField = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRequired.initialize(),
                    TestRequired._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRequiredMessageMap,
    json: any
  ): TestRequiredMessageMap {
    const mapField = json.mapField ?? json.map_field;
    if (mapField) {
      for (const [key, value] of Object.entries(mapField)) {
        msg.mapField[key] = TestRequired._readMessageJSON(
          TestRequired.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestArenaMap to JSON.
   */
  encodeJSON: function (testArenaMap: Partial<TestArenaMap>): string {
    return JSON.stringify(TestArenaMap._writeMessageJSON(testArenaMap));
  },

  /**
   * Deserializes a TestArenaMap from JSON.
   */
  decodeJSON: function (json: string): TestArenaMap {
    return TestArenaMap._readMessageJSON(
      TestArenaMap.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    if (msg.mapInt64Int64) {
      for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
        if (key && value) {
          writer.writeMessage(2, {}, (_, mapWriter) => {
            mapWriter.writeInt64String(1, key as any);
            mapWriter.writeInt64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapUint32Uint32) {
      for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
        if (key && value) {
          writer.writeMessage(3, {}, (_, mapWriter) => {
            mapWriter.writeUint32(1, key as any);
            mapWriter.writeUint32(2, value);
          });
        }
      }
    }
    if (msg.mapUint64Uint64) {
      for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
        if (key && value) {
          writer.writeMessage(4, {}, (_, mapWriter) => {
            mapWriter.writeUint64String(1, key as any);
            mapWriter.writeUint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSint32Sint32) {
      for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
        if (key && value) {
          writer.writeMessage(5, {}, (_, mapWriter) => {
            mapWriter.writeSint32(1, key as any);
            mapWriter.writeSint32(2, value);
          });
        }
      }
    }
    if (msg.mapSint64Sint64) {
      for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
        if (key && value) {
          writer.writeMessage(6, {}, (_, mapWriter) => {
            mapWriter.writeSint64String(1, key as any);
            mapWriter.writeSint64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
        if (key && value) {
          writer.writeMessage(7, {}, (_, mapWriter) => {
            mapWriter.writeFixed32(1, key as any);
            mapWriter.writeFixed32(2, value);
          });
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
        if (key && value) {
          writer.writeMessage(8, {}, (_, mapWriter) => {
            mapWriter.writeFixed64String(1, key as any);
            mapWriter.writeFixed64String(2, value.toString());
          });
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
        if (key && value) {
          writer.writeMessage(9, {}, (_, mapWriter) => {
            mapWriter.writeSfixed32(1, key as any);
            mapWriter.writeSfixed32(2, value);
          });
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
        if (key && value) {
          writer.writeMessage(10, {}, (_, mapWriter) => {
            mapWriter.writeSfixed64(1, key as any);
            mapWriter.writeSfixed64(2, value.toString());
          });
        }
      }
    }
    if (msg.mapInt32Float) {
      for (const [key, value] of Object.entries(msg.mapInt32Float)) {
        if (key && value) {
          writer.writeMessage(11, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeFloat(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Double) {
      for (const [key, value] of Object.entries(msg.mapInt32Double)) {
        if (key && value) {
          writer.writeMessage(12, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeDouble(2, value);
          });
        }
      }
    }
    if (msg.mapBoolBool) {
      for (const [key, value] of Object.entries(msg.mapBoolBool)) {
        if (key && value) {
          writer.writeMessage(13, {}, (_, mapWriter) => {
            mapWriter.writeBool(1, key as any);
            mapWriter.writeBool(2, value);
          });
        }
      }
    }
    if (msg.mapStringString) {
      for (const [key, value] of Object.entries(msg.mapStringString)) {
        if (key && value) {
          writer.writeMessage(14, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeString(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Bytes) {
      for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
        if (key && value) {
          writer.writeMessage(15, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeBytes(2, value);
          });
        }
      }
    }
    if (msg.mapInt32Enum) {
      for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
        if (key && value) {
          writer.writeMessage(16, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeEnum(2, value as MapEnum);
          });
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
        if (key && value) {
          writer.writeMessage(17, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeMessage(2, value, ForeignMessage._writeMessage);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestArenaMap>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      if (msg.mapInt32Int32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Int32)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Int32 = map;
          }
        }
      }
    }
    if (msg.mapInt64Int64) {
      if (msg.mapInt64Int64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt64Int64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapInt64Int64 = map;
          }
        }
      }
    }
    if (msg.mapUint32Uint32) {
      if (msg.mapUint32Uint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint32Uint32)) {
          if (key && value) {
            map[key] = value;
            json.mapUint32Uint32 = map;
          }
        }
      }
    }
    if (msg.mapUint64Uint64) {
      if (msg.mapUint64Uint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapUint64Uint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapUint64Uint64 = map;
          }
        }
      }
    }
    if (msg.mapSint32Sint32) {
      if (msg.mapSint32Sint32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint32Sint32)) {
          if (key && value) {
            map[key] = value;
            json.mapSint32Sint32 = map;
          }
        }
      }
    }
    if (msg.mapSint64Sint64) {
      if (msg.mapSint64Sint64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSint64Sint64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSint64Sint64 = map;
          }
        }
      }
    }
    if (msg.mapFixed32Fixed32) {
      if (msg.mapFixed32Fixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed32Fixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapFixed32Fixed32 = map;
          }
        }
      }
    }
    if (msg.mapFixed64Fixed64) {
      if (msg.mapFixed64Fixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapFixed64Fixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapFixed64Fixed64 = map;
          }
        }
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      if (msg.mapSfixed32Sfixed32) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed32Sfixed32)) {
          if (key && value) {
            map[key] = value;
            json.mapSfixed32Sfixed32 = map;
          }
        }
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      if (msg.mapSfixed64Sfixed64) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapSfixed64Sfixed64)) {
          if (key && value) {
            map[key] = value.toString();
            json.mapSfixed64Sfixed64 = map;
          }
        }
      }
    }
    if (msg.mapInt32Float) {
      if (msg.mapInt32Float) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Float)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Float = map;
          }
        }
      }
    }
    if (msg.mapInt32Double) {
      if (msg.mapInt32Double) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Double)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Double = map;
          }
        }
      }
    }
    if (msg.mapBoolBool) {
      if (msg.mapBoolBool) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapBoolBool)) {
          if (key && value) {
            map[key] = value;
            json.mapBoolBool = map;
          }
        }
      }
    }
    if (msg.mapStringString) {
      if (msg.mapStringString) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapStringString)) {
          if (key && value) {
            map[key] = value;
            json.mapStringString = map;
          }
        }
      }
    }
    if (msg.mapInt32Bytes) {
      if (msg.mapInt32Bytes) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Bytes)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Bytes = map;
          }
        }
      }
    }
    if (msg.mapInt32Enum) {
      if (msg.mapInt32Enum) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32Enum)) {
          if (key && value) {
            map[key] = value;
            json.mapInt32Enum = map;
          }
        }
      }
    }
    if (msg.mapInt32ForeignMessage) {
      if (msg.mapInt32ForeignMessage) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.mapInt32ForeignMessage)) {
          if (key && value) {
            map[key] = ForeignMessage._writeMessageJSON(value);
            json.mapInt32ForeignMessage = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readInt64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readUint64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSint64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readFixed64String());
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: bigint | undefined;
            let value = 0n;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = BigInt(reader.readSfixed64());
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum() as MapEnum;
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    ForeignMessage.initialize(),
                    ForeignMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestArenaMap, json: any): TestArenaMap {
    const mapInt32Int32 = json.mapInt32Int32 ?? json.map_int32_int32;
    if (mapInt32Int32) {
      for (const [key, value] of Object.entries(mapInt32Int32)) {
        msg.mapInt32Int32[key] = value;
      }
    }
    const mapInt64Int64 = json.mapInt64Int64 ?? json.map_int64_int64;
    if (mapInt64Int64) {
      for (const [key, value] of Object.entries(mapInt64Int64)) {
        msg.mapInt64Int64[key] = BigInt(value as string);
      }
    }
    const mapUint32Uint32 = json.mapUint32Uint32 ?? json.map_uint32_uint32;
    if (mapUint32Uint32) {
      for (const [key, value] of Object.entries(mapUint32Uint32)) {
        msg.mapUint32Uint32[key] = value;
      }
    }
    const mapUint64Uint64 = json.mapUint64Uint64 ?? json.map_uint64_uint64;
    if (mapUint64Uint64) {
      for (const [key, value] of Object.entries(mapUint64Uint64)) {
        msg.mapUint64Uint64[key] = BigInt(value as string);
      }
    }
    const mapSint32Sint32 = json.mapSint32Sint32 ?? json.map_sint32_sint32;
    if (mapSint32Sint32) {
      for (const [key, value] of Object.entries(mapSint32Sint32)) {
        msg.mapSint32Sint32[key] = value;
      }
    }
    const mapSint64Sint64 = json.mapSint64Sint64 ?? json.map_sint64_sint64;
    if (mapSint64Sint64) {
      for (const [key, value] of Object.entries(mapSint64Sint64)) {
        msg.mapSint64Sint64[key] = BigInt(value as string);
      }
    }
    const mapFixed32Fixed32 =
      json.mapFixed32Fixed32 ?? json.map_fixed32_fixed32;
    if (mapFixed32Fixed32) {
      for (const [key, value] of Object.entries(mapFixed32Fixed32)) {
        msg.mapFixed32Fixed32[key] = value;
      }
    }
    const mapFixed64Fixed64 =
      json.mapFixed64Fixed64 ?? json.map_fixed64_fixed64;
    if (mapFixed64Fixed64) {
      for (const [key, value] of Object.entries(mapFixed64Fixed64)) {
        msg.mapFixed64Fixed64[key] = BigInt(value as string);
      }
    }
    const mapSfixed32Sfixed32 =
      json.mapSfixed32Sfixed32 ?? json.map_sfixed32_sfixed32;
    if (mapSfixed32Sfixed32) {
      for (const [key, value] of Object.entries(mapSfixed32Sfixed32)) {
        msg.mapSfixed32Sfixed32[key] = value;
      }
    }
    const mapSfixed64Sfixed64 =
      json.mapSfixed64Sfixed64 ?? json.map_sfixed64_sfixed64;
    if (mapSfixed64Sfixed64) {
      for (const [key, value] of Object.entries(mapSfixed64Sfixed64)) {
        msg.mapSfixed64Sfixed64[key] = BigInt(value as string);
      }
    }
    const mapInt32Float = json.mapInt32Float ?? json.map_int32_float;
    if (mapInt32Float) {
      for (const [key, value] of Object.entries(mapInt32Float)) {
        msg.mapInt32Float[key] = value;
      }
    }
    const mapInt32Double = json.mapInt32Double ?? json.map_int32_double;
    if (mapInt32Double) {
      for (const [key, value] of Object.entries(mapInt32Double)) {
        msg.mapInt32Double[key] = value;
      }
    }
    const mapBoolBool = json.mapBoolBool ?? json.map_bool_bool;
    if (mapBoolBool) {
      for (const [key, value] of Object.entries(mapBoolBool)) {
        msg.mapBoolBool[key] = value;
      }
    }
    const mapStringString = json.mapStringString ?? json.map_string_string;
    if (mapStringString) {
      for (const [key, value] of Object.entries(mapStringString)) {
        msg.mapStringString[key] = value;
      }
    }
    const mapInt32Bytes = json.mapInt32Bytes ?? json.map_int32_bytes;
    if (mapInt32Bytes) {
      for (const [key, value] of Object.entries(mapInt32Bytes)) {
        msg.mapInt32Bytes[key] = value;
      }
    }
    const mapInt32Enum = json.mapInt32Enum ?? json.map_int32_enum;
    if (mapInt32Enum) {
      for (const [key, value] of Object.entries(mapInt32Enum)) {
        msg.mapInt32Enum[key] = value as MapEnum;
      }
    }
    const mapInt32ForeignMessage =
      json.mapInt32ForeignMessage ?? json.map_int32_foreign_message;
    if (mapInt32ForeignMessage) {
      for (const [key, value] of Object.entries(mapInt32ForeignMessage)) {
        msg.mapInt32ForeignMessage[key] = ForeignMessage._readMessageJSON(
          ForeignMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a MessageContainingMapCalledEntry to JSON.
   */
  encodeJSON: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): string {
    return JSON.stringify(
      MessageContainingMapCalledEntry._writeMessageJSON(
        messageContainingMapCalledEntry
      )
    );
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from JSON.
   */
  decodeJSON: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessageJSON(
      MessageContainingMapCalledEntry.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const [key, value] of Object.entries(msg.entry)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeInt32(1, key as any);
            mapWriter.writeInt32(2, value);
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<MessageContainingMapCalledEntry>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      if (msg.entry) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.entry)) {
          if (key && value) {
            map[key] = value;
            json.entry = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: MessageContainingMapCalledEntry,
    json: any
  ): MessageContainingMapCalledEntry {
    const entry = json.entry ?? json.entry;
    if (entry) {
      for (const [key, value] of Object.entries(entry)) {
        msg.entry[key] = value;
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestRecursiveMapMessage to JSON.
   */
  encodeJSON: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): string {
    return JSON.stringify(
      TestRecursiveMapMessage._writeMessageJSON(testRecursiveMapMessage)
    );
  },

  /**
   * Deserializes a TestRecursiveMapMessage from JSON.
   */
  decodeJSON: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessageJSON(
      TestRecursiveMapMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const [key, value] of Object.entries(msg.a)) {
        if (key && value) {
          writer.writeMessage(1, {}, (_, mapWriter) => {
            mapWriter.writeString(1, key as any);
            mapWriter.writeMessage(
              2,
              value,
              TestRecursiveMapMessage._writeMessage
            );
          });
        }
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestRecursiveMapMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      if (msg.a) {
        const map: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(msg.a)) {
          if (key && value) {
            map[key] = TestRecursiveMapMessage._writeMessageJSON(value);
            json.a = map;
          }
        }
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  reader.readMessage(
                    TestRecursiveMapMessage.initialize(),
                    TestRecursiveMapMessage._readMessage
                  );
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestRecursiveMapMessage,
    json: any
  ): TestRecursiveMapMessage {
    const a = json.a ?? json.a;
    if (a) {
      for (const [key, value] of Object.entries(a)) {
        msg.a[key] = TestRecursiveMapMessage._readMessageJSON(
          TestRecursiveMapMessage.initialize(),
          value
        );
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestAllTypes to JSON.
   */
  encodeJSON: function (testAllTypes: Partial<TestAllTypes>): string {
    return JSON.stringify(TestAllTypes._writeMessageJSON(testAllTypes));
  },

  /**
   * Deserializes a TestAllTypes from JSON.
   */
  decodeJSON: function (json: string): TestAllTypes {
    return TestAllTypes._readMessageJSON(
      TestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json.optionalInt32 = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json.optionalInt64 = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json.optionalUint32 = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json.optionalUint64 = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json.optionalSint32 = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json.optionalSint64 = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json.optionalFixed32 = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json.optionalFixed64 = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json.optionalSfixed32 = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json.optionalSfixed64 = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json.optionalFloat = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json.optionalDouble = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json.optionalBool = msg.optionalBool;
    }
    if (msg.optionalString) {
      json.optionalString = msg.optionalString;
    }
    if (msg.optionalBytes) {
      json.optionalBytes = msg.optionalBytes;
    }
    if (msg.optionalNestedMessage) {
      const optionalNestedMessage =
        TestAllTypes.NestedMessage._writeMessageJSON(msg.optionalNestedMessage);
      if (Object.keys(optionalNestedMessage).length > 0) {
        json.optionalNestedMessage = optionalNestedMessage;
      }
    }
    if (msg.optionalForeignMessage) {
      const optionalForeignMessage = ForeignMessage._writeMessageJSON(
        msg.optionalForeignMessage
      );
      if (Object.keys(optionalForeignMessage).length > 0) {
        json.optionalForeignMessage = optionalForeignMessage;
      }
    }
    if (msg.optionalImportMessage) {
      const optionalImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalImportMessage
      );
      if (Object.keys(optionalImportMessage).length > 0) {
        json.optionalImportMessage = optionalImportMessage;
      }
    }
    if (msg.optionalNestedEnum) {
      json.optionalNestedEnum = msg.optionalNestedEnum;
    }
    if (msg.optionalForeignEnum) {
      json.optionalForeignEnum = msg.optionalForeignEnum;
    }
    if (msg.optionalStringPiece) {
      json.optionalStringPiece = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json.optionalCord = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const optionalPublicImportMessage = PublicImportMessage._writeMessageJSON(
        msg.optionalPublicImportMessage
      );
      if (Object.keys(optionalPublicImportMessage).length > 0) {
        json.optionalPublicImportMessage = optionalPublicImportMessage;
      }
    }
    if (msg.optionalLazyMessage) {
      const optionalLazyMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.optionalLazyMessage
      );
      if (Object.keys(optionalLazyMessage).length > 0) {
        json.optionalLazyMessage = optionalLazyMessage;
      }
    }
    if (msg.optionalLazyImportMessage) {
      const optionalLazyImportMessage = ImportMessage._writeMessageJSON(
        msg.optionalLazyImportMessage
      );
      if (Object.keys(optionalLazyImportMessage).length > 0) {
        json.optionalLazyImportMessage = optionalLazyImportMessage;
      }
    }
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json.repeatedString = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json.repeatedBytes = msg.repeatedBytes;
    }
    if (msg.repeatedNestedMessage?.length) {
      json.repeatedNestedMessage = msg.repeatedNestedMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json.repeatedForeignMessage = msg.repeatedForeignMessage.map(
        ForeignMessage._writeMessageJSON
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json.repeatedImportMessage = msg.repeatedImportMessage.map(
        ImportMessage._writeMessageJSON
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json.repeatedForeignEnum = msg.repeatedForeignEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json.repeatedStringPiece = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json.repeatedCord = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json.repeatedLazyMessage = msg.repeatedLazyMessage.map(
        TestAllTypes.NestedMessage._writeMessageJSON
      );
    }
    if (msg.oneofUint32 != undefined) {
      json.oneofUint32 = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const oneofNestedMessage = TestAllTypes.NestedMessage._writeMessageJSON(
        msg.oneofNestedMessage
      );
      if (Object.keys(oneofNestedMessage).length > 0) {
        json.oneofNestedMessage = oneofNestedMessage;
      }
    }
    if (msg.oneofString != undefined) {
      json.oneofString = msg.oneofString;
    }
    if (msg.oneofBytes != undefined) {
      json.oneofBytes = msg.oneofBytes;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestAllTypes, json: any): TestAllTypes {
    const optionalInt32 = json.optionalInt32 ?? json.optional_int32;
    if (optionalInt32) {
      msg.optionalInt32 = optionalInt32;
    }
    const optionalInt64 = json.optionalInt64 ?? json.optional_int64;
    if (optionalInt64) {
      msg.optionalInt64 = BigInt(optionalInt64);
    }
    const optionalUint32 = json.optionalUint32 ?? json.optional_uint32;
    if (optionalUint32) {
      msg.optionalUint32 = optionalUint32;
    }
    const optionalUint64 = json.optionalUint64 ?? json.optional_uint64;
    if (optionalUint64) {
      msg.optionalUint64 = BigInt(optionalUint64);
    }
    const optionalSint32 = json.optionalSint32 ?? json.optional_sint32;
    if (optionalSint32) {
      msg.optionalSint32 = optionalSint32;
    }
    const optionalSint64 = json.optionalSint64 ?? json.optional_sint64;
    if (optionalSint64) {
      msg.optionalSint64 = BigInt(optionalSint64);
    }
    const optionalFixed32 = json.optionalFixed32 ?? json.optional_fixed32;
    if (optionalFixed32) {
      msg.optionalFixed32 = optionalFixed32;
    }
    const optionalFixed64 = json.optionalFixed64 ?? json.optional_fixed64;
    if (optionalFixed64) {
      msg.optionalFixed64 = BigInt(optionalFixed64);
    }
    const optionalSfixed32 = json.optionalSfixed32 ?? json.optional_sfixed32;
    if (optionalSfixed32) {
      msg.optionalSfixed32 = optionalSfixed32;
    }
    const optionalSfixed64 = json.optionalSfixed64 ?? json.optional_sfixed64;
    if (optionalSfixed64) {
      msg.optionalSfixed64 = BigInt(optionalSfixed64);
    }
    const optionalFloat = json.optionalFloat ?? json.optional_float;
    if (optionalFloat) {
      msg.optionalFloat = optionalFloat;
    }
    const optionalDouble = json.optionalDouble ?? json.optional_double;
    if (optionalDouble) {
      msg.optionalDouble = optionalDouble;
    }
    const optionalBool = json.optionalBool ?? json.optional_bool;
    if (optionalBool) {
      msg.optionalBool = optionalBool;
    }
    const optionalString = json.optionalString ?? json.optional_string;
    if (optionalString) {
      msg.optionalString = optionalString;
    }
    const optionalBytes = json.optionalBytes ?? json.optional_bytes;
    if (optionalBytes) {
      msg.optionalBytes = optionalBytes;
    }
    const optionalNestedMessage =
      json.optionalNestedMessage ?? json.optional_nested_message;
    if (optionalNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalNestedMessage);
      msg.optionalNestedMessage = m;
    }
    const optionalForeignMessage =
      json.optionalForeignMessage ?? json.optional_foreign_message;
    if (optionalForeignMessage) {
      const m = ForeignMessage.initialize();
      ForeignMessage._readMessageJSON(m, optionalForeignMessage);
      msg.optionalForeignMessage = m;
    }
    const optionalImportMessage =
      json.optionalImportMessage ?? json.optional_import_message;
    if (optionalImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalImportMessage);
      msg.optionalImportMessage = m;
    }
    const optionalNestedEnum =
      json.optionalNestedEnum ?? json.optional_nested_enum;
    if (optionalNestedEnum) {
      msg.optionalNestedEnum = optionalNestedEnum;
    }
    const optionalForeignEnum =
      json.optionalForeignEnum ?? json.optional_foreign_enum;
    if (optionalForeignEnum) {
      msg.optionalForeignEnum = optionalForeignEnum;
    }
    const optionalStringPiece =
      json.optionalStringPiece ?? json.optional_string_piece;
    if (optionalStringPiece) {
      msg.optionalStringPiece = optionalStringPiece;
    }
    const optionalCord = json.optionalCord ?? json.optional_cord;
    if (optionalCord) {
      msg.optionalCord = optionalCord;
    }
    const optionalPublicImportMessage =
      json.optionalPublicImportMessage ?? json.optional_public_import_message;
    if (optionalPublicImportMessage) {
      const m = PublicImportMessage.initialize();
      PublicImportMessage._readMessageJSON(m, optionalPublicImportMessage);
      msg.optionalPublicImportMessage = m;
    }
    const optionalLazyMessage =
      json.optionalLazyMessage ?? json.optional_lazy_message;
    if (optionalLazyMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, optionalLazyMessage);
      msg.optionalLazyMessage = m;
    }
    const optionalLazyImportMessage =
      json.optionalLazyImportMessage ?? json.optional_lazy_import_message;
    if (optionalLazyImportMessage) {
      const m = ImportMessage.initialize();
      ImportMessage._readMessageJSON(m, optionalLazyImportMessage);
      msg.optionalLazyImportMessage = m;
    }
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedString = json.repeatedString ?? json.repeated_string;
    if (repeatedString) {
      msg.repeatedString = repeatedString;
    }
    const repeatedBytes = json.repeatedBytes ?? json.repeated_bytes;
    if (repeatedBytes) {
      msg.repeatedBytes = repeatedBytes;
    }
    const repeatedNestedMessage =
      json.repeatedNestedMessage ?? json.repeated_nested_message;
    if (repeatedNestedMessage) {
      for (const item of repeatedNestedMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const repeatedForeignMessage =
      json.repeatedForeignMessage ?? json.repeated_foreign_message;
    if (repeatedForeignMessage) {
      for (const item of repeatedForeignMessage) {
        const m = ForeignMessage.initialize();
        ForeignMessage._readMessageJSON(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const repeatedImportMessage =
      json.repeatedImportMessage ?? json.repeated_import_message;
    if (repeatedImportMessage) {
      for (const item of repeatedImportMessage) {
        const m = ImportMessage.initialize();
        ImportMessage._readMessageJSON(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    const repeatedForeignEnum =
      json.repeatedForeignEnum ?? json.repeated_foreign_enum;
    if (repeatedForeignEnum) {
      msg.repeatedForeignEnum = repeatedForeignEnum;
    }
    const repeatedStringPiece =
      json.repeatedStringPiece ?? json.repeated_string_piece;
    if (repeatedStringPiece) {
      msg.repeatedStringPiece = repeatedStringPiece;
    }
    const repeatedCord = json.repeatedCord ?? json.repeated_cord;
    if (repeatedCord) {
      msg.repeatedCord = repeatedCord;
    }
    const repeatedLazyMessage =
      json.repeatedLazyMessage ?? json.repeated_lazy_message;
    if (repeatedLazyMessage) {
      for (const item of repeatedLazyMessage) {
        const m = TestAllTypes.NestedMessage.initialize();
        TestAllTypes.NestedMessage._readMessageJSON(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const oneofUint32 = json.oneofUint32 ?? json.oneof_uint32;
    if (oneofUint32) {
      msg.oneofUint32 = oneofUint32;
    }
    const oneofNestedMessage =
      json.oneofNestedMessage ?? json.oneof_nested_message;
    if (oneofNestedMessage) {
      const m = TestAllTypes.NestedMessage.initialize();
      TestAllTypes.NestedMessage._readMessageJSON(m, oneofNestedMessage);
      msg.oneofNestedMessage = m;
    }
    const oneofString = json.oneofString ?? json.oneof_string;
    if (oneofString) {
      msg.oneofString = oneofString;
    }
    const oneofBytes = json.oneofBytes ?? json.oneof_bytes;
    if (oneofBytes) {
      msg.oneofBytes = oneofBytes;
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Serializes a TestAllTypes.NestedMessage to JSON.
     */
    encodeJSON: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): string {
      return JSON.stringify(
        TestAllTypes.NestedMessage._writeMessageJSON(nestedMessage)
      );
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from JSON.
     */
    decodeJSON: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessageJSON(
        TestAllTypes.NestedMessage.initialize(),
        JSON.parse(json)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (
      msg: Partial<TestAllTypes.NestedMessage>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json.bb = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (
      msg: TestAllTypes.NestedMessage,
      json: any
    ): TestAllTypes.NestedMessage {
      const bb = json.bb ?? json.bb;
      if (bb) {
        msg.bb = bb;
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestPackedTypes to JSON.
   */
  encodeJSON: function (testPackedTypes: Partial<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypes._writeMessageJSON(testPackedTypes));
  },

  /**
   * Deserializes a TestPackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestPackedTypes {
    return TestPackedTypes._readMessageJSON(
      TestPackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64.toString());
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64.toString());
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64.toString());
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64.toString());
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64.toString());
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestPackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json.packedInt32 = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json.packedInt64 = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json.packedUint32 = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json.packedUint64 = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json.packedSint32 = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json.packedSint64 = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json.packedFixed32 = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json.packedFixed64 = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json.packedSfixed32 = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json.packedSfixed64 = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json.packedFloat = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json.packedDouble = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json.packedBool = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json.packedEnum = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestPackedTypes,
    json: any
  ): TestPackedTypes {
    const packedInt32 = json.packedInt32 ?? json.packed_int32;
    if (packedInt32) {
      msg.packedInt32 = packedInt32;
    }
    const packedInt64 = json.packedInt64 ?? json.packed_int64;
    if (packedInt64) {
      msg.packedInt64 = packedInt64.map(BigInt);
    }
    const packedUint32 = json.packedUint32 ?? json.packed_uint32;
    if (packedUint32) {
      msg.packedUint32 = packedUint32;
    }
    const packedUint64 = json.packedUint64 ?? json.packed_uint64;
    if (packedUint64) {
      msg.packedUint64 = packedUint64.map(BigInt);
    }
    const packedSint32 = json.packedSint32 ?? json.packed_sint32;
    if (packedSint32) {
      msg.packedSint32 = packedSint32;
    }
    const packedSint64 = json.packedSint64 ?? json.packed_sint64;
    if (packedSint64) {
      msg.packedSint64 = packedSint64.map(BigInt);
    }
    const packedFixed32 = json.packedFixed32 ?? json.packed_fixed32;
    if (packedFixed32) {
      msg.packedFixed32 = packedFixed32;
    }
    const packedFixed64 = json.packedFixed64 ?? json.packed_fixed64;
    if (packedFixed64) {
      msg.packedFixed64 = packedFixed64.map(BigInt);
    }
    const packedSfixed32 = json.packedSfixed32 ?? json.packed_sfixed32;
    if (packedSfixed32) {
      msg.packedSfixed32 = packedSfixed32;
    }
    const packedSfixed64 = json.packedSfixed64 ?? json.packed_sfixed64;
    if (packedSfixed64) {
      msg.packedSfixed64 = packedSfixed64.map(BigInt);
    }
    const packedFloat = json.packedFloat ?? json.packed_float;
    if (packedFloat) {
      msg.packedFloat = packedFloat;
    }
    const packedDouble = json.packedDouble ?? json.packed_double;
    if (packedDouble) {
      msg.packedDouble = packedDouble;
    }
    const packedBool = json.packedBool ?? json.packed_bool;
    if (packedBool) {
      msg.packedBool = packedBool;
    }
    const packedEnum = json.packedEnum ?? json.packed_enum;
    if (packedEnum) {
      msg.packedEnum = packedEnum;
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestUnpackedTypes to JSON.
   */
  encodeJSON: function (testUnpackedTypes: Partial<TestUnpackedTypes>): string {
    return JSON.stringify(
      TestUnpackedTypes._writeMessageJSON(testUnpackedTypes)
    );
  },

  /**
   * Deserializes a TestUnpackedTypes from JSON.
   */
  decodeJSON: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypes._readMessageJSON(
      TestUnpackedTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64.toString());
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64.toString());
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64.toString());
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64.toString());
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestUnpackedTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedInt32?.length) {
      json.repeatedInt32 = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json.repeatedInt64 = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json.repeatedUint32 = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json.repeatedUint64 = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json.repeatedSint32 = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json.repeatedSint64 = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json.repeatedFixed32 = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json.repeatedFixed64 = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json.repeatedSfixed32 = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json.repeatedSfixed64 = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json.repeatedFloat = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json.repeatedDouble = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json.repeatedBool = msg.repeatedBool;
    }
    if (msg.repeatedNestedEnum?.length) {
      json.repeatedNestedEnum = msg.repeatedNestedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64 = reader.readInt64String().map(BigInt);
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64 = reader.readUint64String().map(BigInt);
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64 = reader.readSint64().map(BigInt);
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64 = reader.readFixed64String().map(BigInt);
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64 = reader.readSfixed64().map(BigInt);
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestUnpackedTypes,
    json: any
  ): TestUnpackedTypes {
    const repeatedInt32 = json.repeatedInt32 ?? json.repeated_int32;
    if (repeatedInt32) {
      msg.repeatedInt32 = repeatedInt32;
    }
    const repeatedInt64 = json.repeatedInt64 ?? json.repeated_int64;
    if (repeatedInt64) {
      msg.repeatedInt64 = repeatedInt64.map(BigInt);
    }
    const repeatedUint32 = json.repeatedUint32 ?? json.repeated_uint32;
    if (repeatedUint32) {
      msg.repeatedUint32 = repeatedUint32;
    }
    const repeatedUint64 = json.repeatedUint64 ?? json.repeated_uint64;
    if (repeatedUint64) {
      msg.repeatedUint64 = repeatedUint64.map(BigInt);
    }
    const repeatedSint32 = json.repeatedSint32 ?? json.repeated_sint32;
    if (repeatedSint32) {
      msg.repeatedSint32 = repeatedSint32;
    }
    const repeatedSint64 = json.repeatedSint64 ?? json.repeated_sint64;
    if (repeatedSint64) {
      msg.repeatedSint64 = repeatedSint64.map(BigInt);
    }
    const repeatedFixed32 = json.repeatedFixed32 ?? json.repeated_fixed32;
    if (repeatedFixed32) {
      msg.repeatedFixed32 = repeatedFixed32;
    }
    const repeatedFixed64 = json.repeatedFixed64 ?? json.repeated_fixed64;
    if (repeatedFixed64) {
      msg.repeatedFixed64 = repeatedFixed64.map(BigInt);
    }
    const repeatedSfixed32 = json.repeatedSfixed32 ?? json.repeated_sfixed32;
    if (repeatedSfixed32) {
      msg.repeatedSfixed32 = repeatedSfixed32;
    }
    const repeatedSfixed64 = json.repeatedSfixed64 ?? json.repeated_sfixed64;
    if (repeatedSfixed64) {
      msg.repeatedSfixed64 = repeatedSfixed64.map(BigInt);
    }
    const repeatedFloat = json.repeatedFloat ?? json.repeated_float;
    if (repeatedFloat) {
      msg.repeatedFloat = repeatedFloat;
    }
    const repeatedDouble = json.repeatedDouble ?? json.repeated_double;
    if (repeatedDouble) {
      msg.repeatedDouble = repeatedDouble;
    }
    const repeatedBool = json.repeatedBool ?? json.repeated_bool;
    if (repeatedBool) {
      msg.repeatedBool = repeatedBool;
    }
    const repeatedNestedEnum =
      json.repeatedNestedEnum ?? json.repeated_nested_enum;
    if (repeatedNestedEnum) {
      msg.repeatedNestedEnum = repeatedNestedEnum;
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a NestedTestAllTypes to JSON.
   */
  encodeJSON: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): string {
    return JSON.stringify(
      NestedTestAllTypes._writeMessageJSON(nestedTestAllTypes)
    );
  },

  /**
   * Deserializes a NestedTestAllTypes from JSON.
   */
  decodeJSON: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypes._readMessageJSON(
      NestedTestAllTypes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<NestedTestAllTypes>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const child = NestedTestAllTypes._writeMessageJSON(msg.child);
      if (Object.keys(child).length > 0) {
        json.child = child;
      }
    }
    if (msg.payload) {
      const payload = TestAllTypes._writeMessageJSON(msg.payload);
      if (Object.keys(payload).length > 0) {
        json.payload = payload;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: NestedTestAllTypes,
    json: any
  ): NestedTestAllTypes {
    const child = json.child ?? json.child;
    if (child) {
      const m = NestedTestAllTypes.initialize();
      NestedTestAllTypes._readMessageJSON(m, child);
      msg.child = m;
    }
    const payload = json.payload ?? json.payload;
    if (payload) {
      const m = TestAllTypes.initialize();
      TestAllTypes._readMessageJSON(m, payload);
      msg.payload = m;
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a ForeignMessage to JSON.
   */
  encodeJSON: function (foreignMessage: Partial<ForeignMessage>): string {
    return JSON.stringify(ForeignMessage._writeMessageJSON(foreignMessage));
  },

  /**
   * Deserializes a ForeignMessage from JSON.
   */
  decodeJSON: function (json: string): ForeignMessage {
    return ForeignMessage._readMessageJSON(
      ForeignMessage.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<ForeignMessage>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json.c = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: ForeignMessage, json: any): ForeignMessage {
    const c = json.c ?? json.c;
    if (c) {
      msg.c = c;
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Serializes a TestEmptyMessage to JSON.
   */

  encodeJSON: function (_testEmptyMessage?: Partial<TestEmptyMessage>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a TestEmptyMessage from JSON.
   */

  decodeJSON: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestEmptyMessage,
    json: any
  ): TestEmptyMessage {
    return msg;
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestMessageWithDummy to JSON.
   */
  encodeJSON: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): string {
    return JSON.stringify(
      TestMessageWithDummy._writeMessageJSON(testMessageWithDummy)
    );
  },

  /**
   * Deserializes a TestMessageWithDummy from JSON.
   */
  decodeJSON: function (json: string): TestMessageWithDummy {
    return TestMessageWithDummy._readMessageJSON(
      TestMessageWithDummy.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestMessageWithDummy>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.dummy) {
      json.dummy = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (
    msg: TestMessageWithDummy,
    json: any
  ): TestMessageWithDummy {
    const dummy = json.dummy ?? json.dummy;
    if (dummy) {
      msg.dummy = dummy;
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a TestOneof2 to JSON.
   */
  encodeJSON: function (testOneof2: Partial<TestOneof2>): string {
    return JSON.stringify(TestOneof2._writeMessageJSON(testOneof2));
  },

  /**
   * Deserializes a TestOneof2 from JSON.
   */
  decodeJSON: function (json: string): TestOneof2 {
    return TestOneof2._readMessageJSON(
      TestOneof2.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (
    msg: Partial<TestOneof2>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooEnum != undefined) {
      json.fooEnum = msg.fooEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: TestOneof2, json: any): TestOneof2 {
    const fooEnum = json.fooEnum ?? json.foo_enum;
    if (fooEnum) {
      msg.fooEnum = fooEnum;
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Serializes a Empty to JSON.
   */

  encodeJSON: function (_empty?: Partial<Empty>): string {
    return \\"{}\\";
  },

  /**
   * Deserializes a Empty from JSON.
   */

  decodeJSON: function (_json?: string): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg: Empty, json: any): Empty {
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { ClientConfiguration } from \\"twirpscript\\";
import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_44 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//              Foo Service               //
//========================================//

export interface FooService<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFooHandler<Context>(service: FooService<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
