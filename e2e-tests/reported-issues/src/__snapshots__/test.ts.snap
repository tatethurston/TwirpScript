// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[` 1`] = `
"$ /Users/tatethurston/twirpscript/e2e-tests/reported-issues/node_modules/.bin/twirpscript
[TwirpScript] Using configuration file at '/Users/tatethurston/twirpscript/e2e-tests/reported-issues/.twirp.json'.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
"
`;

exports[` 2`] = `
"$ /Users/tatethurston/twirpscript/e2e-tests/reported-issues/node_modules/.bin/tsc --noEmit
"
`;

exports[`TwirpScript Compiler generates src/7/a.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/a.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/A.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/A.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/A.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/A.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/A.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/A.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
) {
  return {
    name: \\"A.FooService\\",
    methods: {
      Foo1: {
        name: \\"Foo1\\",
        handler: service.Foo1,
        input: Foo1Request,
        output: Foo1Response,
      },
      Foo2: {
        name: \\"Foo2\\",
        handler: service.Foo2,
        input: Foo2Request,
        output: Foo2Response,
      },
      Foo3: {
        name: \\"Foo3\\",
        handler: service.Foo3,
        input: Foo3Request,
        output: Foo3Response,
      },
      Foo4: {
        name: \\"Foo4\\",
        handler: service.Foo4,
        input: Foo4Request,
        output: Foo4Response,
      },
      Foo5: {
        name: \\"Foo5\\",
        handler: service.Foo5,
        input: Foo5Request,
        output: Foo5Response,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/b.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/b.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/B.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/B.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/B.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/B.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/B.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/B.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
) {
  return {
    name: \\"B.FooService\\",
    methods: {
      Foo1: {
        name: \\"Foo1\\",
        handler: service.Foo1,
        input: Foo1Request,
        output: Foo1Response,
      },
      Foo2: {
        name: \\"Foo2\\",
        handler: service.Foo2,
        input: Foo2Request,
        output: Foo2Response,
      },
      Foo3: {
        name: \\"Foo3\\",
        handler: service.Foo3,
        input: Foo3Request,
        output: Foo3Response,
      },
      Foo4: {
        name: \\"Foo4\\",
        handler: service.Foo4,
        input: Foo4Request,
        output: Foo4Response,
      },
      Foo5: {
        name: \\"Foo5\\",
        handler: service.Foo5,
        input: Foo5Request,
        output: Foo5Response,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/c.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/c.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/C.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/C.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/C.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/C.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/C.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/C.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
) {
  return {
    name: \\"C.FooService\\",
    methods: {
      Foo1: {
        name: \\"Foo1\\",
        handler: service.Foo1,
        input: Foo1Request,
        output: Foo1Response,
      },
      Foo2: {
        name: \\"Foo2\\",
        handler: service.Foo2,
        input: Foo2Request,
        output: Foo2Response,
      },
      Foo3: {
        name: \\"Foo3\\",
        handler: service.Foo3,
        input: Foo3Request,
        output: Foo3Response,
      },
      Foo4: {
        name: \\"Foo4\\",
        handler: service.Foo4,
        input: Foo4Request,
        output: Foo4Response,
      },
      Foo5: {
        name: \\"Foo5\\",
        handler: service.Foo5,
        input: Foo5Request,
        output: Foo5Response,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/7/d.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 7/d.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//========================================//
//       FooService Protobuf Client       //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo1\\",
    Foo1Request.encode(foo1Request),
    config
  );
  return Foo1Response.decode(response);
}

export async function Foo2(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo2\\",
    Foo2Request.encode(foo2Request),
    config
  );
  return Foo2Response.decode(response);
}

export async function Foo3(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo3\\",
    Foo3Request.encode(foo3Request),
    config
  );
  return Foo3Response.decode(response);
}

export async function Foo4(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo4\\",
    Foo4Request.encode(foo4Request),
    config
  );
  return Foo4Response.decode(response);
}

export async function Foo5(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await PBrequest(
    \\"/D.FooService/Foo5\\",
    Foo5Request.encode(foo5Request),
    config
  );
  return Foo5Response.decode(response);
}

//========================================//
//         FooService JSON Client         //
//========================================//

/**
 * Login via credentials
 */
export async function Foo1JSON(
  foo1Request: Foo1Request,
  config?: ClientConfiguration
): Promise<Foo1Response> {
  const response = await JSONrequest<Foo1Response>(
    \\"/D.FooService/Foo1\\",
    foo1Request,
    config
  );
  return response;
}

export async function Foo2JSON(
  foo2Request: Foo2Request,
  config?: ClientConfiguration
): Promise<Foo2Response> {
  const response = await JSONrequest<Foo2Response>(
    \\"/D.FooService/Foo2\\",
    foo2Request,
    config
  );
  return response;
}

export async function Foo3JSON(
  foo3Request: Foo3Request,
  config?: ClientConfiguration
): Promise<Foo3Response> {
  const response = await JSONrequest<Foo3Response>(
    \\"/D.FooService/Foo3\\",
    foo3Request,
    config
  );
  return response;
}

export async function Foo4JSON(
  foo4Request: Foo4Request,
  config?: ClientConfiguration
): Promise<Foo4Response> {
  const response = await JSONrequest<Foo4Response>(
    \\"/D.FooService/Foo4\\",
    foo4Request,
    config
  );
  return response;
}

export async function Foo5JSON(
  foo5Request: Foo5Request,
  config?: ClientConfiguration
): Promise<Foo5Response> {
  const response = await JSONrequest<Foo5Response>(
    \\"/D.FooService/Foo5\\",
    foo5Request,
    config
  );
  return response;
}

//========================================//
//           FooService Service           //
//========================================//

export interface FooServiceService<Context = unknown> {
  /**
   * Login via credentials
   */
  Foo1: (
    foo1Request: Foo1Request,
    context: Context
  ) => Promise<Foo1Response> | Foo1Response;
  Foo2: (
    foo2Request: Foo2Request,
    context: Context
  ) => Promise<Foo2Response> | Foo2Response;
  Foo3: (
    foo3Request: Foo3Request,
    context: Context
  ) => Promise<Foo3Response> | Foo3Response;
  Foo4: (
    foo4Request: Foo4Request,
    context: Context
  ) => Promise<Foo4Response> | Foo4Response;
  Foo5: (
    foo5Request: Foo5Request,
    context: Context
  ) => Promise<Foo5Response> | Foo5Response;
}

export function createFooServiceHandler<Context>(
  service: FooServiceService<Context>
) {
  return {
    name: \\"D.FooService\\",
    methods: {
      Foo1: {
        name: \\"Foo1\\",
        handler: service.Foo1,
        input: Foo1Request,
        output: Foo1Response,
      },
      Foo2: {
        name: \\"Foo2\\",
        handler: service.Foo2,
        input: Foo2Request,
        output: Foo2Response,
      },
      Foo3: {
        name: \\"Foo3\\",
        handler: service.Foo3,
        input: Foo3Request,
        output: Foo3Response,
      },
      Foo4: {
        name: \\"Foo4\\",
        handler: service.Foo4,
        input: Foo4Request,
        output: Foo4Response,
      },
      Foo5: {
        name: \\"Foo5\\",
        handler: service.Foo5,
        input: Foo5Request,
        output: Foo5Response,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface Foo1Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo1Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo2Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo3Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo4Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Request {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

export interface Foo5Response {
  a: string[];
  b: string[];
  c: string[];
  d: string[];
  e: string[];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Foo1Request = {
  writeMessage: function (msg: Foo1Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Request: Foo1Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Request.writeMessage(foo1Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Request.readMessage(message, reader);
    return message as Foo1Request;
  },

  defaultValue: function (): Foo1Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo1Response = {
  writeMessage: function (msg: Foo1Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo1Response: Foo1Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo1Response.writeMessage(foo1Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo1Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo1Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo1Response.readMessage(message, reader);
    return message as Foo1Response;
  },

  defaultValue: function (): Foo1Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Request = {
  writeMessage: function (msg: Foo2Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Request: Foo2Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Request.writeMessage(foo2Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Request.readMessage(message, reader);
    return message as Foo2Request;
  },

  defaultValue: function (): Foo2Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo2Response = {
  writeMessage: function (msg: Foo2Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo2Response: Foo2Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo2Response.writeMessage(foo2Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo2Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo2Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo2Response.readMessage(message, reader);
    return message as Foo2Response;
  },

  defaultValue: function (): Foo2Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Request = {
  writeMessage: function (msg: Foo3Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Request: Foo3Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Request.writeMessage(foo3Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Request.readMessage(message, reader);
    return message as Foo3Request;
  },

  defaultValue: function (): Foo3Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo3Response = {
  writeMessage: function (msg: Foo3Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo3Response: Foo3Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo3Response.writeMessage(foo3Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo3Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo3Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo3Response.readMessage(message, reader);
    return message as Foo3Response;
  },

  defaultValue: function (): Foo3Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Request = {
  writeMessage: function (msg: Foo4Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Request: Foo4Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Request.writeMessage(foo4Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Request.readMessage(message, reader);
    return message as Foo4Request;
  },

  defaultValue: function (): Foo4Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo4Response = {
  writeMessage: function (msg: Foo4Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo4Response: Foo4Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo4Response.writeMessage(foo4Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo4Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo4Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo4Response.readMessage(message, reader);
    return message as Foo4Response;
  },

  defaultValue: function (): Foo4Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Request = {
  writeMessage: function (msg: Foo5Request, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Request: Foo5Request): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Request.writeMessage(foo5Request, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Request>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Request {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Request.readMessage(message, reader);
    return message as Foo5Request;
  },

  defaultValue: function (): Foo5Request {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};

export const Foo5Response = {
  writeMessage: function (msg: Foo5Response, writer: BinaryWriter): void {
    if (msg.a.length > 0) {
      writer.writeRepeatedString(1, msg.a);
    }
    if (msg.b.length > 0) {
      writer.writeRepeatedString(2, msg.b);
    }
    if (msg.c.length > 0) {
      writer.writeRepeatedString(3, msg.c);
    }
    if (msg.d.length > 0) {
      writer.writeRepeatedString(4, msg.d);
    }
    if (msg.e.length > 0) {
      writer.writeRepeatedString(5, msg.e);
    }
  },

  encode: function (foo5Response: Foo5Response): Uint8Array {
    const writer = new BinaryWriter();
    Foo5Response.writeMessage(foo5Response, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Foo5Response>,
    reader: BinaryReader
  ): void {
    msg.a = [];
    msg.b = [];
    msg.c = [];
    msg.d = [];
    msg.e = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a.push(reader.readString());
          break;
        }
        case 2: {
          msg.b.push(reader.readString());
          break;
        }
        case 3: {
          msg.c.push(reader.readString());
          break;
        }
        case 4: {
          msg.d.push(reader.readString());
          break;
        }
        case 5: {
          msg.e.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): Foo5Response {
    const reader = new BinaryReader(bytes);
    const message = {};
    Foo5Response.readMessage(message, reader);
    return message as Foo5Response;
  },

  defaultValue: function (): Foo5Response {
    return {
      a: [],
      b: [],
      c: [],
      d: [],
      e: [],
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/10/multi-service.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 10/multi-service.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//========================================//
//      CheckService Protobuf Client      //
//========================================//

export async function Info(
  infoRequest: InfoRequest,
  config?: ClientConfiguration
): Promise<InfoResponse> {
  const response = await PBrequest(
    \\"/api.v1.CheckService/Info\\",
    InfoRequest.encode(infoRequest),
    config
  );
  return InfoResponse.decode(response);
}

export async function DoStuff(
  doStuffRequest: DoStuffRequest,
  config?: ClientConfiguration
): Promise<DoStuffResponse> {
  const response = await PBrequest(
    \\"/api.v1.CheckService/DoStuff\\",
    DoStuffRequest.encode(doStuffRequest),
    config
  );
  return DoStuffResponse.decode(response);
}

//========================================//
//  VerificationService Protobuf Client   //
//========================================//

export async function Verify(
  verifyRequest: VerifyRequest,
  config?: ClientConfiguration
): Promise<VerifyResponse> {
  const response = await PBrequest(
    \\"/api.v1.VerificationService/Verify\\",
    VerifyRequest.encode(verifyRequest),
    config
  );
  return VerifyResponse.decode(response);
}

//========================================//
//        CheckService JSON Client        //
//========================================//

export async function InfoJSON(
  infoRequest: InfoRequest,
  config?: ClientConfiguration
): Promise<InfoResponse> {
  const response = await JSONrequest<InfoResponse>(
    \\"/api.v1.CheckService/Info\\",
    infoRequest,
    config
  );
  return response;
}

export async function DoStuffJSON(
  doStuffRequest: DoStuffRequest,
  config?: ClientConfiguration
): Promise<DoStuffResponse> {
  const response = await JSONrequest<DoStuffResponse>(
    \\"/api.v1.CheckService/DoStuff\\",
    doStuffRequest,
    config
  );
  return response;
}

//========================================//
//    VerificationService JSON Client     //
//========================================//

export async function VerifyJSON(
  verifyRequest: VerifyRequest,
  config?: ClientConfiguration
): Promise<VerifyResponse> {
  const response = await JSONrequest<VerifyResponse>(
    \\"/api.v1.VerificationService/Verify\\",
    verifyRequest,
    config
  );
  return response;
}

//========================================//
//          CheckService Service          //
//========================================//

export interface CheckServiceService<Context = unknown> {
  Info: (
    infoRequest: InfoRequest,
    context: Context
  ) => Promise<InfoResponse> | InfoResponse;
  DoStuff: (
    doStuffRequest: DoStuffRequest,
    context: Context
  ) => Promise<DoStuffResponse> | DoStuffResponse;
}

export function createCheckServiceHandler<Context>(
  service: CheckServiceService<Context>
) {
  return {
    name: \\"api.v1.CheckService\\",
    methods: {
      Info: {
        name: \\"Info\\",
        handler: service.Info,
        input: InfoRequest,
        output: InfoResponse,
      },
      DoStuff: {
        name: \\"DoStuff\\",
        handler: service.DoStuff,
        input: DoStuffRequest,
        output: DoStuffResponse,
      },
    },
  } as const;
}

//========================================//
//      VerificationService Service       //
//========================================//

export interface VerificationServiceService<Context = unknown> {
  Verify: (
    verifyRequest: VerifyRequest,
    context: Context
  ) => Promise<VerifyResponse> | VerifyResponse;
}

export function createVerificationServiceHandler<Context>(
  service: VerificationServiceService<Context>
) {
  return {
    name: \\"api.v1.VerificationService\\",
    methods: {
      Verify: {
        name: \\"Verify\\",
        handler: service.Verify,
        input: VerifyRequest,
        output: VerifyResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface InfoRequest {}

export interface DoStuffRequest {}

export interface InfoResponse {
  hostname: string;
}

export interface DoStuffResponse {
  data: string;
}

export interface VerifyRequest {
  token: string;
  nonce: string;
}

export interface VerifyResponse {
  status: boolean;
  sign: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const InfoRequest = {
  writeMessage: function (msg: InfoRequest, writer: BinaryWriter): void {},

  encode: function (infoRequest: InfoRequest): Uint8Array {
    const writer = new BinaryWriter();
    InfoRequest.writeMessage(infoRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<InfoRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): InfoRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    InfoRequest.readMessage(message, reader);
    return message as InfoRequest;
  },

  defaultValue: function (): InfoRequest {
    return {};
  },
};

export const DoStuffRequest = {
  writeMessage: function (msg: DoStuffRequest, writer: BinaryWriter): void {},

  encode: function (doStuffRequest: DoStuffRequest): Uint8Array {
    const writer = new BinaryWriter();
    DoStuffRequest.writeMessage(doStuffRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<DoStuffRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): DoStuffRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    DoStuffRequest.readMessage(message, reader);
    return message as DoStuffRequest;
  },

  defaultValue: function (): DoStuffRequest {
    return {};
  },
};

export const InfoResponse = {
  writeMessage: function (msg: InfoResponse, writer: BinaryWriter): void {
    if (msg.hostname) {
      writer.writeString(1, msg.hostname);
    }
  },

  encode: function (infoResponse: InfoResponse): Uint8Array {
    const writer = new BinaryWriter();
    InfoResponse.writeMessage(infoResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<InfoResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.hostname = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.hostname) {
      msg.hostname = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): InfoResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    InfoResponse.readMessage(message, reader);
    return message as InfoResponse;
  },

  defaultValue: function (): InfoResponse {
    return {
      hostname: \\"\\",
    };
  },
};

export const DoStuffResponse = {
  writeMessage: function (msg: DoStuffResponse, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (doStuffResponse: DoStuffResponse): Uint8Array {
    const writer = new BinaryWriter();
    DoStuffResponse.writeMessage(doStuffResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<DoStuffResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): DoStuffResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    DoStuffResponse.readMessage(message, reader);
    return message as DoStuffResponse;
  },

  defaultValue: function (): DoStuffResponse {
    return {
      data: \\"\\",
    };
  },
};

export const VerifyRequest = {
  writeMessage: function (msg: VerifyRequest, writer: BinaryWriter): void {
    if (msg.token) {
      writer.writeString(1, msg.token);
    }
    if (msg.nonce) {
      writer.writeInt64String(2, msg.nonce);
    }
  },

  encode: function (verifyRequest: VerifyRequest): Uint8Array {
    const writer = new BinaryWriter();
    VerifyRequest.writeMessage(verifyRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VerifyRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.token = reader.readString();
          break;
        }
        case 2: {
          msg.nonce = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.token) {
      msg.token = \\"\\";
    }
    if (!msg.nonce) {
      msg.nonce = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): VerifyRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    VerifyRequest.readMessage(message, reader);
    return message as VerifyRequest;
  },

  defaultValue: function (): VerifyRequest {
    return {
      token: \\"\\",
      nonce: \\"\\",
    };
  },
};

export const VerifyResponse = {
  writeMessage: function (msg: VerifyResponse, writer: BinaryWriter): void {
    if (msg.status) {
      writer.writeBool(1, msg.status);
    }
    if (msg.sign) {
      writer.writeString(2, msg.sign);
    }
  },

  encode: function (verifyResponse: VerifyResponse): Uint8Array {
    const writer = new BinaryWriter();
    VerifyResponse.writeMessage(verifyResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VerifyResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.status = reader.readBool();
          break;
        }
        case 2: {
          msg.sign = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.status) {
      msg.status = false;
    }
    if (!msg.sign) {
      msg.sign = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): VerifyResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    VerifyResponse.readMessage(message, reader);
    return message as VerifyResponse;
  },

  defaultValue: function (): VerifyResponse {
    return {
      status: false,
      sign: \\"\\",
    };
  },
};
"
`;

exports[`TwirpScript Compiler generates src/24/long.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 24/long.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

//======================================================//
// VeryLongNameThatCausesAnErrorService Protobuf Client //
//======================================================//

export async function GetAll(
  getAllRequest: GetAllRequest,
  config?: ClientConfiguration
): Promise<GetAllResponse> {
  const response = await PBrequest(
    \\"/pkg.VeryLongNameThatCausesAnErrorService/GetAll\\",
    GetAllRequest.encode(getAllRequest),
    config
  );
  return GetAllResponse.decode(response);
}

//==================================================//
// VeryLongNameThatCausesAnErrorService JSON Client //
//==================================================//

export async function GetAllJSON(
  getAllRequest: GetAllRequest,
  config?: ClientConfiguration
): Promise<GetAllResponse> {
  const response = await JSONrequest<GetAllResponse>(
    \\"/pkg.VeryLongNameThatCausesAnErrorService/GetAll\\",
    getAllRequest,
    config
  );
  return response;
}

//==============================================//
// VeryLongNameThatCausesAnErrorService Service //
//==============================================//

export interface VeryLongNameThatCausesAnErrorServiceService<
  Context = unknown
> {
  GetAll: (
    getAllRequest: GetAllRequest,
    context: Context
  ) => Promise<GetAllResponse> | GetAllResponse;
}

export function createVeryLongNameThatCausesAnErrorServiceHandler<Context>(
  service: VeryLongNameThatCausesAnErrorServiceService<Context>
) {
  return {
    name: \\"pkg.VeryLongNameThatCausesAnErrorService\\",
    methods: {
      GetAll: {
        name: \\"GetAll\\",
        handler: service.GetAll,
        input: GetAllRequest,
        output: GetAllResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export interface VeryLongNameThatCausesAnError {
  id: number;
}

export interface GetAllRequest {}

export interface GetAllResponse {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const VeryLongNameThatCausesAnError = {
  writeMessage: function (
    msg: VeryLongNameThatCausesAnError,
    writer: BinaryWriter
  ): void {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
  },

  encode: function (
    veryLongNameThatCausesAnError: VeryLongNameThatCausesAnError
  ): Uint8Array {
    const writer = new BinaryWriter();
    VeryLongNameThatCausesAnError.writeMessage(
      veryLongNameThatCausesAnError,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<VeryLongNameThatCausesAnError>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.id) {
      msg.id = 0;
    }
  },

  decode: function (bytes: ByteSource): VeryLongNameThatCausesAnError {
    const reader = new BinaryReader(bytes);
    const message = {};
    VeryLongNameThatCausesAnError.readMessage(message, reader);
    return message as VeryLongNameThatCausesAnError;
  },

  defaultValue: function (): VeryLongNameThatCausesAnError {
    return {
      id: 0,
    };
  },
};

export const GetAllRequest = {
  writeMessage: function (msg: GetAllRequest, writer: BinaryWriter): void {},

  encode: function (getAllRequest: GetAllRequest): Uint8Array {
    const writer = new BinaryWriter();
    GetAllRequest.writeMessage(getAllRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetAllRequest>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): GetAllRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetAllRequest.readMessage(message, reader);
    return message as GetAllRequest;
  },

  defaultValue: function (): GetAllRequest {
    return {};
  },
};

export const GetAllResponse = {
  writeMessage: function (msg: GetAllResponse, writer: BinaryWriter): void {},

  encode: function (getAllResponse: GetAllResponse): Uint8Array {
    const writer = new BinaryWriter();
    GetAllResponse.writeMessage(getAllResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetAllResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): GetAllResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetAllResponse.readMessage(message, reader);
    return message as GetAllResponse;
  },

  defaultValue: function (): GetAllResponse {
    return {};
  },
};
"
`;

exports[`TwirpScript Compiler generates src/34/address.pb.ts 1`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: 34/address.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface GetUserResponse {
  user_id: string;
  addresses: GetUserResponse.AddressList;
}

export namespace GetUserResponse {
  export interface Address {
    id: string;
    value: AddressValue;
  }

  export interface AddressList {
    address: GetUserResponse.Address[];
    primary: GetUserResponse.Address;
  }
}

export interface AddressValue {
  address_line1?: string;
  address_line2?: string;
  country_code?: string;
  postcode?: string;
  state?: string;
  suburb?: string;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const GetUserResponse = {
  writeMessage: function (msg: GetUserResponse, writer: BinaryWriter): void {
    if (msg.user_id) {
      writer.writeString(1, msg.user_id);
    }
    if (msg.addresses) {
      writer.writeMessage(
        2,
        msg.addresses,
        GetUserResponse.AddressList.writeMessage
      );
    }
  },

  encode: function (getUserResponse: GetUserResponse): Uint8Array {
    const writer = new BinaryWriter();
    GetUserResponse.writeMessage(getUserResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<GetUserResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.user_id = reader.readString();
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, GetUserResponse.AddressList.readMessage);
          msg.addresses = message as GetUserResponse.AddressList;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.user_id) {
      msg.user_id = \\"\\";
    }
    if (!msg.addresses) {
      msg.addresses = GetUserResponse.AddressList.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): GetUserResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    GetUserResponse.readMessage(message, reader);
    return message as GetUserResponse;
  },

  defaultValue: function (): GetUserResponse {
    return {
      user_id: \\"\\",
      addresses: GetUserResponse.AddressList.defaultValue(),
    };
  },

  Address: {
    writeMessage: function (
      msg: GetUserResponse.Address,
      writer: BinaryWriter
    ): void {
      if (msg.id) {
        writer.writeString(1, msg.id);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, AddressValue.writeMessage);
      }
    },

    encode: function (address: GetUserResponse.Address): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.Address.writeMessage(address, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.Address>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.id = reader.readString();
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, AddressValue.readMessage);
            msg.value = message as AddressValue;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.id) {
        msg.id = \\"\\";
      }
      if (!msg.value) {
        msg.value = AddressValue.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.Address {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.Address.readMessage(message, reader);
      return message as GetUserResponse.Address;
    },

    defaultValue: function (): GetUserResponse.Address {
      return {
        id: \\"\\",
        value: AddressValue.defaultValue(),
      };
    },
  },

  AddressList: {
    writeMessage: function (
      msg: GetUserResponse.AddressList,
      writer: BinaryWriter
    ): void {
      if (msg.address.length > 0) {
        writer.writeRepeatedMessage(
          1,
          msg.address as any,
          GetUserResponse.Address.writeMessage
        );
      }
      if (msg.primary) {
        writer.writeMessage(
          2,
          msg.primary,
          GetUserResponse.Address.writeMessage
        );
      }
    },

    encode: function (addressList: GetUserResponse.AddressList): Uint8Array {
      const writer = new BinaryWriter();
      GetUserResponse.AddressList.writeMessage(addressList, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<GetUserResponse.AddressList>,
      reader: BinaryReader
    ): void {
      msg.address = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.address.push(message as GetUserResponse.Address);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, GetUserResponse.Address.readMessage);
            msg.primary = message as GetUserResponse.Address;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.primary) {
        msg.primary = GetUserResponse.Address.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): GetUserResponse.AddressList {
      const reader = new BinaryReader(bytes);
      const message = {};
      GetUserResponse.AddressList.readMessage(message, reader);
      return message as GetUserResponse.AddressList;
    },

    defaultValue: function (): GetUserResponse.AddressList {
      return {
        address: [],
        primary: GetUserResponse.Address.defaultValue(),
      };
    },
  },
};

export const AddressValue = {
  writeMessage: function (msg: AddressValue, writer: BinaryWriter): void {
    if (msg.address_line1 != undefined) {
      writer.writeString(1, msg.address_line1);
    }
    if (msg.address_line2 != undefined) {
      writer.writeString(2, msg.address_line2);
    }
    if (msg.country_code != undefined) {
      writer.writeString(3, msg.country_code);
    }
    if (msg.postcode != undefined) {
      writer.writeString(4, msg.postcode);
    }
    if (msg.state != undefined) {
      writer.writeString(5, msg.state);
    }
    if (msg.suburb != undefined) {
      writer.writeString(6, msg.suburb);
    }
  },

  encode: function (addressValue: AddressValue): Uint8Array {
    const writer = new BinaryWriter();
    AddressValue.writeMessage(addressValue, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<AddressValue>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.address_line1 = reader.readString();
          break;
        }
        case 2: {
          msg.address_line2 = reader.readString();
          break;
        }
        case 3: {
          msg.country_code = reader.readString();
          break;
        }
        case 4: {
          msg.postcode = reader.readString();
          break;
        }
        case 5: {
          msg.state = reader.readString();
          break;
        }
        case 6: {
          msg.suburb = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): AddressValue {
    const reader = new BinaryReader(bytes);
    const message = {};
    AddressValue.readMessage(message, reader);
    return message as AddressValue;
  },

  defaultValue: function (): AddressValue {
    return {};
  },
};
"
`;
