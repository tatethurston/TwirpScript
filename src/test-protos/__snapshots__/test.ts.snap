// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
  },

  encode: function (publicImportMessage) {
    const writer = new BinaryWriter();
    PublicImportMessage.writeMessage(publicImportMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.e) {
      msg.e = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    PublicImportMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      e: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
  },

  encode: function (importMessage) {
    const writer = new BinaryWriter();
    ImportMessage.writeMessage(importMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ImportMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      d: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes) {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_import_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message;
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(message);
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message);
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum = reader.readEnum();
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum();
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum();
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_import_enum) {
      msg.optional_import_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.default_int32) {
      msg.default_int32 = 0;
    }
    if (!msg.default_int64) {
      msg.default_int64 = \\"\\";
    }
    if (!msg.default_uint32) {
      msg.default_uint32 = 0;
    }
    if (!msg.default_uint64) {
      msg.default_uint64 = \\"\\";
    }
    if (!msg.default_sint32) {
      msg.default_sint32 = 0;
    }
    if (!msg.default_sint64) {
      msg.default_sint64 = \\"\\";
    }
    if (!msg.default_fixed32) {
      msg.default_fixed32 = 0;
    }
    if (!msg.default_fixed64) {
      msg.default_fixed64 = \\"\\";
    }
    if (!msg.default_sfixed32) {
      msg.default_sfixed32 = 0;
    }
    if (!msg.default_sfixed64) {
      msg.default_sfixed64 = \\"\\";
    }
    if (!msg.default_float) {
      msg.default_float = 0;
    }
    if (!msg.default_double) {
      msg.default_double = 0;
    }
    if (!msg.default_bool) {
      msg.default_bool = false;
    }
    if (!msg.default_string) {
      msg.default_string = \\"\\";
    }
    if (!msg.default_bytes) {
      msg.default_bytes = new Uint8Array();
    }
    if (!msg.default_nested_enum) {
      msg.default_nested_enum = 0;
    }
    if (!msg.default_foreign_enum) {
      msg.default_foreign_enum = 0;
    }
    if (!msg.default_import_enum) {
      msg.default_import_enum = 0;
    }
    if (!msg.default_string_piece) {
      msg.default_string_piece = \\"\\";
    }
    if (!msg.default_cord) {
      msg.default_cord = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestAllTypes.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
    },

    encode: function (repeatedGroup) {
      const writer = new BinaryWriter();
      TestAllTypes.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.RepeatedGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child,
        NestedTestAllTypes.writeMessage
      );
    }
  },

  encode: function (nestedTestAllTypes) {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_child = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.repeated_child.push(message);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
      repeated_child: [],
    };
  },
};

export const TestDeprecatedFields = {
  writeMessage: function (msg, writer) {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
  },

  encode: function (testDeprecatedFields) {
    const writer = new BinaryWriter();
    TestDeprecatedFields.writeMessage(testDeprecatedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.deprecated_int32) {
      msg.deprecated_int32 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedFields.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      deprecated_int32: 0,
    };
  },
};

export const TestDeprecatedMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testDeprecatedMessage) {
    const writer = new BinaryWriter();
    TestDeprecatedMessage.writeMessage(testDeprecatedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const ForeignMessage = {
  writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
  },

  encode: function (foreignMessage) {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      c: 0,
      d: 0,
    };
  },
};

export const TestReservedFields = {
  writeMessage: function (msg, writer) {},

  encode: function (testReservedFields) {
    const writer = new BinaryWriter();
    TestReservedFields.writeMessage(testReservedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReservedFields.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestAllExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testAllExtensions) {
    const writer = new BinaryWriter();
    TestAllExtensions.writeMessage(testAllExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
  },

  encode: function (optionalGroup_extension) {
    const writer = new BinaryWriter();
    OptionalGroup_extension.writeMessage(optionalGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OptionalGroup_extension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },
};

export const RepeatedGroup_extension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
  },

  encode: function (repeatedGroup_extension) {
    const writer = new BinaryWriter();
    RepeatedGroup_extension.writeMessage(repeatedGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    RepeatedGroup_extension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },
};

export const TestGroup = {
  writeMessage: function (msg, writer) {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
  },

  encode: function (testGroup) {
    const writer = new BinaryWriter();
    TestGroup.writeMessage(testGroup, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroup.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_foreign_enum: 0,
    };
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestGroup.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestGroup.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestGroupExtension = {
  writeMessage: function (msg, writer) {},

  encode: function (testGroupExtension) {
    const writer = new BinaryWriter();
    TestGroupExtension.writeMessage(testGroupExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroupExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestNestedExtension = {
  writeMessage: function (msg, writer) {},

  encode: function (testNestedExtension) {
    const writer = new BinaryWriter();
    TestNestedExtension.writeMessage(testNestedExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  OptionalGroup_extension: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup_extension) {
      const writer = new BinaryWriter();
      TestNestedExtension.OptionalGroup_extension.writeMessage(
        optionalGroup_extension,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedExtension.OptionalGroup_extension.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestChildExtension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions.writeMessage
      );
    }
  },

  encode: function (testChildExtension) {
    const writer = new BinaryWriter();
    TestChildExtension.writeMessage(testChildExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllExtensions.readMessage);
          msg.optional_extension = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
    if (!msg.b) {
      msg.b = \\"\\";
    }
    if (!msg.optional_extension) {
      msg.optional_extension = TestAllExtensions.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestChildExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.defaultValue(),
    };
  },
};

export const TestRequired = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
  },

  encode: function (testRequired) {
    const writer = new BinaryWriter();
    TestRequired.writeMessage(testRequired, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.dummy2) {
      msg.dummy2 = 0;
    }
    if (!msg.b) {
      msg.b = 0;
    }
    if (!msg.dummy4) {
      msg.dummy4 = 0;
    }
    if (!msg.dummy5) {
      msg.dummy5 = 0;
    }
    if (!msg.dummy6) {
      msg.dummy6 = 0;
    }
    if (!msg.dummy7) {
      msg.dummy7 = 0;
    }
    if (!msg.dummy8) {
      msg.dummy8 = 0;
    }
    if (!msg.dummy9) {
      msg.dummy9 = 0;
    }
    if (!msg.dummy10) {
      msg.dummy10 = 0;
    }
    if (!msg.dummy11) {
      msg.dummy11 = 0;
    }
    if (!msg.dummy12) {
      msg.dummy12 = 0;
    }
    if (!msg.dummy13) {
      msg.dummy13 = 0;
    }
    if (!msg.dummy14) {
      msg.dummy14 = 0;
    }
    if (!msg.dummy15) {
      msg.dummy15 = 0;
    }
    if (!msg.dummy16) {
      msg.dummy16 = 0;
    }
    if (!msg.dummy17) {
      msg.dummy17 = 0;
    }
    if (!msg.dummy18) {
      msg.dummy18 = 0;
    }
    if (!msg.dummy19) {
      msg.dummy19 = 0;
    }
    if (!msg.dummy20) {
      msg.dummy20 = 0;
    }
    if (!msg.dummy21) {
      msg.dummy21 = 0;
    }
    if (!msg.dummy22) {
      msg.dummy22 = 0;
    }
    if (!msg.dummy23) {
      msg.dummy23 = 0;
    }
    if (!msg.dummy24) {
      msg.dummy24 = 0;
    }
    if (!msg.dummy25) {
      msg.dummy25 = 0;
    }
    if (!msg.dummy26) {
      msg.dummy26 = 0;
    }
    if (!msg.dummy27) {
      msg.dummy27 = 0;
    }
    if (!msg.dummy28) {
      msg.dummy28 = 0;
    }
    if (!msg.dummy29) {
      msg.dummy29 = 0;
    }
    if (!msg.dummy30) {
      msg.dummy30 = 0;
    }
    if (!msg.dummy31) {
      msg.dummy31 = 0;
    }
    if (!msg.dummy32) {
      msg.dummy32 = 0;
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequired.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },
};

export const TestRequiredForeign = {
  writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired.writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
  },

  encode: function (testRequiredForeign) {
    const writer = new BinaryWriter();
    TestRequiredForeign.writeMessage(testRequiredForeign, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.dummy) {
      msg.dummy = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredForeign.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      dummy: 0,
    };
  },
};

export const TestRequiredMessage = {
  writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired.writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired.writeMessage);
    }
  },

  encode: function (testRequiredMessage) {
    const writer = new BinaryWriter();
    TestRequiredMessage.writeMessage(testRequiredMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message);
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.required_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.required_message) {
      msg.required_message = TestRequired.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      required_message: TestRequired.defaultValue(),
    };
  },
};

export const TestForeignNested = {
  writeMessage: function (msg, writer) {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testForeignNested) {
    const writer = new BinaryWriter();
    TestForeignNested.writeMessage(testForeignNested, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.foreign_nested = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foreign_nested) {
      msg.foreign_nested = TestAllTypes.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestForeignNested.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foreign_nested: TestAllTypes.NestedMessage.defaultValue(),
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessage) {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessageWithExtensions) {
    const writer = new BinaryWriter();
    TestEmptyMessageWithExtensions.writeMessage(
      testEmptyMessageWithExtensions,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessageWithExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testPickleNestedMessage) {
    const writer = new BinaryWriter();
    TestPickleNestedMessage.writeMessage(testPickleNestedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPickleNestedMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestPickleNestedMessage.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestPickleNestedMessage.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },

    NestedNestedMessage: {
      writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
      },

      encode: function (nestedNestedMessage) {
        const writer = new BinaryWriter();
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.writeMessage(
          nestedNestedMessage,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.cc) {
          msg.cc = 0;
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          cc: 0,
        };
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  writeMessage: function (msg, writer) {},

  encode: function (testMultipleExtensionRanges) {
    const writer = new BinaryWriter();
    TestMultipleExtensionRanges.writeMessage(
      testMultipleExtensionRanges,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMultipleExtensionRanges.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
  },

  encode: function (testReallyLargeTagNumber) {
    const writer = new BinaryWriter();
    TestReallyLargeTagNumber.writeMessage(testReallyLargeTagNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.bb) {
      msg.bb = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReallyLargeTagNumber.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
      bb: 0,
    };
  },
};

export const TestRecursiveMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage.writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
  },

  encode: function (testRecursiveMessage) {
    const writer = new BinaryWriter();
    TestRecursiveMessage.writeMessage(testRecursiveMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRecursiveMessage.readMessage);
          msg.a = message;
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestRecursiveMessage.defaultValue();
    }
    if (!msg.i) {
      msg.i = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: TestRecursiveMessage.defaultValue(),
      i: 0,
    };
  },
};

export const TestMutualRecursionA = {
  writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB.writeMessage);
    }
  },

  encode: function (testMutualRecursionA) {
    const writer = new BinaryWriter();
    TestMutualRecursionA.writeMessage(testMutualRecursionA, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionB.readMessage);
          msg.bb = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.bb) {
      msg.bb = TestMutualRecursionB.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionA.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      bb: TestMutualRecursionB.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB.writeMessage);
      }
    },

    encode: function (subMessage) {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestMutualRecursionB.readMessage);
            msg.b = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.b) {
        msg.b = TestMutualRecursionB.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        b: TestMutualRecursionB.defaultValue(),
      };
    },
  },

  SubGroup: {
    writeMessage: function (msg, writer) {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage.writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes.writeMessage);
      }
    },

    encode: function (subGroup) {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubGroup.writeMessage(subGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            const message = {};
            reader.readMessage(
              message,
              TestMutualRecursionA.SubMessage.readMessage
            );
            msg.sub_message = message;
            break;
          }
          case 4: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.not_in_this_scc = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.sub_message) {
        msg.sub_message = TestMutualRecursionA.SubMessage.defaultValue();
      }
      if (!msg.not_in_this_scc) {
        msg.not_in_this_scc = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        sub_message: TestMutualRecursionA.SubMessage.defaultValue(),
        not_in_this_scc: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestMutualRecursionB = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA.writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
  },

  encode: function (testMutualRecursionB) {
    const writer = new BinaryWriter();
    TestMutualRecursionB.writeMessage(testMutualRecursionB, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionA.readMessage);
          msg.a = message;
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestMutualRecursionA.defaultValue();
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionB.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: TestMutualRecursionA.defaultValue(),
      optional_int32: 0,
    };
  },
};

export const TestIsInitialized = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage.writeMessage
      );
    }
  },

  encode: function (testIsInitialized) {
    const writer = new BinaryWriter();
    TestIsInitialized.writeMessage(testIsInitialized, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestIsInitialized.SubMessage.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestIsInitialized.SubMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestIsInitialized.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestIsInitialized.SubMessage.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (msg, writer) {},

    encode: function (subMessage) {
      const writer = new BinaryWriter();
      TestIsInitialized.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestIsInitialized.SubMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {};
    },

    SubGroup: {
      writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
      },

      encode: function (subGroup) {
        const writer = new BinaryWriter();
        TestIsInitialized.SubMessage.SubGroup.writeMessage(subGroup, writer);
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.i) {
          msg.i = 0;
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestIsInitialized.SubMessage.SubGroup.readMessage(message, reader);
        return message;
      },

      defaultValue: function () {
        return {
          i: 0,
        };
      },
    },
  },
};

export const TestDupFieldNumber = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
  },

  encode: function (testDupFieldNumber) {
    const writer = new BinaryWriter();
    TestDupFieldNumber.writeMessage(testDupFieldNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDupFieldNumber.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },

  Foo: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (foo) {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Foo.writeMessage(foo, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Foo.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },

  Bar: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (bar) {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Bar.writeMessage(bar, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Bar.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestEagerMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testEagerMessage) {
    const writer = new BinaryWriter();
    TestEagerMessage.writeMessage(testEagerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEagerMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestLazyMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testLazyMessage) {
    const writer = new BinaryWriter();
    TestLazyMessage.writeMessage(testLazyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestLazyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestNestedMessageHasBits = {
  writeMessage: function (msg, writer) {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testNestedMessageHasBits) {
    const writer = new BinaryWriter();
    TestNestedMessageHasBits.writeMessage(testNestedMessageHasBits, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(
            message,
            TestNestedMessageHasBits.NestedMessage.readMessage
          );
          msg.optional_nested_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestNestedMessageHasBits.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedMessageHasBits.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage,
          ForeignMessage.writeMessage
        );
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestNestedMessageHasBits.NestedMessage.writeMessage(
        nestedMessage,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.nestedmessage_repeated_int32 = [];
      msg.nestedmessage_repeated_foreignmessage = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, ForeignMessage.readMessage);
            msg.nestedmessage_repeated_foreignmessage.push(message);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedMessageHasBits.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },
  },
};

export const TestCamelCaseFieldNames = {
  writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage.writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage.writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
  },

  encode: function (testCamelCaseFieldNames) {
    const writer = new BinaryWriter();
    TestCamelCaseFieldNames.writeMessage(testCamelCaseFieldNames, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.RepeatedPrimitiveField = [];
    msg.RepeatedStringField = [];
    msg.RepeatedEnumField = [];
    msg.RepeatedMessageField = [];
    msg.RepeatedStringPieceField = [];
    msg.RepeatedCordField = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.MessageField = message;
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.RepeatedMessageField.push(message);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.PrimitiveField) {
      msg.PrimitiveField = 0;
    }
    if (!msg.StringField) {
      msg.StringField = \\"\\";
    }
    if (!msg.EnumField) {
      msg.EnumField = 0;
    }
    if (!msg.MessageField) {
      msg.MessageField = ForeignMessage.defaultValue();
    }
    if (!msg.StringPieceField) {
      msg.StringPieceField = \\"\\";
    }
    if (!msg.CordField) {
      msg.CordField = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCamelCaseFieldNames.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.defaultValue(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },
};

export const TestFieldOrderings = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testFieldOrderings) {
    const writer = new BinaryWriter();
    TestFieldOrderings.writeMessage(testFieldOrderings, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          const message = {};
          reader.readMessage(
            message,
            TestFieldOrderings.NestedMessage.readMessage
          );
          msg.optional_nested_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
    if (!msg.my_int) {
      msg.my_int = \\"\\";
    }
    if (!msg.my_float) {
      msg.my_float = 0;
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestFieldOrderings.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestFieldOrderings.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestFieldOrderings.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.oo) {
        msg.oo = \\"\\";
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestFieldOrderings.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },
  },
};

export const TestExtensionOrderings1 = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (testExtensionOrderings1) {
    const writer = new BinaryWriter();
    TestExtensionOrderings1.writeMessage(testExtensionOrderings1, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings1.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
    };
  },
};

export const TestExtensionOrderings2 = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (testExtensionOrderings2) {
    const writer = new BinaryWriter();
    TestExtensionOrderings2.writeMessage(testExtensionOrderings2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
    };
  },

  TestExtensionOrderings3: {
    writeMessage: function (msg, writer) {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
    },

    encode: function (testExtensionOrderings3) {
      const writer = new BinaryWriter();
      TestExtensionOrderings2.TestExtensionOrderings3.writeMessage(
        testExtensionOrderings3,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.my_string) {
        msg.my_string = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestExtensionOrderings2.TestExtensionOrderings3.readMessage(
        message,
        reader
      );
      return message;
    },

    defaultValue: function () {
      return {
        my_string: \\"\\",
      };
    },
  },
};

export const TestExtremeDefaultValues = {
  writeMessage: function (msg, writer) {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
  },

  encode: function (testExtremeDefaultValues) {
    const writer = new BinaryWriter();
    TestExtremeDefaultValues.writeMessage(testExtremeDefaultValues, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.escaped_bytes) {
      msg.escaped_bytes = new Uint8Array();
    }
    if (!msg.large_uint32) {
      msg.large_uint32 = 0;
    }
    if (!msg.large_uint64) {
      msg.large_uint64 = \\"\\";
    }
    if (!msg.small_int32) {
      msg.small_int32 = 0;
    }
    if (!msg.small_int64) {
      msg.small_int64 = \\"\\";
    }
    if (!msg.really_small_int32) {
      msg.really_small_int32 = 0;
    }
    if (!msg.really_small_int64) {
      msg.really_small_int64 = \\"\\";
    }
    if (!msg.utf8_string) {
      msg.utf8_string = \\"\\";
    }
    if (!msg.zero_float) {
      msg.zero_float = 0;
    }
    if (!msg.one_float) {
      msg.one_float = 0;
    }
    if (!msg.small_float) {
      msg.small_float = 0;
    }
    if (!msg.negative_one_float) {
      msg.negative_one_float = 0;
    }
    if (!msg.negative_float) {
      msg.negative_float = 0;
    }
    if (!msg.large_float) {
      msg.large_float = 0;
    }
    if (!msg.small_negative_float) {
      msg.small_negative_float = 0;
    }
    if (!msg.inf_double) {
      msg.inf_double = 0;
    }
    if (!msg.neg_inf_double) {
      msg.neg_inf_double = 0;
    }
    if (!msg.nan_double) {
      msg.nan_double = 0;
    }
    if (!msg.inf_float) {
      msg.inf_float = 0;
    }
    if (!msg.neg_inf_float) {
      msg.neg_inf_float = 0;
    }
    if (!msg.nan_float) {
      msg.nan_float = 0;
    }
    if (!msg.cpp_trigraph) {
      msg.cpp_trigraph = \\"\\";
    }
    if (!msg.string_with_zero) {
      msg.string_with_zero = \\"\\";
    }
    if (!msg.bytes_with_zero) {
      msg.bytes_with_zero = new Uint8Array();
    }
    if (!msg.string_piece_with_zero) {
      msg.string_piece_with_zero = \\"\\";
    }
    if (!msg.cord_with_zero) {
      msg.cord_with_zero = \\"\\";
    }
    if (!msg.replacement_string) {
      msg.replacement_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtremeDefaultValues.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },
};

export const SparseEnumMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
  },

  encode: function (sparseEnumMessage) {
    const writer = new BinaryWriter();
    SparseEnumMessage.writeMessage(sparseEnumMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sparse_enum) {
      msg.sparse_enum = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    SparseEnumMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sparse_enum: 0,
    };
  },
};

export const OneString = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (oneString) {
    const writer = new BinaryWriter();
    OneString.writeMessage(oneString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneString.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const MoreString = {
  writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
  },

  encode: function (moreString) {
    const writer = new BinaryWriter();
    MoreString.writeMessage(moreString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreString.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: [],
    };
  },
};

export const OneBytes = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
  },

  encode: function (oneBytes) {
    const writer = new BinaryWriter();
    OneBytes.writeMessage(oneBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = new Uint8Array();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneBytes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: new Uint8Array(),
    };
  },
};

export const MoreBytes = {
  writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
  },

  encode: function (moreBytes) {
    const writer = new BinaryWriter();
    MoreBytes.writeMessage(moreBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreBytes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: [],
    };
  },
};

export const Int32Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
  },

  encode: function (int32Message) {
    const writer = new BinaryWriter();
    Int32Message.writeMessage(int32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int32Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: 0,
    };
  },
};

export const Uint32Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
  },

  encode: function (uint32Message) {
    const writer = new BinaryWriter();
    Uint32Message.writeMessage(uint32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint32Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: 0,
    };
  },
};

export const Int64Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
  },

  encode: function (int64Message) {
    const writer = new BinaryWriter();
    Int64Message.writeMessage(int64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int64Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const Uint64Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
  },

  encode: function (uint64Message) {
    const writer = new BinaryWriter();
    Uint64Message.writeMessage(uint64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint64Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const BoolMessage = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
  },

  encode: function (boolMessage) {
    const writer = new BinaryWriter();
    BoolMessage.writeMessage(boolMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = false;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BoolMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: false,
    };
  },
};

export const TestOneof = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneof) {
    const writer = new BinaryWriter();
    TestOneof.writeMessage(testOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneof.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneofBackwardsCompatible = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneofBackwardsCompatible) {
    const writer = new BinaryWriter();
    TestOneofBackwardsCompatible.writeMessage(
      testOneofBackwardsCompatible,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_int) {
      msg.foo_int = 0;
    }
    if (!msg.foo_string) {
      msg.foo_string = \\"\\";
    }
    if (!msg.foo_message) {
      msg.foo_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneofBackwardsCompatible.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneofBackwardsCompatible.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneofBackwardsCompatible.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneof2 = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
  },

  encode: function (testOneof2) {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        case 7: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_message = message;
          break;
        }
        case 11: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_lazy_message = message;
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum();
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.baz_int) {
      msg.baz_int = 0;
    }
    if (!msg.baz_string) {
      msg.baz_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestOneof2.NestedMessage.defaultValue(),
      foo_lazy_message: TestOneof2.NestedMessage.defaultValue(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneof2.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestOneof2.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.corge_int = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.qux_int) {
        msg.qux_int = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },
  },
};

export const TestRequiredOneof = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testRequiredOneof) {
    const writer = new BinaryWriter();
    TestRequiredOneof.writeMessage(testRequiredOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(
            message,
            TestRequiredOneof.NestedMessage.readMessage
          );
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredOneof.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestRequiredOneof.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestRequiredOneof.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.required_double) {
        msg.required_double = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestRequiredOneof.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        required_double: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes) {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
  },

  encode: function (testUnpackedTypes) {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.unpacked_int32 = [];
    msg.unpacked_int64 = [];
    msg.unpacked_uint32 = [];
    msg.unpacked_uint64 = [];
    msg.unpacked_sint32 = [];
    msg.unpacked_sint64 = [];
    msg.unpacked_fixed32 = [];
    msg.unpacked_fixed64 = [];
    msg.unpacked_sfixed32 = [];
    msg.unpacked_sfixed64 = [];
    msg.unpacked_float = [];
    msg.unpacked_double = [];
    msg.unpacked_bool = [];
    msg.unpacked_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },
};

export const TestPackedExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testPackedExtensions) {
    const writer = new BinaryWriter();
    TestPackedExtensions.writeMessage(testPackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testUnpackedExtensions) {
    const writer = new BinaryWriter();
    TestUnpackedExtensions.writeMessage(testUnpackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  writeMessage: function (msg, writer) {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage.writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType.writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
  },

  encode: function (testDynamicExtensions) {
    const writer = new BinaryWriter();
    TestDynamicExtensions.writeMessage(testDynamicExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_extension = [];
    msg.packed_extension = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension = reader.readEnum();
          break;
        }
        case 2003: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.message_extension = message;
          break;
        }
        case 2004: {
          const message = {};
          reader.readMessage(
            message,
            TestDynamicExtensions.DynamicMessageType.readMessage
          );
          msg.dynamic_message_extension = message;
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.scalar_extension) {
      msg.scalar_extension = 0;
    }
    if (!msg.enum_extension) {
      msg.enum_extension = 0;
    }
    if (!msg.dynamic_enum_extension) {
      msg.dynamic_enum_extension = 0;
    }
    if (!msg.message_extension) {
      msg.message_extension = ForeignMessage.defaultValue();
    }
    if (!msg.dynamic_message_extension) {
      msg.dynamic_message_extension =
        TestDynamicExtensions.DynamicMessageType.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDynamicExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.defaultValue(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.defaultValue(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    writeMessage: function (msg, writer) {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
    },

    encode: function (dynamicMessageType) {
      const writer = new BinaryWriter();
      TestDynamicExtensions.DynamicMessageType.writeMessage(
        dynamicMessageType,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.dynamic_field) {
        msg.dynamic_field = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDynamicExtensions.DynamicMessageType.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        dynamic_field: 0,
      };
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  writeMessage: function (msg, writer) {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
  },

  encode: function (testRepeatedScalarDifferentTagSizes) {
    const writer = new BinaryWriter();
    TestRepeatedScalarDifferentTagSizes.writeMessage(
      testRepeatedScalarDifferentTagSizes,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_fixed32 = [];
    msg.repeated_int32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_int64 = [];
    msg.repeated_float = [];
    msg.repeated_uint64 = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRepeatedScalarDifferentTagSizes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },
};

export const TestParsingMerge = {
  writeMessage: function (msg, writer) {
    if (msg.required_all_types) {
      writer.writeMessage(1, msg.required_all_types, TestAllTypes.writeMessage);
    }
    if (msg.optional_all_types) {
      writer.writeMessage(2, msg.optional_all_types, TestAllTypes.writeMessage);
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types,
        TestAllTypes.writeMessage
      );
    }
  },

  encode: function (testParsingMerge) {
    const writer = new BinaryWriter();
    TestParsingMerge.writeMessage(testParsingMerge, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_all_types = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.required_all_types = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.optional_all_types = message;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.repeated_all_types.push(message);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.required_all_types) {
      msg.required_all_types = TestAllTypes.defaultValue();
    }
    if (!msg.optional_all_types) {
      msg.optional_all_types = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestParsingMerge.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      required_all_types: TestAllTypes.defaultValue(),
      optional_all_types: TestAllTypes.defaultValue(),
      repeated_all_types: [],
    };
  },

  RepeatedFieldsGenerator: {
    writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes.writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes.writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes.writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes.writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes.writeMessage);
      }
    },

    encode: function (repeatedFieldsGenerator) {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedFieldsGenerator.writeMessage(
        repeatedFieldsGenerator,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.field1 = [];
      msg.field2 = [];
      msg.field3 = [];
      msg.ext1 = [];
      msg.ext2 = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field1.push(message);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field2.push(message);
            break;
          }
          case 3: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field3.push(message);
            break;
          }
          case 1000: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext1.push(message);
            break;
          }
          case 1001: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext2.push(message);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedFieldsGenerator.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    Group1: {
      writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (group1) {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group1.writeMessage(
          group1,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group1.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          field1: TestAllTypes.defaultValue(),
        };
      },
    },

    Group2: {
      writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (group2) {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group2.writeMessage(
          group2,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group2.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          field1: TestAllTypes.defaultValue(),
        };
      },
    },
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestParsingMerge.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.optional_group_all_types = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.optional_group_all_types) {
        msg.optional_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        optional_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (msg, writer) {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (repeatedGroup) {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.repeated_group_all_types = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.repeated_group_all_types) {
        msg.repeated_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        repeated_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestCommentInjectionMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
  },

  encode: function (testCommentInjectionMessage) {
    const writer = new BinaryWriter();
    TestCommentInjectionMessage.writeMessage(
      testCommentInjectionMessage,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCommentInjectionMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: \\"\\",
    };
  },
};

export const FooRequest = {
  writeMessage: function (msg, writer) {},

  encode: function (fooRequest) {
    const writer = new BinaryWriter();
    FooRequest.writeMessage(fooRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooRequest.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooResponse = {
  writeMessage: function (msg, writer) {},

  encode: function (fooResponse) {
    const writer = new BinaryWriter();
    FooResponse.writeMessage(fooResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooResponse.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooClientMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (fooClientMessage) {
    const writer = new BinaryWriter();
    FooClientMessage.writeMessage(fooClientMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooClientMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooServerMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (fooServerMessage) {
    const writer = new BinaryWriter();
    FooServerMessage.writeMessage(fooServerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooServerMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const BarRequest = {
  writeMessage: function (msg, writer) {},

  encode: function (barRequest) {
    const writer = new BinaryWriter();
    BarRequest.writeMessage(barRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarRequest.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const BarResponse = {
  writeMessage: function (msg, writer) {},

  encode: function (barResponse) {
    const writer = new BinaryWriter();
    BarResponse.writeMessage(barResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarResponse.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestJsonName = {
  writeMessage: function (msg, writer) {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
  },

  encode: function (testJsonName) {
    const writer = new BinaryWriter();
    TestJsonName.writeMessage(testJsonName, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field_name1) {
      msg.field_name1 = 0;
    }
    if (!msg.fieldName2) {
      msg.fieldName2 = 0;
    }
    if (!msg.FieldName3) {
      msg.FieldName3 = 0;
    }
    if (!msg._field_name4) {
      msg._field_name4 = 0;
    }
    if (!msg.FIELD_NAME5) {
      msg.FIELD_NAME5 = 0;
    }
    if (!msg.field_name6) {
      msg.field_name6 = 0;
    }
    if (!msg.fieldname7) {
      msg.fieldname7 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestJsonName.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },
};

export const TestHugeFieldNumbers = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.string_string_map[key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
  },

  encode: function (testHugeFieldNumbers) {
    const writer = new BinaryWriter();
    TestHugeFieldNumbers.writeMessage(testHugeFieldNumbers, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.packed_int32 = [];
    msg.string_string_map = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_message = message;
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.string_string_map[key] = value;
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.oneof_test_all_types = message;
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.fixed_32) {
      msg.fixed_32 = 0;
    }
    if (!msg.optional_enum) {
      msg.optional_enum = 0;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_message) {
      msg.optional_message = ForeignMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestHugeFieldNumbers.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.defaultValue(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.defaultValue(),
    };
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestHugeFieldNumbers.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.group_a) {
        msg.group_a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestHugeFieldNumbers.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        group_a: 0,
      };
    },
  },
};

export const TestExtensionInsideTable = {
  writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
  },

  encode: function (testExtensionInsideTable) {
    const writer = new BinaryWriter();
    TestExtensionInsideTable.writeMessage(testExtensionInsideTable, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field1) {
      msg.field1 = 0;
    }
    if (!msg.field2) {
      msg.field2 = 0;
    }
    if (!msg.field3) {
      msg.field3 = 0;
    }
    if (!msg.field4) {
      msg.field4 = 0;
    }
    if (!msg.field6) {
      msg.field6 = 0;
    }
    if (!msg.field7) {
      msg.field7 = 0;
    }
    if (!msg.field8) {
      msg.field8 = 0;
    }
    if (!msg.field9) {
      msg.field9 = 0;
    }
    if (!msg.field10) {
      msg.field10 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionInsideTable.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },
};

export const TestExtensionRangeSerialize = {
  writeMessage: function (msg, writer) {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
  },

  encode: function (testExtensionRangeSerialize) {
    const writer = new BinaryWriter();
    TestExtensionRangeSerialize.writeMessage(
      testExtensionRangeSerialize,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_one) {
      msg.foo_one = 0;
    }
    if (!msg.foo_two) {
      msg.foo_two = 0;
    }
    if (!msg.foo_three) {
      msg.foo_three = 0;
    }
    if (!msg.foo_four) {
      msg.foo_four = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionRangeSerialize.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.map_string_foreign_message[key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_all_types[key]);
        });
      }
    }
  },

  encode: function (testMap) {
    const writer = new BinaryWriter();
    TestMap.writeMessage(testMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    msg.map_string_foreign_message = {};
    msg.map_int32_all_types = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64[key] = value;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32[key] = value;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64[key] = value;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32[key] = value;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64[key] = value;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32[key] = value;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64[key] = value;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32[key] = value;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64[key] = value;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float[key] = value;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double[key] = value;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool[key] = value;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string[key] = value;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes[key] = value;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum[key] = value;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message[key] = value;
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_string_foreign_message[key] = value;
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_all_types[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },
};

export const TestMapSubmessage = {
  writeMessage: function (msg, writer) {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap.writeMessage);
    }
  },

  encode: function (testMapSubmessage) {
    const writer = new BinaryWriter();
    TestMapSubmessage.writeMessage(testMapSubmessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMap.readMessage);
          msg.test_map = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.test_map) {
      msg.test_map = TestMap.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMapSubmessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      test_map: TestMap.defaultValue(),
    };
  },
};

export const TestMessageMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_message[key]);
        });
      }
    }
  },

  encode: function (testMessageMap) {
    const writer = new BinaryWriter();
    TestMessageMap.writeMessage(testMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_message[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_message: {},
    };
  },
};

export const TestSameTypeMap = {
  writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
  },

  encode: function (testSameTypeMap) {
    const writer = new BinaryWriter();
    TestSameTypeMap.writeMessage(testSameTypeMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map1 = {};
    msg.map2 = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map1[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map2[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestSameTypeMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map1: {},
      map2: {},
    };
  },
};

export const TestRequiredMessageMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_field[key]);
        });
      }
    }
  },

  encode: function (testRequiredMessageMap) {
    const writer = new BinaryWriter();
    TestRequiredMessageMap.writeMessage(testRequiredMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_field = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_field[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessageMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_field: {},
    };
  },
};

export const TestArenaMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
  },

  encode: function (testArenaMap) {
    const writer = new BinaryWriter();
    TestArenaMap.writeMessage(testArenaMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64[key] = value;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32[key] = value;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64[key] = value;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32[key] = value;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64[key] = value;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32[key] = value;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64[key] = value;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32[key] = value;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64[key] = value;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float[key] = value;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double[key] = value;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool[key] = value;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string[key] = value;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes[key] = value;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum[key] = value;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestArenaMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },
};

export const MessageContainingMapCalledEntry = {
  writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
  },

  encode: function (messageContainingMapCalledEntry) {
    const writer = new BinaryWriter();
    MessageContainingMapCalledEntry.writeMessage(
      messageContainingMapCalledEntry,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.entry = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.entry[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MessageContainingMapCalledEntry.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      entry: {},
    };
  },
};

export const TestRecursiveMapMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
  },

  encode: function (testRecursiveMapMessage) {
    const writer = new BinaryWriter();
    TestRecursiveMapMessage.writeMessage(testRecursiveMapMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.a = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.a[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMapMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: {},
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes) {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message;
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(message);
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes) {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes) {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (nestedTestAllTypes) {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage) {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessage) {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (testMessageWithDummy) {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (msg, writer) {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2) {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
  },

  encode: function (publicImportMessage) {
    const writer = new BinaryWriter();
    PublicImportMessage.writeMessage(publicImportMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.e) {
      msg.e = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    PublicImportMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      e: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
  },

  encode: function (importMessage) {
    const writer = new BinaryWriter();
    ImportMessage.writeMessage(importMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ImportMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      d: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes) {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_import_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message;
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(message);
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message);
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum = reader.readEnum();
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum();
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum();
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_import_enum) {
      msg.optional_import_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.default_int32) {
      msg.default_int32 = 0;
    }
    if (!msg.default_int64) {
      msg.default_int64 = \\"\\";
    }
    if (!msg.default_uint32) {
      msg.default_uint32 = 0;
    }
    if (!msg.default_uint64) {
      msg.default_uint64 = \\"\\";
    }
    if (!msg.default_sint32) {
      msg.default_sint32 = 0;
    }
    if (!msg.default_sint64) {
      msg.default_sint64 = \\"\\";
    }
    if (!msg.default_fixed32) {
      msg.default_fixed32 = 0;
    }
    if (!msg.default_fixed64) {
      msg.default_fixed64 = \\"\\";
    }
    if (!msg.default_sfixed32) {
      msg.default_sfixed32 = 0;
    }
    if (!msg.default_sfixed64) {
      msg.default_sfixed64 = \\"\\";
    }
    if (!msg.default_float) {
      msg.default_float = 0;
    }
    if (!msg.default_double) {
      msg.default_double = 0;
    }
    if (!msg.default_bool) {
      msg.default_bool = false;
    }
    if (!msg.default_string) {
      msg.default_string = \\"\\";
    }
    if (!msg.default_bytes) {
      msg.default_bytes = new Uint8Array();
    }
    if (!msg.default_nested_enum) {
      msg.default_nested_enum = 0;
    }
    if (!msg.default_foreign_enum) {
      msg.default_foreign_enum = 0;
    }
    if (!msg.default_import_enum) {
      msg.default_import_enum = 0;
    }
    if (!msg.default_string_piece) {
      msg.default_string_piece = \\"\\";
    }
    if (!msg.default_cord) {
      msg.default_cord = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestAllTypes.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
    },

    encode: function (repeatedGroup) {
      const writer = new BinaryWriter();
      TestAllTypes.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.RepeatedGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child,
        NestedTestAllTypes.writeMessage
      );
    }
  },

  encode: function (nestedTestAllTypes) {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_child = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.repeated_child.push(message);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
      repeated_child: [],
    };
  },
};

export const TestDeprecatedFields = {
  writeMessage: function (msg, writer) {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
  },

  encode: function (testDeprecatedFields) {
    const writer = new BinaryWriter();
    TestDeprecatedFields.writeMessage(testDeprecatedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.deprecated_int32) {
      msg.deprecated_int32 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedFields.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      deprecated_int32: 0,
    };
  },
};

export const TestDeprecatedMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testDeprecatedMessage) {
    const writer = new BinaryWriter();
    TestDeprecatedMessage.writeMessage(testDeprecatedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const ForeignMessage = {
  writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
  },

  encode: function (foreignMessage) {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      c: 0,
      d: 0,
    };
  },
};

export const TestReservedFields = {
  writeMessage: function (msg, writer) {},

  encode: function (testReservedFields) {
    const writer = new BinaryWriter();
    TestReservedFields.writeMessage(testReservedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReservedFields.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestAllExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testAllExtensions) {
    const writer = new BinaryWriter();
    TestAllExtensions.writeMessage(testAllExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
  },

  encode: function (optionalGroup_extension) {
    const writer = new BinaryWriter();
    OptionalGroup_extension.writeMessage(optionalGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OptionalGroup_extension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },
};

export const RepeatedGroup_extension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
  },

  encode: function (repeatedGroup_extension) {
    const writer = new BinaryWriter();
    RepeatedGroup_extension.writeMessage(repeatedGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    RepeatedGroup_extension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },
};

export const TestGroup = {
  writeMessage: function (msg, writer) {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
  },

  encode: function (testGroup) {
    const writer = new BinaryWriter();
    TestGroup.writeMessage(testGroup, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroup.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_foreign_enum: 0,
    };
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestGroup.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestGroup.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestGroupExtension = {
  writeMessage: function (msg, writer) {},

  encode: function (testGroupExtension) {
    const writer = new BinaryWriter();
    TestGroupExtension.writeMessage(testGroupExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroupExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestNestedExtension = {
  writeMessage: function (msg, writer) {},

  encode: function (testNestedExtension) {
    const writer = new BinaryWriter();
    TestNestedExtension.writeMessage(testNestedExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  OptionalGroup_extension: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (optionalGroup_extension) {
      const writer = new BinaryWriter();
      TestNestedExtension.OptionalGroup_extension.writeMessage(
        optionalGroup_extension,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedExtension.OptionalGroup_extension.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestChildExtension = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions.writeMessage
      );
    }
  },

  encode: function (testChildExtension) {
    const writer = new BinaryWriter();
    TestChildExtension.writeMessage(testChildExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllExtensions.readMessage);
          msg.optional_extension = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
    if (!msg.b) {
      msg.b = \\"\\";
    }
    if (!msg.optional_extension) {
      msg.optional_extension = TestAllExtensions.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestChildExtension.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.defaultValue(),
    };
  },
};

export const TestRequired = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
  },

  encode: function (testRequired) {
    const writer = new BinaryWriter();
    TestRequired.writeMessage(testRequired, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.dummy2) {
      msg.dummy2 = 0;
    }
    if (!msg.b) {
      msg.b = 0;
    }
    if (!msg.dummy4) {
      msg.dummy4 = 0;
    }
    if (!msg.dummy5) {
      msg.dummy5 = 0;
    }
    if (!msg.dummy6) {
      msg.dummy6 = 0;
    }
    if (!msg.dummy7) {
      msg.dummy7 = 0;
    }
    if (!msg.dummy8) {
      msg.dummy8 = 0;
    }
    if (!msg.dummy9) {
      msg.dummy9 = 0;
    }
    if (!msg.dummy10) {
      msg.dummy10 = 0;
    }
    if (!msg.dummy11) {
      msg.dummy11 = 0;
    }
    if (!msg.dummy12) {
      msg.dummy12 = 0;
    }
    if (!msg.dummy13) {
      msg.dummy13 = 0;
    }
    if (!msg.dummy14) {
      msg.dummy14 = 0;
    }
    if (!msg.dummy15) {
      msg.dummy15 = 0;
    }
    if (!msg.dummy16) {
      msg.dummy16 = 0;
    }
    if (!msg.dummy17) {
      msg.dummy17 = 0;
    }
    if (!msg.dummy18) {
      msg.dummy18 = 0;
    }
    if (!msg.dummy19) {
      msg.dummy19 = 0;
    }
    if (!msg.dummy20) {
      msg.dummy20 = 0;
    }
    if (!msg.dummy21) {
      msg.dummy21 = 0;
    }
    if (!msg.dummy22) {
      msg.dummy22 = 0;
    }
    if (!msg.dummy23) {
      msg.dummy23 = 0;
    }
    if (!msg.dummy24) {
      msg.dummy24 = 0;
    }
    if (!msg.dummy25) {
      msg.dummy25 = 0;
    }
    if (!msg.dummy26) {
      msg.dummy26 = 0;
    }
    if (!msg.dummy27) {
      msg.dummy27 = 0;
    }
    if (!msg.dummy28) {
      msg.dummy28 = 0;
    }
    if (!msg.dummy29) {
      msg.dummy29 = 0;
    }
    if (!msg.dummy30) {
      msg.dummy30 = 0;
    }
    if (!msg.dummy31) {
      msg.dummy31 = 0;
    }
    if (!msg.dummy32) {
      msg.dummy32 = 0;
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequired.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },
};

export const TestRequiredForeign = {
  writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired.writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
  },

  encode: function (testRequiredForeign) {
    const writer = new BinaryWriter();
    TestRequiredForeign.writeMessage(testRequiredForeign, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.dummy) {
      msg.dummy = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredForeign.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      dummy: 0,
    };
  },
};

export const TestRequiredMessage = {
  writeMessage: function (msg, writer) {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message,
        TestRequired.writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired.writeMessage);
    }
  },

  encode: function (testRequiredMessage) {
    const writer = new BinaryWriter();
    TestRequiredMessage.writeMessage(testRequiredMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message);
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.required_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.required_message) {
      msg.required_message = TestRequired.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      required_message: TestRequired.defaultValue(),
    };
  },
};

export const TestForeignNested = {
  writeMessage: function (msg, writer) {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testForeignNested) {
    const writer = new BinaryWriter();
    TestForeignNested.writeMessage(testForeignNested, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.foreign_nested = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foreign_nested) {
      msg.foreign_nested = TestAllTypes.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestForeignNested.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foreign_nested: TestAllTypes.NestedMessage.defaultValue(),
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessage) {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessageWithExtensions) {
    const writer = new BinaryWriter();
    TestEmptyMessageWithExtensions.writeMessage(
      testEmptyMessageWithExtensions,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessageWithExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testPickleNestedMessage) {
    const writer = new BinaryWriter();
    TestPickleNestedMessage.writeMessage(testPickleNestedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPickleNestedMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestPickleNestedMessage.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestPickleNestedMessage.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },

    NestedNestedMessage: {
      writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
      },

      encode: function (nestedNestedMessage) {
        const writer = new BinaryWriter();
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.writeMessage(
          nestedNestedMessage,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.cc) {
          msg.cc = 0;
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          cc: 0,
        };
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  writeMessage: function (msg, writer) {},

  encode: function (testMultipleExtensionRanges) {
    const writer = new BinaryWriter();
    TestMultipleExtensionRanges.writeMessage(
      testMultipleExtensionRanges,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMultipleExtensionRanges.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
  },

  encode: function (testReallyLargeTagNumber) {
    const writer = new BinaryWriter();
    TestReallyLargeTagNumber.writeMessage(testReallyLargeTagNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.bb) {
      msg.bb = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReallyLargeTagNumber.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
      bb: 0,
    };
  },
};

export const TestRecursiveMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage.writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
  },

  encode: function (testRecursiveMessage) {
    const writer = new BinaryWriter();
    TestRecursiveMessage.writeMessage(testRecursiveMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRecursiveMessage.readMessage);
          msg.a = message;
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestRecursiveMessage.defaultValue();
    }
    if (!msg.i) {
      msg.i = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: TestRecursiveMessage.defaultValue(),
      i: 0,
    };
  },
};

export const TestMutualRecursionA = {
  writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB.writeMessage);
    }
  },

  encode: function (testMutualRecursionA) {
    const writer = new BinaryWriter();
    TestMutualRecursionA.writeMessage(testMutualRecursionA, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionB.readMessage);
          msg.bb = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.bb) {
      msg.bb = TestMutualRecursionB.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionA.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      bb: TestMutualRecursionB.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB.writeMessage);
      }
    },

    encode: function (subMessage) {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestMutualRecursionB.readMessage);
            msg.b = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.b) {
        msg.b = TestMutualRecursionB.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        b: TestMutualRecursionB.defaultValue(),
      };
    },
  },

  SubGroup: {
    writeMessage: function (msg, writer) {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage.writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes.writeMessage);
      }
    },

    encode: function (subGroup) {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubGroup.writeMessage(subGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            const message = {};
            reader.readMessage(
              message,
              TestMutualRecursionA.SubMessage.readMessage
            );
            msg.sub_message = message;
            break;
          }
          case 4: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.not_in_this_scc = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.sub_message) {
        msg.sub_message = TestMutualRecursionA.SubMessage.defaultValue();
      }
      if (!msg.not_in_this_scc) {
        msg.not_in_this_scc = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        sub_message: TestMutualRecursionA.SubMessage.defaultValue(),
        not_in_this_scc: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestMutualRecursionB = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA.writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
  },

  encode: function (testMutualRecursionB) {
    const writer = new BinaryWriter();
    TestMutualRecursionB.writeMessage(testMutualRecursionB, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionA.readMessage);
          msg.a = message;
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestMutualRecursionA.defaultValue();
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionB.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: TestMutualRecursionA.defaultValue(),
      optional_int32: 0,
    };
  },
};

export const TestIsInitialized = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage.writeMessage
      );
    }
  },

  encode: function (testIsInitialized) {
    const writer = new BinaryWriter();
    TestIsInitialized.writeMessage(testIsInitialized, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestIsInitialized.SubMessage.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestIsInitialized.SubMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestIsInitialized.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestIsInitialized.SubMessage.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (msg, writer) {},

    encode: function (subMessage) {
      const writer = new BinaryWriter();
      TestIsInitialized.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestIsInitialized.SubMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {};
    },

    SubGroup: {
      writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
      },

      encode: function (subGroup) {
        const writer = new BinaryWriter();
        TestIsInitialized.SubMessage.SubGroup.writeMessage(subGroup, writer);
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.i) {
          msg.i = 0;
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestIsInitialized.SubMessage.SubGroup.readMessage(message, reader);
        return message;
      },

      defaultValue: function () {
        return {
          i: 0,
        };
      },
    },
  },
};

export const TestDupFieldNumber = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
  },

  encode: function (testDupFieldNumber) {
    const writer = new BinaryWriter();
    TestDupFieldNumber.writeMessage(testDupFieldNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDupFieldNumber.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: 0,
    };
  },

  Foo: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (foo) {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Foo.writeMessage(foo, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Foo.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },

  Bar: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (bar) {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Bar.writeMessage(bar, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Bar.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
      };
    },
  },
};

export const TestEagerMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testEagerMessage) {
    const writer = new BinaryWriter();
    TestEagerMessage.writeMessage(testEagerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEagerMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestLazyMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testLazyMessage) {
    const writer = new BinaryWriter();
    TestLazyMessage.writeMessage(testLazyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestLazyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestNestedMessageHasBits = {
  writeMessage: function (msg, writer) {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testNestedMessageHasBits) {
    const writer = new BinaryWriter();
    TestNestedMessageHasBits.writeMessage(testNestedMessageHasBits, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(
            message,
            TestNestedMessageHasBits.NestedMessage.readMessage
          );
          msg.optional_nested_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestNestedMessageHasBits.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedMessageHasBits.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage,
          ForeignMessage.writeMessage
        );
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestNestedMessageHasBits.NestedMessage.writeMessage(
        nestedMessage,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.nestedmessage_repeated_int32 = [];
      msg.nestedmessage_repeated_foreignmessage = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, ForeignMessage.readMessage);
            msg.nestedmessage_repeated_foreignmessage.push(message);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedMessageHasBits.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },
  },
};

export const TestCamelCaseFieldNames = {
  writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage.writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage.writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
  },

  encode: function (testCamelCaseFieldNames) {
    const writer = new BinaryWriter();
    TestCamelCaseFieldNames.writeMessage(testCamelCaseFieldNames, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.RepeatedPrimitiveField = [];
    msg.RepeatedStringField = [];
    msg.RepeatedEnumField = [];
    msg.RepeatedMessageField = [];
    msg.RepeatedStringPieceField = [];
    msg.RepeatedCordField = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.MessageField = message;
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.RepeatedMessageField.push(message);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.PrimitiveField) {
      msg.PrimitiveField = 0;
    }
    if (!msg.StringField) {
      msg.StringField = \\"\\";
    }
    if (!msg.EnumField) {
      msg.EnumField = 0;
    }
    if (!msg.MessageField) {
      msg.MessageField = ForeignMessage.defaultValue();
    }
    if (!msg.StringPieceField) {
      msg.StringPieceField = \\"\\";
    }
    if (!msg.CordField) {
      msg.CordField = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCamelCaseFieldNames.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.defaultValue(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },
};

export const TestFieldOrderings = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testFieldOrderings) {
    const writer = new BinaryWriter();
    TestFieldOrderings.writeMessage(testFieldOrderings, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          const message = {};
          reader.readMessage(
            message,
            TestFieldOrderings.NestedMessage.readMessage
          );
          msg.optional_nested_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
    if (!msg.my_int) {
      msg.my_int = \\"\\";
    }
    if (!msg.my_float) {
      msg.my_float = 0;
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestFieldOrderings.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestFieldOrderings.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestFieldOrderings.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.oo) {
        msg.oo = \\"\\";
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestFieldOrderings.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },
  },
};

export const TestExtensionOrderings1 = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (testExtensionOrderings1) {
    const writer = new BinaryWriter();
    TestExtensionOrderings1.writeMessage(testExtensionOrderings1, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings1.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
    };
  },
};

export const TestExtensionOrderings2 = {
  writeMessage: function (msg, writer) {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (testExtensionOrderings2) {
    const writer = new BinaryWriter();
    TestExtensionOrderings2.writeMessage(testExtensionOrderings2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      my_string: \\"\\",
    };
  },

  TestExtensionOrderings3: {
    writeMessage: function (msg, writer) {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
    },

    encode: function (testExtensionOrderings3) {
      const writer = new BinaryWriter();
      TestExtensionOrderings2.TestExtensionOrderings3.writeMessage(
        testExtensionOrderings3,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.my_string) {
        msg.my_string = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestExtensionOrderings2.TestExtensionOrderings3.readMessage(
        message,
        reader
      );
      return message;
    },

    defaultValue: function () {
      return {
        my_string: \\"\\",
      };
    },
  },
};

export const TestExtremeDefaultValues = {
  writeMessage: function (msg, writer) {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
  },

  encode: function (testExtremeDefaultValues) {
    const writer = new BinaryWriter();
    TestExtremeDefaultValues.writeMessage(testExtremeDefaultValues, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.escaped_bytes) {
      msg.escaped_bytes = new Uint8Array();
    }
    if (!msg.large_uint32) {
      msg.large_uint32 = 0;
    }
    if (!msg.large_uint64) {
      msg.large_uint64 = \\"\\";
    }
    if (!msg.small_int32) {
      msg.small_int32 = 0;
    }
    if (!msg.small_int64) {
      msg.small_int64 = \\"\\";
    }
    if (!msg.really_small_int32) {
      msg.really_small_int32 = 0;
    }
    if (!msg.really_small_int64) {
      msg.really_small_int64 = \\"\\";
    }
    if (!msg.utf8_string) {
      msg.utf8_string = \\"\\";
    }
    if (!msg.zero_float) {
      msg.zero_float = 0;
    }
    if (!msg.one_float) {
      msg.one_float = 0;
    }
    if (!msg.small_float) {
      msg.small_float = 0;
    }
    if (!msg.negative_one_float) {
      msg.negative_one_float = 0;
    }
    if (!msg.negative_float) {
      msg.negative_float = 0;
    }
    if (!msg.large_float) {
      msg.large_float = 0;
    }
    if (!msg.small_negative_float) {
      msg.small_negative_float = 0;
    }
    if (!msg.inf_double) {
      msg.inf_double = 0;
    }
    if (!msg.neg_inf_double) {
      msg.neg_inf_double = 0;
    }
    if (!msg.nan_double) {
      msg.nan_double = 0;
    }
    if (!msg.inf_float) {
      msg.inf_float = 0;
    }
    if (!msg.neg_inf_float) {
      msg.neg_inf_float = 0;
    }
    if (!msg.nan_float) {
      msg.nan_float = 0;
    }
    if (!msg.cpp_trigraph) {
      msg.cpp_trigraph = \\"\\";
    }
    if (!msg.string_with_zero) {
      msg.string_with_zero = \\"\\";
    }
    if (!msg.bytes_with_zero) {
      msg.bytes_with_zero = new Uint8Array();
    }
    if (!msg.string_piece_with_zero) {
      msg.string_piece_with_zero = \\"\\";
    }
    if (!msg.cord_with_zero) {
      msg.cord_with_zero = \\"\\";
    }
    if (!msg.replacement_string) {
      msg.replacement_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtremeDefaultValues.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },
};

export const SparseEnumMessage = {
  writeMessage: function (msg, writer) {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
  },

  encode: function (sparseEnumMessage) {
    const writer = new BinaryWriter();
    SparseEnumMessage.writeMessage(sparseEnumMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sparse_enum) {
      msg.sparse_enum = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    SparseEnumMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      sparse_enum: 0,
    };
  },
};

export const OneString = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (oneString) {
    const writer = new BinaryWriter();
    OneString.writeMessage(oneString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneString.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const MoreString = {
  writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
  },

  encode: function (moreString) {
    const writer = new BinaryWriter();
    MoreString.writeMessage(moreString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreString.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: [],
    };
  },
};

export const OneBytes = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
  },

  encode: function (oneBytes) {
    const writer = new BinaryWriter();
    OneBytes.writeMessage(oneBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = new Uint8Array();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneBytes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: new Uint8Array(),
    };
  },
};

export const MoreBytes = {
  writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
  },

  encode: function (moreBytes) {
    const writer = new BinaryWriter();
    MoreBytes.writeMessage(moreBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreBytes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: [],
    };
  },
};

export const Int32Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
  },

  encode: function (int32Message) {
    const writer = new BinaryWriter();
    Int32Message.writeMessage(int32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int32Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: 0,
    };
  },
};

export const Uint32Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
  },

  encode: function (uint32Message) {
    const writer = new BinaryWriter();
    Uint32Message.writeMessage(uint32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint32Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: 0,
    };
  },
};

export const Int64Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
  },

  encode: function (int64Message) {
    const writer = new BinaryWriter();
    Int64Message.writeMessage(int64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int64Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const Uint64Message = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
  },

  encode: function (uint64Message) {
    const writer = new BinaryWriter();
    Uint64Message.writeMessage(uint64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint64Message.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: \\"\\",
    };
  },
};

export const BoolMessage = {
  writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
  },

  encode: function (boolMessage) {
    const writer = new BinaryWriter();
    BoolMessage.writeMessage(boolMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = false;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BoolMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      data: false,
    };
  },
};

export const TestOneof = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneof) {
    const writer = new BinaryWriter();
    TestOneof.writeMessage(testOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneof.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneofBackwardsCompatible = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneofBackwardsCompatible) {
    const writer = new BinaryWriter();
    TestOneofBackwardsCompatible.writeMessage(
      testOneofBackwardsCompatible,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_int) {
      msg.foo_int = 0;
    }
    if (!msg.foo_string) {
      msg.foo_string = \\"\\";
    }
    if (!msg.foo_message) {
      msg.foo_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneofBackwardsCompatible.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneofBackwardsCompatible.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneofBackwardsCompatible.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneof2 = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
  },

  encode: function (testOneof2) {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        case 7: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_message = message;
          break;
        }
        case 11: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_lazy_message = message;
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum();
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.baz_int) {
      msg.baz_int = 0;
    }
    if (!msg.baz_string) {
      msg.baz_string = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestOneof2.NestedMessage.defaultValue(),
      foo_lazy_message: TestOneof2.NestedMessage.defaultValue(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
    },

    encode: function (fooGroup) {
      const writer = new BinaryWriter();
      TestOneof2.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.FooGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestOneof2.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.corge_int = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.qux_int) {
        msg.qux_int = \\"\\";
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },
  },
};

export const TestRequiredOneof = {
  writeMessage: function (msg, writer) {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testRequiredOneof) {
    const writer = new BinaryWriter();
    TestRequiredOneof.writeMessage(testRequiredOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(
            message,
            TestRequiredOneof.NestedMessage.readMessage
          );
          msg.foo_message = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredOneof.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_message: TestRequiredOneof.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestRequiredOneof.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.required_double) {
        msg.required_double = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestRequiredOneof.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        required_double: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes) {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
  },

  encode: function (testUnpackedTypes) {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.unpacked_int32 = [];
    msg.unpacked_int64 = [];
    msg.unpacked_uint32 = [];
    msg.unpacked_uint64 = [];
    msg.unpacked_sint32 = [];
    msg.unpacked_sint64 = [];
    msg.unpacked_fixed32 = [];
    msg.unpacked_fixed64 = [];
    msg.unpacked_sfixed32 = [];
    msg.unpacked_sfixed64 = [];
    msg.unpacked_float = [];
    msg.unpacked_double = [];
    msg.unpacked_bool = [];
    msg.unpacked_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },
};

export const TestPackedExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testPackedExtensions) {
    const writer = new BinaryWriter();
    TestPackedExtensions.writeMessage(testPackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  writeMessage: function (msg, writer) {},

  encode: function (testUnpackedExtensions) {
    const writer = new BinaryWriter();
    TestUnpackedExtensions.writeMessage(testUnpackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  writeMessage: function (msg, writer) {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage.writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType.writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
  },

  encode: function (testDynamicExtensions) {
    const writer = new BinaryWriter();
    TestDynamicExtensions.writeMessage(testDynamicExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_extension = [];
    msg.packed_extension = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension = reader.readEnum();
          break;
        }
        case 2003: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.message_extension = message;
          break;
        }
        case 2004: {
          const message = {};
          reader.readMessage(
            message,
            TestDynamicExtensions.DynamicMessageType.readMessage
          );
          msg.dynamic_message_extension = message;
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.scalar_extension) {
      msg.scalar_extension = 0;
    }
    if (!msg.enum_extension) {
      msg.enum_extension = 0;
    }
    if (!msg.dynamic_enum_extension) {
      msg.dynamic_enum_extension = 0;
    }
    if (!msg.message_extension) {
      msg.message_extension = ForeignMessage.defaultValue();
    }
    if (!msg.dynamic_message_extension) {
      msg.dynamic_message_extension =
        TestDynamicExtensions.DynamicMessageType.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDynamicExtensions.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.defaultValue(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.defaultValue(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    writeMessage: function (msg, writer) {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
    },

    encode: function (dynamicMessageType) {
      const writer = new BinaryWriter();
      TestDynamicExtensions.DynamicMessageType.writeMessage(
        dynamicMessageType,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.dynamic_field) {
        msg.dynamic_field = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDynamicExtensions.DynamicMessageType.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        dynamic_field: 0,
      };
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  writeMessage: function (msg, writer) {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
  },

  encode: function (testRepeatedScalarDifferentTagSizes) {
    const writer = new BinaryWriter();
    TestRepeatedScalarDifferentTagSizes.writeMessage(
      testRepeatedScalarDifferentTagSizes,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_fixed32 = [];
    msg.repeated_int32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_int64 = [];
    msg.repeated_float = [];
    msg.repeated_uint64 = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRepeatedScalarDifferentTagSizes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },
};

export const TestParsingMerge = {
  writeMessage: function (msg, writer) {
    if (msg.required_all_types) {
      writer.writeMessage(1, msg.required_all_types, TestAllTypes.writeMessage);
    }
    if (msg.optional_all_types) {
      writer.writeMessage(2, msg.optional_all_types, TestAllTypes.writeMessage);
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types,
        TestAllTypes.writeMessage
      );
    }
  },

  encode: function (testParsingMerge) {
    const writer = new BinaryWriter();
    TestParsingMerge.writeMessage(testParsingMerge, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_all_types = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.required_all_types = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.optional_all_types = message;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.repeated_all_types.push(message);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.required_all_types) {
      msg.required_all_types = TestAllTypes.defaultValue();
    }
    if (!msg.optional_all_types) {
      msg.optional_all_types = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestParsingMerge.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      required_all_types: TestAllTypes.defaultValue(),
      optional_all_types: TestAllTypes.defaultValue(),
      repeated_all_types: [],
    };
  },

  RepeatedFieldsGenerator: {
    writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes.writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes.writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes.writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes.writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes.writeMessage);
      }
    },

    encode: function (repeatedFieldsGenerator) {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedFieldsGenerator.writeMessage(
        repeatedFieldsGenerator,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      msg.field1 = [];
      msg.field2 = [];
      msg.field3 = [];
      msg.ext1 = [];
      msg.ext2 = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field1.push(message);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field2.push(message);
            break;
          }
          case 3: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field3.push(message);
            break;
          }
          case 1000: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext1.push(message);
            break;
          }
          case 1001: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext2.push(message);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedFieldsGenerator.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    Group1: {
      writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (group1) {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group1.writeMessage(
          group1,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group1.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          field1: TestAllTypes.defaultValue(),
        };
      },
    },

    Group2: {
      writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (group2) {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group2.writeMessage(
          group2,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (bytes) {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group2.readMessage(
          message,
          reader
        );
        return message;
      },

      defaultValue: function () {
        return {
          field1: TestAllTypes.defaultValue(),
        };
      },
    },
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestParsingMerge.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.optional_group_all_types = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.optional_group_all_types) {
        msg.optional_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        optional_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (msg, writer) {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (repeatedGroup) {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.repeated_group_all_types = message;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.repeated_group_all_types) {
        msg.repeated_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        repeated_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestCommentInjectionMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
  },

  encode: function (testCommentInjectionMessage) {
    const writer = new BinaryWriter();
    TestCommentInjectionMessage.writeMessage(
      testCommentInjectionMessage,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCommentInjectionMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: \\"\\",
    };
  },
};

export const FooRequest = {
  writeMessage: function (msg, writer) {},

  encode: function (fooRequest) {
    const writer = new BinaryWriter();
    FooRequest.writeMessage(fooRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooRequest.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooResponse = {
  writeMessage: function (msg, writer) {},

  encode: function (fooResponse) {
    const writer = new BinaryWriter();
    FooResponse.writeMessage(fooResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooResponse.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooClientMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (fooClientMessage) {
    const writer = new BinaryWriter();
    FooClientMessage.writeMessage(fooClientMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooClientMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const FooServerMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (fooServerMessage) {
    const writer = new BinaryWriter();
    FooServerMessage.writeMessage(fooServerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooServerMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const BarRequest = {
  writeMessage: function (msg, writer) {},

  encode: function (barRequest) {
    const writer = new BinaryWriter();
    BarRequest.writeMessage(barRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarRequest.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const BarResponse = {
  writeMessage: function (msg, writer) {},

  encode: function (barResponse) {
    const writer = new BinaryWriter();
    BarResponse.writeMessage(barResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarResponse.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestJsonName = {
  writeMessage: function (msg, writer) {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
  },

  encode: function (testJsonName) {
    const writer = new BinaryWriter();
    TestJsonName.writeMessage(testJsonName, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field_name1) {
      msg.field_name1 = 0;
    }
    if (!msg.fieldName2) {
      msg.fieldName2 = 0;
    }
    if (!msg.FieldName3) {
      msg.FieldName3 = 0;
    }
    if (!msg._field_name4) {
      msg._field_name4 = 0;
    }
    if (!msg.FIELD_NAME5) {
      msg.FIELD_NAME5 = 0;
    }
    if (!msg.field_name6) {
      msg.field_name6 = 0;
    }
    if (!msg.fieldname7) {
      msg.fieldname7 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestJsonName.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },
};

export const TestHugeFieldNumbers = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.string_string_map[key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
  },

  encode: function (testHugeFieldNumbers) {
    const writer = new BinaryWriter();
    TestHugeFieldNumbers.writeMessage(testHugeFieldNumbers, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.packed_int32 = [];
    msg.string_string_map = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_message = message;
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.string_string_map[key] = value;
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.oneof_test_all_types = message;
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.fixed_32) {
      msg.fixed_32 = 0;
    }
    if (!msg.optional_enum) {
      msg.optional_enum = 0;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_message) {
      msg.optional_message = ForeignMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestHugeFieldNumbers.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.defaultValue(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.defaultValue(),
    };
  },

  OptionalGroup: {
    writeMessage: function (msg, writer) {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
    },

    encode: function (optionalGroup) {
      const writer = new BinaryWriter();
      TestHugeFieldNumbers.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.group_a) {
        msg.group_a = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestHugeFieldNumbers.OptionalGroup.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        group_a: 0,
      };
    },
  },
};

export const TestExtensionInsideTable = {
  writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
  },

  encode: function (testExtensionInsideTable) {
    const writer = new BinaryWriter();
    TestExtensionInsideTable.writeMessage(testExtensionInsideTable, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field1) {
      msg.field1 = 0;
    }
    if (!msg.field2) {
      msg.field2 = 0;
    }
    if (!msg.field3) {
      msg.field3 = 0;
    }
    if (!msg.field4) {
      msg.field4 = 0;
    }
    if (!msg.field6) {
      msg.field6 = 0;
    }
    if (!msg.field7) {
      msg.field7 = 0;
    }
    if (!msg.field8) {
      msg.field8 = 0;
    }
    if (!msg.field9) {
      msg.field9 = 0;
    }
    if (!msg.field10) {
      msg.field10 = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionInsideTable.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },
};

export const TestExtensionRangeSerialize = {
  writeMessage: function (msg, writer) {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
  },

  encode: function (testExtensionRangeSerialize) {
    const writer = new BinaryWriter();
    TestExtensionRangeSerialize.writeMessage(
      testExtensionRangeSerialize,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_one) {
      msg.foo_one = 0;
    }
    if (!msg.foo_two) {
      msg.foo_two = 0;
    }
    if (!msg.foo_three) {
      msg.foo_three = 0;
    }
    if (!msg.foo_four) {
      msg.foo_four = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionRangeSerialize.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.map_string_foreign_message[key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_all_types[key]);
        });
      }
    }
  },

  encode: function (testMap) {
    const writer = new BinaryWriter();
    TestMap.writeMessage(testMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    msg.map_string_foreign_message = {};
    msg.map_int32_all_types = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64[key] = value;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32[key] = value;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64[key] = value;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32[key] = value;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64[key] = value;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32[key] = value;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64[key] = value;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32[key] = value;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64[key] = value;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float[key] = value;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double[key] = value;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool[key] = value;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string[key] = value;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes[key] = value;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum[key] = value;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message[key] = value;
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_string_foreign_message[key] = value;
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_all_types[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },
};

export const TestMapSubmessage = {
  writeMessage: function (msg, writer) {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap.writeMessage);
    }
  },

  encode: function (testMapSubmessage) {
    const writer = new BinaryWriter();
    TestMapSubmessage.writeMessage(testMapSubmessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMap.readMessage);
          msg.test_map = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.test_map) {
      msg.test_map = TestMap.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMapSubmessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      test_map: TestMap.defaultValue(),
    };
  },
};

export const TestMessageMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_message[key]);
        });
      }
    }
  },

  encode: function (testMessageMap) {
    const writer = new BinaryWriter();
    TestMessageMap.writeMessage(testMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_message[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_message: {},
    };
  },
};

export const TestSameTypeMap = {
  writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
  },

  encode: function (testSameTypeMap) {
    const writer = new BinaryWriter();
    TestSameTypeMap.writeMessage(testSameTypeMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map1 = {};
    msg.map2 = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map1[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map2[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestSameTypeMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map1: {},
      map2: {},
    };
  },
};

export const TestRequiredMessageMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_field[key]);
        });
      }
    }
  },

  encode: function (testRequiredMessageMap) {
    const writer = new BinaryWriter();
    TestRequiredMessageMap.writeMessage(testRequiredMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_field = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_field[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessageMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_field: {},
    };
  },
};

export const TestArenaMap = {
  writeMessage: function (msg, writer) {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map_int32_int32[key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.map_int64_int64[key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.map_uint32_uint32[key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64[key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.map_sint32_sint32[key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64[key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32[key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64[key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32[key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64[key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.map_int32_float[key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.map_int32_double[key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.map_bool_bool[key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.map_string_string[key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.map_int32_bytes[key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.map_int32_enum[key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message[key]);
        });
      }
    }
  },

  encode: function (testArenaMap) {
    const writer = new BinaryWriter();
    TestArenaMap.writeMessage(testArenaMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32[key] = value;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64[key] = value;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32[key] = value;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64[key] = value;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32[key] = value;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64[key] = value;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32[key] = value;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64[key] = value;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32[key] = value;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64[key] = value;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float[key] = value;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double[key] = value;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool[key] = value;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string[key] = value;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes[key] = value;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum[key] = value;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestArenaMap.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },
};

export const MessageContainingMapCalledEntry = {
  writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
  },

  encode: function (messageContainingMapCalledEntry) {
    const writer = new BinaryWriter();
    MessageContainingMapCalledEntry.writeMessage(
      messageContainingMapCalledEntry,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.entry = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.entry[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    MessageContainingMapCalledEntry.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      entry: {},
    };
  },
};

export const TestRecursiveMapMessage = {
  writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
  },

  encode: function (testRecursiveMapMessage) {
    const writer = new BinaryWriter();
    TestRecursiveMapMessage.writeMessage(testRecursiveMapMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.a = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.a[key] = value;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMapMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      a: {},
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes) {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message;
          break;
        }
        case 21: {
          msg.optional_nested_enum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(message);
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (nestedMessage) {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes) {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message;
    },

    defaultValue: function () {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes) {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (msg, writer) {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes) {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (nestedTestAllTypes) {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage) {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (msg, writer) {},

  encode: function (testEmptyMessage) {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (testMessageWithDummy) {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (msg, writer) {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2) {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes) {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message;
  },

  defaultValue: function () {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
  },

  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    PublicImportMessage.writeMessage(publicImportMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<PublicImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.e) {
      msg.e = 0;
    }
  },

  decode: function (bytes: ByteSource): PublicImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    PublicImportMessage.readMessage(message, reader);
    return message as PublicImportMessage;
  },

  defaultValue: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
  },

  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ImportMessage.writeMessage(importMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes: ByteSource): ImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ImportMessage.readMessage(message, reader);
    return message as ImportMessage;
  },

  defaultValue: function (): ImportMessage {
    return {
      d: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_import_enum: ImportEnum;
  optional_string_piece: string;
  optional_cord: string;
  optional_public_import_message: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_lazy_message: TestAllTypes.NestedMessage;
  repeated_int32: number[];
  /**
   * Repeated
   */
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_import_enum: ImportEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  default_int32: number;
  default_int64: string;
  /**
   * Singular with defaults
   */
  default_uint32: number;
  default_uint64: string;
  default_sint32: number;
  default_sint64: string;
  default_fixed32: number;
  default_fixed64: string;
  default_sfixed32: number;
  default_sfixed64: string;
  default_float: number;
  default_double: number;
  default_bool: boolean;
  default_string: string;
  default_bytes: Uint8Array;
  default_nested_enum: TestAllTypes.NestedEnum;
  default_foreign_enum: ForeignEnum;
  default_import_enum: ImportEnum;
  default_string_piece: string;
  default_cord: string;
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeated_child: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecated_int32: number;
  deprecated_int32_in_oneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optional_foreign_enum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optional_extension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  required_message: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreign_nested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    sub_message: TestMutualRecursionA.SubMessage;
    not_in_this_scc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optional_int32: number;
}

export interface TestIsInitialized {
  sub_message: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  sub_message: TestAllTypes;
}

export interface TestLazyMessage {
  sub_message: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optional_nested_message: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessage_repeated_int32: number[];
    nestedmessage_repeated_foreignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  my_string: string;
  my_int: string;
  my_float: number;
  optional_nested_message: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  my_string: string;
}

export interface TestExtensionOrderings2 {
  my_string: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    my_string: string;
  }
}

export interface TestExtremeDefaultValues {
  escaped_bytes: Uint8Array;
  large_uint32: number;
  large_uint64: string;
  small_int32: number;
  small_int64: string;
  really_small_int32: number;
  really_small_int64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8_string: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zero_float: number;
  one_float: number;
  small_float: number;
  negative_one_float: number;
  negative_float: number;
  /**
   * Using exponents
   */
  large_float: number;
  small_negative_float: number;
  /**
   * Text for nonfinite floating-point values.
   */
  inf_double: number;
  neg_inf_double: number;
  nan_double: number;
  inf_float: number;
  neg_inf_float: number;
  nan_float: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cpp_trigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  string_with_zero: string;
  bytes_with_zero: Uint8Array;
  string_piece_with_zero: string;
  cord_with_zero: string;
  replacement_string: string;
}

export interface SparseEnumMessage {
  sparse_enum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  foo_int: number;
  foo_string: string;
  foo_message: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  foo_int?: number;
  foo_string?: string;
  foo_cord?: string;
  foo_string_piece?: string;
  foo_bytes?: Uint8Array;
  foo_enum?: TestOneof2.NestedEnum;
  foo_message?: TestOneof2.NestedMessage;
  foo_lazy_message?: TestOneof2.NestedMessage;
  bar_int?: number;
  bar_string?: string;
  bar_cord?: string;
  bar_string_piece?: string;
  bar_bytes?: Uint8Array;
  bar_enum?: TestOneof2.NestedEnum;
  bar_string_with_empty_default?: string;
  bar_cord_with_empty_default?: string;
  bar_string_piece_with_empty_default?: string;
  bar_bytes_with_empty_default?: Uint8Array;
  baz_int: number;
  baz_string: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    qux_int: string;
    corge_int: number[];
  }
}

export interface TestRequiredOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    required_double: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpacked_int32: number[];
  unpacked_int64: string[];
  unpacked_uint32: number[];
  unpacked_uint64: string[];
  unpacked_sint32: number[];
  unpacked_sint64: string[];
  unpacked_fixed32: number[];
  unpacked_fixed64: string[];
  unpacked_sfixed32: number[];
  unpacked_sfixed64: string[];
  unpacked_float: number[];
  unpacked_double: number[];
  unpacked_bool: boolean[];
  unpacked_enum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalar_extension: number;
  enum_extension: ForeignEnum;
  dynamic_enum_extension: TestDynamicExtensions.DynamicEnumType;
  message_extension: ForeignMessage;
  dynamic_message_extension: TestDynamicExtensions.DynamicMessageType;
  repeated_extension: string[];
  packed_extension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamic_field: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeated_fixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeated_int32: number[];
  /**
   * These have two-byte tags.
   */
  repeated_fixed64: string[];
  repeated_int64: string[];
  /**
   * Three byte tags.
   */
  repeated_float: number[];
  repeated_uint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  required_all_types: TestAllTypes;
  optional_all_types: TestAllTypes;
  repeated_all_types: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optional_group_all_types: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeated_group_all_types: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  field_name1: number;
  fieldName2: number;
  FieldName3: number;
  _field_name4: number;
  FIELD_NAME5: number;
  field_name6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optional_int32: number;
  fixed_32: number;
  repeated_int32: number[];
  packed_int32: number[];
  optional_enum: ForeignEnum;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_message: ForeignMessage;
  string_string_map: TestHugeFieldNumbers.StringStringMap;
  oneof_uint32?: number;
  oneof_test_all_types?: TestAllTypes;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    group_a: number;
  }

  export type StringStringMap = Record<string, string | undefined>;
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  foo_one: number;
  foo_two: number;
  foo_three: number;
  foo_four: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_import_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_import_enum) {
      msg.optional_import_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.default_int32) {
      msg.default_int32 = 0;
    }
    if (!msg.default_int64) {
      msg.default_int64 = \\"\\";
    }
    if (!msg.default_uint32) {
      msg.default_uint32 = 0;
    }
    if (!msg.default_uint64) {
      msg.default_uint64 = \\"\\";
    }
    if (!msg.default_sint32) {
      msg.default_sint32 = 0;
    }
    if (!msg.default_sint64) {
      msg.default_sint64 = \\"\\";
    }
    if (!msg.default_fixed32) {
      msg.default_fixed32 = 0;
    }
    if (!msg.default_fixed64) {
      msg.default_fixed64 = \\"\\";
    }
    if (!msg.default_sfixed32) {
      msg.default_sfixed32 = 0;
    }
    if (!msg.default_sfixed64) {
      msg.default_sfixed64 = \\"\\";
    }
    if (!msg.default_float) {
      msg.default_float = 0;
    }
    if (!msg.default_double) {
      msg.default_double = 0;
    }
    if (!msg.default_bool) {
      msg.default_bool = false;
    }
    if (!msg.default_string) {
      msg.default_string = \\"\\";
    }
    if (!msg.default_bytes) {
      msg.default_bytes = new Uint8Array();
    }
    if (!msg.default_nested_enum) {
      msg.default_nested_enum = 0;
    }
    if (!msg.default_foreign_enum) {
      msg.default_foreign_enum = 0;
    }
    if (!msg.default_import_enum) {
      msg.default_import_enum = 0;
    }
    if (!msg.default_string_piece) {
      msg.default_string_piece = \\"\\";
    }
    if (!msg.default_cord) {
      msg.default_cord = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.OptionalGroup.readMessage(message, reader);
      return message as TestAllTypes.OptionalGroup;
    },

    defaultValue: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
    },

    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.RepeatedGroup.readMessage(message, reader);
      return message as TestAllTypes.RepeatedGroup;
    },

    defaultValue: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child as any,
        NestedTestAllTypes.writeMessage
      );
    }
  },

  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_child = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.repeated_child.push(message as NestedTestAllTypes);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
      repeated_child: [],
    };
  },
};

export const TestDeprecatedFields = {
  writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): void {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
  },

  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDeprecatedFields.writeMessage(testDeprecatedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDeprecatedFields>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.deprecated_int32) {
      msg.deprecated_int32 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestDeprecatedFields {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedFields.readMessage(message, reader);
    return message as TestDeprecatedFields;
  },

  defaultValue: function (): TestDeprecatedFields {
    return {
      deprecated_int32: 0,
    };
  },
};

export const TestDeprecatedMessage = {
  writeMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testDeprecatedMessage: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDeprecatedMessage.writeMessage(testDeprecatedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestDeprecatedMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedMessage.readMessage(message, reader);
    return message as TestDeprecatedMessage;
  },

  defaultValue: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
  },

  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },
};

export const TestReservedFields = {
  writeMessage: function (
    msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testReservedFields: Partial<TestReservedFields>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestReservedFields.writeMessage(testReservedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestReservedFields>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestReservedFields {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReservedFields.readMessage(message, reader);
    return message as TestReservedFields;
  },

  defaultValue: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  writeMessage: function (
    msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (testAllExtensions: Partial<TestAllExtensions>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllExtensions.writeMessage(testAllExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestAllExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllExtensions.readMessage(message, reader);
    return message as TestAllExtensions;
  },

  defaultValue: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
  },

  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    OptionalGroup_extension.writeMessage(optionalGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<OptionalGroup_extension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): OptionalGroup_extension {
    const reader = new BinaryReader(bytes);
    const message = {};
    OptionalGroup_extension.readMessage(message, reader);
    return message as OptionalGroup_extension;
  },

  defaultValue: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },
};

export const RepeatedGroup_extension = {
  writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
  },

  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    RepeatedGroup_extension.writeMessage(repeatedGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    const reader = new BinaryReader(bytes);
    const message = {};
    RepeatedGroup_extension.readMessage(message, reader);
    return message as RepeatedGroup_extension;
  },

  defaultValue: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },
};

export const TestGroup = {
  writeMessage: function (msg: Partial<TestGroup>, writer: BinaryWriter): void {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
  },

  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    const writer = new BinaryWriter();
    TestGroup.writeMessage(testGroup, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestGroup>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
  },

  decode: function (bytes: ByteSource): TestGroup {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroup.readMessage(message, reader);
    return message as TestGroup;
  },

  defaultValue: function (): TestGroup {
    return {
      optional_foreign_enum: 0,
    };
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestGroup.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestGroup.OptionalGroup.readMessage(message, reader);
      return message as TestGroup.OptionalGroup;
    },

    defaultValue: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },
  },
};

export const TestGroupExtension = {
  writeMessage: function (
    msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testGroupExtension: Partial<TestGroupExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestGroupExtension.writeMessage(testGroupExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestGroupExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestGroupExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroupExtension.readMessage(message, reader);
    return message as TestGroupExtension;
  },

  defaultValue: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  writeMessage: function (
    msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testNestedExtension: Partial<TestNestedExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestNestedExtension.writeMessage(testNestedExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestNestedExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestNestedExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedExtension.readMessage(message, reader);
    return message as TestNestedExtension;
  },

  defaultValue: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestNestedExtension.OptionalGroup_extension.writeMessage(
        optionalGroup_extension,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedExtension.OptionalGroup_extension.readMessage(message, reader);
      return message as TestNestedExtension.OptionalGroup_extension;
    },

    defaultValue: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },
  },
};

export const TestChildExtension = {
  writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions.writeMessage
      );
    }
  },

  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestChildExtension.writeMessage(testChildExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestChildExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllExtensions.readMessage);
          msg.optional_extension = message as TestAllExtensions;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
    if (!msg.b) {
      msg.b = \\"\\";
    }
    if (!msg.optional_extension) {
      msg.optional_extension = TestAllExtensions.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestChildExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestChildExtension.readMessage(message, reader);
    return message as TestChildExtension;
  },

  defaultValue: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.defaultValue(),
    };
  },
};

export const TestRequired = {
  writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
  },

  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    const writer = new BinaryWriter();
    TestRequired.writeMessage(testRequired, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequired>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.dummy2) {
      msg.dummy2 = 0;
    }
    if (!msg.b) {
      msg.b = 0;
    }
    if (!msg.dummy4) {
      msg.dummy4 = 0;
    }
    if (!msg.dummy5) {
      msg.dummy5 = 0;
    }
    if (!msg.dummy6) {
      msg.dummy6 = 0;
    }
    if (!msg.dummy7) {
      msg.dummy7 = 0;
    }
    if (!msg.dummy8) {
      msg.dummy8 = 0;
    }
    if (!msg.dummy9) {
      msg.dummy9 = 0;
    }
    if (!msg.dummy10) {
      msg.dummy10 = 0;
    }
    if (!msg.dummy11) {
      msg.dummy11 = 0;
    }
    if (!msg.dummy12) {
      msg.dummy12 = 0;
    }
    if (!msg.dummy13) {
      msg.dummy13 = 0;
    }
    if (!msg.dummy14) {
      msg.dummy14 = 0;
    }
    if (!msg.dummy15) {
      msg.dummy15 = 0;
    }
    if (!msg.dummy16) {
      msg.dummy16 = 0;
    }
    if (!msg.dummy17) {
      msg.dummy17 = 0;
    }
    if (!msg.dummy18) {
      msg.dummy18 = 0;
    }
    if (!msg.dummy19) {
      msg.dummy19 = 0;
    }
    if (!msg.dummy20) {
      msg.dummy20 = 0;
    }
    if (!msg.dummy21) {
      msg.dummy21 = 0;
    }
    if (!msg.dummy22) {
      msg.dummy22 = 0;
    }
    if (!msg.dummy23) {
      msg.dummy23 = 0;
    }
    if (!msg.dummy24) {
      msg.dummy24 = 0;
    }
    if (!msg.dummy25) {
      msg.dummy25 = 0;
    }
    if (!msg.dummy26) {
      msg.dummy26 = 0;
    }
    if (!msg.dummy27) {
      msg.dummy27 = 0;
    }
    if (!msg.dummy28) {
      msg.dummy28 = 0;
    }
    if (!msg.dummy29) {
      msg.dummy29 = 0;
    }
    if (!msg.dummy30) {
      msg.dummy30 = 0;
    }
    if (!msg.dummy31) {
      msg.dummy31 = 0;
    }
    if (!msg.dummy32) {
      msg.dummy32 = 0;
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRequired {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequired.readMessage(message, reader);
    return message as TestRequired;
  },

  defaultValue: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },
};

export const TestRequiredForeign = {
  writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired.writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
  },

  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredForeign.writeMessage(testRequiredForeign, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredForeign>,
    reader: BinaryReader
  ): void {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message as TestRequired;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message as TestRequired);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.dummy) {
      msg.dummy = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRequiredForeign {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredForeign.readMessage(message, reader);
    return message as TestRequiredForeign;
  },

  defaultValue: function (): TestRequiredForeign {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      dummy: 0,
    };
  },
};

export const TestRequiredMessage = {
  writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired.writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired.writeMessage);
    }
  },

  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredMessage.writeMessage(testRequiredMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredMessage>,
    reader: BinaryReader
  ): void {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message as TestRequired;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message as TestRequired);
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.required_message = message as TestRequired;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.required_message) {
      msg.required_message = TestRequired.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestRequiredMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessage.readMessage(message, reader);
    return message as TestRequiredMessage;
  },

  defaultValue: function (): TestRequiredMessage {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      required_message: TestRequired.defaultValue(),
    };
  },
};

export const TestForeignNested = {
  writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): void {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    const writer = new BinaryWriter();
    TestForeignNested.writeMessage(testForeignNested, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestForeignNested>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.foreign_nested = message as TestAllTypes.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foreign_nested) {
      msg.foreign_nested = TestAllTypes.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestForeignNested {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestForeignNested.readMessage(message, reader);
    return message as TestForeignNested;
  },

  defaultValue: function (): TestForeignNested {
    return {
      foreign_nested: TestAllTypes.NestedMessage.defaultValue(),
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  writeMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testEmptyMessageWithExtensions: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessageWithExtensions.writeMessage(
      testEmptyMessageWithExtensions,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessageWithExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessageWithExtensions.readMessage(message, reader);
    return message as TestEmptyMessageWithExtensions;
  },

  defaultValue: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  writeMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testPickleNestedMessage: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestPickleNestedMessage.writeMessage(testPickleNestedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPickleNestedMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPickleNestedMessage.readMessage(message, reader);
    return message as TestPickleNestedMessage;
  },

  defaultValue: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestPickleNestedMessage.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestPickleNestedMessage.NestedMessage.readMessage(message, reader);
      return message as TestPickleNestedMessage.NestedMessage;
    },

    defaultValue: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    NestedNestedMessage: {
      writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): void {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
      },

      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.writeMessage(
          nestedNestedMessage,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.cc) {
          msg.cc = 0;
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.readMessage(
          message,
          reader
        );
        return message as TestPickleNestedMessage.NestedMessage.NestedNestedMessage;
      },

      defaultValue:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },
    },
  },
};

export const TestMultipleExtensionRanges = {
  writeMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testMultipleExtensionRanges: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMultipleExtensionRanges.writeMessage(
      testMultipleExtensionRanges,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMultipleExtensionRanges {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMultipleExtensionRanges.readMessage(message, reader);
    return message as TestMultipleExtensionRanges;
  },

  defaultValue: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
  },

  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestReallyLargeTagNumber.writeMessage(testReallyLargeTagNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.bb) {
      msg.bb = 0;
    }
  },

  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReallyLargeTagNumber.readMessage(message, reader);
    return message as TestReallyLargeTagNumber;
  },

  defaultValue: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },
};

export const TestRecursiveMessage = {
  writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage.writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
  },

  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRecursiveMessage.writeMessage(testRecursiveMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRecursiveMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRecursiveMessage.readMessage);
          msg.a = message as TestRecursiveMessage;
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestRecursiveMessage.defaultValue();
    }
    if (!msg.i) {
      msg.i = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRecursiveMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMessage.readMessage(message, reader);
    return message as TestRecursiveMessage;
  },

  defaultValue: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.defaultValue(),
      i: 0,
    };
  },
};

export const TestMutualRecursionA = {
  writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): void {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB.writeMessage);
    }
  },

  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMutualRecursionA.writeMessage(testMutualRecursionA, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMutualRecursionA>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionB.readMessage);
          msg.bb = message as TestMutualRecursionB;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.bb) {
      msg.bb = TestMutualRecursionB.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestMutualRecursionA {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionA.readMessage(message, reader);
    return message as TestMutualRecursionA;
  },

  defaultValue: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB.writeMessage);
      }
    },

    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestMutualRecursionB.readMessage);
            msg.b = message as TestMutualRecursionB;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.b) {
        msg.b = TestMutualRecursionB.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubMessage.readMessage(message, reader);
      return message as TestMutualRecursionA.SubMessage;
    },

    defaultValue: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.defaultValue(),
      };
    },
  },

  SubGroup: {
    writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage.writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes.writeMessage);
      }
    },

    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubGroup.writeMessage(subGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            const message = {};
            reader.readMessage(
              message,
              TestMutualRecursionA.SubMessage.readMessage
            );
            msg.sub_message = message as TestMutualRecursionA.SubMessage;
            break;
          }
          case 4: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.not_in_this_scc = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.sub_message) {
        msg.sub_message = TestMutualRecursionA.SubMessage.defaultValue();
      }
      if (!msg.not_in_this_scc) {
        msg.not_in_this_scc = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubGroup.readMessage(message, reader);
      return message as TestMutualRecursionA.SubGroup;
    },

    defaultValue: function (): TestMutualRecursionA.SubGroup {
      return {
        sub_message: TestMutualRecursionA.SubMessage.defaultValue(),
        not_in_this_scc: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestMutualRecursionB = {
  writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA.writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
  },

  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMutualRecursionB.writeMessage(testMutualRecursionB, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMutualRecursionB>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionA.readMessage);
          msg.a = message as TestMutualRecursionA;
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestMutualRecursionA.defaultValue();
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestMutualRecursionB {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionB.readMessage(message, reader);
    return message as TestMutualRecursionB;
  },

  defaultValue: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.defaultValue(),
      optional_int32: 0,
    };
  },
};

export const TestIsInitialized = {
  writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage.writeMessage
      );
    }
  },

  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    const writer = new BinaryWriter();
    TestIsInitialized.writeMessage(testIsInitialized, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestIsInitialized>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestIsInitialized.SubMessage.readMessage);
          msg.sub_message = message as TestIsInitialized.SubMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestIsInitialized.SubMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestIsInitialized {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestIsInitialized.readMessage(message, reader);
    return message as TestIsInitialized;
  },

  defaultValue: function (): TestIsInitialized {
    return {
      sub_message: TestIsInitialized.SubMessage.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): void {},

    encode: function (
      subMessage: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestIsInitialized.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes: ByteSource): TestIsInitialized.SubMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestIsInitialized.SubMessage.readMessage(message, reader);
      return message as TestIsInitialized.SubMessage;
    },

    defaultValue: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): void {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
      },

      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestIsInitialized.SubMessage.SubGroup.writeMessage(subGroup, writer);
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.i) {
          msg.i = 0;
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestIsInitialized.SubMessage.SubGroup.readMessage(message, reader);
        return message as TestIsInitialized.SubMessage.SubGroup;
      },

      defaultValue: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },
    },
  },
};

export const TestDupFieldNumber = {
  writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
  },

  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDupFieldNumber.writeMessage(testDupFieldNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDupFieldNumber>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): TestDupFieldNumber {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDupFieldNumber.readMessage(message, reader);
    return message as TestDupFieldNumber;
  },

  defaultValue: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  Foo: {
    writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Foo.writeMessage(foo, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Foo.readMessage(message, reader);
      return message as TestDupFieldNumber.Foo;
    },

    defaultValue: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },
  },

  Bar: {
    writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Bar.writeMessage(bar, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Bar.readMessage(message, reader);
      return message as TestDupFieldNumber.Bar;
    },

    defaultValue: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },
  },
};

export const TestEagerMessage = {
  writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEagerMessage.writeMessage(testEagerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEagerMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestEagerMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEagerMessage.readMessage(message, reader);
    return message as TestEagerMessage;
  },

  defaultValue: function (): TestEagerMessage {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestLazyMessage = {
  writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestLazyMessage.writeMessage(testLazyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestLazyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestLazyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestLazyMessage.readMessage(message, reader);
    return message as TestLazyMessage;
  },

  defaultValue: function (): TestLazyMessage {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestNestedMessageHasBits = {
  writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage.writeMessage
      );
    }
  },

  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestNestedMessageHasBits.writeMessage(testNestedMessageHasBits, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(
            message,
            TestNestedMessageHasBits.NestedMessage.readMessage
          );
          msg.optional_nested_message =
            message as TestNestedMessageHasBits.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestNestedMessageHasBits.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedMessageHasBits.readMessage(message, reader);
    return message as TestNestedMessageHasBits;
  },

  defaultValue: function (): TestNestedMessageHasBits {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage as any,
          ForeignMessage.writeMessage
        );
      }
    },

    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestNestedMessageHasBits.NestedMessage.writeMessage(
        nestedMessage,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      reader: BinaryReader
    ): void {
      msg.nestedmessage_repeated_int32 = [];
      msg.nestedmessage_repeated_foreignmessage = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, ForeignMessage.readMessage);
            msg.nestedmessage_repeated_foreignmessage.push(
              message as ForeignMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedMessageHasBits.NestedMessage.readMessage(message, reader);
      return message as TestNestedMessageHasBits.NestedMessage;
    },

    defaultValue: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },
  },
};

export const TestCamelCaseFieldNames = {
  writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): void {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage.writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
  },

  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestCamelCaseFieldNames.writeMessage(testCamelCaseFieldNames, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    reader: BinaryReader
  ): void {
    msg.RepeatedPrimitiveField = [];
    msg.RepeatedStringField = [];
    msg.RepeatedEnumField = [];
    msg.RepeatedMessageField = [];
    msg.RepeatedStringPieceField = [];
    msg.RepeatedCordField = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.MessageField = message as ForeignMessage;
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.RepeatedMessageField.push(message as ForeignMessage);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.PrimitiveField) {
      msg.PrimitiveField = 0;
    }
    if (!msg.StringField) {
      msg.StringField = \\"\\";
    }
    if (!msg.EnumField) {
      msg.EnumField = 0;
    }
    if (!msg.MessageField) {
      msg.MessageField = ForeignMessage.defaultValue();
    }
    if (!msg.StringPieceField) {
      msg.StringPieceField = \\"\\";
    }
    if (!msg.CordField) {
      msg.CordField = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCamelCaseFieldNames.readMessage(message, reader);
    return message as TestCamelCaseFieldNames;
  },

  defaultValue: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.defaultValue(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },
};

export const TestFieldOrderings = {
  writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage.writeMessage
      );
    }
  },

  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestFieldOrderings.writeMessage(testFieldOrderings, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestFieldOrderings>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          const message = {};
          reader.readMessage(
            message,
            TestFieldOrderings.NestedMessage.readMessage
          );
          msg.optional_nested_message =
            message as TestFieldOrderings.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
    if (!msg.my_int) {
      msg.my_int = \\"\\";
    }
    if (!msg.my_float) {
      msg.my_float = 0;
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestFieldOrderings.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestFieldOrderings {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestFieldOrderings.readMessage(message, reader);
    return message as TestFieldOrderings;
  },

  defaultValue: function (): TestFieldOrderings {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestFieldOrderings.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.oo) {
        msg.oo = \\"\\";
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestFieldOrderings.NestedMessage.readMessage(message, reader);
      return message as TestFieldOrderings.NestedMessage;
    },

    defaultValue: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },
  },
};

export const TestExtensionOrderings1 = {
  writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionOrderings1.writeMessage(testExtensionOrderings1, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings1.readMessage(message, reader);
    return message as TestExtensionOrderings1;
  },

  defaultValue: function (): TestExtensionOrderings1 {
    return {
      my_string: \\"\\",
    };
  },
};

export const TestExtensionOrderings2 = {
  writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionOrderings2.writeMessage(testExtensionOrderings2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings2.readMessage(message, reader);
    return message as TestExtensionOrderings2;
  },

  defaultValue: function (): TestExtensionOrderings2 {
    return {
      my_string: \\"\\",
    };
  },

  TestExtensionOrderings3: {
    writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): void {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
    },

    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestExtensionOrderings2.TestExtensionOrderings3.writeMessage(
        testExtensionOrderings3,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.my_string) {
        msg.my_string = \\"\\";
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestExtensionOrderings2.TestExtensionOrderings3.readMessage(
        message,
        reader
      );
      return message as TestExtensionOrderings2.TestExtensionOrderings3;
    },

    defaultValue: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        my_string: \\"\\",
      };
    },
  },
};

export const TestExtremeDefaultValues = {
  writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): void {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
  },

  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtremeDefaultValues.writeMessage(testExtremeDefaultValues, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.escaped_bytes) {
      msg.escaped_bytes = new Uint8Array();
    }
    if (!msg.large_uint32) {
      msg.large_uint32 = 0;
    }
    if (!msg.large_uint64) {
      msg.large_uint64 = \\"\\";
    }
    if (!msg.small_int32) {
      msg.small_int32 = 0;
    }
    if (!msg.small_int64) {
      msg.small_int64 = \\"\\";
    }
    if (!msg.really_small_int32) {
      msg.really_small_int32 = 0;
    }
    if (!msg.really_small_int64) {
      msg.really_small_int64 = \\"\\";
    }
    if (!msg.utf8_string) {
      msg.utf8_string = \\"\\";
    }
    if (!msg.zero_float) {
      msg.zero_float = 0;
    }
    if (!msg.one_float) {
      msg.one_float = 0;
    }
    if (!msg.small_float) {
      msg.small_float = 0;
    }
    if (!msg.negative_one_float) {
      msg.negative_one_float = 0;
    }
    if (!msg.negative_float) {
      msg.negative_float = 0;
    }
    if (!msg.large_float) {
      msg.large_float = 0;
    }
    if (!msg.small_negative_float) {
      msg.small_negative_float = 0;
    }
    if (!msg.inf_double) {
      msg.inf_double = 0;
    }
    if (!msg.neg_inf_double) {
      msg.neg_inf_double = 0;
    }
    if (!msg.nan_double) {
      msg.nan_double = 0;
    }
    if (!msg.inf_float) {
      msg.inf_float = 0;
    }
    if (!msg.neg_inf_float) {
      msg.neg_inf_float = 0;
    }
    if (!msg.nan_float) {
      msg.nan_float = 0;
    }
    if (!msg.cpp_trigraph) {
      msg.cpp_trigraph = \\"\\";
    }
    if (!msg.string_with_zero) {
      msg.string_with_zero = \\"\\";
    }
    if (!msg.bytes_with_zero) {
      msg.bytes_with_zero = new Uint8Array();
    }
    if (!msg.string_piece_with_zero) {
      msg.string_piece_with_zero = \\"\\";
    }
    if (!msg.cord_with_zero) {
      msg.cord_with_zero = \\"\\";
    }
    if (!msg.replacement_string) {
      msg.replacement_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtremeDefaultValues.readMessage(message, reader);
    return message as TestExtremeDefaultValues;
  },

  defaultValue: function (): TestExtremeDefaultValues {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },
};

export const SparseEnumMessage = {
  writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
  },

  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    const writer = new BinaryWriter();
    SparseEnumMessage.writeMessage(sparseEnumMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<SparseEnumMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sparse_enum) {
      msg.sparse_enum = 0;
    }
  },

  decode: function (bytes: ByteSource): SparseEnumMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    SparseEnumMessage.readMessage(message, reader);
    return message as SparseEnumMessage;
  },

  defaultValue: function (): SparseEnumMessage {
    return {
      sparse_enum: 0,
    };
  },
};

export const OneString = {
  writeMessage: function (msg: Partial<OneString>, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (oneString: Partial<OneString>): Uint8Array {
    const writer = new BinaryWriter();
    OneString.writeMessage(oneString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<OneString>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): OneString {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneString.readMessage(message, reader);
    return message as OneString;
  },

  defaultValue: function (): OneString {
    return {
      data: \\"\\",
    };
  },
};

export const MoreString = {
  writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): void {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
  },

  encode: function (moreString: Partial<MoreString>): Uint8Array {
    const writer = new BinaryWriter();
    MoreString.writeMessage(moreString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<MoreString>, reader: BinaryReader): void {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MoreString {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreString.readMessage(message, reader);
    return message as MoreString;
  },

  defaultValue: function (): MoreString {
    return {
      data: [],
    };
  },
};

export const OneBytes = {
  writeMessage: function (msg: Partial<OneBytes>, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
  },

  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    const writer = new BinaryWriter();
    OneBytes.writeMessage(oneBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<OneBytes>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = new Uint8Array();
    }
  },

  decode: function (bytes: ByteSource): OneBytes {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneBytes.readMessage(message, reader);
    return message as OneBytes;
  },

  defaultValue: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },
};

export const MoreBytes = {
  writeMessage: function (msg: Partial<MoreBytes>, writer: BinaryWriter): void {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
  },

  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    const writer = new BinaryWriter();
    MoreBytes.writeMessage(moreBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<MoreBytes>, reader: BinaryReader): void {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MoreBytes {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreBytes.readMessage(message, reader);
    return message as MoreBytes;
  },

  defaultValue: function (): MoreBytes {
    return {
      data: [],
    };
  },
};

export const Int32Message = {
  writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
  },

  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    const writer = new BinaryWriter();
    Int32Message.writeMessage(int32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Int32Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes: ByteSource): Int32Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int32Message.readMessage(message, reader);
    return message as Int32Message;
  },

  defaultValue: function (): Int32Message {
    return {
      data: 0,
    };
  },
};

export const Uint32Message = {
  writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
  },

  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    const writer = new BinaryWriter();
    Uint32Message.writeMessage(uint32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Uint32Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes: ByteSource): Uint32Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint32Message.readMessage(message, reader);
    return message as Uint32Message;
  },

  defaultValue: function (): Uint32Message {
    return {
      data: 0,
    };
  },
};

export const Int64Message = {
  writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
  },

  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    const writer = new BinaryWriter();
    Int64Message.writeMessage(int64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Int64Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): Int64Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int64Message.readMessage(message, reader);
    return message as Int64Message;
  },

  defaultValue: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },
};

export const Uint64Message = {
  writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
  },

  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    const writer = new BinaryWriter();
    Uint64Message.writeMessage(uint64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Uint64Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): Uint64Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint64Message.readMessage(message, reader);
    return message as Uint64Message;
  },

  defaultValue: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },
};

export const BoolMessage = {
  writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
  },

  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    const writer = new BinaryWriter();
    BoolMessage.writeMessage(boolMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<BoolMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = false;
    }
  },

  decode: function (bytes: ByteSource): BoolMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    BoolMessage.readMessage(message, reader);
    return message as BoolMessage;
  },

  defaultValue: function (): BoolMessage {
    return {
      data: false,
    };
  },
};

export const TestOneof = {
  writeMessage: function (msg: Partial<TestOneof>, writer: BinaryWriter): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof.writeMessage(testOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof.readMessage(message, reader);
    return message as TestOneof;
  },

  defaultValue: function (): TestOneof {
    return {
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof.FooGroup.readMessage(message, reader);
      return message as TestOneof.FooGroup;
    },

    defaultValue: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneofBackwardsCompatible = {
  writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestOneofBackwardsCompatible.writeMessage(
      testOneofBackwardsCompatible,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_int) {
      msg.foo_int = 0;
    }
    if (!msg.foo_string) {
      msg.foo_string = \\"\\";
    }
    if (!msg.foo_message) {
      msg.foo_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneofBackwardsCompatible.readMessage(message, reader);
    return message as TestOneofBackwardsCompatible;
  },

  defaultValue: function (): TestOneofBackwardsCompatible {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestOneofBackwardsCompatible.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneofBackwardsCompatible.FooGroup.readMessage(message, reader);
      return message as TestOneofBackwardsCompatible.FooGroup;
    },

    defaultValue: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneof2 = {
  writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
  },

  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_message = message as TestOneof2.NestedMessage;
          break;
        }
        case 11: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_lazy_message = message as TestOneof2.NestedMessage;
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.baz_int) {
      msg.baz_int = 0;
    }
    if (!msg.baz_string) {
      msg.baz_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {
      foo_message: TestOneof2.NestedMessage.defaultValue(),
      foo_lazy_message: TestOneof2.NestedMessage.defaultValue(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
    },

    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof2.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.FooGroup.readMessage(message, reader);
      return message as TestOneof2.FooGroup;
    },

    defaultValue: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
    },

    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof2.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      reader: BinaryReader
    ): void {
      msg.corge_int = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.qux_int) {
        msg.qux_int = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.NestedMessage.readMessage(message, reader);
      return message as TestOneof2.NestedMessage;
    },

    defaultValue: function (): TestOneof2.NestedMessage {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },
  },
};

export const TestRequiredOneof = {
  writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredOneof.writeMessage(testRequiredOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredOneof>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(
            message,
            TestRequiredOneof.NestedMessage.readMessage
          );
          msg.foo_message = message as TestRequiredOneof.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRequiredOneof {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredOneof.readMessage(message, reader);
    return message as TestRequiredOneof;
  },

  defaultValue: function (): TestRequiredOneof {
    return {
      foo_message: TestRequiredOneof.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
    },

    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestRequiredOneof.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.required_double) {
        msg.required_double = 0;
      }
    },

    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestRequiredOneof.NestedMessage.readMessage(message, reader);
      return message as TestRequiredOneof.NestedMessage;
    },

    defaultValue: function (): TestRequiredOneof.NestedMessage {
      return {
        required_double: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
  },

  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.unpacked_int32 = [];
    msg.unpacked_int64 = [];
    msg.unpacked_uint32 = [];
    msg.unpacked_uint64 = [];
    msg.unpacked_sint32 = [];
    msg.unpacked_sint64 = [];
    msg.unpacked_fixed32 = [];
    msg.unpacked_fixed64 = [];
    msg.unpacked_sfixed32 = [];
    msg.unpacked_sfixed64 = [];
    msg.unpacked_float = [];
    msg.unpacked_double = [];
    msg.unpacked_bool = [];
    msg.unpacked_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },
};

export const TestPackedExtensions = {
  writeMessage: function (
    msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testPackedExtensions: Partial<TestPackedExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedExtensions.writeMessage(testPackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedExtensions.readMessage(message, reader);
    return message as TestPackedExtensions;
  },

  defaultValue: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  writeMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testUnpackedExtensions: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedExtensions.writeMessage(testUnpackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedExtensions.readMessage(message, reader);
    return message as TestUnpackedExtensions;
  },

  defaultValue: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): void {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage.writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType.writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
  },

  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDynamicExtensions.writeMessage(testDynamicExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDynamicExtensions>,
    reader: BinaryReader
  ): void {
    msg.repeated_extension = [];
    msg.packed_extension = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.message_extension = message as ForeignMessage;
          break;
        }
        case 2004: {
          const message = {};
          reader.readMessage(
            message,
            TestDynamicExtensions.DynamicMessageType.readMessage
          );
          msg.dynamic_message_extension =
            message as TestDynamicExtensions.DynamicMessageType;
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.scalar_extension) {
      msg.scalar_extension = 0;
    }
    if (!msg.enum_extension) {
      msg.enum_extension = 0;
    }
    if (!msg.dynamic_enum_extension) {
      msg.dynamic_enum_extension = 0;
    }
    if (!msg.message_extension) {
      msg.message_extension = ForeignMessage.defaultValue();
    }
    if (!msg.dynamic_message_extension) {
      msg.dynamic_message_extension =
        TestDynamicExtensions.DynamicMessageType.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestDynamicExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDynamicExtensions.readMessage(message, reader);
    return message as TestDynamicExtensions;
  },

  defaultValue: function (): TestDynamicExtensions {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.defaultValue(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.defaultValue(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): void {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
    },

    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestDynamicExtensions.DynamicMessageType.writeMessage(
        dynamicMessageType,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.dynamic_field) {
        msg.dynamic_field = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDynamicExtensions.DynamicMessageType.readMessage(message, reader);
      return message as TestDynamicExtensions.DynamicMessageType;
    },

    defaultValue: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamic_field: 0,
      };
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): void {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
  },

  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRepeatedScalarDifferentTagSizes.writeMessage(
      testRepeatedScalarDifferentTagSizes,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    reader: BinaryReader
  ): void {
    msg.repeated_fixed32 = [];
    msg.repeated_int32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_int64 = [];
    msg.repeated_float = [];
    msg.repeated_uint64 = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRepeatedScalarDifferentTagSizes.readMessage(message, reader);
    return message as TestRepeatedScalarDifferentTagSizes;
  },

  defaultValue: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },
};

export const TestParsingMerge = {
  writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): void {
    if (msg.required_all_types) {
      writer.writeMessage(1, msg.required_all_types, TestAllTypes.writeMessage);
    }
    if (msg.optional_all_types) {
      writer.writeMessage(2, msg.optional_all_types, TestAllTypes.writeMessage);
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types as any,
        TestAllTypes.writeMessage
      );
    }
  },

  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    const writer = new BinaryWriter();
    TestParsingMerge.writeMessage(testParsingMerge, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestParsingMerge>,
    reader: BinaryReader
  ): void {
    msg.repeated_all_types = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.required_all_types = message as TestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.optional_all_types = message as TestAllTypes;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.repeated_all_types.push(message as TestAllTypes);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.required_all_types) {
      msg.required_all_types = TestAllTypes.defaultValue();
    }
    if (!msg.optional_all_types) {
      msg.optional_all_types = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestParsingMerge {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestParsingMerge.readMessage(message, reader);
    return message as TestParsingMerge;
  },

  defaultValue: function (): TestParsingMerge {
    return {
      required_all_types: TestAllTypes.defaultValue(),
      optional_all_types: TestAllTypes.defaultValue(),
      repeated_all_types: [],
    };
  },

  RepeatedFieldsGenerator: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): void {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedFieldsGenerator.writeMessage(
        repeatedFieldsGenerator,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      reader: BinaryReader
    ): void {
      msg.field1 = [];
      msg.field2 = [];
      msg.field3 = [];
      msg.ext1 = [];
      msg.ext2 = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field1.push(message as TestAllTypes);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field2.push(message as TestAllTypes);
            break;
          }
          case 3: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field3.push(message as TestAllTypes);
            break;
          }
          case 1000: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext1.push(message as TestAllTypes);
            break;
          }
          case 1001: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext2.push(message as TestAllTypes);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedFieldsGenerator.readMessage(message, reader);
      return message as TestParsingMerge.RepeatedFieldsGenerator;
    },

    defaultValue: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    Group1: {
      writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): void {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group1.writeMessage(
          group1,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message as TestAllTypes;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group1.readMessage(
          message,
          reader
        );
        return message as TestParsingMerge.RepeatedFieldsGenerator.Group1;
      },

      defaultValue:
        function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
          return {
            field1: TestAllTypes.defaultValue(),
          };
        },
    },

    Group2: {
      writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): void {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group2.writeMessage(
          group2,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message as TestAllTypes;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group2.readMessage(
          message,
          reader
        );
        return message as TestParsingMerge.RepeatedFieldsGenerator.Group2;
      },

      defaultValue:
        function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
          return {
            field1: TestAllTypes.defaultValue(),
          };
        },
    },
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.optional_group_all_types = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.optional_group_all_types) {
        msg.optional_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.OptionalGroup.readMessage(message, reader);
      return message as TestParsingMerge.OptionalGroup;
    },

    defaultValue: function (): TestParsingMerge.OptionalGroup {
      return {
        optional_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.repeated_group_all_types = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.repeated_group_all_types) {
        msg.repeated_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedGroup.readMessage(message, reader);
      return message as TestParsingMerge.RepeatedGroup;
    },

    defaultValue: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeated_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestCommentInjectionMessage = {
  writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
  },

  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestCommentInjectionMessage.writeMessage(
      testCommentInjectionMessage,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCommentInjectionMessage.readMessage(message, reader);
    return message as TestCommentInjectionMessage;
  },

  defaultValue: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },
};

export const FooRequest = {
  writeMessage: function (
    msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooRequest: Partial<FooRequest>): Uint8Array {
    const writer = new BinaryWriter();
    FooRequest.writeMessage(fooRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<FooRequest>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooRequest.readMessage(message, reader);
    return message as FooRequest;
  },

  defaultValue: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  writeMessage: function (
    msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooResponse: Partial<FooResponse>): Uint8Array {
    const writer = new BinaryWriter();
    FooResponse.writeMessage(fooResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooResponse.readMessage(message, reader);
    return message as FooResponse;
  },

  defaultValue: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  writeMessage: function (
    msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooClientMessage: Partial<FooClientMessage>): Uint8Array {
    const writer = new BinaryWriter();
    FooClientMessage.writeMessage(fooClientMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooClientMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooClientMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooClientMessage.readMessage(message, reader);
    return message as FooClientMessage;
  },

  defaultValue: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  writeMessage: function (
    msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooServerMessage: Partial<FooServerMessage>): Uint8Array {
    const writer = new BinaryWriter();
    FooServerMessage.writeMessage(fooServerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooServerMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooServerMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooServerMessage.readMessage(message, reader);
    return message as FooServerMessage;
  },

  defaultValue: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  writeMessage: function (
    msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): void {},

  encode: function (barRequest: Partial<BarRequest>): Uint8Array {
    const writer = new BinaryWriter();
    BarRequest.writeMessage(barRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<BarRequest>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): BarRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarRequest.readMessage(message, reader);
    return message as BarRequest;
  },

  defaultValue: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  writeMessage: function (
    msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): void {},

  encode: function (barResponse: Partial<BarResponse>): Uint8Array {
    const writer = new BinaryWriter();
    BarResponse.writeMessage(barResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<BarResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): BarResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarResponse.readMessage(message, reader);
    return message as BarResponse;
  },

  defaultValue: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): void {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
  },

  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    const writer = new BinaryWriter();
    TestJsonName.writeMessage(testJsonName, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestJsonName>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field_name1) {
      msg.field_name1 = 0;
    }
    if (!msg.fieldName2) {
      msg.fieldName2 = 0;
    }
    if (!msg.FieldName3) {
      msg.FieldName3 = 0;
    }
    if (!msg._field_name4) {
      msg._field_name4 = 0;
    }
    if (!msg.FIELD_NAME5) {
      msg.FIELD_NAME5 = 0;
    }
    if (!msg.field_name6) {
      msg.field_name6 = 0;
    }
    if (!msg.fieldname7) {
      msg.fieldname7 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestJsonName {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestJsonName.readMessage(message, reader);
    return message as TestJsonName;
  },

  defaultValue: function (): TestJsonName {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },
};

export const TestHugeFieldNumbers = {
  writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.string_string_map![key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
  },

  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestHugeFieldNumbers.writeMessage(testHugeFieldNumbers, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.packed_int32 = [];
    msg.string_string_map = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_message = message as ForeignMessage;
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.string_string_map![key!] = value!;
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.oneof_test_all_types = message as TestAllTypes;
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.fixed_32) {
      msg.fixed_32 = 0;
    }
    if (!msg.optional_enum) {
      msg.optional_enum = 0;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_message) {
      msg.optional_message = ForeignMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestHugeFieldNumbers.readMessage(message, reader);
    return message as TestHugeFieldNumbers;
  },

  defaultValue: function (): TestHugeFieldNumbers {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.defaultValue(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.defaultValue(),
    };
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestHugeFieldNumbers.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.group_a) {
        msg.group_a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestHugeFieldNumbers.OptionalGroup.readMessage(message, reader);
      return message as TestHugeFieldNumbers.OptionalGroup;
    },

    defaultValue: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        group_a: 0,
      };
    },
  },
};

export const TestExtensionInsideTable = {
  writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): void {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
  },

  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionInsideTable.writeMessage(testExtensionInsideTable, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field1) {
      msg.field1 = 0;
    }
    if (!msg.field2) {
      msg.field2 = 0;
    }
    if (!msg.field3) {
      msg.field3 = 0;
    }
    if (!msg.field4) {
      msg.field4 = 0;
    }
    if (!msg.field6) {
      msg.field6 = 0;
    }
    if (!msg.field7) {
      msg.field7 = 0;
    }
    if (!msg.field8) {
      msg.field8 = 0;
    }
    if (!msg.field9) {
      msg.field9 = 0;
    }
    if (!msg.field10) {
      msg.field10 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionInsideTable.readMessage(message, reader);
    return message as TestExtensionInsideTable;
  },

  defaultValue: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },
};

export const TestExtensionRangeSerialize = {
  writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
  },

  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionRangeSerialize.writeMessage(
      testExtensionRangeSerialize,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_one) {
      msg.foo_one = 0;
    }
    if (!msg.foo_two) {
      msg.foo_two = 0;
    }
    if (!msg.foo_three) {
      msg.foo_three = 0;
    }
    if (!msg.foo_four) {
      msg.foo_four = 0;
    }
  },

  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionRangeSerialize.readMessage(message, reader);
    return message as TestExtensionRangeSerialize;
  },

  defaultValue: function (): TestExtensionRangeSerialize {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  map_int32_int32: TestMap.MapInt32Int32;
  map_int64_int64: TestMap.MapInt64Int64;
  map_uint32_uint32: TestMap.MapUint32Uint32;
  map_uint64_uint64: TestMap.MapUint64Uint64;
  map_sint32_sint32: TestMap.MapSint32Sint32;
  map_sint64_sint64: TestMap.MapSint64Sint64;
  map_fixed32_fixed32: TestMap.MapFixed32Fixed32;
  map_fixed64_fixed64: TestMap.MapFixed64Fixed64;
  map_sfixed32_sfixed32: TestMap.MapSfixed32Sfixed32;
  map_sfixed64_sfixed64: TestMap.MapSfixed64Sfixed64;
  map_int32_float: TestMap.MapInt32Float;
  map_int32_double: TestMap.MapInt32Double;
  map_bool_bool: TestMap.MapBoolBool;
  map_string_string: TestMap.MapStringString;
  map_int32_bytes: TestMap.MapInt32Bytes;
  map_int32_enum: TestMap.MapInt32Enum;
  map_int32_foreign_message: TestMap.MapInt32ForeignMessage;
  map_string_foreign_message: TestMap.MapStringForeignMessage;
  map_int32_all_types: TestMap.MapInt32AllTypes;
}

export namespace TestMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<string, string | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<string, string | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<string, string | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<string, string | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<string, string | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;

  export type MapStringForeignMessage = Record<
    string,
    ForeignMessage | undefined
  >;

  export type MapInt32AllTypes = Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  test_map: TestMap;
}

export interface TestMessageMap {
  map_int32_message: TestMessageMap.MapInt32Message;
}

export namespace TestMessageMap {
  export type MapInt32Message = Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: TestSameTypeMap.Map1;
  map2: TestSameTypeMap.Map2;
}

export namespace TestSameTypeMap {
  export type Map1 = Record<number, number | undefined>;

  export type Map2 = Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  map_field: TestRequiredMessageMap.MapField;
}

export namespace TestRequiredMessageMap {
  export type MapField = Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  map_int32_int32: TestArenaMap.MapInt32Int32;
  map_int64_int64: TestArenaMap.MapInt64Int64;
  map_uint32_uint32: TestArenaMap.MapUint32Uint32;
  map_uint64_uint64: TestArenaMap.MapUint64Uint64;
  map_sint32_sint32: TestArenaMap.MapSint32Sint32;
  map_sint64_sint64: TestArenaMap.MapSint64Sint64;
  map_fixed32_fixed32: TestArenaMap.MapFixed32Fixed32;
  map_fixed64_fixed64: TestArenaMap.MapFixed64Fixed64;
  map_sfixed32_sfixed32: TestArenaMap.MapSfixed32Sfixed32;
  map_sfixed64_sfixed64: TestArenaMap.MapSfixed64Sfixed64;
  map_int32_float: TestArenaMap.MapInt32Float;
  map_int32_double: TestArenaMap.MapInt32Double;
  map_bool_bool: TestArenaMap.MapBoolBool;
  map_string_string: TestArenaMap.MapStringString;
  map_int32_bytes: TestArenaMap.MapInt32Bytes;
  map_int32_enum: TestArenaMap.MapInt32Enum;
  map_int32_foreign_message: TestArenaMap.MapInt32ForeignMessage;
}

export namespace TestArenaMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<string, string | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<string, string | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<string, string | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<string, string | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<string, string | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: MessageContainingMapCalledEntry.Entry;
}

export namespace MessageContainingMapCalledEntry {
  export type Entry = Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: TestRecursiveMapMessage.A;
}

export namespace TestRecursiveMapMessage {
  export type A = Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  writeMessage: function (msg: Partial<TestMap>, writer: BinaryWriter): void {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as any);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as any);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as any);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as any);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as any);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as any);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as any);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as any);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as any);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as any);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeMessage(2, msg.map_string_foreign_message![key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_all_types![key]);
        });
      }
    }
  },

  encode: function (testMap: Partial<TestMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestMap.writeMessage(testMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestMap>, reader: BinaryReader): void {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    msg.map_string_foreign_message = {};
    msg.map_int32_all_types = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64![key!] = value!;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32![key!] = value!;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64![key!] = value!;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32![key!] = value!;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64![key!] = value!;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32![key!] = value!;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64![key!] = value!;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32![key!] = value!;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64![key!] = value!;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float![key!] = value!;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double![key!] = value!;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean;
            let value: boolean;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool![key!] = value!;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string![key!] = value!;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: Uint8Array;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes![key!] = value!;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: MapEnum;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum![key!] = value!;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message![key!] = value!;
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_string_foreign_message![key!] = value!;
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestAllTypes;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_all_types![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMap.readMessage(message, reader);
    return message as TestMap;
  },

  defaultValue: function (): TestMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },
};

export const TestMapSubmessage = {
  writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): void {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap.writeMessage);
    }
  },

  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestMapSubmessage.writeMessage(testMapSubmessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMapSubmessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMap.readMessage);
          msg.test_map = message as TestMap;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.test_map) {
      msg.test_map = TestMap.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestMapSubmessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMapSubmessage.readMessage(message, reader);
    return message as TestMapSubmessage;
  },

  defaultValue: function (): TestMapSubmessage {
    return {
      test_map: TestMap.defaultValue(),
    };
  },
};

export const TestMessageMap = {
  writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_message![key]);
        });
      }
    }
  },

  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageMap.writeMessage(testMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageMap>,
    reader: BinaryReader
  ): void {
    msg.map_int32_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestAllTypes;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_message![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMessageMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageMap.readMessage(message, reader);
    return message as TestMessageMap;
  },

  defaultValue: function (): TestMessageMap {
    return {
      map_int32_message: {},
    };
  },
};

export const TestSameTypeMap = {
  writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
  },

  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestSameTypeMap.writeMessage(testSameTypeMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestSameTypeMap>,
    reader: BinaryReader
  ): void {
    msg.map1 = {};
    msg.map2 = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map1![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map2![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestSameTypeMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestSameTypeMap.readMessage(message, reader);
    return message as TestSameTypeMap;
  },

  defaultValue: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },
};

export const TestRequiredMessageMap = {
  writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_field![key]);
        });
      }
    }
  },

  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredMessageMap.writeMessage(testRequiredMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    reader: BinaryReader
  ): void {
    msg.map_field = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestRequired;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_field![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessageMap.readMessage(message, reader);
    return message as TestRequiredMessageMap;
  },

  defaultValue: function (): TestRequiredMessageMap {
    return {
      map_field: {},
    };
  },
};

export const TestArenaMap = {
  writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as any);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as any);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as any);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as any);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as any);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as any);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as any);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as any);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as any);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as any);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
  },

  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestArenaMap.writeMessage(testArenaMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestArenaMap>,
    reader: BinaryReader
  ): void {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64![key!] = value!;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32![key!] = value!;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64![key!] = value!;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32![key!] = value!;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64![key!] = value!;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32![key!] = value!;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64![key!] = value!;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32![key!] = value!;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64![key!] = value!;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float![key!] = value!;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double![key!] = value!;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean;
            let value: boolean;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool![key!] = value!;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string![key!] = value!;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: Uint8Array;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes![key!] = value!;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: MapEnum;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum![key!] = value!;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestArenaMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestArenaMap.readMessage(message, reader);
    return message as TestArenaMap;
  },

  defaultValue: function (): TestArenaMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },
};

export const MessageContainingMapCalledEntry = {
  writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): void {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
  },

  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    const writer = new BinaryWriter();
    MessageContainingMapCalledEntry.writeMessage(
      messageContainingMapCalledEntry,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    reader: BinaryReader
  ): void {
    msg.entry = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.entry![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    const reader = new BinaryReader(bytes);
    const message = {};
    MessageContainingMapCalledEntry.readMessage(message, reader);
    return message as MessageContainingMapCalledEntry;
  },

  defaultValue: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },
};

export const TestRecursiveMapMessage = {
  writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
  },

  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRecursiveMapMessage.writeMessage(testRecursiveMapMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    reader: BinaryReader
  ): void {
    msg.a = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: TestRecursiveMapMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.a![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMapMessage.readMessage(message, reader);
    return message as TestRecursiveMapMessage;
  },

  defaultValue: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message as ImportMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): void {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageWithDummy>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes: ByteSource): TestMessageWithDummy {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message as TestMessageWithDummy;
  },

  defaultValue: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
  },

  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    PublicImportMessage.writeMessage(publicImportMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<PublicImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.e) {
      msg.e = 0;
    }
  },

  decode: function (bytes: ByteSource): PublicImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    PublicImportMessage.readMessage(message, reader);
    return message as PublicImportMessage;
  },

  defaultValue: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
  },

  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ImportMessage.writeMessage(importMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ImportMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes: ByteSource): ImportMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ImportMessage.readMessage(message, reader);
    return message as ImportMessage;
  },

  defaultValue: function (): ImportMessage {
    return {
      d: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
  // This is the minimum version supported by the current runtime.
  // If this line fails typechecking, breaking changes have been introduced and this
  // file needs to be regenerated by running \`yarn twirpscript\`.
  MIN_SUPPORTED_VERSION_0_0_34,
} from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_import_enum: ImportEnum;
  optional_string_piece: string;
  optional_cord: string;
  optional_public_import_message: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_lazy_message: TestAllTypes.NestedMessage;
  repeated_int32: number[];
  /**
   * Repeated
   */
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_import_enum: ImportEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  default_int32: number;
  default_int64: string;
  /**
   * Singular with defaults
   */
  default_uint32: number;
  default_uint64: string;
  default_sint32: number;
  default_sint64: string;
  default_fixed32: number;
  default_fixed64: string;
  default_sfixed32: number;
  default_sfixed64: string;
  default_float: number;
  default_double: number;
  default_bool: boolean;
  default_string: string;
  default_bytes: Uint8Array;
  default_nested_enum: TestAllTypes.NestedEnum;
  default_foreign_enum: ForeignEnum;
  default_import_enum: ImportEnum;
  default_string_piece: string;
  default_cord: string;
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeated_child: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecated_int32: number;
  deprecated_int32_in_oneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optional_foreign_enum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optional_extension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optional_message: TestRequired;
  repeated_message: TestRequired[];
  required_message: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreign_nested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    sub_message: TestMutualRecursionA.SubMessage;
    not_in_this_scc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optional_int32: number;
}

export interface TestIsInitialized {
  sub_message: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  sub_message: TestAllTypes;
}

export interface TestLazyMessage {
  sub_message: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optional_nested_message: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessage_repeated_int32: number[];
    nestedmessage_repeated_foreignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  my_string: string;
  my_int: string;
  my_float: number;
  optional_nested_message: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  my_string: string;
}

export interface TestExtensionOrderings2 {
  my_string: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    my_string: string;
  }
}

export interface TestExtremeDefaultValues {
  escaped_bytes: Uint8Array;
  large_uint32: number;
  large_uint64: string;
  small_int32: number;
  small_int64: string;
  really_small_int32: number;
  really_small_int64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8_string: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zero_float: number;
  one_float: number;
  small_float: number;
  negative_one_float: number;
  negative_float: number;
  /**
   * Using exponents
   */
  large_float: number;
  small_negative_float: number;
  /**
   * Text for nonfinite floating-point values.
   */
  inf_double: number;
  neg_inf_double: number;
  nan_double: number;
  inf_float: number;
  neg_inf_float: number;
  nan_float: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cpp_trigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  string_with_zero: string;
  bytes_with_zero: Uint8Array;
  string_piece_with_zero: string;
  cord_with_zero: string;
  replacement_string: string;
}

export interface SparseEnumMessage {
  sparse_enum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  foo_int: number;
  foo_string: string;
  foo_message: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  foo_int?: number;
  foo_string?: string;
  foo_cord?: string;
  foo_string_piece?: string;
  foo_bytes?: Uint8Array;
  foo_enum?: TestOneof2.NestedEnum;
  foo_message?: TestOneof2.NestedMessage;
  foo_lazy_message?: TestOneof2.NestedMessage;
  bar_int?: number;
  bar_string?: string;
  bar_cord?: string;
  bar_string_piece?: string;
  bar_bytes?: Uint8Array;
  bar_enum?: TestOneof2.NestedEnum;
  bar_string_with_empty_default?: string;
  bar_cord_with_empty_default?: string;
  bar_string_piece_with_empty_default?: string;
  bar_bytes_with_empty_default?: Uint8Array;
  baz_int: number;
  baz_string: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    qux_int: string;
    corge_int: number[];
  }
}

export interface TestRequiredOneof {
  foo_int?: number;
  foo_string?: string;
  foo_message?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    required_double: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpacked_int32: number[];
  unpacked_int64: string[];
  unpacked_uint32: number[];
  unpacked_uint64: string[];
  unpacked_sint32: number[];
  unpacked_sint64: string[];
  unpacked_fixed32: number[];
  unpacked_fixed64: string[];
  unpacked_sfixed32: number[];
  unpacked_sfixed64: string[];
  unpacked_float: number[];
  unpacked_double: number[];
  unpacked_bool: boolean[];
  unpacked_enum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalar_extension: number;
  enum_extension: ForeignEnum;
  dynamic_enum_extension: TestDynamicExtensions.DynamicEnumType;
  message_extension: ForeignMessage;
  dynamic_message_extension: TestDynamicExtensions.DynamicMessageType;
  repeated_extension: string[];
  packed_extension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamic_field: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeated_fixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeated_int32: number[];
  /**
   * These have two-byte tags.
   */
  repeated_fixed64: string[];
  repeated_int64: string[];
  /**
   * Three byte tags.
   */
  repeated_float: number[];
  repeated_uint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  required_all_types: TestAllTypes;
  optional_all_types: TestAllTypes;
  repeated_all_types: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optional_group_all_types: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeated_group_all_types: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  field_name1: number;
  fieldName2: number;
  FieldName3: number;
  _field_name4: number;
  FIELD_NAME5: number;
  field_name6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optional_int32: number;
  fixed_32: number;
  repeated_int32: number[];
  packed_int32: number[];
  optional_enum: ForeignEnum;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_message: ForeignMessage;
  string_string_map: TestHugeFieldNumbers.StringStringMap;
  oneof_uint32?: number;
  oneof_test_all_types?: TestAllTypes;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    group_a: number;
  }

  export type StringStringMap = Record<string, string | undefined>;
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  foo_one: number;
  foo_two: number;
  foo_three: number;
  foo_four: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_import_enum) {
      writer.writeEnum(23, msg.optional_import_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_import_enum?.length) {
      writer.writeRepeatedEnum(53, msg.repeated_import_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.default_int32) {
      writer.writeInt32(61, msg.default_int32);
    }
    if (msg.default_int64) {
      writer.writeInt64String(62, msg.default_int64);
    }
    if (msg.default_uint32) {
      writer.writeUint32(63, msg.default_uint32);
    }
    if (msg.default_uint64) {
      writer.writeUint64String(64, msg.default_uint64);
    }
    if (msg.default_sint32) {
      writer.writeSint32(65, msg.default_sint32);
    }
    if (msg.default_sint64) {
      writer.writeSint64String(66, msg.default_sint64);
    }
    if (msg.default_fixed32) {
      writer.writeFixed32(67, msg.default_fixed32);
    }
    if (msg.default_fixed64) {
      writer.writeFixed64String(68, msg.default_fixed64);
    }
    if (msg.default_sfixed32) {
      writer.writeSfixed32(69, msg.default_sfixed32);
    }
    if (msg.default_sfixed64) {
      writer.writeSfixed64(70, msg.default_sfixed64);
    }
    if (msg.default_float) {
      writer.writeFloat(71, msg.default_float);
    }
    if (msg.default_double) {
      writer.writeDouble(72, msg.default_double);
    }
    if (msg.default_bool) {
      writer.writeBool(73, msg.default_bool);
    }
    if (msg.default_string) {
      writer.writeString(74, msg.default_string);
    }
    if (msg.default_bytes) {
      writer.writeBytes(75, msg.default_bytes);
    }
    if (msg.default_nested_enum) {
      writer.writeEnum(81, msg.default_nested_enum);
    }
    if (msg.default_foreign_enum) {
      writer.writeEnum(82, msg.default_foreign_enum);
    }
    if (msg.default_import_enum) {
      writer.writeEnum(83, msg.default_import_enum);
    }
    if (msg.default_string_piece) {
      writer.writeString(84, msg.default_string_piece);
    }
    if (msg.default_cord) {
      writer.writeString(85, msg.default_cord);
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_import_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optional_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeated_import_enum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 61: {
          msg.default_int32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.default_int64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.default_uint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.default_uint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.default_sint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.default_sint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.default_fixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.default_fixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.default_sfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.default_sfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.default_float = reader.readFloat();
          break;
        }
        case 72: {
          msg.default_double = reader.readDouble();
          break;
        }
        case 73: {
          msg.default_bool = reader.readBool();
          break;
        }
        case 74: {
          msg.default_string = reader.readString();
          break;
        }
        case 75: {
          msg.default_bytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.default_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.default_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.default_import_enum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.default_string_piece = reader.readString();
          break;
        }
        case 85: {
          msg.default_cord = reader.readString();
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_import_enum) {
      msg.optional_import_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.default_int32) {
      msg.default_int32 = 0;
    }
    if (!msg.default_int64) {
      msg.default_int64 = \\"\\";
    }
    if (!msg.default_uint32) {
      msg.default_uint32 = 0;
    }
    if (!msg.default_uint64) {
      msg.default_uint64 = \\"\\";
    }
    if (!msg.default_sint32) {
      msg.default_sint32 = 0;
    }
    if (!msg.default_sint64) {
      msg.default_sint64 = \\"\\";
    }
    if (!msg.default_fixed32) {
      msg.default_fixed32 = 0;
    }
    if (!msg.default_fixed64) {
      msg.default_fixed64 = \\"\\";
    }
    if (!msg.default_sfixed32) {
      msg.default_sfixed32 = 0;
    }
    if (!msg.default_sfixed64) {
      msg.default_sfixed64 = \\"\\";
    }
    if (!msg.default_float) {
      msg.default_float = 0;
    }
    if (!msg.default_double) {
      msg.default_double = 0;
    }
    if (!msg.default_bool) {
      msg.default_bool = false;
    }
    if (!msg.default_string) {
      msg.default_string = \\"\\";
    }
    if (!msg.default_bytes) {
      msg.default_bytes = new Uint8Array();
    }
    if (!msg.default_nested_enum) {
      msg.default_nested_enum = 0;
    }
    if (!msg.default_foreign_enum) {
      msg.default_foreign_enum = 0;
    }
    if (!msg.default_import_enum) {
      msg.default_import_enum = 0;
    }
    if (!msg.default_string_piece) {
      msg.default_string_piece = \\"\\";
    }
    if (!msg.default_cord) {
      msg.default_cord = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_import_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_import_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      default_int32: 0,
      default_int64: \\"\\",
      default_uint32: 0,
      default_uint64: \\"\\",
      default_sint32: 0,
      default_sint64: \\"\\",
      default_fixed32: 0,
      default_fixed64: \\"\\",
      default_sfixed32: 0,
      default_sfixed64: \\"\\",
      default_float: 0,
      default_double: 0,
      default_bool: false,
      default_string: \\"\\",
      default_bytes: new Uint8Array(),
      default_nested_enum: 0,
      default_foreign_enum: 0,
      default_import_enum: 0,
      default_string_piece: \\"\\",
      default_cord: \\"\\",
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.OptionalGroup.readMessage(message, reader);
      return message as TestAllTypes.OptionalGroup;
    },

    defaultValue: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
    },

    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.RepeatedGroup.readMessage(message, reader);
      return message as TestAllTypes.RepeatedGroup;
    },

    defaultValue: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
    if (msg.repeated_child?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_child as any,
        NestedTestAllTypes.writeMessage
      );
    }
  },

  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_child = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.repeated_child.push(message as NestedTestAllTypes);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
      repeated_child: [],
    };
  },
};

export const TestDeprecatedFields = {
  writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): void {
    if (msg.deprecated_int32) {
      writer.writeInt32(1, msg.deprecated_int32);
    }
    if (msg.deprecated_int32_in_oneof != undefined) {
      writer.writeInt32(2, msg.deprecated_int32_in_oneof);
    }
  },

  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDeprecatedFields.writeMessage(testDeprecatedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDeprecatedFields>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecated_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecated_int32_in_oneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.deprecated_int32) {
      msg.deprecated_int32 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestDeprecatedFields {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedFields.readMessage(message, reader);
    return message as TestDeprecatedFields;
  },

  defaultValue: function (): TestDeprecatedFields {
    return {
      deprecated_int32: 0,
    };
  },
};

export const TestDeprecatedMessage = {
  writeMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testDeprecatedMessage: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDeprecatedMessage.writeMessage(testDeprecatedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDeprecatedMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestDeprecatedMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDeprecatedMessage.readMessage(message, reader);
    return message as TestDeprecatedMessage;
  },

  defaultValue: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
  },

  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
    if (!msg.d) {
      msg.d = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },
};

export const TestReservedFields = {
  writeMessage: function (
    msg: Partial<TestReservedFields>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testReservedFields: Partial<TestReservedFields>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestReservedFields.writeMessage(testReservedFields, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestReservedFields>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestReservedFields {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReservedFields.readMessage(message, reader);
    return message as TestReservedFields;
  },

  defaultValue: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  writeMessage: function (
    msg: Partial<TestAllExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (testAllExtensions: Partial<TestAllExtensions>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllExtensions.writeMessage(testAllExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestAllExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllExtensions.readMessage(message, reader);
    return message as TestAllExtensions;
  },

  defaultValue: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
  },

  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    OptionalGroup_extension.writeMessage(optionalGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<OptionalGroup_extension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): OptionalGroup_extension {
    const reader = new BinaryReader(bytes);
    const message = {};
    OptionalGroup_extension.readMessage(message, reader);
    return message as OptionalGroup_extension;
  },

  defaultValue: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },
};

export const RepeatedGroup_extension = {
  writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
  },

  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    RepeatedGroup_extension.writeMessage(repeatedGroup_extension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    const reader = new BinaryReader(bytes);
    const message = {};
    RepeatedGroup_extension.readMessage(message, reader);
    return message as RepeatedGroup_extension;
  },

  defaultValue: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },
};

export const TestGroup = {
  writeMessage: function (msg: Partial<TestGroup>, writer: BinaryWriter): void {
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
  },

  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    const writer = new BinaryWriter();
    TestGroup.writeMessage(testGroup, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestGroup>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
  },

  decode: function (bytes: ByteSource): TestGroup {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroup.readMessage(message, reader);
    return message as TestGroup;
  },

  defaultValue: function (): TestGroup {
    return {
      optional_foreign_enum: 0,
    };
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestGroup.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestGroup.OptionalGroup.readMessage(message, reader);
      return message as TestGroup.OptionalGroup;
    },

    defaultValue: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },
  },
};

export const TestGroupExtension = {
  writeMessage: function (
    msg: Partial<TestGroupExtension>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testGroupExtension: Partial<TestGroupExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestGroupExtension.writeMessage(testGroupExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestGroupExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestGroupExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestGroupExtension.readMessage(message, reader);
    return message as TestGroupExtension;
  },

  defaultValue: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  writeMessage: function (
    msg: Partial<TestNestedExtension>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testNestedExtension: Partial<TestNestedExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestNestedExtension.writeMessage(testNestedExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestNestedExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestNestedExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedExtension.readMessage(message, reader);
    return message as TestNestedExtension;
  },

  defaultValue: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
    },

    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestNestedExtension.OptionalGroup_extension.writeMessage(
        optionalGroup_extension,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedExtension.OptionalGroup_extension.readMessage(message, reader);
      return message as TestNestedExtension.OptionalGroup_extension;
    },

    defaultValue: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },
  },
};

export const TestChildExtension = {
  writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optional_extension) {
      writer.writeMessage(
        3,
        msg.optional_extension,
        TestAllExtensions.writeMessage
      );
    }
  },

  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestChildExtension.writeMessage(testChildExtension, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestChildExtension>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllExtensions.readMessage);
          msg.optional_extension = message as TestAllExtensions;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
    if (!msg.b) {
      msg.b = \\"\\";
    }
    if (!msg.optional_extension) {
      msg.optional_extension = TestAllExtensions.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestChildExtension {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestChildExtension.readMessage(message, reader);
    return message as TestChildExtension;
  },

  defaultValue: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optional_extension: TestAllExtensions.defaultValue(),
    };
  },
};

export const TestRequired = {
  writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
  },

  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    const writer = new BinaryWriter();
    TestRequired.writeMessage(testRequired, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequired>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.dummy2) {
      msg.dummy2 = 0;
    }
    if (!msg.b) {
      msg.b = 0;
    }
    if (!msg.dummy4) {
      msg.dummy4 = 0;
    }
    if (!msg.dummy5) {
      msg.dummy5 = 0;
    }
    if (!msg.dummy6) {
      msg.dummy6 = 0;
    }
    if (!msg.dummy7) {
      msg.dummy7 = 0;
    }
    if (!msg.dummy8) {
      msg.dummy8 = 0;
    }
    if (!msg.dummy9) {
      msg.dummy9 = 0;
    }
    if (!msg.dummy10) {
      msg.dummy10 = 0;
    }
    if (!msg.dummy11) {
      msg.dummy11 = 0;
    }
    if (!msg.dummy12) {
      msg.dummy12 = 0;
    }
    if (!msg.dummy13) {
      msg.dummy13 = 0;
    }
    if (!msg.dummy14) {
      msg.dummy14 = 0;
    }
    if (!msg.dummy15) {
      msg.dummy15 = 0;
    }
    if (!msg.dummy16) {
      msg.dummy16 = 0;
    }
    if (!msg.dummy17) {
      msg.dummy17 = 0;
    }
    if (!msg.dummy18) {
      msg.dummy18 = 0;
    }
    if (!msg.dummy19) {
      msg.dummy19 = 0;
    }
    if (!msg.dummy20) {
      msg.dummy20 = 0;
    }
    if (!msg.dummy21) {
      msg.dummy21 = 0;
    }
    if (!msg.dummy22) {
      msg.dummy22 = 0;
    }
    if (!msg.dummy23) {
      msg.dummy23 = 0;
    }
    if (!msg.dummy24) {
      msg.dummy24 = 0;
    }
    if (!msg.dummy25) {
      msg.dummy25 = 0;
    }
    if (!msg.dummy26) {
      msg.dummy26 = 0;
    }
    if (!msg.dummy27) {
      msg.dummy27 = 0;
    }
    if (!msg.dummy28) {
      msg.dummy28 = 0;
    }
    if (!msg.dummy29) {
      msg.dummy29 = 0;
    }
    if (!msg.dummy30) {
      msg.dummy30 = 0;
    }
    if (!msg.dummy31) {
      msg.dummy31 = 0;
    }
    if (!msg.dummy32) {
      msg.dummy32 = 0;
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRequired {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequired.readMessage(message, reader);
    return message as TestRequired;
  },

  defaultValue: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },
};

export const TestRequiredForeign = {
  writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired.writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
  },

  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredForeign.writeMessage(testRequiredForeign, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredForeign>,
    reader: BinaryReader
  ): void {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message as TestRequired;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message as TestRequired);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.dummy) {
      msg.dummy = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRequiredForeign {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredForeign.readMessage(message, reader);
    return message as TestRequiredForeign;
  },

  defaultValue: function (): TestRequiredForeign {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      dummy: 0,
    };
  },
};

export const TestRequiredMessage = {
  writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_message) {
      writer.writeMessage(1, msg.optional_message, TestRequired.writeMessage);
    }
    if (msg.repeated_message?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeated_message as any,
        TestRequired.writeMessage
      );
    }
    if (msg.required_message) {
      writer.writeMessage(3, msg.required_message, TestRequired.writeMessage);
    }
  },

  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredMessage.writeMessage(testRequiredMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredMessage>,
    reader: BinaryReader
  ): void {
    msg.repeated_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.optional_message = message as TestRequired;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.repeated_message.push(message as TestRequired);
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestRequired.readMessage);
          msg.required_message = message as TestRequired;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_message) {
      msg.optional_message = TestRequired.defaultValue();
    }
    if (!msg.required_message) {
      msg.required_message = TestRequired.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestRequiredMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessage.readMessage(message, reader);
    return message as TestRequiredMessage;
  },

  defaultValue: function (): TestRequiredMessage {
    return {
      optional_message: TestRequired.defaultValue(),
      repeated_message: [],
      required_message: TestRequired.defaultValue(),
    };
  },
};

export const TestForeignNested = {
  writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): void {
    if (msg.foreign_nested) {
      writer.writeMessage(
        1,
        msg.foreign_nested,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    const writer = new BinaryWriter();
    TestForeignNested.writeMessage(testForeignNested, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestForeignNested>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.foreign_nested = message as TestAllTypes.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foreign_nested) {
      msg.foreign_nested = TestAllTypes.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestForeignNested {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestForeignNested.readMessage(message, reader);
    return message as TestForeignNested;
  },

  defaultValue: function (): TestForeignNested {
    return {
      foreign_nested: TestAllTypes.NestedMessage.defaultValue(),
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  writeMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testEmptyMessageWithExtensions: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessageWithExtensions.writeMessage(
      testEmptyMessageWithExtensions,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessageWithExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessageWithExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessageWithExtensions.readMessage(message, reader);
    return message as TestEmptyMessageWithExtensions;
  },

  defaultValue: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  writeMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testPickleNestedMessage: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestPickleNestedMessage.writeMessage(testPickleNestedMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPickleNestedMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPickleNestedMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPickleNestedMessage.readMessage(message, reader);
    return message as TestPickleNestedMessage;
  },

  defaultValue: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestPickleNestedMessage.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestPickleNestedMessage.NestedMessage.readMessage(message, reader);
      return message as TestPickleNestedMessage.NestedMessage;
    },

    defaultValue: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    NestedNestedMessage: {
      writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): void {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
      },

      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.writeMessage(
          nestedNestedMessage,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.cc) {
          msg.cc = 0;
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestPickleNestedMessage.NestedMessage.NestedNestedMessage.readMessage(
          message,
          reader
        );
        return message as TestPickleNestedMessage.NestedMessage.NestedNestedMessage;
      },

      defaultValue:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },
    },
  },
};

export const TestMultipleExtensionRanges = {
  writeMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testMultipleExtensionRanges: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMultipleExtensionRanges.writeMessage(
      testMultipleExtensionRanges,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMultipleExtensionRanges>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMultipleExtensionRanges {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMultipleExtensionRanges.readMessage(message, reader);
    return message as TestMultipleExtensionRanges;
  },

  defaultValue: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
  },

  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestReallyLargeTagNumber.writeMessage(testReallyLargeTagNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
    if (!msg.bb) {
      msg.bb = 0;
    }
  },

  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestReallyLargeTagNumber.readMessage(message, reader);
    return message as TestReallyLargeTagNumber;
  },

  defaultValue: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },
};

export const TestRecursiveMessage = {
  writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage.writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
  },

  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRecursiveMessage.writeMessage(testRecursiveMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRecursiveMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestRecursiveMessage.readMessage);
          msg.a = message as TestRecursiveMessage;
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestRecursiveMessage.defaultValue();
    }
    if (!msg.i) {
      msg.i = 0;
    }
  },

  decode: function (bytes: ByteSource): TestRecursiveMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMessage.readMessage(message, reader);
    return message as TestRecursiveMessage;
  },

  defaultValue: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.defaultValue(),
      i: 0,
    };
  },
};

export const TestMutualRecursionA = {
  writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): void {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB.writeMessage);
    }
  },

  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMutualRecursionA.writeMessage(testMutualRecursionA, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMutualRecursionA>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionB.readMessage);
          msg.bb = message as TestMutualRecursionB;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.bb) {
      msg.bb = TestMutualRecursionB.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestMutualRecursionA {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionA.readMessage(message, reader);
    return message as TestMutualRecursionA;
  },

  defaultValue: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB.writeMessage);
      }
    },

    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestMutualRecursionB.readMessage);
            msg.b = message as TestMutualRecursionB;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.b) {
        msg.b = TestMutualRecursionB.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubMessage.readMessage(message, reader);
      return message as TestMutualRecursionA.SubMessage;
    },

    defaultValue: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.defaultValue(),
      };
    },
  },

  SubGroup: {
    writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.sub_message) {
        writer.writeMessage(
          3,
          msg.sub_message,
          TestMutualRecursionA.SubMessage.writeMessage
        );
      }
      if (msg.not_in_this_scc) {
        writer.writeMessage(4, msg.not_in_this_scc, TestAllTypes.writeMessage);
      }
    },

    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestMutualRecursionA.SubGroup.writeMessage(subGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            const message = {};
            reader.readMessage(
              message,
              TestMutualRecursionA.SubMessage.readMessage
            );
            msg.sub_message = message as TestMutualRecursionA.SubMessage;
            break;
          }
          case 4: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.not_in_this_scc = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.sub_message) {
        msg.sub_message = TestMutualRecursionA.SubMessage.defaultValue();
      }
      if (!msg.not_in_this_scc) {
        msg.not_in_this_scc = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestMutualRecursionA.SubGroup.readMessage(message, reader);
      return message as TestMutualRecursionA.SubGroup;
    },

    defaultValue: function (): TestMutualRecursionA.SubGroup {
      return {
        sub_message: TestMutualRecursionA.SubMessage.defaultValue(),
        not_in_this_scc: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestMutualRecursionB = {
  writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA.writeMessage);
    }
    if (msg.optional_int32) {
      writer.writeInt32(2, msg.optional_int32);
    }
  },

  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMutualRecursionB.writeMessage(testMutualRecursionB, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMutualRecursionB>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMutualRecursionA.readMessage);
          msg.a = message as TestMutualRecursionA;
          break;
        }
        case 2: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = TestMutualRecursionA.defaultValue();
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestMutualRecursionB {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMutualRecursionB.readMessage(message, reader);
    return message as TestMutualRecursionB;
  },

  defaultValue: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.defaultValue(),
      optional_int32: 0,
    };
  },
};

export const TestIsInitialized = {
  writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(
        1,
        msg.sub_message,
        TestIsInitialized.SubMessage.writeMessage
      );
    }
  },

  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    const writer = new BinaryWriter();
    TestIsInitialized.writeMessage(testIsInitialized, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestIsInitialized>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestIsInitialized.SubMessage.readMessage);
          msg.sub_message = message as TestIsInitialized.SubMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestIsInitialized.SubMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestIsInitialized {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestIsInitialized.readMessage(message, reader);
    return message as TestIsInitialized;
  },

  defaultValue: function (): TestIsInitialized {
    return {
      sub_message: TestIsInitialized.SubMessage.defaultValue(),
    };
  },

  SubMessage: {
    writeMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      writer: BinaryWriter
    ): void {},

    encode: function (
      subMessage: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestIsInitialized.SubMessage.writeMessage(subMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestIsInitialized.SubMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (bytes: ByteSource): TestIsInitialized.SubMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestIsInitialized.SubMessage.readMessage(message, reader);
      return message as TestIsInitialized.SubMessage;
    },

    defaultValue: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): void {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
      },

      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestIsInitialized.SubMessage.SubGroup.writeMessage(subGroup, writer);
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.i) {
          msg.i = 0;
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestIsInitialized.SubMessage.SubGroup.readMessage(message, reader);
        return message as TestIsInitialized.SubMessage.SubGroup;
      },

      defaultValue: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },
    },
  },
};

export const TestDupFieldNumber = {
  writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
  },

  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDupFieldNumber.writeMessage(testDupFieldNumber, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDupFieldNumber>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = 0;
    }
  },

  decode: function (bytes: ByteSource): TestDupFieldNumber {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDupFieldNumber.readMessage(message, reader);
    return message as TestDupFieldNumber;
  },

  defaultValue: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  Foo: {
    writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Foo.writeMessage(foo, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Foo.readMessage(message, reader);
      return message as TestDupFieldNumber.Foo;
    },

    defaultValue: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },
  },

  Bar: {
    writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
    },

    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      const writer = new BinaryWriter();
      TestDupFieldNumber.Bar.writeMessage(bar, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDupFieldNumber.Bar.readMessage(message, reader);
      return message as TestDupFieldNumber.Bar;
    },

    defaultValue: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },
  },
};

export const TestEagerMessage = {
  writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEagerMessage.writeMessage(testEagerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEagerMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestEagerMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEagerMessage.readMessage(message, reader);
    return message as TestEagerMessage;
  },

  defaultValue: function (): TestEagerMessage {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestLazyMessage = {
  writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sub_message) {
      writer.writeMessage(1, msg.sub_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestLazyMessage.writeMessage(testLazyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestLazyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.sub_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sub_message) {
      msg.sub_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestLazyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestLazyMessage.readMessage(message, reader);
    return message as TestLazyMessage;
  },

  defaultValue: function (): TestLazyMessage {
    return {
      sub_message: TestAllTypes.defaultValue(),
    };
  },
};

export const TestNestedMessageHasBits = {
  writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_nested_message) {
      writer.writeMessage(
        1,
        msg.optional_nested_message,
        TestNestedMessageHasBits.NestedMessage.writeMessage
      );
    }
  },

  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestNestedMessageHasBits.writeMessage(testNestedMessageHasBits, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(
            message,
            TestNestedMessageHasBits.NestedMessage.readMessage
          );
          msg.optional_nested_message =
            message as TestNestedMessageHasBits.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestNestedMessageHasBits.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestNestedMessageHasBits.readMessage(message, reader);
    return message as TestNestedMessageHasBits;
  },

  defaultValue: function (): TestNestedMessageHasBits {
    return {
      optional_nested_message:
        TestNestedMessageHasBits.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.nestedmessage_repeated_int32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessage_repeated_int32);
      }
      if (msg.nestedmessage_repeated_foreignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessage_repeated_foreignmessage as any,
          ForeignMessage.writeMessage
        );
      }
    },

    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestNestedMessageHasBits.NestedMessage.writeMessage(
        nestedMessage,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      reader: BinaryReader
    ): void {
      msg.nestedmessage_repeated_int32 = [];
      msg.nestedmessage_repeated_foreignmessage = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessage_repeated_int32.push(reader.readInt32());
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, ForeignMessage.readMessage);
            msg.nestedmessage_repeated_foreignmessage.push(
              message as ForeignMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestNestedMessageHasBits.NestedMessage.readMessage(message, reader);
      return message as TestNestedMessageHasBits.NestedMessage;
    },

    defaultValue: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessage_repeated_int32: [],
        nestedmessage_repeated_foreignmessage: [],
      };
    },
  },
};

export const TestCamelCaseFieldNames = {
  writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): void {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage.writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
  },

  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestCamelCaseFieldNames.writeMessage(testCamelCaseFieldNames, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    reader: BinaryReader
  ): void {
    msg.RepeatedPrimitiveField = [];
    msg.RepeatedStringField = [];
    msg.RepeatedEnumField = [];
    msg.RepeatedMessageField = [];
    msg.RepeatedStringPieceField = [];
    msg.RepeatedCordField = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.MessageField = message as ForeignMessage;
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.RepeatedMessageField.push(message as ForeignMessage);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.PrimitiveField) {
      msg.PrimitiveField = 0;
    }
    if (!msg.StringField) {
      msg.StringField = \\"\\";
    }
    if (!msg.EnumField) {
      msg.EnumField = 0;
    }
    if (!msg.MessageField) {
      msg.MessageField = ForeignMessage.defaultValue();
    }
    if (!msg.StringPieceField) {
      msg.StringPieceField = \\"\\";
    }
    if (!msg.CordField) {
      msg.CordField = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCamelCaseFieldNames.readMessage(message, reader);
    return message as TestCamelCaseFieldNames;
  },

  defaultValue: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.defaultValue(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },
};

export const TestFieldOrderings = {
  writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(11, msg.my_string);
    }
    if (msg.my_int) {
      writer.writeInt64String(1, msg.my_int);
    }
    if (msg.my_float) {
      writer.writeFloat(101, msg.my_float);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        200,
        msg.optional_nested_message,
        TestFieldOrderings.NestedMessage.writeMessage
      );
    }
  },

  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestFieldOrderings.writeMessage(testFieldOrderings, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestFieldOrderings>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.my_string = reader.readString();
          break;
        }
        case 1: {
          msg.my_int = reader.readInt64String();
          break;
        }
        case 101: {
          msg.my_float = reader.readFloat();
          break;
        }
        case 200: {
          const message = {};
          reader.readMessage(
            message,
            TestFieldOrderings.NestedMessage.readMessage
          );
          msg.optional_nested_message =
            message as TestFieldOrderings.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
    if (!msg.my_int) {
      msg.my_int = \\"\\";
    }
    if (!msg.my_float) {
      msg.my_float = 0;
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message =
        TestFieldOrderings.NestedMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestFieldOrderings {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestFieldOrderings.readMessage(message, reader);
    return message as TestFieldOrderings;
  },

  defaultValue: function (): TestFieldOrderings {
    return {
      my_string: \\"\\",
      my_int: \\"\\",
      my_float: 0,
      optional_nested_message: TestFieldOrderings.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestFieldOrderings.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.oo) {
        msg.oo = \\"\\";
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestFieldOrderings.NestedMessage.readMessage(message, reader);
      return message as TestFieldOrderings.NestedMessage;
    },

    defaultValue: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },
  },
};

export const TestExtensionOrderings1 = {
  writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionOrderings1.writeMessage(testExtensionOrderings1, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings1.readMessage(message, reader);
    return message as TestExtensionOrderings1;
  },

  defaultValue: function (): TestExtensionOrderings1 {
    return {
      my_string: \\"\\",
    };
  },
};

export const TestExtensionOrderings2 = {
  writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): void {
    if (msg.my_string) {
      writer.writeString(1, msg.my_string);
    }
  },

  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionOrderings2.writeMessage(testExtensionOrderings2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.my_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.my_string) {
      msg.my_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionOrderings2.readMessage(message, reader);
    return message as TestExtensionOrderings2;
  },

  defaultValue: function (): TestExtensionOrderings2 {
    return {
      my_string: \\"\\",
    };
  },

  TestExtensionOrderings3: {
    writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): void {
      if (msg.my_string) {
        writer.writeString(1, msg.my_string);
      }
    },

    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestExtensionOrderings2.TestExtensionOrderings3.writeMessage(
        testExtensionOrderings3,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.my_string = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.my_string) {
        msg.my_string = \\"\\";
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestExtensionOrderings2.TestExtensionOrderings3.readMessage(
        message,
        reader
      );
      return message as TestExtensionOrderings2.TestExtensionOrderings3;
    },

    defaultValue: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        my_string: \\"\\",
      };
    },
  },
};

export const TestExtremeDefaultValues = {
  writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): void {
    if (msg.escaped_bytes) {
      writer.writeBytes(1, msg.escaped_bytes);
    }
    if (msg.large_uint32) {
      writer.writeUint32(2, msg.large_uint32);
    }
    if (msg.large_uint64) {
      writer.writeUint64String(3, msg.large_uint64);
    }
    if (msg.small_int32) {
      writer.writeInt32(4, msg.small_int32);
    }
    if (msg.small_int64) {
      writer.writeInt64String(5, msg.small_int64);
    }
    if (msg.really_small_int32) {
      writer.writeInt32(21, msg.really_small_int32);
    }
    if (msg.really_small_int64) {
      writer.writeInt64String(22, msg.really_small_int64);
    }
    if (msg.utf8_string) {
      writer.writeString(6, msg.utf8_string);
    }
    if (msg.zero_float) {
      writer.writeFloat(7, msg.zero_float);
    }
    if (msg.one_float) {
      writer.writeFloat(8, msg.one_float);
    }
    if (msg.small_float) {
      writer.writeFloat(9, msg.small_float);
    }
    if (msg.negative_one_float) {
      writer.writeFloat(10, msg.negative_one_float);
    }
    if (msg.negative_float) {
      writer.writeFloat(11, msg.negative_float);
    }
    if (msg.large_float) {
      writer.writeFloat(12, msg.large_float);
    }
    if (msg.small_negative_float) {
      writer.writeFloat(13, msg.small_negative_float);
    }
    if (msg.inf_double) {
      writer.writeDouble(14, msg.inf_double);
    }
    if (msg.neg_inf_double) {
      writer.writeDouble(15, msg.neg_inf_double);
    }
    if (msg.nan_double) {
      writer.writeDouble(16, msg.nan_double);
    }
    if (msg.inf_float) {
      writer.writeFloat(17, msg.inf_float);
    }
    if (msg.neg_inf_float) {
      writer.writeFloat(18, msg.neg_inf_float);
    }
    if (msg.nan_float) {
      writer.writeFloat(19, msg.nan_float);
    }
    if (msg.cpp_trigraph) {
      writer.writeString(20, msg.cpp_trigraph);
    }
    if (msg.string_with_zero) {
      writer.writeString(23, msg.string_with_zero);
    }
    if (msg.bytes_with_zero) {
      writer.writeBytes(24, msg.bytes_with_zero);
    }
    if (msg.string_piece_with_zero) {
      writer.writeString(25, msg.string_piece_with_zero);
    }
    if (msg.cord_with_zero) {
      writer.writeString(26, msg.cord_with_zero);
    }
    if (msg.replacement_string) {
      writer.writeString(27, msg.replacement_string);
    }
  },

  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtremeDefaultValues.writeMessage(testExtremeDefaultValues, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escaped_bytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.large_uint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.large_uint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.small_int32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.small_int64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.really_small_int32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.really_small_int64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8_string = reader.readString();
          break;
        }
        case 7: {
          msg.zero_float = reader.readFloat();
          break;
        }
        case 8: {
          msg.one_float = reader.readFloat();
          break;
        }
        case 9: {
          msg.small_float = reader.readFloat();
          break;
        }
        case 10: {
          msg.negative_one_float = reader.readFloat();
          break;
        }
        case 11: {
          msg.negative_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.large_float = reader.readFloat();
          break;
        }
        case 13: {
          msg.small_negative_float = reader.readFloat();
          break;
        }
        case 14: {
          msg.inf_double = reader.readDouble();
          break;
        }
        case 15: {
          msg.neg_inf_double = reader.readDouble();
          break;
        }
        case 16: {
          msg.nan_double = reader.readDouble();
          break;
        }
        case 17: {
          msg.inf_float = reader.readFloat();
          break;
        }
        case 18: {
          msg.neg_inf_float = reader.readFloat();
          break;
        }
        case 19: {
          msg.nan_float = reader.readFloat();
          break;
        }
        case 20: {
          msg.cpp_trigraph = reader.readString();
          break;
        }
        case 23: {
          msg.string_with_zero = reader.readString();
          break;
        }
        case 24: {
          msg.bytes_with_zero = reader.readBytes();
          break;
        }
        case 25: {
          msg.string_piece_with_zero = reader.readString();
          break;
        }
        case 26: {
          msg.cord_with_zero = reader.readString();
          break;
        }
        case 27: {
          msg.replacement_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.escaped_bytes) {
      msg.escaped_bytes = new Uint8Array();
    }
    if (!msg.large_uint32) {
      msg.large_uint32 = 0;
    }
    if (!msg.large_uint64) {
      msg.large_uint64 = \\"\\";
    }
    if (!msg.small_int32) {
      msg.small_int32 = 0;
    }
    if (!msg.small_int64) {
      msg.small_int64 = \\"\\";
    }
    if (!msg.really_small_int32) {
      msg.really_small_int32 = 0;
    }
    if (!msg.really_small_int64) {
      msg.really_small_int64 = \\"\\";
    }
    if (!msg.utf8_string) {
      msg.utf8_string = \\"\\";
    }
    if (!msg.zero_float) {
      msg.zero_float = 0;
    }
    if (!msg.one_float) {
      msg.one_float = 0;
    }
    if (!msg.small_float) {
      msg.small_float = 0;
    }
    if (!msg.negative_one_float) {
      msg.negative_one_float = 0;
    }
    if (!msg.negative_float) {
      msg.negative_float = 0;
    }
    if (!msg.large_float) {
      msg.large_float = 0;
    }
    if (!msg.small_negative_float) {
      msg.small_negative_float = 0;
    }
    if (!msg.inf_double) {
      msg.inf_double = 0;
    }
    if (!msg.neg_inf_double) {
      msg.neg_inf_double = 0;
    }
    if (!msg.nan_double) {
      msg.nan_double = 0;
    }
    if (!msg.inf_float) {
      msg.inf_float = 0;
    }
    if (!msg.neg_inf_float) {
      msg.neg_inf_float = 0;
    }
    if (!msg.nan_float) {
      msg.nan_float = 0;
    }
    if (!msg.cpp_trigraph) {
      msg.cpp_trigraph = \\"\\";
    }
    if (!msg.string_with_zero) {
      msg.string_with_zero = \\"\\";
    }
    if (!msg.bytes_with_zero) {
      msg.bytes_with_zero = new Uint8Array();
    }
    if (!msg.string_piece_with_zero) {
      msg.string_piece_with_zero = \\"\\";
    }
    if (!msg.cord_with_zero) {
      msg.cord_with_zero = \\"\\";
    }
    if (!msg.replacement_string) {
      msg.replacement_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtremeDefaultValues.readMessage(message, reader);
    return message as TestExtremeDefaultValues;
  },

  defaultValue: function (): TestExtremeDefaultValues {
    return {
      escaped_bytes: new Uint8Array(),
      large_uint32: 0,
      large_uint64: \\"\\",
      small_int32: 0,
      small_int64: \\"\\",
      really_small_int32: 0,
      really_small_int64: \\"\\",
      utf8_string: \\"\\",
      zero_float: 0,
      one_float: 0,
      small_float: 0,
      negative_one_float: 0,
      negative_float: 0,
      large_float: 0,
      small_negative_float: 0,
      inf_double: 0,
      neg_inf_double: 0,
      nan_double: 0,
      inf_float: 0,
      neg_inf_float: 0,
      nan_float: 0,
      cpp_trigraph: \\"\\",
      string_with_zero: \\"\\",
      bytes_with_zero: new Uint8Array(),
      string_piece_with_zero: \\"\\",
      cord_with_zero: \\"\\",
      replacement_string: \\"\\",
    };
  },
};

export const SparseEnumMessage = {
  writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.sparse_enum) {
      writer.writeEnum(1, msg.sparse_enum);
    }
  },

  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    const writer = new BinaryWriter();
    SparseEnumMessage.writeMessage(sparseEnumMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<SparseEnumMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparse_enum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.sparse_enum) {
      msg.sparse_enum = 0;
    }
  },

  decode: function (bytes: ByteSource): SparseEnumMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    SparseEnumMessage.readMessage(message, reader);
    return message as SparseEnumMessage;
  },

  defaultValue: function (): SparseEnumMessage {
    return {
      sparse_enum: 0,
    };
  },
};

export const OneString = {
  writeMessage: function (msg: Partial<OneString>, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
  },

  encode: function (oneString: Partial<OneString>): Uint8Array {
    const writer = new BinaryWriter();
    OneString.writeMessage(oneString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<OneString>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): OneString {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneString.readMessage(message, reader);
    return message as OneString;
  },

  defaultValue: function (): OneString {
    return {
      data: \\"\\",
    };
  },
};

export const MoreString = {
  writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): void {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
  },

  encode: function (moreString: Partial<MoreString>): Uint8Array {
    const writer = new BinaryWriter();
    MoreString.writeMessage(moreString, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<MoreString>, reader: BinaryReader): void {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MoreString {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreString.readMessage(message, reader);
    return message as MoreString;
  },

  defaultValue: function (): MoreString {
    return {
      data: [],
    };
  },
};

export const OneBytes = {
  writeMessage: function (msg: Partial<OneBytes>, writer: BinaryWriter): void {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
  },

  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    const writer = new BinaryWriter();
    OneBytes.writeMessage(oneBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<OneBytes>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = new Uint8Array();
    }
  },

  decode: function (bytes: ByteSource): OneBytes {
    const reader = new BinaryReader(bytes);
    const message = {};
    OneBytes.readMessage(message, reader);
    return message as OneBytes;
  },

  defaultValue: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },
};

export const MoreBytes = {
  writeMessage: function (msg: Partial<MoreBytes>, writer: BinaryWriter): void {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
  },

  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    const writer = new BinaryWriter();
    MoreBytes.writeMessage(moreBytes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<MoreBytes>, reader: BinaryReader): void {
    msg.data = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MoreBytes {
    const reader = new BinaryReader(bytes);
    const message = {};
    MoreBytes.readMessage(message, reader);
    return message as MoreBytes;
  },

  defaultValue: function (): MoreBytes {
    return {
      data: [],
    };
  },
};

export const Int32Message = {
  writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
  },

  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    const writer = new BinaryWriter();
    Int32Message.writeMessage(int32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Int32Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes: ByteSource): Int32Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int32Message.readMessage(message, reader);
    return message as Int32Message;
  },

  defaultValue: function (): Int32Message {
    return {
      data: 0,
    };
  },
};

export const Uint32Message = {
  writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
  },

  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    const writer = new BinaryWriter();
    Uint32Message.writeMessage(uint32Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Uint32Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = 0;
    }
  },

  decode: function (bytes: ByteSource): Uint32Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint32Message.readMessage(message, reader);
    return message as Uint32Message;
  },

  defaultValue: function (): Uint32Message {
    return {
      data: 0,
    };
  },
};

export const Int64Message = {
  writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
  },

  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    const writer = new BinaryWriter();
    Int64Message.writeMessage(int64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Int64Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): Int64Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Int64Message.readMessage(message, reader);
    return message as Int64Message;
  },

  defaultValue: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },
};

export const Uint64Message = {
  writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
  },

  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    const writer = new BinaryWriter();
    Uint64Message.writeMessage(uint64Message, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<Uint64Message>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): Uint64Message {
    const reader = new BinaryReader(bytes);
    const message = {};
    Uint64Message.readMessage(message, reader);
    return message as Uint64Message;
  },

  defaultValue: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },
};

export const BoolMessage = {
  writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
  },

  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    const writer = new BinaryWriter();
    BoolMessage.writeMessage(boolMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<BoolMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.data) {
      msg.data = false;
    }
  },

  decode: function (bytes: ByteSource): BoolMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    BoolMessage.readMessage(message, reader);
    return message as BoolMessage;
  },

  defaultValue: function (): BoolMessage {
    return {
      data: false,
    };
  },
};

export const TestOneof = {
  writeMessage: function (msg: Partial<TestOneof>, writer: BinaryWriter): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof.writeMessage(testOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof.readMessage(message, reader);
    return message as TestOneof;
  },

  defaultValue: function (): TestOneof {
    return {
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof.FooGroup.readMessage(message, reader);
      return message as TestOneof.FooGroup;
    },

    defaultValue: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneofBackwardsCompatible = {
  writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message) {
      writer.writeMessage(3, msg.foo_message, TestAllTypes.writeMessage);
    }
  },

  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestOneofBackwardsCompatible.writeMessage(
      testOneofBackwardsCompatible,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.foo_message = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_int) {
      msg.foo_int = 0;
    }
    if (!msg.foo_string) {
      msg.foo_string = \\"\\";
    }
    if (!msg.foo_message) {
      msg.foo_message = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneofBackwardsCompatible.readMessage(message, reader);
    return message as TestOneofBackwardsCompatible;
  },

  defaultValue: function (): TestOneofBackwardsCompatible {
    return {
      foo_int: 0,
      foo_string: \\"\\",
      foo_message: TestAllTypes.defaultValue(),
    };
  },

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
    },

    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestOneofBackwardsCompatible.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneofBackwardsCompatible.FooGroup.readMessage(message, reader);
      return message as TestOneofBackwardsCompatible.FooGroup;
    },

    defaultValue: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },
};

export const TestOneof2 = {
  writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_cord != undefined) {
      writer.writeString(3, msg.foo_cord);
    }
    if (msg.foo_string_piece != undefined) {
      writer.writeString(4, msg.foo_string_piece);
    }
    if (msg.foo_bytes != undefined) {
      writer.writeBytes(5, msg.foo_bytes);
    }
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        7,
        msg.foo_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.foo_lazy_message != undefined) {
      writer.writeMessage(
        11,
        msg.foo_lazy_message,
        TestOneof2.NestedMessage.writeMessage
      );
    }
    if (msg.bar_int != undefined) {
      writer.writeInt32(12, msg.bar_int);
    }
    if (msg.bar_string != undefined) {
      writer.writeString(13, msg.bar_string);
    }
    if (msg.bar_cord != undefined) {
      writer.writeString(14, msg.bar_cord);
    }
    if (msg.bar_string_piece != undefined) {
      writer.writeString(15, msg.bar_string_piece);
    }
    if (msg.bar_bytes != undefined) {
      writer.writeBytes(16, msg.bar_bytes);
    }
    if (msg.bar_enum != undefined) {
      writer.writeEnum(17, msg.bar_enum);
    }
    if (msg.bar_string_with_empty_default != undefined) {
      writer.writeString(20, msg.bar_string_with_empty_default);
    }
    if (msg.bar_cord_with_empty_default != undefined) {
      writer.writeString(21, msg.bar_cord_with_empty_default);
    }
    if (msg.bar_string_piece_with_empty_default != undefined) {
      writer.writeString(22, msg.bar_string_piece_with_empty_default);
    }
    if (msg.bar_bytes_with_empty_default != undefined) {
      writer.writeBytes(23, msg.bar_bytes_with_empty_default);
    }
    if (msg.baz_int) {
      writer.writeInt32(18, msg.baz_int);
    }
    if (msg.baz_string) {
      writer.writeString(19, msg.baz_string);
    }
  },

  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          msg.foo_cord = reader.readString();
          break;
        }
        case 4: {
          msg.foo_string_piece = reader.readString();
          break;
        }
        case 5: {
          msg.foo_bytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_message = message as TestOneof2.NestedMessage;
          break;
        }
        case 11: {
          const message = {};
          reader.readMessage(message, TestOneof2.NestedMessage.readMessage);
          msg.foo_lazy_message = message as TestOneof2.NestedMessage;
          break;
        }
        case 12: {
          msg.bar_int = reader.readInt32();
          break;
        }
        case 13: {
          msg.bar_string = reader.readString();
          break;
        }
        case 14: {
          msg.bar_cord = reader.readString();
          break;
        }
        case 15: {
          msg.bar_string_piece = reader.readString();
          break;
        }
        case 16: {
          msg.bar_bytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.bar_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.bar_string_with_empty_default = reader.readString();
          break;
        }
        case 21: {
          msg.bar_cord_with_empty_default = reader.readString();
          break;
        }
        case 22: {
          msg.bar_string_piece_with_empty_default = reader.readString();
          break;
        }
        case 23: {
          msg.bar_bytes_with_empty_default = reader.readBytes();
          break;
        }
        case 18: {
          msg.baz_int = reader.readInt32();
          break;
        }
        case 19: {
          msg.baz_string = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.baz_int) {
      msg.baz_int = 0;
    }
    if (!msg.baz_string) {
      msg.baz_string = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {
      foo_message: TestOneof2.NestedMessage.defaultValue(),
      foo_lazy_message: TestOneof2.NestedMessage.defaultValue(),
      baz_int: 0,
      baz_string: \\"\\",
    };
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
    },

    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof2.FooGroup.writeMessage(fooGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.a) {
        msg.a = 0;
      }
      if (!msg.b) {
        msg.b = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.FooGroup.readMessage(message, reader);
      return message as TestOneof2.FooGroup;
    },

    defaultValue: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.qux_int) {
        writer.writeInt64String(1, msg.qux_int);
      }
      if (msg.corge_int?.length) {
        writer.writeRepeatedInt32(2, msg.corge_int);
      }
    },

    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestOneof2.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      reader: BinaryReader
    ): void {
      msg.corge_int = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.qux_int = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corge_int.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.qux_int) {
        msg.qux_int = \\"\\";
      }
    },

    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestOneof2.NestedMessage.readMessage(message, reader);
      return message as TestOneof2.NestedMessage;
    },

    defaultValue: function (): TestOneof2.NestedMessage {
      return {
        qux_int: \\"\\",
        corge_int: [],
      };
    },
  },
};

export const TestRequiredOneof = {
  writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_int != undefined) {
      writer.writeInt32(1, msg.foo_int);
    }
    if (msg.foo_string != undefined) {
      writer.writeString(2, msg.foo_string);
    }
    if (msg.foo_message != undefined) {
      writer.writeMessage(
        3,
        msg.foo_message,
        TestRequiredOneof.NestedMessage.writeMessage
      );
    }
  },

  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredOneof.writeMessage(testRequiredOneof, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredOneof>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_int = reader.readInt32();
          break;
        }
        case 2: {
          msg.foo_string = reader.readString();
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(
            message,
            TestRequiredOneof.NestedMessage.readMessage
          );
          msg.foo_message = message as TestRequiredOneof.NestedMessage;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRequiredOneof {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredOneof.readMessage(message, reader);
    return message as TestRequiredOneof;
  },

  defaultValue: function (): TestRequiredOneof {
    return {
      foo_message: TestRequiredOneof.NestedMessage.defaultValue(),
    };
  },

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.required_double) {
        writer.writeDouble(1, msg.required_double);
      }
    },

    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestRequiredOneof.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.required_double = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.required_double) {
        msg.required_double = 0;
      }
    },

    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestRequiredOneof.NestedMessage.readMessage(message, reader);
      return message as TestRequiredOneof.NestedMessage;
    },

    defaultValue: function (): TestRequiredOneof.NestedMessage {
      return {
        required_double: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.unpacked_int32?.length) {
      writer.writeRepeatedInt32(90, msg.unpacked_int32);
    }
    if (msg.unpacked_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpacked_int64);
    }
    if (msg.unpacked_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpacked_uint32);
    }
    if (msg.unpacked_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpacked_uint64);
    }
    if (msg.unpacked_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpacked_sint32);
    }
    if (msg.unpacked_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpacked_sint64);
    }
    if (msg.unpacked_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpacked_fixed32);
    }
    if (msg.unpacked_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpacked_fixed64);
    }
    if (msg.unpacked_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpacked_sfixed32);
    }
    if (msg.unpacked_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpacked_sfixed64);
    }
    if (msg.unpacked_float?.length) {
      writer.writeRepeatedFloat(100, msg.unpacked_float);
    }
    if (msg.unpacked_double?.length) {
      writer.writeRepeatedDouble(101, msg.unpacked_double);
    }
    if (msg.unpacked_bool?.length) {
      writer.writeRepeatedBool(102, msg.unpacked_bool);
    }
    if (msg.unpacked_enum?.length) {
      writer.writeRepeatedEnum(103, msg.unpacked_enum);
    }
  },

  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.unpacked_int32 = [];
    msg.unpacked_int64 = [];
    msg.unpacked_uint32 = [];
    msg.unpacked_uint64 = [];
    msg.unpacked_sint32 = [];
    msg.unpacked_sint64 = [];
    msg.unpacked_fixed32 = [];
    msg.unpacked_fixed64 = [];
    msg.unpacked_sfixed32 = [];
    msg.unpacked_sfixed64 = [];
    msg.unpacked_float = [];
    msg.unpacked_double = [];
    msg.unpacked_bool = [];
    msg.unpacked_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpacked_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpacked_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpacked_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpacked_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpacked_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpacked_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpacked_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpacked_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpacked_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpacked_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpacked_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpacked_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpacked_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpacked_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      unpacked_int32: [],
      unpacked_int64: [],
      unpacked_uint32: [],
      unpacked_uint64: [],
      unpacked_sint32: [],
      unpacked_sint64: [],
      unpacked_fixed32: [],
      unpacked_fixed64: [],
      unpacked_sfixed32: [],
      unpacked_sfixed64: [],
      unpacked_float: [],
      unpacked_double: [],
      unpacked_bool: [],
      unpacked_enum: [],
    };
  },
};

export const TestPackedExtensions = {
  writeMessage: function (
    msg: Partial<TestPackedExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testPackedExtensions: Partial<TestPackedExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedExtensions.writeMessage(testPackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedExtensions.readMessage(message, reader);
    return message as TestPackedExtensions;
  },

  defaultValue: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  writeMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    writer: BinaryWriter
  ): void {},

  encode: function (
    testUnpackedExtensions: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedExtensions.writeMessage(testUnpackedExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedExtensions>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedExtensions.readMessage(message, reader);
    return message as TestUnpackedExtensions;
  },

  defaultValue: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): void {
    if (msg.scalar_extension) {
      writer.writeFixed32(2000, msg.scalar_extension);
    }
    if (msg.enum_extension) {
      writer.writeEnum(2001, msg.enum_extension);
    }
    if (msg.dynamic_enum_extension) {
      writer.writeEnum(2002, msg.dynamic_enum_extension);
    }
    if (msg.message_extension) {
      writer.writeMessage(
        2003,
        msg.message_extension,
        ForeignMessage.writeMessage
      );
    }
    if (msg.dynamic_message_extension) {
      writer.writeMessage(
        2004,
        msg.dynamic_message_extension,
        TestDynamicExtensions.DynamicMessageType.writeMessage
      );
    }
    if (msg.repeated_extension?.length) {
      writer.writeRepeatedString(2005, msg.repeated_extension);
    }
    if (msg.packed_extension?.length) {
      writer.writeRepeatedSint32(2006, msg.packed_extension);
    }
  },

  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestDynamicExtensions.writeMessage(testDynamicExtensions, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestDynamicExtensions>,
    reader: BinaryReader
  ): void {
    msg.repeated_extension = [];
    msg.packed_extension = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalar_extension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enum_extension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamic_enum_extension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.message_extension = message as ForeignMessage;
          break;
        }
        case 2004: {
          const message = {};
          reader.readMessage(
            message,
            TestDynamicExtensions.DynamicMessageType.readMessage
          );
          msg.dynamic_message_extension =
            message as TestDynamicExtensions.DynamicMessageType;
          break;
        }
        case 2005: {
          msg.repeated_extension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packed_extension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.scalar_extension) {
      msg.scalar_extension = 0;
    }
    if (!msg.enum_extension) {
      msg.enum_extension = 0;
    }
    if (!msg.dynamic_enum_extension) {
      msg.dynamic_enum_extension = 0;
    }
    if (!msg.message_extension) {
      msg.message_extension = ForeignMessage.defaultValue();
    }
    if (!msg.dynamic_message_extension) {
      msg.dynamic_message_extension =
        TestDynamicExtensions.DynamicMessageType.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestDynamicExtensions {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestDynamicExtensions.readMessage(message, reader);
    return message as TestDynamicExtensions;
  },

  defaultValue: function (): TestDynamicExtensions {
    return {
      scalar_extension: 0,
      enum_extension: 0,
      dynamic_enum_extension: 0,
      message_extension: ForeignMessage.defaultValue(),
      dynamic_message_extension:
        TestDynamicExtensions.DynamicMessageType.defaultValue(),
      repeated_extension: [],
      packed_extension: [],
    };
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): void {
      if (msg.dynamic_field) {
        writer.writeInt32(2100, msg.dynamic_field);
      }
    },

    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestDynamicExtensions.DynamicMessageType.writeMessage(
        dynamicMessageType,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamic_field = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.dynamic_field) {
        msg.dynamic_field = 0;
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestDynamicExtensions.DynamicMessageType.readMessage(message, reader);
      return message as TestDynamicExtensions.DynamicMessageType;
    },

    defaultValue: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamic_field: 0,
      };
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): void {
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeated_fixed32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(13, msg.repeated_int32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeated_fixed64);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeated_int64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(262142, msg.repeated_float);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeated_uint64);
    }
  },

  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRepeatedScalarDifferentTagSizes.writeMessage(
      testRepeatedScalarDifferentTagSizes,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    reader: BinaryReader
  ): void {
    msg.repeated_fixed32 = [];
    msg.repeated_int32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_int64 = [];
    msg.repeated_float = [];
    msg.repeated_uint64 = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRepeatedScalarDifferentTagSizes.readMessage(message, reader);
    return message as TestRepeatedScalarDifferentTagSizes;
  },

  defaultValue: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeated_fixed32: [],
      repeated_int32: [],
      repeated_fixed64: [],
      repeated_int64: [],
      repeated_float: [],
      repeated_uint64: [],
    };
  },
};

export const TestParsingMerge = {
  writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): void {
    if (msg.required_all_types) {
      writer.writeMessage(1, msg.required_all_types, TestAllTypes.writeMessage);
    }
    if (msg.optional_all_types) {
      writer.writeMessage(2, msg.optional_all_types, TestAllTypes.writeMessage);
    }
    if (msg.repeated_all_types?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeated_all_types as any,
        TestAllTypes.writeMessage
      );
    }
  },

  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    const writer = new BinaryWriter();
    TestParsingMerge.writeMessage(testParsingMerge, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestParsingMerge>,
    reader: BinaryReader
  ): void {
    msg.repeated_all_types = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.required_all_types = message as TestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.optional_all_types = message as TestAllTypes;
          break;
        }
        case 3: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.repeated_all_types.push(message as TestAllTypes);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.required_all_types) {
      msg.required_all_types = TestAllTypes.defaultValue();
    }
    if (!msg.optional_all_types) {
      msg.optional_all_types = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestParsingMerge {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestParsingMerge.readMessage(message, reader);
    return message as TestParsingMerge;
  },

  defaultValue: function (): TestParsingMerge {
    return {
      required_all_types: TestAllTypes.defaultValue(),
      optional_all_types: TestAllTypes.defaultValue(),
      repeated_all_types: [],
    };
  },

  RepeatedFieldsGenerator: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): void {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes.writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedFieldsGenerator.writeMessage(
        repeatedFieldsGenerator,
        writer
      );
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      reader: BinaryReader
    ): void {
      msg.field1 = [];
      msg.field2 = [];
      msg.field3 = [];
      msg.ext1 = [];
      msg.ext2 = [];
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field1.push(message as TestAllTypes);
            break;
          }
          case 2: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field2.push(message as TestAllTypes);
            break;
          }
          case 3: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.field3.push(message as TestAllTypes);
            break;
          }
          case 1000: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext1.push(message as TestAllTypes);
            break;
          }
          case 1001: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.ext2.push(message as TestAllTypes);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
    },

    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedFieldsGenerator.readMessage(message, reader);
      return message as TestParsingMerge.RepeatedFieldsGenerator;
    },

    defaultValue: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    Group1: {
      writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): void {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group1.writeMessage(
          group1,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message as TestAllTypes;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group1.readMessage(
          message,
          reader
        );
        return message as TestParsingMerge.RepeatedFieldsGenerator.Group1;
      },

      defaultValue:
        function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
          return {
            field1: TestAllTypes.defaultValue(),
          };
        },
    },

    Group2: {
      writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): void {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes.writeMessage);
        }
      },

      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        const writer = new BinaryWriter();
        TestParsingMerge.RepeatedFieldsGenerator.Group2.writeMessage(
          group2,
          writer
        );
        return writer.getResultBuffer();
      },

      readMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        reader: BinaryReader
      ): void {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              const message = {};
              reader.readMessage(message, TestAllTypes.readMessage);
              msg.field1 = message as TestAllTypes;
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        if (!msg.field1) {
          msg.field1 = TestAllTypes.defaultValue();
        }
      },

      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const reader = new BinaryReader(bytes);
        const message = {};
        TestParsingMerge.RepeatedFieldsGenerator.Group2.readMessage(
          message,
          reader
        );
        return message as TestParsingMerge.RepeatedFieldsGenerator.Group2;
      },

      defaultValue:
        function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
          return {
            field1: TestAllTypes.defaultValue(),
          };
        },
    },
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.optional_group_all_types) {
        writer.writeMessage(
          11,
          msg.optional_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.optional_group_all_types = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.optional_group_all_types) {
        msg.optional_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.OptionalGroup.readMessage(message, reader);
      return message as TestParsingMerge.OptionalGroup;
    },

    defaultValue: function (): TestParsingMerge.OptionalGroup {
      return {
        optional_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },

  RepeatedGroup: {
    writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.repeated_group_all_types) {
        writer.writeMessage(
          21,
          msg.repeated_group_all_types,
          TestAllTypes.writeMessage
        );
      }
    },

    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestParsingMerge.RepeatedGroup.writeMessage(repeatedGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            const message = {};
            reader.readMessage(message, TestAllTypes.readMessage);
            msg.repeated_group_all_types = message as TestAllTypes;
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.repeated_group_all_types) {
        msg.repeated_group_all_types = TestAllTypes.defaultValue();
      }
    },

    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestParsingMerge.RepeatedGroup.readMessage(message, reader);
      return message as TestParsingMerge.RepeatedGroup;
    },

    defaultValue: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeated_group_all_types: TestAllTypes.defaultValue(),
      };
    },
  },
};

export const TestCommentInjectionMessage = {
  writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
  },

  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestCommentInjectionMessage.writeMessage(
      testCommentInjectionMessage,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.a) {
      msg.a = \\"\\";
    }
  },

  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestCommentInjectionMessage.readMessage(message, reader);
    return message as TestCommentInjectionMessage;
  },

  defaultValue: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },
};

export const FooRequest = {
  writeMessage: function (
    msg: Partial<FooRequest>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooRequest: Partial<FooRequest>): Uint8Array {
    const writer = new BinaryWriter();
    FooRequest.writeMessage(fooRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<FooRequest>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooRequest.readMessage(message, reader);
    return message as FooRequest;
  },

  defaultValue: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  writeMessage: function (
    msg: Partial<FooResponse>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooResponse: Partial<FooResponse>): Uint8Array {
    const writer = new BinaryWriter();
    FooResponse.writeMessage(fooResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooResponse.readMessage(message, reader);
    return message as FooResponse;
  },

  defaultValue: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  writeMessage: function (
    msg: Partial<FooClientMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooClientMessage: Partial<FooClientMessage>): Uint8Array {
    const writer = new BinaryWriter();
    FooClientMessage.writeMessage(fooClientMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooClientMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooClientMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooClientMessage.readMessage(message, reader);
    return message as FooClientMessage;
  },

  defaultValue: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  writeMessage: function (
    msg: Partial<FooServerMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (fooServerMessage: Partial<FooServerMessage>): Uint8Array {
    const writer = new BinaryWriter();
    FooServerMessage.writeMessage(fooServerMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<FooServerMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): FooServerMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    FooServerMessage.readMessage(message, reader);
    return message as FooServerMessage;
  },

  defaultValue: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  writeMessage: function (
    msg: Partial<BarRequest>,
    writer: BinaryWriter
  ): void {},

  encode: function (barRequest: Partial<BarRequest>): Uint8Array {
    const writer = new BinaryWriter();
    BarRequest.writeMessage(barRequest, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<BarRequest>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): BarRequest {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarRequest.readMessage(message, reader);
    return message as BarRequest;
  },

  defaultValue: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  writeMessage: function (
    msg: Partial<BarResponse>,
    writer: BinaryWriter
  ): void {},

  encode: function (barResponse: Partial<BarResponse>): Uint8Array {
    const writer = new BinaryWriter();
    BarResponse.writeMessage(barResponse, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<BarResponse>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): BarResponse {
    const reader = new BinaryReader(bytes);
    const message = {};
    BarResponse.readMessage(message, reader);
    return message as BarResponse;
  },

  defaultValue: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): void {
    if (msg.field_name1) {
      writer.writeInt32(1, msg.field_name1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg._field_name4) {
      writer.writeInt32(4, msg._field_name4);
    }
    if (msg.FIELD_NAME5) {
      writer.writeInt32(5, msg.FIELD_NAME5);
    }
    if (msg.field_name6) {
      writer.writeInt32(6, msg.field_name6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
  },

  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    const writer = new BinaryWriter();
    TestJsonName.writeMessage(testJsonName, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestJsonName>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field_name1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg._field_name4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELD_NAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field_name6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field_name1) {
      msg.field_name1 = 0;
    }
    if (!msg.fieldName2) {
      msg.fieldName2 = 0;
    }
    if (!msg.FieldName3) {
      msg.FieldName3 = 0;
    }
    if (!msg._field_name4) {
      msg._field_name4 = 0;
    }
    if (!msg.FIELD_NAME5) {
      msg.FIELD_NAME5 = 0;
    }
    if (!msg.field_name6) {
      msg.field_name6 = 0;
    }
    if (!msg.fieldname7) {
      msg.fieldname7 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestJsonName {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestJsonName.readMessage(message, reader);
    return message as TestJsonName;
  },

  defaultValue: function (): TestJsonName {
    return {
      field_name1: 0,
      fieldName2: 0,
      FieldName3: 0,
      _field_name4: 0,
      FIELD_NAME5: 0,
      field_name6: 0,
      fieldname7: 0,
    };
  },
};

export const TestHugeFieldNumbers = {
  writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(536870000, msg.optional_int32);
    }
    if (msg.fixed_32) {
      writer.writeInt32(536870001, msg.fixed_32);
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeated_int32);
    }
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packed_int32);
    }
    if (msg.optional_enum) {
      writer.writeEnum(536870004, msg.optional_enum);
    }
    if (msg.optional_string) {
      writer.writeString(536870005, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(536870006, msg.optional_bytes);
    }
    if (msg.optional_message) {
      writer.writeMessage(
        536870007,
        msg.optional_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.string_string_map) {
      for (const key in msg.string_string_map) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.string_string_map![key]);
        });
      }
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(536870011, msg.oneof_uint32);
    }
    if (msg.oneof_test_all_types != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneof_test_all_types,
        TestAllTypes.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(536870013, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(536870014, msg.oneof_bytes);
    }
  },

  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestHugeFieldNumbers.writeMessage(testHugeFieldNumbers, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.packed_int32 = [];
    msg.string_string_map = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed_32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optional_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optional_string = reader.readString();
          break;
        }
        case 536870006: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 536870007: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_message = message as ForeignMessage;
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.string_string_map![key!] = value!;
          });
          break;
        }
        case 536870011: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.oneof_test_all_types = message as TestAllTypes;
          break;
        }
        case 536870013: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.fixed_32) {
      msg.fixed_32 = 0;
    }
    if (!msg.optional_enum) {
      msg.optional_enum = 0;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_message) {
      msg.optional_message = ForeignMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestHugeFieldNumbers.readMessage(message, reader);
    return message as TestHugeFieldNumbers;
  },

  defaultValue: function (): TestHugeFieldNumbers {
    return {
      optional_int32: 0,
      fixed_32: 0,
      repeated_int32: [],
      packed_int32: [],
      optional_enum: 0,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_message: ForeignMessage.defaultValue(),
      string_string_map: {},
      oneof_test_all_types: TestAllTypes.defaultValue(),
    };
  },

  OptionalGroup: {
    writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): void {
      if (msg.group_a) {
        writer.writeInt32(536870009, msg.group_a);
      }
    },

    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestHugeFieldNumbers.OptionalGroup.writeMessage(optionalGroup, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.group_a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.group_a) {
        msg.group_a = 0;
      }
    },

    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestHugeFieldNumbers.OptionalGroup.readMessage(message, reader);
      return message as TestHugeFieldNumbers.OptionalGroup;
    },

    defaultValue: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        group_a: 0,
      };
    },
  },
};

export const TestExtensionInsideTable = {
  writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): void {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
  },

  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionInsideTable.writeMessage(testExtensionInsideTable, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.field1) {
      msg.field1 = 0;
    }
    if (!msg.field2) {
      msg.field2 = 0;
    }
    if (!msg.field3) {
      msg.field3 = 0;
    }
    if (!msg.field4) {
      msg.field4 = 0;
    }
    if (!msg.field6) {
      msg.field6 = 0;
    }
    if (!msg.field7) {
      msg.field7 = 0;
    }
    if (!msg.field8) {
      msg.field8 = 0;
    }
    if (!msg.field9) {
      msg.field9 = 0;
    }
    if (!msg.field10) {
      msg.field10 = 0;
    }
  },

  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionInsideTable.readMessage(message, reader);
    return message as TestExtensionInsideTable;
  },

  defaultValue: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },
};

export const TestExtensionRangeSerialize = {
  writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_one) {
      writer.writeInt32(1, msg.foo_one);
    }
    if (msg.foo_two) {
      writer.writeInt32(6, msg.foo_two);
    }
    if (msg.foo_three) {
      writer.writeInt32(7, msg.foo_three);
    }
    if (msg.foo_four) {
      writer.writeInt32(13, msg.foo_four);
    }
  },

  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestExtensionRangeSerialize.writeMessage(
      testExtensionRangeSerialize,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.foo_one = reader.readInt32();
          break;
        }
        case 6: {
          msg.foo_two = reader.readInt32();
          break;
        }
        case 7: {
          msg.foo_three = reader.readInt32();
          break;
        }
        case 13: {
          msg.foo_four = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.foo_one) {
      msg.foo_one = 0;
    }
    if (!msg.foo_two) {
      msg.foo_two = 0;
    }
    if (!msg.foo_three) {
      msg.foo_three = 0;
    }
    if (!msg.foo_four) {
      msg.foo_four = 0;
    }
  },

  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestExtensionRangeSerialize.readMessage(message, reader);
    return message as TestExtensionRangeSerialize;
  },

  defaultValue: function (): TestExtensionRangeSerialize {
    return {
      foo_one: 0,
      foo_two: 0,
      foo_three: 0,
      foo_four: 0,
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  map_int32_int32: TestMap.MapInt32Int32;
  map_int64_int64: TestMap.MapInt64Int64;
  map_uint32_uint32: TestMap.MapUint32Uint32;
  map_uint64_uint64: TestMap.MapUint64Uint64;
  map_sint32_sint32: TestMap.MapSint32Sint32;
  map_sint64_sint64: TestMap.MapSint64Sint64;
  map_fixed32_fixed32: TestMap.MapFixed32Fixed32;
  map_fixed64_fixed64: TestMap.MapFixed64Fixed64;
  map_sfixed32_sfixed32: TestMap.MapSfixed32Sfixed32;
  map_sfixed64_sfixed64: TestMap.MapSfixed64Sfixed64;
  map_int32_float: TestMap.MapInt32Float;
  map_int32_double: TestMap.MapInt32Double;
  map_bool_bool: TestMap.MapBoolBool;
  map_string_string: TestMap.MapStringString;
  map_int32_bytes: TestMap.MapInt32Bytes;
  map_int32_enum: TestMap.MapInt32Enum;
  map_int32_foreign_message: TestMap.MapInt32ForeignMessage;
  map_string_foreign_message: TestMap.MapStringForeignMessage;
  map_int32_all_types: TestMap.MapInt32AllTypes;
}

export namespace TestMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<string, string | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<string, string | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<string, string | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<string, string | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<string, string | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;

  export type MapStringForeignMessage = Record<
    string,
    ForeignMessage | undefined
  >;

  export type MapInt32AllTypes = Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  test_map: TestMap;
}

export interface TestMessageMap {
  map_int32_message: TestMessageMap.MapInt32Message;
}

export namespace TestMessageMap {
  export type MapInt32Message = Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: TestSameTypeMap.Map1;
  map2: TestSameTypeMap.Map2;
}

export namespace TestSameTypeMap {
  export type Map1 = Record<number, number | undefined>;

  export type Map2 = Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  map_field: TestRequiredMessageMap.MapField;
}

export namespace TestRequiredMessageMap {
  export type MapField = Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  map_int32_int32: TestArenaMap.MapInt32Int32;
  map_int64_int64: TestArenaMap.MapInt64Int64;
  map_uint32_uint32: TestArenaMap.MapUint32Uint32;
  map_uint64_uint64: TestArenaMap.MapUint64Uint64;
  map_sint32_sint32: TestArenaMap.MapSint32Sint32;
  map_sint64_sint64: TestArenaMap.MapSint64Sint64;
  map_fixed32_fixed32: TestArenaMap.MapFixed32Fixed32;
  map_fixed64_fixed64: TestArenaMap.MapFixed64Fixed64;
  map_sfixed32_sfixed32: TestArenaMap.MapSfixed32Sfixed32;
  map_sfixed64_sfixed64: TestArenaMap.MapSfixed64Sfixed64;
  map_int32_float: TestArenaMap.MapInt32Float;
  map_int32_double: TestArenaMap.MapInt32Double;
  map_bool_bool: TestArenaMap.MapBoolBool;
  map_string_string: TestArenaMap.MapStringString;
  map_int32_bytes: TestArenaMap.MapInt32Bytes;
  map_int32_enum: TestArenaMap.MapInt32Enum;
  map_int32_foreign_message: TestArenaMap.MapInt32ForeignMessage;
}

export namespace TestArenaMap {
  export type MapInt32Int32 = Record<number, number | undefined>;

  export type MapInt64Int64 = Record<string, string | undefined>;

  export type MapUint32Uint32 = Record<number, number | undefined>;

  export type MapUint64Uint64 = Record<string, string | undefined>;

  export type MapSint32Sint32 = Record<number, number | undefined>;

  export type MapSint64Sint64 = Record<string, string | undefined>;

  export type MapFixed32Fixed32 = Record<number, number | undefined>;

  export type MapFixed64Fixed64 = Record<string, string | undefined>;

  export type MapSfixed32Sfixed32 = Record<number, number | undefined>;

  export type MapSfixed64Sfixed64 = Record<string, string | undefined>;

  export type MapInt32Float = Record<number, number | undefined>;

  export type MapInt32Double = Record<number, number | undefined>;

  export type MapBoolBool = Record<boolean, boolean | undefined>;

  export type MapStringString = Record<string, string | undefined>;

  export type MapInt32Bytes = Record<number, Uint8Array | undefined>;

  export type MapInt32Enum = Record<number, MapEnum | undefined>;

  export type MapInt32ForeignMessage = Record<
    number,
    ForeignMessage | undefined
  >;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: MessageContainingMapCalledEntry.Entry;
}

export namespace MessageContainingMapCalledEntry {
  export type Entry = Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: TestRecursiveMapMessage.A;
}

export namespace TestRecursiveMapMessage {
  export type A = Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  writeMessage: function (msg: Partial<TestMap>, writer: BinaryWriter): void {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as any);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as any);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as any);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as any);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as any);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as any);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as any);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as any);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as any);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as any);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
    if (msg.map_string_foreign_message) {
      for (const key in msg.map_string_foreign_message) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeMessage(2, msg.map_string_foreign_message![key]);
        });
      }
    }
    if (msg.map_int32_all_types) {
      for (const key in msg.map_int32_all_types) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_all_types![key]);
        });
      }
    }
  },

  encode: function (testMap: Partial<TestMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestMap.writeMessage(testMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestMap>, reader: BinaryReader): void {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    msg.map_string_foreign_message = {};
    msg.map_int32_all_types = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64![key!] = value!;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32![key!] = value!;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64![key!] = value!;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32![key!] = value!;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64![key!] = value!;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32![key!] = value!;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64![key!] = value!;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32![key!] = value!;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64![key!] = value!;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float![key!] = value!;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double![key!] = value!;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean;
            let value: boolean;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool![key!] = value!;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string![key!] = value!;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: Uint8Array;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes![key!] = value!;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: MapEnum;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum![key!] = value!;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message![key!] = value!;
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_string_foreign_message![key!] = value!;
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestAllTypes;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_all_types![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMap.readMessage(message, reader);
    return message as TestMap;
  },

  defaultValue: function (): TestMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
      map_string_foreign_message: {},
      map_int32_all_types: {},
    };
  },
};

export const TestMapSubmessage = {
  writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): void {
    if (msg.test_map) {
      writer.writeMessage(1, msg.test_map, TestMap.writeMessage);
    }
  },

  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestMapSubmessage.writeMessage(testMapSubmessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMapSubmessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, TestMap.readMessage);
          msg.test_map = message as TestMap;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.test_map) {
      msg.test_map = TestMap.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestMapSubmessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMapSubmessage.readMessage(message, reader);
    return message as TestMapSubmessage;
  },

  defaultValue: function (): TestMapSubmessage {
    return {
      test_map: TestMap.defaultValue(),
    };
  },
};

export const TestMessageMap = {
  writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_int32_message) {
      for (const key in msg.map_int32_message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_message![key]);
        });
      }
    }
  },

  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageMap.writeMessage(testMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageMap>,
    reader: BinaryReader
  ): void {
    msg.map_int32_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestAllTypes;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_message![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestMessageMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageMap.readMessage(message, reader);
    return message as TestMessageMap;
  },

  defaultValue: function (): TestMessageMap {
    return {
      map_int32_message: {},
    };
  },
};

export const TestSameTypeMap = {
  writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
  },

  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestSameTypeMap.writeMessage(testSameTypeMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestSameTypeMap>,
    reader: BinaryReader
  ): void {
    msg.map1 = {};
    msg.map2 = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map1![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map2![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestSameTypeMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestSameTypeMap.readMessage(message, reader);
    return message as TestSameTypeMap;
  },

  defaultValue: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },
};

export const TestRequiredMessageMap = {
  writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_field) {
      for (const key in msg.map_field) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_field![key]);
        });
      }
    }
  },

  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRequiredMessageMap.writeMessage(testRequiredMessageMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    reader: BinaryReader
  ): void {
    msg.map_field = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: TestRequired;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_field![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRequiredMessageMap.readMessage(message, reader);
    return message as TestRequiredMessageMap;
  },

  defaultValue: function (): TestRequiredMessageMap {
    return {
      map_field: {},
    };
  },
};

export const TestArenaMap = {
  writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): void {
    if (msg.map_int32_int32) {
      for (const key in msg.map_int32_int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.map_int32_int32![key]);
        });
      }
    }
    if (msg.map_int64_int64) {
      for (const key in msg.map_int64_int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as any);
          mapWriter.writeInt64String(2, msg.map_int64_int64![key]);
        });
      }
    }
    if (msg.map_uint32_uint32) {
      for (const key in msg.map_uint32_uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as any);
          mapWriter.writeUint32(2, msg.map_uint32_uint32![key]);
        });
      }
    }
    if (msg.map_uint64_uint64) {
      for (const key in msg.map_uint64_uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as any);
          mapWriter.writeUint64String(2, msg.map_uint64_uint64![key]);
        });
      }
    }
    if (msg.map_sint32_sint32) {
      for (const key in msg.map_sint32_sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as any);
          mapWriter.writeSint32(2, msg.map_sint32_sint32![key]);
        });
      }
    }
    if (msg.map_sint64_sint64) {
      for (const key in msg.map_sint64_sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as any);
          mapWriter.writeSint64String(2, msg.map_sint64_sint64![key]);
        });
      }
    }
    if (msg.map_fixed32_fixed32) {
      for (const key in msg.map_fixed32_fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as any);
          mapWriter.writeFixed32(2, msg.map_fixed32_fixed32![key]);
        });
      }
    }
    if (msg.map_fixed64_fixed64) {
      for (const key in msg.map_fixed64_fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as any);
          mapWriter.writeFixed64String(2, msg.map_fixed64_fixed64![key]);
        });
      }
    }
    if (msg.map_sfixed32_sfixed32) {
      for (const key in msg.map_sfixed32_sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as any);
          mapWriter.writeSfixed32(2, msg.map_sfixed32_sfixed32![key]);
        });
      }
    }
    if (msg.map_sfixed64_sfixed64) {
      for (const key in msg.map_sfixed64_sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as any);
          mapWriter.writeSfixed64(2, msg.map_sfixed64_sfixed64![key]);
        });
      }
    }
    if (msg.map_int32_float) {
      for (const key in msg.map_int32_float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeFloat(2, msg.map_int32_float![key]);
        });
      }
    }
    if (msg.map_int32_double) {
      for (const key in msg.map_int32_double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeDouble(2, msg.map_int32_double![key]);
        });
      }
    }
    if (msg.map_bool_bool) {
      for (const key in msg.map_bool_bool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as any);
          mapWriter.writeBool(2, msg.map_bool_bool![key]);
        });
      }
    }
    if (msg.map_string_string) {
      for (const key in msg.map_string_string) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeString(2, msg.map_string_string![key]);
        });
      }
    }
    if (msg.map_int32_bytes) {
      for (const key in msg.map_int32_bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeBytes(2, msg.map_int32_bytes![key]);
        });
      }
    }
    if (msg.map_int32_enum) {
      for (const key in msg.map_int32_enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeEnum(2, msg.map_int32_enum![key]);
        });
      }
    }
    if (msg.map_int32_foreign_message) {
      for (const key in msg.map_int32_foreign_message) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeMessage(2, msg.map_int32_foreign_message![key]);
        });
      }
    }
  },

  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    const writer = new BinaryWriter();
    TestArenaMap.writeMessage(testArenaMap, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestArenaMap>,
    reader: BinaryReader
  ): void {
    msg.map_int32_int32 = {};
    msg.map_int64_int64 = {};
    msg.map_uint32_uint32 = {};
    msg.map_uint64_uint64 = {};
    msg.map_sint32_sint32 = {};
    msg.map_sint64_sint64 = {};
    msg.map_fixed32_fixed32 = {};
    msg.map_fixed64_fixed64 = {};
    msg.map_sfixed32_sfixed32 = {};
    msg.map_sfixed64_sfixed64 = {};
    msg.map_int32_float = {};
    msg.map_int32_double = {};
    msg.map_bool_bool = {};
    msg.map_string_string = {};
    msg.map_int32_bytes = {};
    msg.map_int32_enum = {};
    msg.map_int32_foreign_message = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.map_int32_int32![key!] = value!;
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            msg.map_int64_int64![key!] = value!;
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            msg.map_uint32_uint32![key!] = value!;
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            msg.map_uint64_uint64![key!] = value!;
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            msg.map_sint32_sint32![key!] = value!;
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            msg.map_sint64_sint64![key!] = value!;
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            msg.map_fixed32_fixed32![key!] = value!;
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            msg.map_fixed64_fixed64![key!] = value!;
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            msg.map_sfixed32_sfixed32![key!] = value!;
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            msg.map_sfixed64_sfixed64![key!] = value!;
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            msg.map_int32_float![key!] = value!;
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            msg.map_int32_double![key!] = value!;
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean;
            let value: boolean;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            msg.map_bool_bool![key!] = value!;
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: string;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            msg.map_string_string![key!] = value!;
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: Uint8Array;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            msg.map_int32_bytes![key!] = value!;
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: MapEnum;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            msg.map_int32_enum![key!] = value!;
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: ForeignMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.map_int32_foreign_message![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestArenaMap {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestArenaMap.readMessage(message, reader);
    return message as TestArenaMap;
  },

  defaultValue: function (): TestArenaMap {
    return {
      map_int32_int32: {},
      map_int64_int64: {},
      map_uint32_uint32: {},
      map_uint64_uint64: {},
      map_sint32_sint32: {},
      map_sint64_sint64: {},
      map_fixed32_fixed32: {},
      map_fixed64_fixed64: {},
      map_sfixed32_sfixed32: {},
      map_sfixed64_sfixed64: {},
      map_int32_float: {},
      map_int32_double: {},
      map_bool_bool: {},
      map_string_string: {},
      map_int32_bytes: {},
      map_int32_enum: {},
      map_int32_foreign_message: {},
    };
  },
};

export const MessageContainingMapCalledEntry = {
  writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): void {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as any);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
  },

  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    const writer = new BinaryWriter();
    MessageContainingMapCalledEntry.writeMessage(
      messageContainingMapCalledEntry,
      writer
    );
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    reader: BinaryReader
  ): void {
    msg.entry = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number;
            let value: number;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            msg.entry![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    const reader = new BinaryReader(bytes);
    const message = {};
    MessageContainingMapCalledEntry.readMessage(message, reader);
    return message as MessageContainingMapCalledEntry;
  },

  defaultValue: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },
};

export const TestRecursiveMapMessage = {
  writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as any);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
  },

  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestRecursiveMapMessage.writeMessage(testRecursiveMapMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    reader: BinaryReader
  ): void {
    msg.a = {};
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string;
            let value: TestRecursiveMapMessage;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            msg.a![key!] = value!;
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestRecursiveMapMessage.readMessage(message, reader);
    return message as TestRecursiveMapMessage;
  },

  defaultValue: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optional_int32: number;
  optional_int64: string;
  optional_uint32: number;
  optional_uint64: string;
  optional_sint32: number;
  optional_sint64: string;
  optional_fixed32: number;
  optional_fixed64: string;
  optional_sfixed32: number;
  optional_sfixed64: string;
  optional_float: number;
  optional_double: number;
  optional_bool: boolean;
  optional_string: string;
  optional_bytes: Uint8Array;
  optional_nested_message: TestAllTypes.NestedMessage;
  optional_foreign_message: ForeignMessage;
  optional_import_message: ImportMessage;
  optional_nested_enum: TestAllTypes.NestedEnum;
  optional_foreign_enum: ForeignEnum;
  optional_string_piece: string;
  optional_cord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optional_public_import_message: PublicImportMessage;
  optional_lazy_message: TestAllTypes.NestedMessage;
  optional_lazy_import_message: ImportMessage;
  /**
   * Repeated
   */
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_string: string[];
  repeated_bytes: Uint8Array[];
  repeated_nested_message: TestAllTypes.NestedMessage[];
  repeated_foreign_message: ForeignMessage[];
  repeated_import_message: ImportMessage[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
  repeated_foreign_enum: ForeignEnum[];
  repeated_string_piece: string[];
  repeated_cord: string[];
  repeated_lazy_message: TestAllTypes.NestedMessage[];
  oneof_uint32?: number;
  oneof_nested_message?: TestAllTypes.NestedMessage;
  oneof_string?: string;
  oneof_bytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packed_int32: number[];
  packed_int64: string[];
  packed_uint32: number[];
  packed_uint64: string[];
  packed_sint32: number[];
  packed_sint64: string[];
  packed_fixed32: number[];
  packed_fixed64: string[];
  packed_sfixed32: number[];
  packed_sfixed64: string[];
  packed_float: number[];
  packed_double: number[];
  packed_bool: boolean[];
  packed_enum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeated_int32: number[];
  repeated_int64: string[];
  repeated_uint32: number[];
  repeated_uint64: string[];
  repeated_sint32: number[];
  repeated_sint64: string[];
  repeated_fixed32: number[];
  repeated_fixed64: string[];
  repeated_sfixed32: number[];
  repeated_sfixed64: string[];
  repeated_float: number[];
  repeated_double: number[];
  repeated_bool: boolean[];
  repeated_nested_enum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  foo_enum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.optional_int32) {
      writer.writeInt32(1, msg.optional_int32);
    }
    if (msg.optional_int64) {
      writer.writeInt64String(2, msg.optional_int64);
    }
    if (msg.optional_uint32) {
      writer.writeUint32(3, msg.optional_uint32);
    }
    if (msg.optional_uint64) {
      writer.writeUint64String(4, msg.optional_uint64);
    }
    if (msg.optional_sint32) {
      writer.writeSint32(5, msg.optional_sint32);
    }
    if (msg.optional_sint64) {
      writer.writeSint64String(6, msg.optional_sint64);
    }
    if (msg.optional_fixed32) {
      writer.writeFixed32(7, msg.optional_fixed32);
    }
    if (msg.optional_fixed64) {
      writer.writeFixed64String(8, msg.optional_fixed64);
    }
    if (msg.optional_sfixed32) {
      writer.writeSfixed32(9, msg.optional_sfixed32);
    }
    if (msg.optional_sfixed64) {
      writer.writeSfixed64(10, msg.optional_sfixed64);
    }
    if (msg.optional_float) {
      writer.writeFloat(11, msg.optional_float);
    }
    if (msg.optional_double) {
      writer.writeDouble(12, msg.optional_double);
    }
    if (msg.optional_bool) {
      writer.writeBool(13, msg.optional_bool);
    }
    if (msg.optional_string) {
      writer.writeString(14, msg.optional_string);
    }
    if (msg.optional_bytes) {
      writer.writeBytes(15, msg.optional_bytes);
    }
    if (msg.optional_nested_message) {
      writer.writeMessage(
        18,
        msg.optional_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_foreign_message) {
      writer.writeMessage(
        19,
        msg.optional_foreign_message,
        ForeignMessage.writeMessage
      );
    }
    if (msg.optional_import_message) {
      writer.writeMessage(
        20,
        msg.optional_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.optional_nested_enum) {
      writer.writeEnum(21, msg.optional_nested_enum);
    }
    if (msg.optional_foreign_enum) {
      writer.writeEnum(22, msg.optional_foreign_enum);
    }
    if (msg.optional_string_piece) {
      writer.writeString(24, msg.optional_string_piece);
    }
    if (msg.optional_cord) {
      writer.writeString(25, msg.optional_cord);
    }
    if (msg.optional_public_import_message) {
      writer.writeMessage(
        26,
        msg.optional_public_import_message,
        PublicImportMessage.writeMessage
      );
    }
    if (msg.optional_lazy_message) {
      writer.writeMessage(
        27,
        msg.optional_lazy_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.optional_lazy_import_message) {
      writer.writeMessage(
        115,
        msg.optional_lazy_import_message,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(31, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(41, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(42, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(43, msg.repeated_bool);
    }
    if (msg.repeated_string?.length) {
      writer.writeRepeatedString(44, msg.repeated_string);
    }
    if (msg.repeated_bytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeated_bytes);
    }
    if (msg.repeated_nested_message?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeated_nested_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.repeated_foreign_message?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeated_foreign_message as any,
        ForeignMessage.writeMessage
      );
    }
    if (msg.repeated_import_message?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeated_import_message as any,
        ImportMessage.writeMessage
      );
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(51, msg.repeated_nested_enum);
    }
    if (msg.repeated_foreign_enum?.length) {
      writer.writeRepeatedEnum(52, msg.repeated_foreign_enum);
    }
    if (msg.repeated_string_piece?.length) {
      writer.writeRepeatedString(54, msg.repeated_string_piece);
    }
    if (msg.repeated_cord?.length) {
      writer.writeRepeatedString(55, msg.repeated_cord);
    }
    if (msg.repeated_lazy_message?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeated_lazy_message as any,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_uint32 != undefined) {
      writer.writeUint32(111, msg.oneof_uint32);
    }
    if (msg.oneof_nested_message != undefined) {
      writer.writeMessage(
        112,
        msg.oneof_nested_message,
        TestAllTypes.NestedMessage.writeMessage
      );
    }
    if (msg.oneof_string != undefined) {
      writer.writeString(113, msg.oneof_string);
    }
    if (msg.oneof_bytes != undefined) {
      writer.writeBytes(114, msg.oneof_bytes);
    }
  },

  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestAllTypes.writeMessage(testAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestAllTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_string = [];
    msg.repeated_bytes = [];
    msg.repeated_nested_message = [];
    msg.repeated_foreign_message = [];
    msg.repeated_import_message = [];
    msg.repeated_nested_enum = [];
    msg.repeated_foreign_enum = [];
    msg.repeated_string_piece = [];
    msg.repeated_cord = [];
    msg.repeated_lazy_message = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optional_int32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optional_int64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optional_uint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optional_uint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optional_sint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optional_sint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optional_fixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optional_fixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optional_sfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optional_sfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optional_float = reader.readFloat();
          break;
        }
        case 12: {
          msg.optional_double = reader.readDouble();
          break;
        }
        case 13: {
          msg.optional_bool = reader.readBool();
          break;
        }
        case 14: {
          msg.optional_string = reader.readString();
          break;
        }
        case 15: {
          msg.optional_bytes = reader.readBytes();
          break;
        }
        case 18: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 19: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.optional_foreign_message = message as ForeignMessage;
          break;
        }
        case 20: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_import_message = message as ImportMessage;
          break;
        }
        case 21: {
          msg.optional_nested_enum =
            reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optional_foreign_enum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optional_string_piece = reader.readString();
          break;
        }
        case 25: {
          msg.optional_cord = reader.readString();
          break;
        }
        case 26: {
          const message = {};
          reader.readMessage(message, PublicImportMessage.readMessage);
          msg.optional_public_import_message = message as PublicImportMessage;
          break;
        }
        case 27: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.optional_lazy_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 115: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.optional_lazy_import_message = message as ImportMessage;
          break;
        }
        case 31: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeated_string.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeated_bytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_nested_message.push(
            message as TestAllTypes.NestedMessage
          );
          break;
        }
        case 49: {
          const message = {};
          reader.readMessage(message, ForeignMessage.readMessage);
          msg.repeated_foreign_message.push(message as ForeignMessage);
          break;
        }
        case 50: {
          const message = {};
          reader.readMessage(message, ImportMessage.readMessage);
          msg.repeated_import_message.push(message as ImportMessage);
          break;
        }
        case 51: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeated_foreign_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeated_string_piece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeated_cord.push(reader.readString());
          break;
        }
        case 57: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.repeated_lazy_message.push(message as TestAllTypes.NestedMessage);
          break;
        }
        case 111: {
          msg.oneof_uint32 = reader.readUint32();
          break;
        }
        case 112: {
          const message = {};
          reader.readMessage(message, TestAllTypes.NestedMessage.readMessage);
          msg.oneof_nested_message = message as TestAllTypes.NestedMessage;
          break;
        }
        case 113: {
          msg.oneof_string = reader.readString();
          break;
        }
        case 114: {
          msg.oneof_bytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.optional_int32) {
      msg.optional_int32 = 0;
    }
    if (!msg.optional_int64) {
      msg.optional_int64 = \\"\\";
    }
    if (!msg.optional_uint32) {
      msg.optional_uint32 = 0;
    }
    if (!msg.optional_uint64) {
      msg.optional_uint64 = \\"\\";
    }
    if (!msg.optional_sint32) {
      msg.optional_sint32 = 0;
    }
    if (!msg.optional_sint64) {
      msg.optional_sint64 = \\"\\";
    }
    if (!msg.optional_fixed32) {
      msg.optional_fixed32 = 0;
    }
    if (!msg.optional_fixed64) {
      msg.optional_fixed64 = \\"\\";
    }
    if (!msg.optional_sfixed32) {
      msg.optional_sfixed32 = 0;
    }
    if (!msg.optional_sfixed64) {
      msg.optional_sfixed64 = \\"\\";
    }
    if (!msg.optional_float) {
      msg.optional_float = 0;
    }
    if (!msg.optional_double) {
      msg.optional_double = 0;
    }
    if (!msg.optional_bool) {
      msg.optional_bool = false;
    }
    if (!msg.optional_string) {
      msg.optional_string = \\"\\";
    }
    if (!msg.optional_bytes) {
      msg.optional_bytes = new Uint8Array();
    }
    if (!msg.optional_nested_message) {
      msg.optional_nested_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_foreign_message) {
      msg.optional_foreign_message = ForeignMessage.defaultValue();
    }
    if (!msg.optional_import_message) {
      msg.optional_import_message = ImportMessage.defaultValue();
    }
    if (!msg.optional_nested_enum) {
      msg.optional_nested_enum = 0;
    }
    if (!msg.optional_foreign_enum) {
      msg.optional_foreign_enum = 0;
    }
    if (!msg.optional_string_piece) {
      msg.optional_string_piece = \\"\\";
    }
    if (!msg.optional_cord) {
      msg.optional_cord = \\"\\";
    }
    if (!msg.optional_public_import_message) {
      msg.optional_public_import_message = PublicImportMessage.defaultValue();
    }
    if (!msg.optional_lazy_message) {
      msg.optional_lazy_message = TestAllTypes.NestedMessage.defaultValue();
    }
    if (!msg.optional_lazy_import_message) {
      msg.optional_lazy_import_message = ImportMessage.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): TestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestAllTypes.readMessage(message, reader);
    return message as TestAllTypes;
  },

  defaultValue: function (): TestAllTypes {
    return {
      optional_int32: 0,
      optional_int64: \\"\\",
      optional_uint32: 0,
      optional_uint64: \\"\\",
      optional_sint32: 0,
      optional_sint64: \\"\\",
      optional_fixed32: 0,
      optional_fixed64: \\"\\",
      optional_sfixed32: 0,
      optional_sfixed64: \\"\\",
      optional_float: 0,
      optional_double: 0,
      optional_bool: false,
      optional_string: \\"\\",
      optional_bytes: new Uint8Array(),
      optional_nested_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_foreign_message: ForeignMessage.defaultValue(),
      optional_import_message: ImportMessage.defaultValue(),
      optional_nested_enum: 0,
      optional_foreign_enum: 0,
      optional_string_piece: \\"\\",
      optional_cord: \\"\\",
      optional_public_import_message: PublicImportMessage.defaultValue(),
      optional_lazy_message: TestAllTypes.NestedMessage.defaultValue(),
      optional_lazy_import_message: ImportMessage.defaultValue(),
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_string: [],
      repeated_bytes: [],
      repeated_nested_message: [],
      repeated_foreign_message: [],
      repeated_import_message: [],
      repeated_nested_enum: [],
      repeated_foreign_enum: [],
      repeated_string_piece: [],
      repeated_cord: [],
      repeated_lazy_message: [],
      oneof_nested_message: TestAllTypes.NestedMessage.defaultValue(),
    };
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): void {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
    },

    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      const writer = new BinaryWriter();
      TestAllTypes.NestedMessage.writeMessage(nestedMessage, writer);
      return writer.getResultBuffer();
    },

    readMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      reader: BinaryReader
    ): void {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      if (!msg.bb) {
        msg.bb = 0;
      }
    },

    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      const reader = new BinaryReader(bytes);
      const message = {};
      TestAllTypes.NestedMessage.readMessage(message, reader);
      return message as TestAllTypes.NestedMessage;
    },

    defaultValue: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },
  },
};

export const TestPackedTypes = {
  writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.packed_int32?.length) {
      writer.writeRepeatedInt32(90, msg.packed_int32);
    }
    if (msg.packed_int64?.length) {
      writer.writeRepeatedInt64String(91, msg.packed_int64);
    }
    if (msg.packed_uint32?.length) {
      writer.writeRepeatedUint32(92, msg.packed_uint32);
    }
    if (msg.packed_uint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packed_uint64);
    }
    if (msg.packed_sint32?.length) {
      writer.writeRepeatedSint32(94, msg.packed_sint32);
    }
    if (msg.packed_sint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packed_sint64);
    }
    if (msg.packed_fixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packed_fixed32);
    }
    if (msg.packed_fixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packed_fixed64);
    }
    if (msg.packed_sfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packed_sfixed32);
    }
    if (msg.packed_sfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packed_sfixed64);
    }
    if (msg.packed_float?.length) {
      writer.writeRepeatedFloat(100, msg.packed_float);
    }
    if (msg.packed_double?.length) {
      writer.writeRepeatedDouble(101, msg.packed_double);
    }
    if (msg.packed_bool?.length) {
      writer.writeRepeatedBool(102, msg.packed_bool);
    }
    if (msg.packed_enum?.length) {
      writer.writeRepeatedEnum(103, msg.packed_enum);
    }
  },

  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestPackedTypes.writeMessage(testPackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestPackedTypes>,
    reader: BinaryReader
  ): void {
    msg.packed_int32 = [];
    msg.packed_int64 = [];
    msg.packed_uint32 = [];
    msg.packed_uint64 = [];
    msg.packed_sint32 = [];
    msg.packed_sint64 = [];
    msg.packed_fixed32 = [];
    msg.packed_fixed64 = [];
    msg.packed_sfixed32 = [];
    msg.packed_sfixed64 = [];
    msg.packed_float = [];
    msg.packed_double = [];
    msg.packed_bool = [];
    msg.packed_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packed_int32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packed_int64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packed_uint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packed_uint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packed_sint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packed_sint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packed_fixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packed_fixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packed_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packed_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packed_float.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packed_double.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packed_bool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packed_enum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestPackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestPackedTypes.readMessage(message, reader);
    return message as TestPackedTypes;
  },

  defaultValue: function (): TestPackedTypes {
    return {
      packed_int32: [],
      packed_int64: [],
      packed_uint32: [],
      packed_uint64: [],
      packed_sint32: [],
      packed_sint64: [],
      packed_fixed32: [],
      packed_fixed64: [],
      packed_sfixed32: [],
      packed_sfixed64: [],
      packed_float: [],
      packed_double: [],
      packed_bool: [],
      packed_enum: [],
    };
  },
};

export const TestUnpackedTypes = {
  writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.repeated_int32?.length) {
      writer.writeRepeatedInt32(1, msg.repeated_int32);
    }
    if (msg.repeated_int64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeated_int64);
    }
    if (msg.repeated_uint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeated_uint32);
    }
    if (msg.repeated_uint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeated_uint64);
    }
    if (msg.repeated_sint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeated_sint32);
    }
    if (msg.repeated_sint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeated_sint64);
    }
    if (msg.repeated_fixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeated_fixed32);
    }
    if (msg.repeated_fixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeated_fixed64);
    }
    if (msg.repeated_sfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeated_sfixed32);
    }
    if (msg.repeated_sfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeated_sfixed64);
    }
    if (msg.repeated_float?.length) {
      writer.writeRepeatedFloat(11, msg.repeated_float);
    }
    if (msg.repeated_double?.length) {
      writer.writeRepeatedDouble(12, msg.repeated_double);
    }
    if (msg.repeated_bool?.length) {
      writer.writeRepeatedBool(13, msg.repeated_bool);
    }
    if (msg.repeated_nested_enum?.length) {
      writer.writeRepeatedEnum(14, msg.repeated_nested_enum);
    }
  },

  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    const writer = new BinaryWriter();
    TestUnpackedTypes.writeMessage(testUnpackedTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestUnpackedTypes>,
    reader: BinaryReader
  ): void {
    msg.repeated_int32 = [];
    msg.repeated_int64 = [];
    msg.repeated_uint32 = [];
    msg.repeated_uint64 = [];
    msg.repeated_sint32 = [];
    msg.repeated_sint64 = [];
    msg.repeated_fixed32 = [];
    msg.repeated_fixed64 = [];
    msg.repeated_sfixed32 = [];
    msg.repeated_sfixed64 = [];
    msg.repeated_float = [];
    msg.repeated_double = [];
    msg.repeated_bool = [];
    msg.repeated_nested_enum = [];
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeated_int32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeated_int64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeated_uint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeated_uint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeated_sint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeated_sint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeated_fixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeated_fixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeated_sfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeated_sfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeated_float.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeated_double.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeated_bool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeated_nested_enum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestUnpackedTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestUnpackedTypes.readMessage(message, reader);
    return message as TestUnpackedTypes;
  },

  defaultValue: function (): TestUnpackedTypes {
    return {
      repeated_int32: [],
      repeated_int64: [],
      repeated_uint32: [],
      repeated_uint64: [],
      repeated_sint32: [],
      repeated_sint64: [],
      repeated_fixed32: [],
      repeated_fixed64: [],
      repeated_sfixed32: [],
      repeated_sfixed64: [],
      repeated_float: [],
      repeated_double: [],
      repeated_bool: [],
      repeated_nested_enum: [],
    };
  },
};

export const NestedTestAllTypes = {
  writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): void {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes.writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes.writeMessage);
    }
  },

  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    const writer = new BinaryWriter();
    NestedTestAllTypes.writeMessage(nestedTestAllTypes, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<NestedTestAllTypes>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const message = {};
          reader.readMessage(message, NestedTestAllTypes.readMessage);
          msg.child = message as NestedTestAllTypes;
          break;
        }
        case 2: {
          const message = {};
          reader.readMessage(message, TestAllTypes.readMessage);
          msg.payload = message as TestAllTypes;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.child) {
      msg.child = NestedTestAllTypes.defaultValue();
    }
    if (!msg.payload) {
      msg.payload = TestAllTypes.defaultValue();
    }
  },

  decode: function (bytes: ByteSource): NestedTestAllTypes {
    const reader = new BinaryReader(bytes);
    const message = {};
    NestedTestAllTypes.readMessage(message, reader);
    return message as NestedTestAllTypes;
  },

  defaultValue: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.defaultValue(),
      payload: TestAllTypes.defaultValue(),
    };
  },
};

export const ForeignMessage = {
  writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): void {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
  },

  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    const writer = new BinaryWriter();
    ForeignMessage.writeMessage(foreignMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<ForeignMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.c) {
      msg.c = 0;
    }
  },

  decode: function (bytes: ByteSource): ForeignMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    ForeignMessage.readMessage(message, reader);
    return message as ForeignMessage;
  },

  defaultValue: function (): ForeignMessage {
    return {
      c: 0,
    };
  },
};

export const TestEmptyMessage = {
  writeMessage: function (
    msg: Partial<TestEmptyMessage>,
    writer: BinaryWriter
  ): void {},

  encode: function (testEmptyMessage: Partial<TestEmptyMessage>): Uint8Array {
    const writer = new BinaryWriter();
    TestEmptyMessage.writeMessage(testEmptyMessage, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestEmptyMessage>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestEmptyMessage {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestEmptyMessage.readMessage(message, reader);
    return message as TestEmptyMessage;
  },

  defaultValue: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): void {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
  },

  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    const writer = new BinaryWriter();
    TestMessageWithDummy.writeMessage(testMessageWithDummy, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (
    msg: Partial<TestMessageWithDummy>,
    reader: BinaryReader
  ): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    if (!msg.dummy) {
      msg.dummy = false;
    }
  },

  decode: function (bytes: ByteSource): TestMessageWithDummy {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestMessageWithDummy.readMessage(message, reader);
    return message as TestMessageWithDummy;
  },

  defaultValue: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },
};

export const TestOneof2 = {
  writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): void {
    if (msg.foo_enum != undefined) {
      writer.writeEnum(6, msg.foo_enum);
    }
  },

  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    const writer = new BinaryWriter();
    TestOneof2.writeMessage(testOneof2, writer);
    return writer.getResultBuffer();
  },

  readMessage: function (msg: Partial<TestOneof2>, reader: BinaryReader): void {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.foo_enum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
  },

  decode: function (bytes: ByteSource): TestOneof2 {
    const reader = new BinaryReader(bytes);
    const message = {};
    TestOneof2.readMessage(message, reader);
    return message as TestOneof2;
  },

  defaultValue: function (): TestOneof2 {
    return {};
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
