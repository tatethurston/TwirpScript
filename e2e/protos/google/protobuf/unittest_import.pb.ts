// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = "IMPORT_FOO" | "IMPORT_BAR" | "IMPORT_BAZ";

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap = "UNKNOWN" | "FOO" | "BAR";

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMap = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessage = {
  /**
   * Serializes ImportMessage to protobuf.
   */
  encode: function (msg: PartialDeep<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ImportMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader,
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ImportEnumJSON = {
  IMPORT_FOO: "IMPORT_FOO",
  IMPORT_BAR: "IMPORT_BAR",
  IMPORT_BAZ: "IMPORT_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnum {
    switch (i) {
      case 7: {
        return "IMPORT_FOO";
      }
      case 8: {
        return "IMPORT_BAR";
      }
      case 9: {
        return "IMPORT_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnum): number {
    switch (i) {
      case "IMPORT_FOO": {
        return 7;
      }
      case "IMPORT_BAR": {
        return 8;
      }
      case "IMPORT_BAZ": {
        return 9;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportEnumForMapJSON = {
  UNKNOWN: "UNKNOWN",
  FOO: "FOO",
  BAR: "BAR",
  /**
   * @private
   */
  _fromInt: function (i: number): ImportEnumForMap {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "FOO";
      }
      case 2: {
        return "BAR";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ImportEnumForMap;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ImportEnumForMap): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "FOO": {
        return 1;
      }
      case "BAR": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const ImportMessageJSON = {
  /**
   * Serializes ImportMessage to JSON.
   */
  encode: function (msg: PartialDeep<ImportMessage>): string {
    return JSON.stringify(ImportMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ImportMessage from JSON.
   */
  decode: function (json: string): ImportMessage {
    return ImportMessageJSON._readMessage(
      ImportMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ImportMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ImportMessage, json: any): ImportMessage {
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};
