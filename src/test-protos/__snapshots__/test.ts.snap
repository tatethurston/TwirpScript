// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: \\"\\",
      defaultUint32: 0,
      defaultUint64: \\"\\",
      defaultSint32: 0,
      defaultSint64: \\"\\",
      defaultFixed32: 0,
      defaultFixed64: \\"\\",
      defaultSfixed32: 0,
      defaultSfixed64: \\"\\",
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum();
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum();
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum();
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (_testDeprecatedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (_testReservedFields) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (_testAllExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (_testGroupExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (_testNestedExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (_testEmptyMessageWithExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (_testPickleNestedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (_testMultipleExtensionRanges) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (_subMessage) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: \\"\\",
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = reader.readInt64String();
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: \\"\\",
      smallInt32: 0,
      smallInt64: \\"\\",
      reallySmallInt32: 0,
      reallySmallInt64: \\"\\",
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum();
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: \\"\\",
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt);
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64);
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64);
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64);
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64);
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64);
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (_testPackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (_testUnpackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const key in msg.stringStringMap) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.stringStringMap[key]);
        });
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.mapInt32Int32[key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.mapInt64Int64[key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.mapUint32Uint32[key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64[key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.mapSint32Sint32[key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64[key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32[key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64[key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32[key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64[key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.mapInt32Float[key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.mapInt32Double[key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.mapBoolBool[key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.mapStringString[key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.mapInt32Bytes[key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.mapInt32Enum[key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage[key]);
        });
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const key in msg.mapStringForeignMessage) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.mapStringForeignMessage[key]);
        });
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const key in msg.mapInt32AllTypes) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32AllTypes[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      for (const key in msg.mapInt32Message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32Message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      for (const key in msg.mapField) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapField[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.mapInt32Int32[key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.mapInt64Int64[key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.mapUint32Uint32[key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64[key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.mapSint32Sint32[key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64[key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32[key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64[key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32[key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64[key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.mapInt32Float[key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.mapInt32Double[key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.mapBoolBool[key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.mapStringString[key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.mapInt32Bytes[key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.mapInt32Enum[key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
      ],
      Array [
        "google/protobuf/empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};
",
      ],
      Array [
        "empty.pb.js",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFooHandler(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (publicImportMessage) {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes) {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = { IMPORT_FOO: 7, IMPORT_BAR: 8, IMPORT_BAZ: 9 };

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 };

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage) {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes) {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

export function createTestServiceHandler(service) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = { FOREIGN_FOO: 4, FOREIGN_BAR: 5, FOREIGN_BAZ: 6 };

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
};

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: \\"\\",
      defaultUint32: 0,
      defaultUint64: \\"\\",
      defaultSint32: 0,
      defaultSint64: \\"\\",
      defaultFixed32: 0,
      defaultFixed64: \\"\\",
      defaultSfixed32: 0,
      defaultSfixed64: \\"\\",
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum();
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum();
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum();
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (testDeprecatedFields) {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (_testDeprecatedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (_testReservedFields) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (_testAllExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (optionalGroup_extension) {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (repeatedGroup_extension) {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup) {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (_testGroupExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (_testNestedExtension) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (optionalGroup_extension) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (testChildExtension) {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired) {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (testRequiredForeign) {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (testRequiredMessage) {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested) {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (_testEmptyMessageWithExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (_testPickleNestedMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (nestedNestedMessage) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (_testMultipleExtensionRanges) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (testReallyLargeTagNumber) {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (testRecursiveMessage) {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (testMutualRecursionA) {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (subMessage) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (subGroup) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (testMutualRecursionB) {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized) {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (_subMessage) {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes) {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (subGroup) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (testDupFieldNumber) {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo) {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar) {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage) {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage) {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (testNestedMessageHasBits) {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (testCamelCaseFieldNames) {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum();
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum());
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (testFieldOrderings) {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
      myInt: \\"\\",
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = reader.readInt64String();
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (testExtensionOrderings1) {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (testExtensionOrderings2) {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (testExtensionOrderings3) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (testExtremeDefaultValues) {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: \\"\\",
      smallInt32: 0,
      smallInt64: \\"\\",
      reallySmallInt32: 0,
      reallySmallInt64: \\"\\",
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage) {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString) {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString) {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes) {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes) {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message) {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message) {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message) {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message) {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage) {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof) {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (testOneofBackwardsCompatible) {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum();
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 },

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup) {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: \\"\\",
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt);
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof) {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64);
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64);
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64);
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64);
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64);
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (_testPackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (_testUnpackedExtensions) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (testDynamicExtensions) {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum();
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension = reader.readEnum();
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: { DYNAMIC_FOO: 2200, DYNAMIC_BAR: 2201, DYNAMIC_BAZ: 2202 },

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (dynamicMessageType) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (testRepeatedScalarDifferentTagSizes) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge) {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (repeatedFieldsGenerator) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (group1) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (group2) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (repeatedGroup) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (testCommentInjectionMessage) {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse) {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName) {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (testHugeFieldNumbers) {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const key in msg.stringStringMap) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.stringStringMap[key]);
        });
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum();
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (optionalGroup) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (testExtensionInsideTable) {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (testExtensionRangeSerialize) {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = { MAP_ENUM_FOO: 0, MAP_ENUM_BAR: 1, MAP_ENUM_BAZ: 2 };

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap) {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.mapInt32Int32[key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.mapInt64Int64[key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.mapUint32Uint32[key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64[key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.mapSint32Sint32[key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64[key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32[key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64[key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32[key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64[key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.mapInt32Float[key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.mapInt32Double[key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.mapBoolBool[key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.mapStringString[key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.mapInt32Bytes[key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.mapInt32Enum[key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage[key]);
        });
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const key in msg.mapStringForeignMessage) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.mapStringForeignMessage[key]);
        });
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const key in msg.mapInt32AllTypes) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32AllTypes[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage) {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap) {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      for (const key in msg.mapInt32Message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32Message[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap) {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map1[key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.map2[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (testRequiredMessageMap) {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      for (const key in msg.mapField) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapField[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap) {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.mapInt32Int32[key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key);
          mapWriter.writeInt64String(2, msg.mapInt64Int64[key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key);
          mapWriter.writeUint32(2, msg.mapUint32Uint32[key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64[key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key);
          mapWriter.writeSint32(2, msg.mapSint32Sint32[key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64[key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32[key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64[key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32[key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64[key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeFloat(2, msg.mapInt32Float[key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeDouble(2, msg.mapInt32Double[key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key);
          mapWriter.writeBool(2, msg.mapBoolBool[key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeString(2, msg.mapStringString[key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeBytes(2, msg.mapInt32Bytes[key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeEnum(2, msg.mapInt32Enum[key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (messageContainingMapCalledEntry) {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key);
          mapWriter.writeInt32(2, msg.entry[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (testRecursiveMapMessage) {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key);
          mapWriter.writeMessage(2, msg.a[key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
};

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes) {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum();
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum();
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum());
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 },

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (nestedMessage) {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes) {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes) {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (nestedTestAllTypes) {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage) {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage) {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (testMessageWithDummy) {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes) {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function () {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2) {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty) {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.js",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(\\"/Foo/Bar\\", empty, config);
  return response;
}

export function createFooHandler(service) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  };
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
Object {
  "array": Array [
    ,
    1,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    Array [
      Array [
        "google/protobuf/unittest_import_public.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_import.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: string;
  optionalUint32: number;
  optionalUint64: string;
  optionalSint32: number;
  optionalSint64: string;
  optionalFixed32: number;
  optionalFixed64: string;
  optionalSfixed32: number;
  optionalSfixed64: string;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: string;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: string;
  defaultSint32: number;
  defaultSint64: string;
  defaultFixed32: number;
  defaultFixed64: string;
  defaultSfixed32: number;
  defaultSfixed64: string;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: string;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: string;
  smallInt32: number;
  smallInt64: string;
  reallySmallInt32: number;
  reallySmallInt64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number;
  fooString?: string;
  fooCord?: string;
  fooStringPiece?: string;
  fooBytes?: Uint8Array;
  fooEnum?: TestOneof2.NestedEnum;
  fooMessage?: TestOneof2.NestedMessage;
  fooLazyMessage?: TestOneof2.NestedMessage;
  barInt?: number;
  barString?: string;
  barCord?: string;
  barStringPiece?: string;
  barBytes?: Uint8Array;
  barEnum?: TestOneof2.NestedEnum;
  barStringWithEmptyDefault?: string;
  barCordWithEmptyDefault?: string;
  barStringPieceWithEmptyDefault?: string;
  barBytesWithEmptyDefault?: Uint8Array;
  bazInt: number;
  bazString: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: string;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: string[];
  packedUint32: number[];
  packedUint64: string[];
  packedSint32: number[];
  packedSint64: string[];
  packedFixed32: number[];
  packedFixed64: string[];
  packedSfixed32: number[];
  packedSfixed64: string[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: string[];
  unpackedUint32: number[];
  unpackedUint64: string[];
  unpackedSint32: number[];
  unpackedSint64: string[];
  unpackedFixed32: number[];
  unpackedFixed64: string[];
  unpackedSfixed32: number[];
  unpackedSfixed64: string[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: string[];
  repeatedInt64: string[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<string, string | undefined>;
  oneofUint32?: number;
  oneofTestAllTypes?: TestAllTypes;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: \\"\\",
      defaultUint32: 0,
      defaultUint64: \\"\\",
      defaultSint32: 0,
      defaultSint64: \\"\\",
      defaultFixed32: 0,
      defaultFixed64: \\"\\",
      defaultSfixed32: 0,
      defaultSfixed64: \\"\\",
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: \\"\\",
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = reader.readInt64String();
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: \\"\\",
      smallInt32: 0,
      smallInt64: \\"\\",
      reallySmallInt32: 0,
      reallySmallInt64: \\"\\",
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: \\"\\",
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt);
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64);
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64);
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64);
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64);
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64);
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const key in msg.stringStringMap) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.stringStringMap![key]);
        });
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/map_unittest.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<string, string | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<string, string | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<string, string | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<string, string | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<string, string | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
  mapStringForeignMessage: Record<string, ForeignMessage | undefined>;
  mapInt32AllTypes: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<string, string | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<string, string | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<string, string | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<string, string | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<string, string | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.mapInt32Int32![key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.mapInt64Int64![key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.mapUint32Uint32![key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64![key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.mapSint32Sint32![key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64![key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32![key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64![key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32![key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64![key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.mapInt32Float![key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.mapInt32Double![key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.mapBoolBool![key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.mapStringString![key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.mapInt32Bytes![key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.mapInt32Enum![key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage![key]);
        });
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const key in msg.mapStringForeignMessage) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.mapStringForeignMessage![key]);
        });
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const key in msg.mapInt32AllTypes) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32AllTypes![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      for (const key in msg.mapInt32Message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32Message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      for (const key in msg.mapField) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapField![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.mapInt32Int32![key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.mapInt64Int64![key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.mapUint32Uint32![key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64![key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.mapSint32Sint32![key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64![key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32![key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64![key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32![key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64![key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.mapInt32Float![key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.mapInt32Double![key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.mapBoolBool![key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.mapStringString![key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.mapInt32Bytes![key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.mapInt32Enum![key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
      ],
      Array [
        "google/protobuf/unittest_proto3.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: string;
  optionalUint32: number;
  optionalUint64: string;
  optionalSint32: number;
  optionalSint64: string;
  optionalFixed32: number;
  optionalFixed64: string;
  optionalSfixed32: number;
  optionalSfixed64: string;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: string[];
  packedUint32: number[];
  packedUint64: string[];
  packedSint32: number[];
  packedSint64: string[];
  packedFixed32: number[];
  packedFixed64: string[];
  packedSfixed32: number[];
  packedSfixed64: string[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
      ],
      Array [
        "google/protobuf/empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },
};
",
      ],
      Array [
        "empty.pb.ts",
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { ClientConfiguration } from \\"twirpscript\\";
import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//              Foo Service               //
//========================================//

export interface FooService<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFooHandler<Context>(service: FooService<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
      ],
    ],
  ],
  "arrayIndexOffset_": -1,
  "convertedPrimitiveFields_": Object {},
  "messageId_": undefined,
  "pivot_": 1.7976931348623157e+308,
  "wrappers_": Object {
    "15": Array [
      Object {
        "array": Array [
          "google/protobuf/unittest_import_public.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import_public.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export interface PublicImportMessage {
  e: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const PublicImportMessage = {
  /**
   * Serializes a PublicImportMessage to protobuf.
   */
  encode: function (
    publicImportMessage: Partial<PublicImportMessage>
  ): Uint8Array {
    return PublicImportMessage._writeMessage(
      publicImportMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a PublicImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): PublicImportMessage {
    return PublicImportMessage._readMessage(
      PublicImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a PublicImportMessage with all fields set to their default value.
   */
  initialize: function (): PublicImportMessage {
    return {
      e: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<PublicImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.e) {
      writer.writeInt32(1, msg.e);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: PublicImportMessage,
    reader: BinaryReader
  ): PublicImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.e = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_import.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_import.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

export type ImportEnum = typeof ImportEnum[keyof typeof ImportEnum];

/**
 * To use an enum in a map, it must has the first value as 0.
 */
export type ImportEnumForMap =
  typeof ImportEnumForMap[keyof typeof ImportEnumForMap];

export interface ImportMessage {
  d: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ImportEnum = {
  IMPORT_FOO: 7,
  IMPORT_BAR: 8,
  IMPORT_BAZ: 9,
} as const;

export const ImportEnumForMap = { UNKNOWN: 0, FOO: 1, BAR: 2 } as const;

export const ImportMessage = {
  /**
   * Serializes a ImportMessage to protobuf.
   */
  encode: function (importMessage: Partial<ImportMessage>): Uint8Array {
    return ImportMessage._writeMessage(
      importMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ImportMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ImportMessage {
    return ImportMessage._readMessage(
      ImportMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ImportMessage with all fields set to their default value.
   */
  initialize: function (): ImportMessage {
    return {
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ImportMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.d) {
      writer.writeInt32(1, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ImportMessage,
    reader: BinaryReader
  ): ImportMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto

import type { ByteSource, ClientConfiguration } from \\"twirpscript\\";
import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { ImportMessage, ImportEnum } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Foo\\",
    FooRequest.encode(fooRequest),
    config
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await PBrequest(
    \\"/protobuf_unittest.TestService/Bar\\",
    BarRequest.encode(barRequest),
    config
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration
): Promise<FooResponse> {
  const response = await JSONrequest<FooResponse>(
    \\"/protobuf_unittest.TestService/Foo\\",
    fooRequest,
    config
  );
  return response;
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration
): Promise<BarResponse> {
  const response = await JSONrequest<BarResponse>(
    \\"/protobuf_unittest.TestService/Bar\\",
    barRequest,
    config
  );
  return response;
}

//========================================//
//          TestService Service           //
//========================================//

export interface TestServiceService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestServiceHandler<Context>(
  service: TestServiceService<Context>
) {
  return {
    name: \\"protobuf_unittest.TestService\\",
    methods: {
      Foo: {
        name: \\"Foo\\",
        handler: service.Foo,
        input: FooRequest,
        output: FooResponse,
      },
      Bar: {
        name: \\"Bar\\",
        handler: service.Bar,
        input: BarRequest,
        output: BarResponse,
      },
    },
  } as const;
}

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue =
  typeof TestEnumWithDupValue[keyof typeof TestEnumWithDupValue];

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum = typeof TestSparseEnum[keyof typeof TestSparseEnum];

export type VeryLargeEnum = typeof VeryLargeEnum[keyof typeof VeryLargeEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: string;
  optionalUint32: number;
  optionalUint64: string;
  optionalSint32: number;
  optionalSint64: string;
  optionalFixed32: number;
  optionalFixed64: string;
  optionalSfixed32: number;
  optionalSfixed64: string;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: string;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: string;
  defaultSint32: number;
  defaultSint64: string;
  defaultFixed32: number;
  defaultFixed64: string;
  defaultSfixed32: number;
  defaultSfixed64: string;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  export namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export namespace TestIsInitialized {
  export interface SubMessage {}

  export namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: string;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: string;
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: string;
  smallInt32: number;
  smallInt64: string;
  reallySmallInt32: number;
  reallySmallInt64: string;
  /**
   * The default value here is UTF-8 for \\"\\\\u1234\\".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, \\"\\\\?\\" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: string;
}

export interface Uint64Message {
  data: string;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestAllTypes;
}

export namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number;
  fooString?: string;
  fooCord?: string;
  fooStringPiece?: string;
  fooBytes?: Uint8Array;
  fooEnum?: TestOneof2.NestedEnum;
  fooMessage?: TestOneof2.NestedMessage;
  fooLazyMessage?: TestOneof2.NestedMessage;
  barInt?: number;
  barString?: string;
  barCord?: string;
  barStringPiece?: string;
  barBytes?: Uint8Array;
  barEnum?: TestOneof2.NestedEnum;
  barStringWithEmptyDefault?: string;
  barCordWithEmptyDefault?: string;
  barStringPieceWithEmptyDefault?: string;
  barBytesWithEmptyDefault?: Uint8Array;
  bazInt: number;
  bazString: string;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: string;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number;
  fooString?: string;
  fooMessage?: TestRequiredOneof.NestedMessage;
}

export namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: string[];
  packedUint32: number[];
  packedUint64: string[];
  packedSint32: number[];
  packedSint64: string[];
  packedFixed32: number[];
  packedFixed64: string[];
  packedSfixed32: number[];
  packedSfixed64: string[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: string[];
  unpackedUint32: number[];
  unpackedUint64: string[];
  unpackedSint32: number[];
  unpackedSint64: string[];
  unpackedFixed32: number[];
  unpackedFixed64: string[];
  unpackedSfixed32: number[];
  unpackedSfixed64: string[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export namespace TestDynamicExtensions {
  export type DynamicEnumType =
    typeof TestDynamicExtensions.DynamicEnumType[keyof typeof TestDynamicExtensions.DynamicEnumType];

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: string[];
  repeatedInt64: string[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: string[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  export namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  FieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<string, string | undefined>;
  oneofUint32?: number;
  oneofTestAllTypes?: TestAllTypes;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestEnumWithDupValue = {
  FOO1: 1,
  BAR1: 2,
  BAZ: 3,
  FOO2: 1,
  BAR2: 2,
} as const;

export const TestSparseEnum = {
  SPARSE_A: 123,
  SPARSE_B: 62374,
  SPARSE_C: 12589234,
  SPARSE_D: -15,
  SPARSE_E: -53452,
  SPARSE_F: 0,
  SPARSE_G: 2,
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: 0,
  ENUM_LABEL_1: 1,
  ENUM_LABEL_2: 2,
  ENUM_LABEL_3: 3,
  ENUM_LABEL_4: 4,
  ENUM_LABEL_5: 5,
  ENUM_LABEL_6: 6,
  ENUM_LABEL_7: 7,
  ENUM_LABEL_8: 8,
  ENUM_LABEL_9: 9,
  ENUM_LABEL_10: 10,
  ENUM_LABEL_11: 11,
  ENUM_LABEL_12: 12,
  ENUM_LABEL_13: 13,
  ENUM_LABEL_14: 14,
  ENUM_LABEL_15: 15,
  ENUM_LABEL_16: 16,
  ENUM_LABEL_17: 17,
  ENUM_LABEL_18: 18,
  ENUM_LABEL_19: 19,
  ENUM_LABEL_20: 20,
  ENUM_LABEL_21: 21,
  ENUM_LABEL_22: 22,
  ENUM_LABEL_23: 23,
  ENUM_LABEL_24: 24,
  ENUM_LABEL_25: 25,
  ENUM_LABEL_26: 26,
  ENUM_LABEL_27: 27,
  ENUM_LABEL_28: 28,
  ENUM_LABEL_29: 29,
  ENUM_LABEL_30: 30,
  ENUM_LABEL_31: 31,
  ENUM_LABEL_32: 32,
  ENUM_LABEL_33: 33,
  ENUM_LABEL_34: 34,
  ENUM_LABEL_35: 35,
  ENUM_LABEL_36: 36,
  ENUM_LABEL_37: 37,
  ENUM_LABEL_38: 38,
  ENUM_LABEL_39: 39,
  ENUM_LABEL_40: 40,
  ENUM_LABEL_41: 41,
  ENUM_LABEL_42: 42,
  ENUM_LABEL_43: 43,
  ENUM_LABEL_44: 44,
  ENUM_LABEL_45: 45,
  ENUM_LABEL_46: 46,
  ENUM_LABEL_47: 47,
  ENUM_LABEL_48: 48,
  ENUM_LABEL_49: 49,
  ENUM_LABEL_50: 50,
  ENUM_LABEL_51: 51,
  ENUM_LABEL_52: 52,
  ENUM_LABEL_53: 53,
  ENUM_LABEL_54: 54,
  ENUM_LABEL_55: 55,
  ENUM_LABEL_56: 56,
  ENUM_LABEL_57: 57,
  ENUM_LABEL_58: 58,
  ENUM_LABEL_59: 59,
  ENUM_LABEL_60: 60,
  ENUM_LABEL_61: 61,
  ENUM_LABEL_62: 62,
  ENUM_LABEL_63: 63,
  ENUM_LABEL_64: 64,
  ENUM_LABEL_65: 65,
  ENUM_LABEL_66: 66,
  ENUM_LABEL_67: 67,
  ENUM_LABEL_68: 68,
  ENUM_LABEL_69: 69,
  ENUM_LABEL_70: 70,
  ENUM_LABEL_71: 71,
  ENUM_LABEL_72: 72,
  ENUM_LABEL_73: 73,
  ENUM_LABEL_74: 74,
  ENUM_LABEL_75: 75,
  ENUM_LABEL_76: 76,
  ENUM_LABEL_77: 77,
  ENUM_LABEL_78: 78,
  ENUM_LABEL_79: 79,
  ENUM_LABEL_80: 80,
  ENUM_LABEL_81: 81,
  ENUM_LABEL_82: 82,
  ENUM_LABEL_83: 83,
  ENUM_LABEL_84: 84,
  ENUM_LABEL_85: 85,
  ENUM_LABEL_86: 86,
  ENUM_LABEL_87: 87,
  ENUM_LABEL_88: 88,
  ENUM_LABEL_89: 89,
  ENUM_LABEL_90: 90,
  ENUM_LABEL_91: 91,
  ENUM_LABEL_92: 92,
  ENUM_LABEL_93: 93,
  ENUM_LABEL_94: 94,
  ENUM_LABEL_95: 95,
  ENUM_LABEL_96: 96,
  ENUM_LABEL_97: 97,
  ENUM_LABEL_98: 98,
  ENUM_LABEL_99: 99,
  ENUM_LABEL_100: 100,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalImportEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: \\"\\",
      defaultUint32: 0,
      defaultUint64: \\"\\",
      defaultSint32: 0,
      defaultSint64: \\"\\",
      defaultFixed32: 0,
      defaultFixed64: \\"\\",
      defaultSfixed32: 0,
      defaultSfixed64: \\"\\",
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: \\"\\",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: 0,
      defaultForeignEnum: 0,
      defaultImportEnum: 0,
      defaultStringPiece: \\"\\",
      defaultCord: \\"\\",
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalImportEnum) {
      writer.writeEnum(23, msg.optionalImportEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writeRepeatedEnum(53, msg.repeatedImportEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64(70, msg.defaultSfixed64);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (msg.defaultNestedEnum) {
      writer.writeEnum(81, msg.defaultNestedEnum);
    }
    if (msg.defaultForeignEnum) {
      writer.writeEnum(82, msg.defaultForeignEnum);
    }
    if (msg.defaultImportEnum) {
      writer.writeEnum(83, msg.defaultImportEnum);
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 23: {
          msg.optionalImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 53: {
          msg.repeatedImportEnum.push(reader.readEnum() as ImportEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = reader.readInt64String();
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = reader.readUint64String();
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = reader.readSint64();
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = reader.readFixed64String();
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = reader.readSfixed64();
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 82: {
          msg.defaultForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 83: {
          msg.defaultImportEnum = reader.readEnum() as ImportEnum;
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestAllTypes.OptionalGroup>
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestAllTypes.RepeatedGroup>
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes a TestDeprecatedFields to protobuf.
   */
  encode: function (
    testDeprecatedFields: Partial<TestDeprecatedFields>
  ): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      testDeprecatedFields,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDeprecatedFields>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes a TestDeprecatedMessage to protobuf.
   */

  encode: function (
    _testDeprecatedMessage?: Partial<TestDeprecatedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestDeprecatedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes a TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes a TestReservedFields to protobuf.
   */

  encode: function (
    _testReservedFields?: Partial<TestReservedFields>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestReservedFields from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Initializes a TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },
};

export const TestAllExtensions = {
  /**
   * Serializes a TestAllExtensions to protobuf.
   */

  encode: function (
    _testAllExtensions?: Partial<TestAllExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestAllExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Initializes a TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes a OptionalGroup_extension to protobuf.
   */
  encode: function (
    optionalGroup_extension: Partial<OptionalGroup_extension>
  ): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      optionalGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OptionalGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes a RepeatedGroup_extension to protobuf.
   */
  encode: function (
    repeatedGroup_extension: Partial<RepeatedGroup_extension>
  ): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      repeatedGroup_extension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<RepeatedGroup_extension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes a TestGroup to protobuf.
   */
  encode: function (testGroup: Partial<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(
      testGroup,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestGroup>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestGroup.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestGroup.OptionalGroup>
    ): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestGroup.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes a TestGroupExtension to protobuf.
   */

  encode: function (
    _testGroupExtension?: Partial<TestGroupExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestGroupExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Initializes a TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },
};

export const TestNestedExtension = {
  /**
   * Serializes a TestNestedExtension to protobuf.
   */

  encode: function (
    _testNestedExtension?: Partial<TestNestedExtension>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestNestedExtension from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Initializes a TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  OptionalGroup_extension: {
    /**
     * Serializes a TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      optionalGroup_extension: Partial<TestNestedExtension.OptionalGroup_extension>
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        optionalGroup_extension,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes a TestChildExtension to protobuf.
   */
  encode: function (
    testChildExtension: Partial<TestChildExtension>
  ): Uint8Array {
    return TestChildExtension._writeMessage(
      testChildExtension,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: \\"\\",
      b: \\"\\",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestChildExtension>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes a TestRequired to protobuf.
   */
  encode: function (testRequired: Partial<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      testRequired,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequired>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes a TestRequiredForeign to protobuf.
   */
  encode: function (
    testRequiredForeign: Partial<TestRequiredForeign>
  ): Uint8Array {
    return TestRequiredForeign._writeMessage(
      testRequiredForeign,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredForeign>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes a TestRequiredMessage to protobuf.
   */
  encode: function (
    testRequiredMessage: Partial<TestRequiredMessage>
  ): Uint8Array {
    return TestRequiredMessage._writeMessage(
      testRequiredMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes a TestForeignNested to protobuf.
   */
  encode: function (testForeignNested: Partial<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      testForeignNested,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestForeignNested>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes a TestEmptyMessageWithExtensions to protobuf.
   */

  encode: function (
    _testEmptyMessageWithExtensions?: Partial<TestEmptyMessageWithExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessageWithExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes a TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes a TestPickleNestedMessage to protobuf.
   */

  encode: function (
    _testPickleNestedMessage?: Partial<TestPickleNestedMessage>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPickleNestedMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes a TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  NestedMessage: {
    /**
     * Serializes a TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestPickleNestedMessage.NestedMessage>
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        nestedNestedMessage: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          nestedNestedMessage,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes a TestMultipleExtensionRanges to protobuf.
   */

  encode: function (
    _testMultipleExtensionRanges?: Partial<TestMultipleExtensionRanges>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestMultipleExtensionRanges from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes a TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes a TestReallyLargeTagNumber to protobuf.
   */
  encode: function (
    testReallyLargeTagNumber: Partial<TestReallyLargeTagNumber>
  ): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      testReallyLargeTagNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestReallyLargeTagNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes a TestRecursiveMessage to protobuf.
   */
  encode: function (
    testRecursiveMessage: Partial<TestRecursiveMessage>
  ): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      testRecursiveMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: TestRecursiveMessage.initialize(),
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes a TestMutualRecursionA to protobuf.
   */
  encode: function (
    testMutualRecursionA: Partial<TestMutualRecursionA>
  ): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      testMutualRecursionA,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionA>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      subMessage: Partial<TestMutualRecursionA.SubMessage>
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        subMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes a TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      subGroup: Partial<TestMutualRecursionA.SubGroup>
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        subGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes a TestMutualRecursionB to protobuf.
   */
  encode: function (
    testMutualRecursionB: Partial<TestMutualRecursionB>
  ): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      testMutualRecursionB,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMutualRecursionB>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes a TestIsInitialized to protobuf.
   */
  encode: function (testIsInitialized: Partial<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      testIsInitialized,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestIsInitialized>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes a TestIsInitialized.SubMessage to protobuf.
     */

    encode: function (
      _subMessage?: Partial<TestIsInitialized.SubMessage>
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes a TestIsInitialized.SubMessage from protobuf.
     */

    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes a TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    SubGroup: {
      /**
       * Serializes a TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        subGroup: Partial<TestIsInitialized.SubMessage.SubGroup>
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          subGroup,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes a TestDupFieldNumber to protobuf.
   */
  encode: function (
    testDupFieldNumber: Partial<TestDupFieldNumber>
  ): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      testDupFieldNumber,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDupFieldNumber>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes a TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (foo: Partial<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        foo,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Foo>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes a TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (bar: Partial<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        bar,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDupFieldNumber.Bar>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes a TestEagerMessage to protobuf.
   */
  encode: function (testEagerMessage: Partial<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      testEagerMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestEagerMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes a TestLazyMessage to protobuf.
   */
  encode: function (testLazyMessage: Partial<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      testLazyMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestLazyMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes a TestNestedMessageHasBits to protobuf.
   */
  encode: function (
    testNestedMessageHasBits: Partial<TestNestedMessageHasBits>
  ): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      testNestedMessageHasBits,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestNestedMessageHasBits>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestNestedMessageHasBits.NestedMessage>
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writeRepeatedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes a TestCamelCaseFieldNames to protobuf.
   */
  encode: function (
    testCamelCaseFieldNames: Partial<TestCamelCaseFieldNames>
  ): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      testCamelCaseFieldNames,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: \\"\\",
      EnumField: 0,
      MessageField: ForeignMessage.initialize(),
      StringPieceField: \\"\\",
      CordField: \\"\\",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCamelCaseFieldNames>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField) {
      writer.writeEnum(3, msg.EnumField);
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writeRepeatedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writeRepeatedEnum(9, msg.RepeatedEnumField);
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = reader.readEnum() as ForeignEnum;
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          msg.RepeatedPrimitiveField.push(reader.readInt32());
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          msg.RepeatedEnumField.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes a TestFieldOrderings to protobuf.
   */
  encode: function (
    testFieldOrderings: Partial<TestFieldOrderings>
  ): Uint8Array {
    return TestFieldOrderings._writeMessage(
      testFieldOrderings,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: \\"\\",
      myInt: \\"\\",
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestFieldOrderings>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = reader.readInt64String();
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestFieldOrderings.NestedMessage>
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: \\"\\",
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = reader.readInt64String();
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes a TestExtensionOrderings1 to protobuf.
   */
  encode: function (
    testExtensionOrderings1: Partial<TestExtensionOrderings1>
  ): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      testExtensionOrderings1,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings1>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes a TestExtensionOrderings2 to protobuf.
   */
  encode: function (
    testExtensionOrderings2: Partial<TestExtensionOrderings2>
  ): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      testExtensionOrderings2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionOrderings2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes a TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      testExtensionOrderings3: Partial<TestExtensionOrderings2.TestExtensionOrderings3>
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        testExtensionOrderings3,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes a TestExtremeDefaultValues to protobuf.
   */
  encode: function (
    testExtremeDefaultValues: Partial<TestExtremeDefaultValues>
  ): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      testExtremeDefaultValues,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: \\"\\",
      smallInt32: 0,
      smallInt64: \\"\\",
      reallySmallInt32: 0,
      reallySmallInt64: \\"\\",
      utf8String: \\"\\",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: \\"\\",
      stringWithZero: \\"\\",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: \\"\\",
      cordWithZero: \\"\\",
      replacementString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtremeDefaultValues>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.escapedBytes) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = reader.readUint64String();
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = reader.readInt64String();
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = reader.readInt64String();
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes a SparseEnumMessage to protobuf.
   */
  encode: function (sparseEnumMessage: Partial<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      sparseEnumMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SparseEnumMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.sparseEnum) {
      writer.writeEnum(1, msg.sparseEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = reader.readEnum() as TestSparseEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes a OneString to protobuf.
   */
  encode: function (oneString: Partial<OneString>): Uint8Array {
    return OneString._writeMessage(
      oneString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes a MoreString to protobuf.
   */
  encode: function (moreString: Partial<MoreString>): Uint8Array {
    return MoreString._writeMessage(
      moreString,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreString>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes a OneBytes to protobuf.
   */
  encode: function (oneBytes: Partial<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(
      oneBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<OneBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes a MoreBytes to protobuf.
   */
  encode: function (moreBytes: Partial<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(
      moreBytes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MoreBytes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes a Int32Message to protobuf.
   */
  encode: function (int32Message: Partial<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      int32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes a Uint32Message to protobuf.
   */
  encode: function (uint32Message: Partial<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      uint32Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint32Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes a Int64Message to protobuf.
   */
  encode: function (int64Message: Partial<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      int64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Int64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes a Uint64Message to protobuf.
   */
  encode: function (uint64Message: Partial<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      uint64Message,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Uint64Message>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint64String();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes a BoolMessage to protobuf.
   */
  encode: function (boolMessage: Partial<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(
      boolMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<BoolMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes a TestOneof to protobuf.
   */
  encode: function (testOneof: Partial<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(
      testOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneof.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes a TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    testOneofBackwardsCompatible: Partial<TestOneofBackwardsCompatible>
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      testOneofBackwardsCompatible,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: \\"\\",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneofBackwardsCompatible>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes a TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      fooGroup: Partial<TestOneofBackwardsCompatible.FooGroup>
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooMessage: TestOneof2.NestedMessage.initialize(),
      fooLazyMessage: TestOneof2.NestedMessage.initialize(),
      bazInt: 0,
      bazString: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes != undefined) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes != undefined) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, msg.barEnum);
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault != undefined) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 7: {
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 11: {
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { FOO: 1, BAR: 2, BAZ: 3 } as const,

  FooGroup: {
    /**
     * Serializes a TestOneof2.FooGroup to protobuf.
     */
    encode: function (fooGroup: Partial<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        fooGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: \\"\\",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.FooGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes a TestOneof2.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestOneof2.NestedMessage>
    ): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: \\"\\",
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestOneof2.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt);
      }
      if (msg.corgeInt?.length) {
        writer.writeRepeatedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = reader.readInt64String();
            break;
          }
          case 2: {
            msg.corgeInt.push(reader.readInt32());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes a TestRequiredOneof to protobuf.
   */
  encode: function (testRequiredOneof: Partial<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      testRequiredOneof,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooMessage: TestRequiredOneof.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredOneof>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes a TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestRequiredOneof.NestedMessage>
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.unpackedInt64);
    }
    if (msg.unpackedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.unpackedUint64);
    }
    if (msg.unpackedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.unpackedSint64);
    }
    if (msg.unpackedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.unpackedFixed64);
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.unpackedSfixed64);
    }
    if (msg.unpackedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writeRepeatedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.unpackedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.unpackedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.unpackedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.unpackedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.unpackedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.unpackedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.unpackedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.unpackedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.unpackedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.unpackedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.unpackedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.unpackedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.unpackedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.unpackedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.unpackedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes a TestPackedExtensions to protobuf.
   */

  encode: function (
    _testPackedExtensions?: Partial<TestPackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestPackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes a TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes a TestUnpackedExtensions to protobuf.
   */

  encode: function (
    _testUnpackedExtensions?: Partial<TestUnpackedExtensions>
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestUnpackedExtensions from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes a TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes a TestDynamicExtensions to protobuf.
   */
  encode: function (
    testDynamicExtensions: Partial<TestDynamicExtensions>
  ): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      testDynamicExtensions,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: 0,
      dynamicEnumExtension: 0,
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestDynamicExtensions>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension) {
      writer.writeEnum(2001, msg.enumExtension);
    }
    if (msg.dynamicEnumExtension) {
      writer.writeEnum(2002, msg.dynamicEnumExtension);
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writeRepeatedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = reader.readEnum() as ForeignEnum;
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            reader.readEnum() as TestDynamicExtensions.DynamicEnumType;
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          msg.packedExtension.push(reader.readSint32());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: 2200,
    DYNAMIC_BAR: 2201,
    DYNAMIC_BAZ: 2202,
  } as const,

  DynamicMessageType: {
    /**
     * Serializes a TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      dynamicMessageType: Partial<TestDynamicExtensions.DynamicMessageType>
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        dynamicMessageType,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes a TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    testRepeatedScalarDifferentTagSizes: Partial<TestRepeatedScalarDifferentTagSizes>
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      testRepeatedScalarDifferentTagSizes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(2046, msg.repeatedFixed64);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2047, msg.repeatedInt64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(262143, msg.repeatedUint64);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 13: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2046: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 2047: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 262142: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 262143: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes a TestParsingMerge to protobuf.
   */
  encode: function (testParsingMerge: Partial<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      testParsingMerge,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestParsingMerge>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes a TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      repeatedFieldsGenerator: Partial<TestParsingMerge.RepeatedFieldsGenerator>
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        repeatedFieldsGenerator,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        group1: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          group1,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        group2: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          group2,
          new BinaryWriter()
        ).getResultBuffer();
      },

      /**
       * Deserializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes)
        );
      },

      /**
       * Initializes a TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: Partial<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes a TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestParsingMerge.OptionalGroup>
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes a TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      repeatedGroup: Partial<TestParsingMerge.RepeatedGroup>
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        repeatedGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes a TestCommentInjectionMessage to protobuf.
   */
  encode: function (
    testCommentInjectionMessage: Partial<TestCommentInjectionMessage>
  ): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      testCommentInjectionMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: \\"\\",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestCommentInjectionMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes a FooRequest to protobuf.
   */

  encode: function (_fooRequest?: Partial<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Initializes a FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },
};

export const FooResponse = {
  /**
   * Serializes a FooResponse to protobuf.
   */

  encode: function (_fooResponse?: Partial<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Initializes a FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },
};

export const FooClientMessage = {
  /**
   * Serializes a FooClientMessage to protobuf.
   */

  encode: function (_fooClientMessage?: Partial<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooClientMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Initializes a FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },
};

export const FooServerMessage = {
  /**
   * Serializes a FooServerMessage to protobuf.
   */

  encode: function (_fooServerMessage?: Partial<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a FooServerMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Initializes a FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },
};

export const BarRequest = {
  /**
   * Serializes a BarRequest to protobuf.
   */

  encode: function (_barRequest?: Partial<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarRequest from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Initializes a BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },
};

export const BarResponse = {
  /**
   * Serializes a BarResponse to protobuf.
   */

  encode: function (_barResponse?: Partial<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a BarResponse from protobuf.
   */

  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Initializes a BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },
};

export const TestJsonName = {
  /**
   * Serializes a TestJsonName to protobuf.
   */
  encode: function (testJsonName: Partial<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      testJsonName,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      FieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestJsonName>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.FieldName4) {
      writer.writeInt32(4, msg.FieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.FieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes a TestHugeFieldNumbers to protobuf.
   */
  encode: function (
    testHugeFieldNumbers: Partial<TestHugeFieldNumbers>
  ): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      testHugeFieldNumbers,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: 0,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofTestAllTypes: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestHugeFieldNumbers>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum) {
      writer.writeEnum(536870004, msg.optionalEnum);
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.stringStringMap) {
      for (const key in msg.stringStringMap) {
        writer.writeMessage(536870010, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.stringStringMap![key]);
        });
      }
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 536870003: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 536870004: {
          msg.optionalEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.stringStringMap[key] = value;
            }
          });
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes a TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      optionalGroup: Partial<TestHugeFieldNumbers.OptionalGroup>
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        optionalGroup,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes a TestExtensionInsideTable to protobuf.
   */
  encode: function (
    testExtensionInsideTable: Partial<TestExtensionInsideTable>
  ): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      testExtensionInsideTable,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionInsideTable>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes a TestExtensionRangeSerialize to protobuf.
   */
  encode: function (
    testExtensionRangeSerialize: Partial<TestExtensionRangeSerialize>
  ): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      testExtensionRangeSerialize,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestExtensionRangeSerialize>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/map_unittest.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ForeignMessage, TestAllTypes, TestRequired } from \\"./unittest.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = typeof MapEnum[keyof typeof MapEnum];

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<string, string | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<string, string | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<string, string | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<string, string | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<string, string | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
  mapStringForeignMessage: Record<string, ForeignMessage | undefined>;
  mapInt32AllTypes: Record<number, TestAllTypes | undefined>;
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<number, TestAllTypes | undefined>;
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<number, number | undefined>;
  map2: Record<number, number | undefined>;
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<number, TestRequired | undefined>;
}

export interface TestArenaMap {
  mapInt32Int32: Record<number, number | undefined>;
  mapInt64Int64: Record<string, string | undefined>;
  mapUint32Uint32: Record<number, number | undefined>;
  mapUint64Uint64: Record<string, string | undefined>;
  mapSint32Sint32: Record<number, number | undefined>;
  mapSint64Sint64: Record<string, string | undefined>;
  mapFixed32Fixed32: Record<number, number | undefined>;
  mapFixed64Fixed64: Record<string, string | undefined>;
  mapSfixed32Sfixed32: Record<number, number | undefined>;
  mapSfixed64Sfixed64: Record<string, string | undefined>;
  mapInt32Float: Record<number, number | undefined>;
  mapInt32Double: Record<number, number | undefined>;
  mapBoolBool: Record<boolean, boolean | undefined>;
  mapStringString: Record<string, string | undefined>;
  mapInt32Bytes: Record<number, Uint8Array | undefined>;
  mapInt32Enum: Record<number, MapEnum | undefined>;
  mapInt32ForeignMessage: Record<number, ForeignMessage | undefined>;
}

/**
 * Previously, message cannot contain map field called \\"entry\\".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<number, number | undefined>;
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage | undefined>;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: 0,
  MAP_ENUM_BAR: 1,
  MAP_ENUM_BAZ: 2,
} as const;

export const TestMap = {
  /**
   * Serializes a TestMap to protobuf.
   */
  encode: function (testMap: Partial<TestMap>): Uint8Array {
    return TestMap._writeMessage(testMap, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes a TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes a TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.mapInt32Int32![key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.mapInt64Int64![key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.mapUint32Uint32![key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64![key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.mapSint32Sint32![key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64![key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32![key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64![key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32![key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64![key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.mapInt32Float![key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.mapInt32Double![key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.mapBoolBool![key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.mapStringString![key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.mapInt32Bytes![key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.mapInt32Enum![key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage![key]);
        });
      }
    }
    if (msg.mapStringForeignMessage) {
      for (const key in msg.mapStringForeignMessage) {
        writer.writeMessage(18, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.mapStringForeignMessage![key]);
        });
      }
    }
    if (msg.mapInt32AllTypes) {
      for (const key in msg.mapInt32AllTypes) {
        writer.writeMessage(19, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32AllTypes![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        case 18: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringForeignMessage[key] = value;
            }
          });
          break;
        }
        case 19: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32AllTypes[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes a TestMapSubmessage to protobuf.
   */
  encode: function (testMapSubmessage: Partial<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      testMapSubmessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMapSubmessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes a TestMessageMap to protobuf.
   */
  encode: function (testMessageMap: Partial<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      testMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      for (const key in msg.mapInt32Message) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32Message![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Message[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes a TestSameTypeMap to protobuf.
   */
  encode: function (testSameTypeMap: Partial<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      testSameTypeMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestSameTypeMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.map1) {
      for (const key in msg.map1) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map1![key]);
        });
      }
    }
    if (msg.map2) {
      for (const key in msg.map2) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.map2![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map1[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.map2[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes a TestRequiredMessageMap to protobuf.
   */
  encode: function (
    testRequiredMessageMap: Partial<TestRequiredMessageMap>
  ): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      testRequiredMessageMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRequiredMessageMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapField) {
      for (const key in msg.mapField) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapField![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapField[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestArenaMap = {
  /**
   * Serializes a TestArenaMap to protobuf.
   */
  encode: function (testArenaMap: Partial<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      testArenaMap,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestArenaMap>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      for (const key in msg.mapInt32Int32) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.mapInt32Int32![key]);
        });
      }
    }
    if (msg.mapInt64Int64) {
      for (const key in msg.mapInt64Int64) {
        writer.writeMessage(2, {}, (_, mapWriter) => {
          mapWriter.writeInt64String(1, key as unknown as string);
          mapWriter.writeInt64String(2, msg.mapInt64Int64![key]);
        });
      }
    }
    if (msg.mapUint32Uint32) {
      for (const key in msg.mapUint32Uint32) {
        writer.writeMessage(3, {}, (_, mapWriter) => {
          mapWriter.writeUint32(1, key as unknown as number);
          mapWriter.writeUint32(2, msg.mapUint32Uint32![key]);
        });
      }
    }
    if (msg.mapUint64Uint64) {
      for (const key in msg.mapUint64Uint64) {
        writer.writeMessage(4, {}, (_, mapWriter) => {
          mapWriter.writeUint64String(1, key as unknown as string);
          mapWriter.writeUint64String(2, msg.mapUint64Uint64![key]);
        });
      }
    }
    if (msg.mapSint32Sint32) {
      for (const key in msg.mapSint32Sint32) {
        writer.writeMessage(5, {}, (_, mapWriter) => {
          mapWriter.writeSint32(1, key as unknown as number);
          mapWriter.writeSint32(2, msg.mapSint32Sint32![key]);
        });
      }
    }
    if (msg.mapSint64Sint64) {
      for (const key in msg.mapSint64Sint64) {
        writer.writeMessage(6, {}, (_, mapWriter) => {
          mapWriter.writeSint64String(1, key as unknown as string);
          mapWriter.writeSint64String(2, msg.mapSint64Sint64![key]);
        });
      }
    }
    if (msg.mapFixed32Fixed32) {
      for (const key in msg.mapFixed32Fixed32) {
        writer.writeMessage(7, {}, (_, mapWriter) => {
          mapWriter.writeFixed32(1, key as unknown as number);
          mapWriter.writeFixed32(2, msg.mapFixed32Fixed32![key]);
        });
      }
    }
    if (msg.mapFixed64Fixed64) {
      for (const key in msg.mapFixed64Fixed64) {
        writer.writeMessage(8, {}, (_, mapWriter) => {
          mapWriter.writeFixed64String(1, key as unknown as string);
          mapWriter.writeFixed64String(2, msg.mapFixed64Fixed64![key]);
        });
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      for (const key in msg.mapSfixed32Sfixed32) {
        writer.writeMessage(9, {}, (_, mapWriter) => {
          mapWriter.writeSfixed32(1, key as unknown as number);
          mapWriter.writeSfixed32(2, msg.mapSfixed32Sfixed32![key]);
        });
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      for (const key in msg.mapSfixed64Sfixed64) {
        writer.writeMessage(10, {}, (_, mapWriter) => {
          mapWriter.writeSfixed64(1, key as unknown as string);
          mapWriter.writeSfixed64(2, msg.mapSfixed64Sfixed64![key]);
        });
      }
    }
    if (msg.mapInt32Float) {
      for (const key in msg.mapInt32Float) {
        writer.writeMessage(11, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeFloat(2, msg.mapInt32Float![key]);
        });
      }
    }
    if (msg.mapInt32Double) {
      for (const key in msg.mapInt32Double) {
        writer.writeMessage(12, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeDouble(2, msg.mapInt32Double![key]);
        });
      }
    }
    if (msg.mapBoolBool) {
      for (const key in msg.mapBoolBool) {
        writer.writeMessage(13, {}, (_, mapWriter) => {
          mapWriter.writeBool(1, key as unknown as boolean);
          mapWriter.writeBool(2, msg.mapBoolBool![key]);
        });
      }
    }
    if (msg.mapStringString) {
      for (const key in msg.mapStringString) {
        writer.writeMessage(14, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeString(2, msg.mapStringString![key]);
        });
      }
    }
    if (msg.mapInt32Bytes) {
      for (const key in msg.mapInt32Bytes) {
        writer.writeMessage(15, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeBytes(2, msg.mapInt32Bytes![key]);
        });
      }
    }
    if (msg.mapInt32Enum) {
      for (const key in msg.mapInt32Enum) {
        writer.writeMessage(16, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeEnum(2, msg.mapInt32Enum![key]);
        });
      }
    }
    if (msg.mapInt32ForeignMessage) {
      for (const key in msg.mapInt32ForeignMessage) {
        writer.writeMessage(17, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeMessage(2, msg.mapInt32ForeignMessage![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Int32[key] = value;
            }
          });
          break;
        }
        case 2: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt64String();
                  break;
                }
                case 2: {
                  value = reader.readInt64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt64Int64[key] = value;
            }
          });
          break;
        }
        case 3: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint32();
                  break;
                }
                case 2: {
                  value = reader.readUint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint32Uint32[key] = value;
            }
          });
          break;
        }
        case 4: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readUint64String();
                  break;
                }
                case 2: {
                  value = reader.readUint64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapUint64Uint64[key] = value;
            }
          });
          break;
        }
        case 5: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint32();
                  break;
                }
                case 2: {
                  value = reader.readSint32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint32Sint32[key] = value;
            }
          });
          break;
        }
        case 6: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSint64();
                  break;
                }
                case 2: {
                  value = reader.readSint64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSint64Sint64[key] = value;
            }
          });
          break;
        }
        case 7: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed32();
                  break;
                }
                case 2: {
                  value = reader.readFixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed32Fixed32[key] = value;
            }
          });
          break;
        }
        case 8: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readFixed64String();
                  break;
                }
                case 2: {
                  value = reader.readFixed64String();
                  break;
                }
              }
            }
            if (key) {
              msg.mapFixed64Fixed64[key] = value;
            }
          });
          break;
        }
        case 9: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed32();
                  break;
                }
                case 2: {
                  value = reader.readSfixed32();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed32Sfixed32[key] = value;
            }
          });
          break;
        }
        case 10: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readSfixed64();
                  break;
                }
                case 2: {
                  value = reader.readSfixed64();
                  break;
                }
              }
            }
            if (key) {
              msg.mapSfixed64Sfixed64[key] = value;
            }
          });
          break;
        }
        case 11: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readFloat();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Float[key] = value;
            }
          });
          break;
        }
        case 12: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readDouble();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Double[key] = value;
            }
          });
          break;
        }
        case 13: {
          reader.readMessage(undefined, () => {
            let key: boolean | undefined;
            let value = false;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readBool();
                  break;
                }
                case 2: {
                  value = reader.readBool();
                  break;
                }
              }
            }
            if (key) {
              msg.mapBoolBool[key] = value;
            }
          });
          break;
        }
        case 14: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = \\"\\";
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readString();
                  break;
                }
              }
            }
            if (key) {
              msg.mapStringString[key] = value;
            }
          });
          break;
        }
        case 15: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = new Uint8Array();
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readBytes();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Bytes[key] = value;
            }
          });
          break;
        }
        case 16: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readEnum();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32Enum[key] = value;
            }
          });
          break;
        }
        case 17: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.mapInt32ForeignMessage[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes a MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    messageContainingMapCalledEntry: Partial<MessageContainingMapCalledEntry>
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      messageContainingMapCalledEntry,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<MessageContainingMapCalledEntry>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entry) {
      for (const key in msg.entry) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeInt32(1, key as unknown as number);
          mapWriter.writeInt32(2, msg.entry![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: number | undefined;
            let value = 0;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readInt32();
                  break;
                }
                case 2: {
                  value = reader.readInt32();
                  break;
                }
              }
            }
            if (key) {
              msg.entry[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes a TestRecursiveMapMessage to protobuf.
   */
  encode: function (
    testRecursiveMapMessage: Partial<TestRecursiveMapMessage>
  ): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      testRecursiveMapMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestRecursiveMapMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.a) {
      for (const key in msg.a) {
        writer.writeMessage(1, {}, (_, mapWriter) => {
          mapWriter.writeString(1, key as unknown as string);
          mapWriter.writeMessage(2, msg.a![key]);
        });
      }
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(undefined, () => {
            let key: string | undefined;
            let value = undefined;
            while (reader.nextField()) {
              const field = reader.getFieldNumber();
              switch (field) {
                case 1: {
                  key = reader.readString();
                  break;
                }
                case 2: {
                  value = reader.readMessage();
                  break;
                }
              }
            }
            if (key) {
              msg.a[key] = value;
            }
          });
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/unittest_proto3.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest_proto3.proto

import type { ByteSource } from \\"twirpscript\\";
import { BinaryReader, BinaryWriter } from \\"twirpscript\\";

import { ImportMessage } from \\"./unittest_import.pb\\";
import { PublicImportMessage } from \\"./unittest_import_public.pb\\";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = typeof ForeignEnum[keyof typeof ForeignEnum];

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: string;
  optionalUint32: number;
  optionalUint64: string;
  optionalSint32: number;
  optionalSint64: string;
  optionalFixed32: number;
  optionalFixed64: string;
  optionalSfixed32: number;
  optionalSfixed64: string;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalStringPiece: string;
  optionalCord: string;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalPublicImportMessage: PublicImportMessage;
  optionalLazyMessage: TestAllTypes.NestedMessage;
  optionalLazyImportMessage: ImportMessage;
  /**
   * Repeated
   */
  repeatedInt32: number[];
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  oneofUint32?: number;
  oneofNestedMessage?: TestAllTypes.NestedMessage;
  oneofString?: string;
  oneofBytes?: Uint8Array;
}

export namespace TestAllTypes {
  export type NestedEnum =
    typeof TestAllTypes.NestedEnum[keyof typeof TestAllTypes.NestedEnum];

  export interface NestedMessage {
    /**
     * The field name \\"b\\" fails to compile in proto1 because it conflicts with
     * a local variable named \\"b\\" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: string[];
  packedUint32: number[];
  packedUint64: string[];
  packedSint32: number[];
  packedSint64: string[];
  packedFixed32: number[];
  packedFixed64: string[];
  packedSfixed32: number[];
  packedSfixed64: string[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * Explicitly set packed to false
 */
export interface TestUnpackedTypes {
  repeatedInt32: number[];
  repeatedInt64: string[];
  repeatedUint32: number[];
  repeatedUint64: string[];
  repeatedSint32: number[];
  repeatedSint64: string[];
  repeatedFixed32: number[];
  repeatedFixed64: string[];
  repeatedSfixed32: number[];
  repeatedSfixed64: string[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes;
  payload: TestAllTypes;
}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
}

/**
 * TestEmptyMessage is used to test behavior of unknown fields.
 */
export interface TestEmptyMessage {}

/**
 * TestMessageWithDummy is also used to test behavior of unknown fields.
 */
export interface TestMessageWithDummy {
  /**
   * This field is only here for triggering copy-on-write; it's not intended to
   * be serialized.
   */
  dummy: boolean;
}

/**
 * Same layout as TestOneof2 in unittest.proto to test unknown enum value
 * parsing behavior in oneof.
 */
export interface TestOneof2 {
  fooEnum?: TestOneof2.NestedEnum;
}

export namespace TestOneof2 {
  export type NestedEnum =
    typeof TestOneof2.NestedEnum[keyof typeof TestOneof2.NestedEnum];
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_ZERO: 0,
  FOREIGN_FOO: 4,
  FOREIGN_BAR: 5,
  FOREIGN_BAZ: 6,
} as const;

export const TestAllTypes = {
  /**
   * Serializes a TestAllTypes to protobuf.
   */
  encode: function (testAllTypes: Partial<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      testAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: \\"\\",
      optionalUint32: 0,
      optionalUint64: \\"\\",
      optionalSint32: 0,
      optionalSint64: \\"\\",
      optionalFixed32: 0,
      optionalFixed64: \\"\\",
      optionalSfixed32: 0,
      optionalSfixed64: \\"\\",
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: \\"\\",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage: ImportMessage.initialize(),
      optionalNestedEnum: 0,
      optionalForeignEnum: 0,
      optionalStringPiece: \\"\\",
      optionalCord: \\"\\",
      optionalPublicImportMessage: PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      optionalLazyImportMessage: ImportMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      oneofNestedMessage: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64(10, msg.optionalSfixed64);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.optionalNestedEnum) {
      writer.writeEnum(21, msg.optionalNestedEnum);
    }
    if (msg.optionalForeignEnum) {
      writer.writeEnum(22, msg.optionalForeignEnum);
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        PublicImportMessage._writeMessage
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.optionalLazyImportMessage) {
      writer.writeMessage(
        115,
        msg.optionalLazyImportMessage,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(32, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(34, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(36, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(38, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(40, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        ImportMessage._writeMessage
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(51, msg.repeatedNestedEnum);
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writeRepeatedEnum(52, msg.repeatedForeignEnum);
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes != undefined) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = reader.readInt64String();
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = reader.readUint64String();
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = reader.readSint64();
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = reader.readFixed64String();
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = reader.readSfixed64();
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = reader.readEnum() as TestAllTypes.NestedEnum;
          break;
        }
        case 22: {
          msg.optionalForeignEnum = reader.readEnum() as ForeignEnum;
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            PublicImportMessage._readMessage
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 115: {
          reader.readMessage(
            msg.optionalLazyImportMessage,
            ImportMessage._readMessage
          );
          break;
        }
        case 31: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 32: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 33: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 34: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 35: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 36: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 37: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 38: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 39: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 40: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 41: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 42: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 43: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = ImportMessage.initialize();
          reader.readMessage(m, ImportMessage._readMessage);
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        case 52: {
          msg.repeatedForeignEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { ZERO: 0, FOO: 1, BAR: 2, BAZ: 3, NEG: -1 } as const,

  NestedMessage: {
    /**
     * Serializes a TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      nestedMessage: Partial<TestAllTypes.NestedMessage>
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        nestedMessage,
        new BinaryWriter()
      ).getResultBuffer();
    },

    /**
     * Deserializes a TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes)
      );
    },

    /**
     * Initializes a TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<TestAllTypes.NestedMessage>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes a TestPackedTypes to protobuf.
   */
  encode: function (testPackedTypes: Partial<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      testPackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestPackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writeRepeatedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writeRepeatedInt64String(91, msg.packedInt64);
    }
    if (msg.packedUint32?.length) {
      writer.writeRepeatedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writeRepeatedUint64String(93, msg.packedUint64);
    }
    if (msg.packedSint32?.length) {
      writer.writeRepeatedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writeRepeatedSint64String(95, msg.packedSint64);
    }
    if (msg.packedFixed32?.length) {
      writer.writeRepeatedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writeRepeatedFixed64String(97, msg.packedFixed64);
    }
    if (msg.packedSfixed32?.length) {
      writer.writeRepeatedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writeRepeatedSfixed64(99, msg.packedSfixed64);
    }
    if (msg.packedFloat?.length) {
      writer.writeRepeatedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writeRepeatedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writeRepeatedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writeRepeatedEnum(103, msg.packedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          msg.packedInt32.push(reader.readInt32());
          break;
        }
        case 91: {
          msg.packedInt64.push(reader.readInt64String());
          break;
        }
        case 92: {
          msg.packedUint32.push(reader.readUint32());
          break;
        }
        case 93: {
          msg.packedUint64.push(reader.readUint64String());
          break;
        }
        case 94: {
          msg.packedSint32.push(reader.readSint32());
          break;
        }
        case 95: {
          msg.packedSint64.push(reader.readSint64());
          break;
        }
        case 96: {
          msg.packedFixed32.push(reader.readFixed32());
          break;
        }
        case 97: {
          msg.packedFixed64.push(reader.readFixed64String());
          break;
        }
        case 98: {
          msg.packedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 99: {
          msg.packedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 100: {
          msg.packedFloat.push(reader.readFloat());
          break;
        }
        case 101: {
          msg.packedDouble.push(reader.readDouble());
          break;
        }
        case 102: {
          msg.packedBool.push(reader.readBool());
          break;
        }
        case 103: {
          msg.packedEnum.push(reader.readEnum() as ForeignEnum);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes a TestUnpackedTypes to protobuf.
   */
  encode: function (testUnpackedTypes: Partial<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      testUnpackedTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedNestedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestUnpackedTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.repeatedInt32?.length) {
      writer.writeRepeatedInt32(1, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writeRepeatedInt64String(2, msg.repeatedInt64);
    }
    if (msg.repeatedUint32?.length) {
      writer.writeRepeatedUint32(3, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writeRepeatedUint64String(4, msg.repeatedUint64);
    }
    if (msg.repeatedSint32?.length) {
      writer.writeRepeatedSint32(5, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writeRepeatedSint64String(6, msg.repeatedSint64);
    }
    if (msg.repeatedFixed32?.length) {
      writer.writeRepeatedFixed32(7, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writeRepeatedFixed64String(8, msg.repeatedFixed64);
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writeRepeatedSfixed32(9, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writeRepeatedSfixed64(10, msg.repeatedSfixed64);
    }
    if (msg.repeatedFloat?.length) {
      writer.writeRepeatedFloat(11, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writeRepeatedDouble(12, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writeRepeatedBool(13, msg.repeatedBool);
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writeRepeatedEnum(14, msg.repeatedNestedEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.repeatedInt32.push(reader.readInt32());
          break;
        }
        case 2: {
          msg.repeatedInt64.push(reader.readInt64String());
          break;
        }
        case 3: {
          msg.repeatedUint32.push(reader.readUint32());
          break;
        }
        case 4: {
          msg.repeatedUint64.push(reader.readUint64String());
          break;
        }
        case 5: {
          msg.repeatedSint32.push(reader.readSint32());
          break;
        }
        case 6: {
          msg.repeatedSint64.push(reader.readSint64());
          break;
        }
        case 7: {
          msg.repeatedFixed32.push(reader.readFixed32());
          break;
        }
        case 8: {
          msg.repeatedFixed64.push(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.repeatedSfixed32.push(reader.readSfixed32());
          break;
        }
        case 10: {
          msg.repeatedSfixed64.push(reader.readSfixed64());
          break;
        }
        case 11: {
          msg.repeatedFloat.push(reader.readFloat());
          break;
        }
        case 12: {
          msg.repeatedDouble.push(reader.readDouble());
          break;
        }
        case 13: {
          msg.repeatedBool.push(reader.readBool());
          break;
        }
        case 14: {
          msg.repeatedNestedEnum.push(
            reader.readEnum() as TestAllTypes.NestedEnum
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes a NestedTestAllTypes to protobuf.
   */
  encode: function (
    nestedTestAllTypes: Partial<NestedTestAllTypes>
  ): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      nestedTestAllTypes,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: NestedTestAllTypes.initialize(),
      payload: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<NestedTestAllTypes>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes a ForeignMessage to protobuf.
   */
  encode: function (foreignMessage: Partial<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      foreignMessage,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<ForeignMessage>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes a TestEmptyMessage to protobuf.
   */

  encode: function (_testEmptyMessage?: Partial<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a TestEmptyMessage from protobuf.
   */

  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes a TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },
};

export const TestMessageWithDummy = {
  /**
   * Serializes a TestMessageWithDummy to protobuf.
   */
  encode: function (
    testMessageWithDummy: Partial<TestMessageWithDummy>
  ): Uint8Array {
    return TestMessageWithDummy._writeMessage(
      testMessageWithDummy,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestMessageWithDummy from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageWithDummy {
    return TestMessageWithDummy._readMessage(
      TestMessageWithDummy.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestMessageWithDummy with all fields set to their default value.
   */
  initialize: function (): TestMessageWithDummy {
    return {
      dummy: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestMessageWithDummy>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.dummy) {
      writer.writeBool(536870911, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageWithDummy,
    reader: BinaryReader
  ): TestMessageWithDummy {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870911: {
          msg.dummy = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof2 = {
  /**
   * Serializes a TestOneof2 to protobuf.
   */
  encode: function (testOneof2: Partial<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(
      testOneof2,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes a TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<TestOneof2>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, msg.fooEnum);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 6: {
          msg.fooEnum = reader.readEnum() as TestOneof2.NestedEnum;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: { UNKNOWN: 0, FOO: 1, BAR: 2, BAZ: 3 } as const,
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "google/protobuf/empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/empty.proto

import type { ByteSource } from \\"twirpscript\\";

//========================================//
//                 Types                  //
//========================================//

/**
 * A generic empty message that you can re-use to avoid defining duplicated
 * empty messages in your APIs. A typical example is to use it as the request
 * or the response type of an API method. For instance:
 *
 *     service Foo {
 *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
 *     }
 *
 * The JSON representation for \`Empty\` is empty JSON object \`{}\`.
 */
export interface Empty {}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Empty = {
  /**
   * Serializes a Empty to protobuf.
   */

  encode: function (_empty?: Partial<Empty>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes a Empty from protobuf.
   */

  decode: function (_bytes?: ByteSource): Empty {
    return {};
  },

  /**
   * Initializes a Empty with all fields set to their default value.
   */
  initialize: function (): Empty {
    return {};
  },
};
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
      Object {
        "array": Array [
          "empty.pb.ts",
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          ,
          "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: empty.proto

import type { ClientConfiguration } from \\"twirpscript\\";
import { JSONrequest, PBrequest } from \\"twirpscript\\";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`yarn twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_34 } from \\"twirpscript\\";

import { Empty } from \\"./google/protobuf/empty.pb\\";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await PBrequest(\\"/Foo/Bar\\", Empty.encode(empty), config);
  return Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: Empty,
  config?: ClientConfiguration
): Promise<Empty> {
  const response = await JSONrequest<Empty>(\\"/Foo/Bar\\", empty, config);
  return response;
}

//========================================//
//              Foo Service               //
//========================================//

export interface FooService<Context = unknown> {
  Bar: (empty: Empty, context: Context) => Promise<Empty> | Empty;
}

export function createFooHandler<Context>(service: FooService<Context>) {
  return {
    name: \\"Foo\\",
    methods: {
      Bar: { name: \\"Bar\\", handler: service.Bar, input: Empty, output: Empty },
    },
  } as const;
}
",
        ],
        "arrayIndexOffset_": -1,
        "convertedPrimitiveFields_": Object {},
        "messageId_": undefined,
        "pivot_": 1.7976931348623157e+308,
        "wrappers_": null,
      },
    ],
  },
}
`;
