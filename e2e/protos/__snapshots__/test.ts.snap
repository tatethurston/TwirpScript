// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`TwirpScript Compiler generates JavaScript 1`] = `
[
  null,
  "",
  "Groups are not supported. Found group optionalgroup
Groups are not supported. Found group repeatedgroup
Groups are not supported. Found group optionalgroup
Groups are not supported. Found group subgroup
Groups are not supported. Found group subgroup
Groups are not supported. Found group foo
Groups are not supported. Found group bar
Groups are not supported. Found group foogroup
Groups are not supported. Found group foogroup
Groups are not supported. Found group foogroup
Groups are not supported. Found group group1
Groups are not supported. Found group group2
Groups are not supported. Found group optionalgroup
Groups are not supported. Found group repeatedgroup
Groups are not supported. Found group optionalgroup
",
]
`;

exports[`TwirpScript Compiler generates JavaScript 2`] = `
[
  "/dist/javascript/twirpscript/empty.pb.js",
  "/dist/javascript/twirpscript/services.pb.js",
  "/dist/javascript/google/protobuf/map_unittest.pb.js",
  "/dist/javascript/google/protobuf/unittest.pb.js",
]
`;

exports[`TwirpScript Compiler generates JavaScript 3`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(empty, config) {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config,
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(empty, config) {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config,
  );
  return protoscript.EmptyJSON.decode(response);
}

export function createFoo(service) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  };
}
"
`;

exports[`TwirpScript Compiler generates JavaScript 4`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(makeHat, config) {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config,
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(makeHat, config) {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config,
  );
  return HatJSON.decode(response);
}

export function createHaberdasher(service) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg) {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes) {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg) {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes) {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json) {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function () {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json) {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function () {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
"
`;

exports[`TwirpScript Compiler generates JavaScript 5`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb.js";

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg) {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes) {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Int32._writeMessage,
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt64Int64._writeMessage,
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint32Uint32._writeMessage,
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapUint64Uint64._writeMessage,
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint32Sint32._writeMessage,
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSint64Sint64._writeMessage,
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed32Fixed32._writeMessage,
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapFixed64Fixed64._writeMessage,
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed32Sfixed32._writeMessage,
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapSfixed64Sfixed64._writeMessage,
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Float._writeMessage,
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Double._writeMessage,
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapBoolBool._writeMessage,
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringString._writeMessage,
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Bytes._writeMessage,
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32Enum._writeMessage,
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32ForeignMessage._writeMessage,
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapStringForeignMessage._writeMessage,
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMap.MapInt32AllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {};
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {};
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg) {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes) {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestMessageMap.MapInt32Message._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg) {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes) {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map1._writeMessage,
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestSameTypeMap.Map2._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRequiredMessageMap.MapField._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg) {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes) {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Int32._writeMessage,
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt64Int64._writeMessage,
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint32Uint32._writeMessage,
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapUint64Uint64._writeMessage,
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint32Sint32._writeMessage,
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSint64Sint64._writeMessage,
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed32Fixed32._writeMessage,
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapFixed64Fixed64._writeMessage,
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed32Sfixed32._writeMessage,
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapSfixed64Sfixed64._writeMessage,
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Float._writeMessage,
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Double._writeMessage,
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapBoolBool._writeMessage,
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapStringString._writeMessage,
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Bytes._writeMessage,
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32Enum._writeMessage,
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestArenaMap.MapInt32ForeignMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage,
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage,
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {};
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {};
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage,
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString());
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString());
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (msg) {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes) {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        MessageContainingMapCalledEntry.Entry._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage,
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestRecursiveMapMessage.A._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {};
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json) {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestAllTypesJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json) {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      TestMapJSON._readMessage(msg.testMap, _testMap_);
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json) {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestAllTypesJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json) {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestRequiredJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json) {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function () {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json) {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function () {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = TestRecursiveMapMessageJSON.initialize();
        TestRecursiveMapMessageJSON._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },
};
"
`;

exports[`TwirpScript Compiler generates JavaScript 6`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";

import * as googleProtobufUnittest_import from "./unittest_import.pb.js";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb.js";

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(fooRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config,
  );
  return FooResponse.decode(response);
}

export async function Bar(barRequest, config) {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config,
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(fooRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config,
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(barRequest, config) {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config,
  );
  return BarResponseJSON.decode(response);
}

export function createTestService(service) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg) {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString());
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString());
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString());
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString());
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString());
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum),
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum),
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage,
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt),
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt),
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt,
        ),
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString());
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString());
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString());
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString());
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString());
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum),
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum),
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage,
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum(),
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage,
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt),
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt),
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum(),
              ),
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum(),
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg) {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes) {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: undefined,
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild,
        NestedTestAllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.child = NestedTestAllTypes.initialize();
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg) {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes) {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg) {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes) {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg) {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg) {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes) {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg) {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes) {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (msg) {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (bytes) {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg) {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes) {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg) {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes) {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg) {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage,
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg) {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage,
        TestRequired._writeMessage,
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg) {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes) {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (msg) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (bytes) {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg) {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes) {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg) {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes) {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: undefined,
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = TestRecursiveMessage.initialize();
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (msg) {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes) {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage,
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage,
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg) {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes) {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg) {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes) {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (_msg) {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg, writer) {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (_msg, _reader) {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (msg) {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (bytes) {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg) {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes) {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg) {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes) {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg) {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes) {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg) {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes) {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg) {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes) {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage,
          ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg) {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes) {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg) {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes) {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString());
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString());
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg) {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (msg) {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (bytes) {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg) {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes) {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString());
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString());
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString());
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg) {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes) {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg) {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes) {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg) {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes) {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg) {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes) {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg) {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes) {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg) {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes) {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg) {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes) {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg) {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes) {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg) {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes) {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString());
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg) {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes) {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg) {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes) {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (msg) {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes) {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg) {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes) {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage,
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage,
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage,
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage,
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString());
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg) {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes) {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (msg) {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes) {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString()),
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString()),
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString()),
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString()),
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString()),
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg) {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes) {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString()),
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString()),
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString()),
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString()),
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString()),
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg) {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes) {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension),
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage,
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage,
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (msg) {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (bytes) {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (msg) {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes) {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString()),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString()),
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg) {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes) {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes,
        TestAllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(1, msg.field1, TestAllTypes._writeMessage);
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(2, msg.field2, TestAllTypes._writeMessage);
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(3, msg.field3, TestAllTypes._writeMessage);
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(1000, msg.ext1, TestAllTypes._writeMessage);
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(1001, msg.ext2, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (msg) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (bytes) {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg, writer) {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (msg, reader) {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (msg) {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes) {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg) {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes) {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg, writer) {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg, _reader) {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg) {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes) {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      fieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.fieldName4) {
      writer.writeInt32(4, msg.fieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.fieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg) {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes) {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        TestHugeFieldNumbers.StringStringMap._writeMessage,
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {};
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage,
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (msg) {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes) {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg) {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg) {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes) {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i) {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i) {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i;
      }
    }
  },
};

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json) {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage,
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage,
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum,
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage,
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage,
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      ForeignMessageJSON._readMessage(
        msg.optionalForeignMessage,
        _optionalForeignMessage_,
      );
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        msg.optionalImportMessage,
        _optionalImportMessage_,
      );
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        msg.optionalPublicImportMessage,
        _optionalPublicImportMessage_,
      );
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalLazyMessage,
        _optionalLazyMessage_,
      );
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessageJSON.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessageJSON.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      msg.oneofNestedMessage = TestAllTypesJSON.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.oneofNestedMessage,
        _oneofNestedMessage_,
      );
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json) {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      child: undefined,
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _child_ = json["child"];
    if (_child_) {
      msg.child = NestedTestAllTypesJSON.initialize();
      NestedTestAllTypesJSON._readMessage(msg.child, _child_);
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      TestAllTypesJSON._readMessage(msg.payload, _payload_);
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypesJSON.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json) {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function () {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json) {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json) {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json) {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json) {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (json) {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json) {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension,
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      TestAllExtensionsJSON._readMessage(
        msg.optionalExtension,
        _optionalExtension_,
      );
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json) {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json) {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage,
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      TestRequiredJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequiredJSON.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json) {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage,
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage,
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      TestRequiredJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequiredJSON.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      TestRequiredJSON._readMessage(msg.requiredMessage, _requiredMessage_);
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json) {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function () {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested,
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.foreignNested,
        _foreignNested_,
      );
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (json) {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize: function () {
        return {
          cc: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json) {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json) {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: undefined,
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = TestRecursiveMessageJSON.initialize();
      TestRecursiveMessageJSON._readMessage(msg.a, _a_);
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function () {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _bb_ = json["bb"];
    if (_bb_) {
      TestMutualRecursionBJSON._readMessage(msg.bb, _bb_);
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _b_ = json["b"];
      if (_b_) {
        TestMutualRecursionBJSON._readMessage(msg.b, _b_);
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json) {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage,
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        TestMutualRecursionAJSON.SubMessage._readMessage(
          msg.subMessage,
          _subMessage_,
        );
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        TestAllTypesJSON._readMessage(msg.notInThisScc, _notInThisScc_);
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json) {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      TestMutualRecursionAJSON._readMessage(msg.a, _a_);
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json) {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage,
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestIsInitializedJSON.SubMessage._readMessage(
        msg.subMessage,
        _subMessage_,
      );
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (_msg) {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json) {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function () {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (_msg) {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (msg, _json) {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg),
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json) {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function () {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json) {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json) {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json) {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestAllTypesJSON._readMessage(msg.subMessage, _subMessage_);
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json) {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestAllTypesJSON._readMessage(msg.subMessage, _subMessage_);
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json) {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage,
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage,
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessageJSON.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json) {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function () {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage,
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      ForeignMessageJSON._readMessage(msg.MessageField, _MessageField_);
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessageJSON.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json) {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage,
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json) {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (json) {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function () {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json) {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function () {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json) {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json) {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json) {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json) {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json) {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json) {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json) {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json) {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json) {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json) {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json) {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestAllTypesJSON.initialize();
      TestAllTypesJSON._readMessage(msg.fooMessage, _fooMessage_);
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json) {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      TestAllTypesJSON._readMessage(msg.fooMessage, _fooMessage_);
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json) {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage,
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage,
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault,
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestOneof2JSON.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(msg.fooMessage, _fooMessage_);
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      msg.fooLazyMessage = TestOneof2JSON.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(
        msg.fooLazyMessage,
        _fooLazyMessage_,
      );
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_,
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json) {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage,
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestRequiredOneofJSON.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(
        msg.fooMessage,
        _fooMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json) {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function () {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json) {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json) {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function () {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json) {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function () {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension,
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension,
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      ForeignMessageJSON._readMessage(msg.messageExtension, _messageExtension_);
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        msg.dynamicMessageExtension,
        _dynamicMessageExtension_,
      );
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i) {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i) {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i;
        }
      }
    },
  },

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json) {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function () {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json) {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function () {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json) {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function () {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes,
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes,
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      TestAllTypesJSON._readMessage(msg.requiredAllTypes, _requiredAllTypes_);
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      TestAllTypesJSON._readMessage(msg.optionalAllTypes, _optionalAllTypes_);
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypesJSON.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function () {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          TestAllTypesJSON._readMessage(msg.field1, _field1_);
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (msg) {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (json) {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function () {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (msg) {
        const json = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (msg, json) {
        const _field1_ = json["field1"];
        if (_field1_) {
          TestAllTypesJSON._readMessage(msg.field1, _field1_);
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes,
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        TestAllTypesJSON._readMessage(
          msg.optionalGroupAllTypes,
          _optionalGroupAllTypes_,
        );
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json) {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes,
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        TestAllTypesJSON._readMessage(
          msg.repeatedGroupAllTypes,
          _repeatedGroupAllTypes_,
        );
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json) {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function () {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json) {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg) {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg, _json) {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json) {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function () {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      fieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.fieldName4) {
      json["FieldName4"] = msg.fieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _fieldName4_ =
      json["FieldName4"] ?? json["fieldName4"] ?? json["_field_name4"];
    if (_fieldName4_) {
      msg.fieldName4 = _fieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json) {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function () {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes,
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      ForeignMessageJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      msg.oneofTestAllTypes = TestAllTypesJSON.initialize();
      TestAllTypesJSON._readMessage(msg.oneofTestAllTypes, _oneofTestAllTypes_);
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (msg) {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json) {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function () {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (msg) {
      const json = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, json) {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json) {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function () {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg) {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json) {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function () {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg) {
    const json = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, json) {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
"
`;

exports[`TwirpScript Compiler generates TypeScript 1`] = `
[
  null,
  "",
  "Groups are not supported. Found group optionalgroup
Groups are not supported. Found group repeatedgroup
Groups are not supported. Found group optionalgroup
Groups are not supported. Found group subgroup
Groups are not supported. Found group subgroup
Groups are not supported. Found group foo
Groups are not supported. Found group bar
Groups are not supported. Found group foogroup
Groups are not supported. Found group foogroup
Groups are not supported. Found group foogroup
Groups are not supported. Found group group1
Groups are not supported. Found group group2
Groups are not supported. Found group optionalgroup
Groups are not supported. Found group repeatedgroup
Groups are not supported. Found group optionalgroup
",
]
`;

exports[`TwirpScript Compiler generates TypeScript 2`] = `
[
  "/dist/typescript/twirpscript/empty.pb.ts",
  "/dist/typescript/twirpscript/services.pb.ts",
  "/dist/typescript/google/protobuf/map_unittest.pb.ts",
  "/dist/typescript/google/protobuf/unittest.pb.ts",
]
`;

exports[`TwirpScript Compiler generates TypeScript 3`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/empty.proto
/* eslint-disable */

import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as protoscript from "protoscript";

//========================================//
//          Foo Protobuf Client           //
//========================================//

export async function Bar(
  empty: protoscript.Empty,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await PBrequest(
    "/Foo/Bar",
    protoscript.Empty.encode(empty),
    config,
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//            Foo JSON Client             //
//========================================//

export async function BarJSON(
  empty: protoscript.Empty,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await JSONrequest(
    "/Foo/Bar",
    protoscript.EmptyJSON.encode(empty),
    config,
  );
  return protoscript.EmptyJSON.decode(response);
}

//========================================//
//                  Foo                   //
//========================================//

export interface Foo<Context = unknown> {
  Bar: (
    empty: protoscript.Empty,
    context: Context,
  ) => Promise<protoscript.Empty> | protoscript.Empty;
}

export function createFoo<Context>(service: Foo<Context>) {
  return {
    name: "Foo",
    methods: {
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  } as const;
}
"
`;

exports[`TwirpScript Compiler generates TypeScript 4`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: twirpscript/services.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * Size of a Hat, in inches.
 */
export interface Req {}

export declare namespace Req {
  export interface MakeHat {
    inches: number;
  }
}

/**
 * A Hat is a piece of headwear made by a Haberdasher.
 */
export interface Hat {
  inches: number;
  color: string;
  name: string;
}

//========================================//
//      Haberdasher Protobuf Client       //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHat(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration,
): Promise<Hat> {
  const response = await PBrequest(
    "/Haberdasher/MakeHat",
    Req.MakeHat.encode(makeHat),
    config,
  );
  return Hat.decode(response);
}

//========================================//
//        Haberdasher JSON Client         //
//========================================//

/**
 * MakeHat produces a hat of mysterious, randomly-selected color!
 */
export async function MakeHatJSON(
  makeHat: Req.MakeHat,
  config?: ClientConfiguration,
): Promise<Hat> {
  const response = await JSONrequest(
    "/Haberdasher/MakeHat",
    ReqJSON.MakeHat.encode(makeHat),
    config,
  );
  return HatJSON.decode(response);
}

//========================================//
//              Haberdasher               //
//========================================//

/**
 * Haberdasher service makes hats for clients.
 */
export interface Haberdasher<Context = unknown> {
  /**
   * MakeHat produces a hat of mysterious, randomly-selected color!
   */
  MakeHat: (makeHat: Req.MakeHat, context: Context) => Promise<Hat> | Hat;
}

export function createHaberdasher<Context>(service: Haberdasher<Context>) {
  return {
    name: "Haberdasher",
    methods: {
      MakeHat: {
        name: "MakeHat",
        handler: service.MakeHat,
        input: { protobuf: Req.MakeHat, json: ReqJSON.MakeHat },
        output: { protobuf: Hat, json: HatJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const Req = {
  /**
   * Serializes Req to protobuf.
   */
  encode: function (_msg?: PartialDeep<Req>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes Req from protobuf.
   */
  decode: function (_bytes?: ByteSource): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<Req>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: Req, _reader: BinaryReader): Req {
    return _msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to protobuf.
     */
    encode: function (msg: PartialDeep<Req.MakeHat>): Uint8Array {
      return Req.MakeHat._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes Req.MakeHat from protobuf.
     */
    decode: function (bytes: ByteSource): Req.MakeHat {
      return Req.MakeHat._readMessage(
        Req.MakeHat.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.MakeHat>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.inches) {
        writer.writeInt32(1, msg.inches);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Req.MakeHat,
      reader: BinaryReader,
    ): Req.MakeHat {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.inches = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const Hat = {
  /**
   * Serializes Hat to protobuf.
   */
  encode: function (msg: PartialDeep<Hat>): Uint8Array {
    return Hat._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Hat from protobuf.
   */
  decode: function (bytes: ByteSource): Hat {
    return Hat._readMessage(Hat.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Hat>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.inches) {
      writer.writeInt32(1, msg.inches);
    }
    if (msg.color) {
      writer.writeString(2, msg.color);
    }
    if (msg.name) {
      writer.writeString(3, msg.name);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, reader: BinaryReader): Hat {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.inches = reader.readInt32();
          break;
        }
        case 2: {
          msg.color = reader.readString();
          break;
        }
        case 3: {
          msg.name = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ReqJSON = {
  /**
   * Serializes Req to JSON.
   */
  encode: function (_msg?: PartialDeep<Req>): string {
    return "{}";
  },

  /**
   * Deserializes Req from JSON.
   */
  decode: function (_json?: string): Req {
    return {};
  },

  /**
   * Initializes Req with all fields set to their default value.
   */
  initialize: function (): Req {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (_msg: PartialDeep<Req>): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: Req, _json: any): Req {
    return msg;
  },

  MakeHat: {
    /**
     * Serializes Req.MakeHat to JSON.
     */
    encode: function (msg: PartialDeep<Req.MakeHat>): string {
      return JSON.stringify(ReqJSON.MakeHat._writeMessage(msg));
    },

    /**
     * Deserializes Req.MakeHat from JSON.
     */
    decode: function (json: string): Req.MakeHat {
      return ReqJSON.MakeHat._readMessage(
        ReqJSON.MakeHat.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes Req.MakeHat with all fields set to their default value.
     */
    initialize: function (): Req.MakeHat {
      return {
        inches: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<Req.MakeHat>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.inches) {
        json["inches"] = msg.inches;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Req.MakeHat, json: any): Req.MakeHat {
      const _inches_ = json["inches"];
      if (_inches_) {
        msg.inches = _inches_;
      }
      return msg;
    },
  },
};

export const HatJSON = {
  /**
   * Serializes Hat to JSON.
   */
  encode: function (msg: PartialDeep<Hat>): string {
    return JSON.stringify(HatJSON._writeMessage(msg));
  },

  /**
   * Deserializes Hat from JSON.
   */
  decode: function (json: string): Hat {
    return HatJSON._readMessage(HatJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Hat with all fields set to their default value.
   */
  initialize: function (): Hat {
    return {
      inches: 0,
      color: "",
      name: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Hat>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.inches) {
      json["inches"] = msg.inches;
    }
    if (msg.color) {
      json["color"] = msg.color;
    }
    if (msg.name) {
      json["name"] = msg.name;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Hat, json: any): Hat {
    const _inches_ = json["inches"];
    if (_inches_) {
      msg.inches = _inches_;
    }
    const _color_ = json["color"];
    if (_color_) {
      msg.color = _color_;
    }
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    return msg;
  },
};
"
`;

exports[`TwirpScript Compiler generates TypeScript 5`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/map_unittest.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";

import * as googleProtobufUnittest from "./unittest.pb";

//========================================//
//                 Types                  //
//========================================//

export type MapEnum = "MAP_ENUM_FOO" | "MAP_ENUM_BAR" | "MAP_ENUM_BAZ";

/**
 * Tests maps.
 */
export interface TestMap {
  mapInt32Int32: Record<string, TestMap.MapInt32Int32["value"] | undefined>;
  mapInt64Int64: Record<string, TestMap.MapInt64Int64["value"] | undefined>;
  mapUint32Uint32: Record<string, TestMap.MapUint32Uint32["value"] | undefined>;
  mapUint64Uint64: Record<string, TestMap.MapUint64Uint64["value"] | undefined>;
  mapSint32Sint32: Record<string, TestMap.MapSint32Sint32["value"] | undefined>;
  mapSint64Sint64: Record<string, TestMap.MapSint64Sint64["value"] | undefined>;
  mapFixed32Fixed32: Record<
    string,
    TestMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<string, TestMap.MapInt32Float["value"] | undefined>;
  mapInt32Double: Record<string, TestMap.MapInt32Double["value"] | undefined>;
  mapBoolBool: Record<string, TestMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<string, TestMap.MapStringString["value"] | undefined>;
  mapInt32Bytes: Record<string, TestMap.MapInt32Bytes["value"] | undefined>;
  mapInt32Enum: Record<string, TestMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestMap.MapInt32ForeignMessage["value"] | undefined
  >;
  mapStringForeignMessage: Record<
    string,
    TestMap.MapStringForeignMessage["value"] | undefined
  >;
  mapInt32AllTypes: Record<
    string,
    TestMap.MapInt32AllTypes["value"] | undefined
  >;
}

export declare namespace TestMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapStringForeignMessage {
    key: string;
    value: googleProtobufUnittest.ForeignMessage;
  }

  interface MapInt32AllTypes {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

export interface TestMapSubmessage {
  testMap: TestMap;
}

export interface TestMessageMap {
  mapInt32Message: Record<
    string,
    TestMessageMap.MapInt32Message["value"] | undefined
  >;
}

export declare namespace TestMessageMap {
  interface MapInt32Message {
    key: number;
    value: googleProtobufUnittest.TestAllTypes;
  }
}

/**
 * Two map fields share the same entry default instance.
 */
export interface TestSameTypeMap {
  map1: Record<string, TestSameTypeMap.Map1["value"] | undefined>;
  map2: Record<string, TestSameTypeMap.Map2["value"] | undefined>;
}

export declare namespace TestSameTypeMap {
  interface Map1 {
    key: number;
    value: number;
  }

  interface Map2 {
    key: number;
    value: number;
  }
}

/**
 * Test embedded message with required fields
 */
export interface TestRequiredMessageMap {
  mapField: Record<
    string,
    TestRequiredMessageMap.MapField["value"] | undefined
  >;
}

export declare namespace TestRequiredMessageMap {
  interface MapField {
    key: number;
    value: googleProtobufUnittest.TestRequired;
  }
}

export interface TestArenaMap {
  mapInt32Int32: Record<
    string,
    TestArenaMap.MapInt32Int32["value"] | undefined
  >;
  mapInt64Int64: Record<
    string,
    TestArenaMap.MapInt64Int64["value"] | undefined
  >;
  mapUint32Uint32: Record<
    string,
    TestArenaMap.MapUint32Uint32["value"] | undefined
  >;
  mapUint64Uint64: Record<
    string,
    TestArenaMap.MapUint64Uint64["value"] | undefined
  >;
  mapSint32Sint32: Record<
    string,
    TestArenaMap.MapSint32Sint32["value"] | undefined
  >;
  mapSint64Sint64: Record<
    string,
    TestArenaMap.MapSint64Sint64["value"] | undefined
  >;
  mapFixed32Fixed32: Record<
    string,
    TestArenaMap.MapFixed32Fixed32["value"] | undefined
  >;
  mapFixed64Fixed64: Record<
    string,
    TestArenaMap.MapFixed64Fixed64["value"] | undefined
  >;
  mapSfixed32Sfixed32: Record<
    string,
    TestArenaMap.MapSfixed32Sfixed32["value"] | undefined
  >;
  mapSfixed64Sfixed64: Record<
    string,
    TestArenaMap.MapSfixed64Sfixed64["value"] | undefined
  >;
  mapInt32Float: Record<
    string,
    TestArenaMap.MapInt32Float["value"] | undefined
  >;
  mapInt32Double: Record<
    string,
    TestArenaMap.MapInt32Double["value"] | undefined
  >;
  mapBoolBool: Record<string, TestArenaMap.MapBoolBool["value"] | undefined>;
  mapStringString: Record<
    string,
    TestArenaMap.MapStringString["value"] | undefined
  >;
  mapInt32Bytes: Record<
    string,
    TestArenaMap.MapInt32Bytes["value"] | undefined
  >;
  mapInt32Enum: Record<string, TestArenaMap.MapInt32Enum["value"] | undefined>;
  mapInt32ForeignMessage: Record<
    string,
    TestArenaMap.MapInt32ForeignMessage["value"] | undefined
  >;
}

export declare namespace TestArenaMap {
  interface MapInt32Int32 {
    key: number;
    value: number;
  }

  interface MapInt64Int64 {
    key: bigint;
    value: bigint;
  }

  interface MapUint32Uint32 {
    key: number;
    value: number;
  }

  interface MapUint64Uint64 {
    key: bigint;
    value: bigint;
  }

  interface MapSint32Sint32 {
    key: number;
    value: number;
  }

  interface MapSint64Sint64 {
    key: bigint;
    value: bigint;
  }

  interface MapFixed32Fixed32 {
    key: number;
    value: number;
  }

  interface MapFixed64Fixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapSfixed32Sfixed32 {
    key: number;
    value: number;
  }

  interface MapSfixed64Sfixed64 {
    key: bigint;
    value: bigint;
  }

  interface MapInt32Float {
    key: number;
    value: number;
  }

  interface MapInt32Double {
    key: number;
    value: number;
  }

  interface MapBoolBool {
    key: boolean;
    value: boolean;
  }

  interface MapStringString {
    key: string;
    value: string;
  }

  interface MapInt32Bytes {
    key: number;
    value: Uint8Array;
  }

  interface MapInt32Enum {
    key: number;
    value: MapEnum;
  }

  interface MapInt32ForeignMessage {
    key: number;
    value: googleProtobufUnittest.ForeignMessage;
  }
}

/**
 * Previously, message cannot contain map field called "entry".
 */
export interface MessageContainingMapCalledEntry {
  entry: Record<
    string,
    MessageContainingMapCalledEntry.Entry["value"] | undefined
  >;
}

export declare namespace MessageContainingMapCalledEntry {
  interface Entry {
    key: number;
    value: number;
  }
}

export interface TestRecursiveMapMessage {
  a: Record<string, TestRecursiveMapMessage.A["value"] | undefined>;
}

export declare namespace TestRecursiveMapMessage {
  interface A {
    key: string;
    value: TestRecursiveMapMessage | null | undefined;
  }
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const MapEnum = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMap = {
  /**
   * Serializes TestMap to protobuf.
   */
  encode: function (msg: PartialDeep<TestMap>): Uint8Array {
    return TestMap._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMap {
    return TestMap._readMessage(TestMap.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMap>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Int32._writeMessage,
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt64Int64._writeMessage,
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint32Uint32._writeMessage,
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapUint64Uint64._writeMessage,
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint32Sint32._writeMessage,
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSint64Sint64._writeMessage,
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed32Fixed32._writeMessage,
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapFixed64Fixed64._writeMessage,
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed32Sfixed32._writeMessage,
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapSfixed64Sfixed64._writeMessage,
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Float._writeMessage,
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Double._writeMessage,
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapBoolBool._writeMessage,
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringString._writeMessage,
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Bytes._writeMessage,
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32Enum._writeMessage,
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32ForeignMessage._writeMessage,
      );
    }
    if (msg.mapStringForeignMessage) {
      writer.writeRepeatedMessage(
        18,
        Object.entries(msg.mapStringForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapStringForeignMessage._writeMessage,
      );
    }
    if (msg.mapInt32AllTypes) {
      writer.writeRepeatedMessage(
        19,
        Object.entries(msg.mapInt32AllTypes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMap.MapInt32AllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, reader: BinaryReader): TestMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMap.MapInt32Int32;
          reader.readMessage(map, TestMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestMap.MapInt64Int64;
          reader.readMessage(map, TestMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestMap.MapUint32Uint32;
          reader.readMessage(map, TestMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestMap.MapUint64Uint64;
          reader.readMessage(map, TestMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestMap.MapSint32Sint32;
          reader.readMessage(map, TestMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestMap.MapSint64Sint64;
          reader.readMessage(map, TestMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestMap.MapFixed32Fixed32;
          reader.readMessage(map, TestMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestMap.MapFixed64Fixed64;
          reader.readMessage(map, TestMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestMap.MapSfixed32Sfixed32;
          reader.readMessage(map, TestMap.MapSfixed32Sfixed32._readMessage);
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestMap.MapSfixed64Sfixed64;
          reader.readMessage(map, TestMap.MapSfixed64Sfixed64._readMessage);
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestMap.MapInt32Float;
          reader.readMessage(map, TestMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestMap.MapInt32Double;
          reader.readMessage(map, TestMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestMap.MapBoolBool;
          reader.readMessage(map, TestMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestMap.MapStringString;
          reader.readMessage(map, TestMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestMap.MapInt32Bytes;
          reader.readMessage(map, TestMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestMap.MapInt32Enum;
          reader.readMessage(map, TestMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestMap.MapInt32ForeignMessage;
          reader.readMessage(map, TestMap.MapInt32ForeignMessage._readMessage);
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 18: {
          const map = {} as TestMap.MapStringForeignMessage;
          reader.readMessage(map, TestMap.MapStringForeignMessage._readMessage);
          msg.mapStringForeignMessage[map.key.toString()] = map.value;
          break;
        }
        case 19: {
          const map = {} as TestMap.MapInt32AllTypes;
          reader.readMessage(map, TestMap.MapInt32AllTypes._readMessage);
          msg.mapInt32AllTypes[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Int32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      reader: BinaryReader,
    ): TestMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt64Int64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      reader: BinaryReader,
    ): TestMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapUint32Uint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      reader: BinaryReader,
    ): TestMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapUint64Uint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      reader: BinaryReader,
    ): TestMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSint32Sint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      reader: BinaryReader,
    ): TestMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSint64Sint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      reader: BinaryReader,
    ): TestMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapFixed32Fixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      reader: BinaryReader,
    ): TestMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapFixed64Fixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      reader: BinaryReader,
    ): TestMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      reader: BinaryReader,
    ): TestMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      reader: BinaryReader,
    ): TestMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Float>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      reader: BinaryReader,
    ): TestMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Double>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      reader: BinaryReader,
    ): TestMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapBoolBool>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      reader: BinaryReader,
    ): TestMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapStringString>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      reader: BinaryReader,
    ): TestMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Bytes>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      reader: BinaryReader,
    ): TestMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Enum>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      reader: BinaryReader,
    ): TestMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32ForeignMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      reader: BinaryReader,
    ): TestMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapStringForeignMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      reader: BinaryReader,
    ): TestMap.MapStringForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32AllTypes>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      reader: BinaryReader,
    ): TestMap.MapInt32AllTypes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMapSubmessage = {
  /**
   * Serializes TestMapSubmessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestMapSubmessage>): Uint8Array {
    return TestMapSubmessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMapSubmessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestMapSubmessage {
    return TestMapSubmessage._readMessage(
      TestMapSubmessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMap.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMapSubmessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.testMap) {
      writer.writeMessage(1, msg.testMap, TestMap._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    reader: BinaryReader,
  ): TestMapSubmessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.testMap, TestMap._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMessageMap = {
  /**
   * Serializes TestMessageMap to protobuf.
   */
  encode: function (msg: PartialDeep<TestMessageMap>): Uint8Array {
    return TestMessageMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestMessageMap {
    return TestMessageMap._readMessage(
      TestMessageMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMessageMap>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.mapInt32Message) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Message).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestMessageMap.MapInt32Message._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMessageMap,
    reader: BinaryReader,
  ): TestMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestMessageMap.MapInt32Message;
          reader.readMessage(map, TestMessageMap.MapInt32Message._readMessage);
          msg.mapInt32Message[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMessageMap.MapInt32Message>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      reader: BinaryReader,
    ): TestMessageMap.MapInt32Message {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestAllTypes.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestSameTypeMap = {
  /**
   * Serializes TestSameTypeMap to protobuf.
   */
  encode: function (msg: PartialDeep<TestSameTypeMap>): Uint8Array {
    return TestSameTypeMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestSameTypeMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestSameTypeMap {
    return TestSameTypeMap._readMessage(
      TestSameTypeMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestSameTypeMap>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.map1) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.map1).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map1._writeMessage,
      );
    }
    if (msg.map2) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.map2).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestSameTypeMap.Map2._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestSameTypeMap,
    reader: BinaryReader,
  ): TestSameTypeMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestSameTypeMap.Map1;
          reader.readMessage(map, TestSameTypeMap.Map1._readMessage);
          msg.map1[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestSameTypeMap.Map2;
          reader.readMessage(map, TestSameTypeMap.Map2._readMessage);
          msg.map2[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestSameTypeMap.Map1>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      reader: BinaryReader,
    ): TestSameTypeMap.Map1 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestSameTypeMap.Map2>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      reader: BinaryReader,
    ): TestSameTypeMap.Map2 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMap = {
  /**
   * Serializes TestRequiredMessageMap to protobuf.
   */
  encode: function (msg: PartialDeep<TestRequiredMessageMap>): Uint8Array {
    return TestRequiredMessageMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessageMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessageMap {
    return TestRequiredMessageMap._readMessage(
      TestRequiredMessageMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredMessageMap>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.mapField) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapField).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRequiredMessageMap.MapField._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    reader: BinaryReader,
  ): TestRequiredMessageMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRequiredMessageMap.MapField;
          reader.readMessage(map, TestRequiredMessageMap.MapField._readMessage);
          msg.mapField[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRequiredMessageMap.MapField>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.TestRequired._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      reader: BinaryReader,
    ): TestRequiredMessageMap.MapField {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.TestRequired.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.TestRequired._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestArenaMap = {
  /**
   * Serializes TestArenaMap to protobuf.
   */
  encode: function (msg: PartialDeep<TestArenaMap>): Uint8Array {
    return TestArenaMap._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestArenaMap from protobuf.
   */
  decode: function (bytes: ByteSource): TestArenaMap {
    return TestArenaMap._readMessage(
      TestArenaMap.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestArenaMap>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.mapInt32Int32) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.mapInt32Int32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Int32._writeMessage,
      );
    }
    if (msg.mapInt64Int64) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.mapInt64Int64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt64Int64._writeMessage,
      );
    }
    if (msg.mapUint32Uint32) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.mapUint32Uint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint32Uint32._writeMessage,
      );
    }
    if (msg.mapUint64Uint64) {
      writer.writeRepeatedMessage(
        4,
        Object.entries(msg.mapUint64Uint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapUint64Uint64._writeMessage,
      );
    }
    if (msg.mapSint32Sint32) {
      writer.writeRepeatedMessage(
        5,
        Object.entries(msg.mapSint32Sint32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint32Sint32._writeMessage,
      );
    }
    if (msg.mapSint64Sint64) {
      writer.writeRepeatedMessage(
        6,
        Object.entries(msg.mapSint64Sint64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSint64Sint64._writeMessage,
      );
    }
    if (msg.mapFixed32Fixed32) {
      writer.writeRepeatedMessage(
        7,
        Object.entries(msg.mapFixed32Fixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed32Fixed32._writeMessage,
      );
    }
    if (msg.mapFixed64Fixed64) {
      writer.writeRepeatedMessage(
        8,
        Object.entries(msg.mapFixed64Fixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapFixed64Fixed64._writeMessage,
      );
    }
    if (msg.mapSfixed32Sfixed32) {
      writer.writeRepeatedMessage(
        9,
        Object.entries(msg.mapSfixed32Sfixed32).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed32Sfixed32._writeMessage,
      );
    }
    if (msg.mapSfixed64Sfixed64) {
      writer.writeRepeatedMessage(
        10,
        Object.entries(msg.mapSfixed64Sfixed64).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapSfixed64Sfixed64._writeMessage,
      );
    }
    if (msg.mapInt32Float) {
      writer.writeRepeatedMessage(
        11,
        Object.entries(msg.mapInt32Float).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Float._writeMessage,
      );
    }
    if (msg.mapInt32Double) {
      writer.writeRepeatedMessage(
        12,
        Object.entries(msg.mapInt32Double).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Double._writeMessage,
      );
    }
    if (msg.mapBoolBool) {
      writer.writeRepeatedMessage(
        13,
        Object.entries(msg.mapBoolBool).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapBoolBool._writeMessage,
      );
    }
    if (msg.mapStringString) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.mapStringString).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapStringString._writeMessage,
      );
    }
    if (msg.mapInt32Bytes) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.mapInt32Bytes).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Bytes._writeMessage,
      );
    }
    if (msg.mapInt32Enum) {
      writer.writeRepeatedMessage(
        16,
        Object.entries(msg.mapInt32Enum).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32Enum._writeMessage,
      );
    }
    if (msg.mapInt32ForeignMessage) {
      writer.writeRepeatedMessage(
        17,
        Object.entries(msg.mapInt32ForeignMessage).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestArenaMap.MapInt32ForeignMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestArenaMap,
    reader: BinaryReader,
  ): TestArenaMap {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestArenaMap.MapInt32Int32;
          reader.readMessage(map, TestArenaMap.MapInt32Int32._readMessage);
          msg.mapInt32Int32[map.key.toString()] = map.value;
          break;
        }
        case 2: {
          const map = {} as TestArenaMap.MapInt64Int64;
          reader.readMessage(map, TestArenaMap.MapInt64Int64._readMessage);
          msg.mapInt64Int64[map.key.toString()] = map.value;
          break;
        }
        case 3: {
          const map = {} as TestArenaMap.MapUint32Uint32;
          reader.readMessage(map, TestArenaMap.MapUint32Uint32._readMessage);
          msg.mapUint32Uint32[map.key.toString()] = map.value;
          break;
        }
        case 4: {
          const map = {} as TestArenaMap.MapUint64Uint64;
          reader.readMessage(map, TestArenaMap.MapUint64Uint64._readMessage);
          msg.mapUint64Uint64[map.key.toString()] = map.value;
          break;
        }
        case 5: {
          const map = {} as TestArenaMap.MapSint32Sint32;
          reader.readMessage(map, TestArenaMap.MapSint32Sint32._readMessage);
          msg.mapSint32Sint32[map.key.toString()] = map.value;
          break;
        }
        case 6: {
          const map = {} as TestArenaMap.MapSint64Sint64;
          reader.readMessage(map, TestArenaMap.MapSint64Sint64._readMessage);
          msg.mapSint64Sint64[map.key.toString()] = map.value;
          break;
        }
        case 7: {
          const map = {} as TestArenaMap.MapFixed32Fixed32;
          reader.readMessage(map, TestArenaMap.MapFixed32Fixed32._readMessage);
          msg.mapFixed32Fixed32[map.key.toString()] = map.value;
          break;
        }
        case 8: {
          const map = {} as TestArenaMap.MapFixed64Fixed64;
          reader.readMessage(map, TestArenaMap.MapFixed64Fixed64._readMessage);
          msg.mapFixed64Fixed64[map.key.toString()] = map.value;
          break;
        }
        case 9: {
          const map = {} as TestArenaMap.MapSfixed32Sfixed32;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed32Sfixed32._readMessage,
          );
          msg.mapSfixed32Sfixed32[map.key.toString()] = map.value;
          break;
        }
        case 10: {
          const map = {} as TestArenaMap.MapSfixed64Sfixed64;
          reader.readMessage(
            map,
            TestArenaMap.MapSfixed64Sfixed64._readMessage,
          );
          msg.mapSfixed64Sfixed64[map.key.toString()] = map.value;
          break;
        }
        case 11: {
          const map = {} as TestArenaMap.MapInt32Float;
          reader.readMessage(map, TestArenaMap.MapInt32Float._readMessage);
          msg.mapInt32Float[map.key.toString()] = map.value;
          break;
        }
        case 12: {
          const map = {} as TestArenaMap.MapInt32Double;
          reader.readMessage(map, TestArenaMap.MapInt32Double._readMessage);
          msg.mapInt32Double[map.key.toString()] = map.value;
          break;
        }
        case 13: {
          const map = {} as TestArenaMap.MapBoolBool;
          reader.readMessage(map, TestArenaMap.MapBoolBool._readMessage);
          msg.mapBoolBool[map.key.toString()] = map.value;
          break;
        }
        case 14: {
          const map = {} as TestArenaMap.MapStringString;
          reader.readMessage(map, TestArenaMap.MapStringString._readMessage);
          msg.mapStringString[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as TestArenaMap.MapInt32Bytes;
          reader.readMessage(map, TestArenaMap.MapInt32Bytes._readMessage);
          msg.mapInt32Bytes[map.key.toString()] = map.value;
          break;
        }
        case 16: {
          const map = {} as TestArenaMap.MapInt32Enum;
          reader.readMessage(map, TestArenaMap.MapInt32Enum._readMessage);
          msg.mapInt32Enum[map.key.toString()] = map.value;
          break;
        }
        case 17: {
          const map = {} as TestArenaMap.MapInt32ForeignMessage;
          reader.readMessage(
            map,
            TestArenaMap.MapInt32ForeignMessage._readMessage,
          );
          msg.mapInt32ForeignMessage[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Int32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32Int32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt64Int64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeInt64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      reader: BinaryReader,
    ): TestArenaMap.MapInt64Int64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readInt64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapUint32Uint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeUint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      reader: BinaryReader,
    ): TestArenaMap.MapUint32Uint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readUint32();
            break;
          }
          case 2: {
            msg.value = reader.readUint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapUint64Uint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeUint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeUint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      reader: BinaryReader,
    ): TestArenaMap.MapUint64Uint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readUint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readUint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSint32Sint32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSint32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      reader: BinaryReader,
    ): TestArenaMap.MapSint32Sint32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSint32();
            break;
          }
          case 2: {
            msg.value = reader.readSint32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSint64Sint64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSint64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSint64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      reader: BinaryReader,
    ): TestArenaMap.MapSint64Sint64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSint64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSint64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapFixed32Fixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      reader: BinaryReader,
    ): TestArenaMap.MapFixed32Fixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readFixed32();
            break;
          }
          case 2: {
            msg.value = reader.readFixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapFixed64Fixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeFixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeFixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      reader: BinaryReader,
    ): TestArenaMap.MapFixed64Fixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readFixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readFixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSfixed32Sfixed32>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed32(1, msg.key);
      }
      if (msg.value) {
        writer.writeSfixed32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      reader: BinaryReader,
    ): TestArenaMap.MapSfixed32Sfixed32 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readSfixed32();
            break;
          }
          case 2: {
            msg.value = reader.readSfixed32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSfixed64Sfixed64>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeSfixed64String(1, msg.key.toString() as any);
      }
      if (msg.value) {
        writer.writeSfixed64String(2, msg.value.toString() as any);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      reader: BinaryReader,
    ): TestArenaMap.MapSfixed64Sfixed64 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = BigInt(reader.readSfixed64String());
            break;
          }
          case 2: {
            msg.value = BigInt(reader.readSfixed64String());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Float>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeFloat(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32Float {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readFloat();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Double>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeDouble(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32Double {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapBoolBool>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeBool(1, msg.key);
      }
      if (msg.value) {
        writer.writeBool(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      reader: BinaryReader,
    ): TestArenaMap.MapBoolBool {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readBool();
            break;
          }
          case 2: {
            msg.value = reader.readBool();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapStringString>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      reader: BinaryReader,
    ): TestArenaMap.MapStringString {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Bytes>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value?.length) {
        writer.writeBytes(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32Bytes {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readBytes();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Enum>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value && MapEnum._toInt(msg.value)) {
        writer.writeEnum(2, MapEnum._toInt(msg.value));
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32Enum {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = MapEnum._fromInt(reader.readEnum());
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32ForeignMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          googleProtobufUnittest.ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      reader: BinaryReader,
    ): TestArenaMap.MapInt32ForeignMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = googleProtobufUnittest.ForeignMessage.initialize();
            reader.readMessage(
              msg.value,
              googleProtobufUnittest.ForeignMessage._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntry = {
  /**
   * Serializes MessageContainingMapCalledEntry to protobuf.
   */
  encode: function (
    msg: PartialDeep<MessageContainingMapCalledEntry>,
  ): Uint8Array {
    return MessageContainingMapCalledEntry._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from protobuf.
   */
  decode: function (bytes: ByteSource): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntry._readMessage(
      MessageContainingMapCalledEntry.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MessageContainingMapCalledEntry>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.entry) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.entry).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        MessageContainingMapCalledEntry.Entry._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    reader: BinaryReader,
  ): MessageContainingMapCalledEntry {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as MessageContainingMapCalledEntry.Entry;
          reader.readMessage(
            map,
            MessageContainingMapCalledEntry.Entry._readMessage,
          );
          msg.entry[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<MessageContainingMapCalledEntry.Entry>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeInt32(1, msg.key);
      }
      if (msg.value) {
        writer.writeInt32(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      reader: BinaryReader,
    ): MessageContainingMapCalledEntry.Entry {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readInt32();
            break;
          }
          case 2: {
            msg.value = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessage = {
  /**
   * Serializes TestRecursiveMapMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestRecursiveMapMessage>): Uint8Array {
    return TestRecursiveMapMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMapMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMapMessage {
    return TestRecursiveMapMessage._readMessage(
      TestRecursiveMapMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRecursiveMapMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeRepeatedMessage(
        1,
        Object.entries(msg.a).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestRecursiveMapMessage.A._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    reader: BinaryReader,
  ): TestRecursiveMapMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const map = {} as TestRecursiveMapMessage.A;
          reader.readMessage(map, TestRecursiveMapMessage.A._readMessage);
          msg.a[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRecursiveMapMessage.A>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(
          2,
          msg.value,
          TestRecursiveMapMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      reader: BinaryReader,
    ): TestRecursiveMapMessage.A {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = TestRecursiveMapMessage.initialize();
            reader.readMessage(msg.value, TestRecursiveMapMessage._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const MapEnumJSON = {
  MAP_ENUM_FOO: "MAP_ENUM_FOO",
  MAP_ENUM_BAR: "MAP_ENUM_BAR",
  MAP_ENUM_BAZ: "MAP_ENUM_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): MapEnum {
    switch (i) {
      case 0: {
        return "MAP_ENUM_FOO";
      }
      case 1: {
        return "MAP_ENUM_BAR";
      }
      case 2: {
        return "MAP_ENUM_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as MapEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: MapEnum): number {
    switch (i) {
      case "MAP_ENUM_FOO": {
        return 0;
      }
      case "MAP_ENUM_BAR": {
        return 1;
      }
      case "MAP_ENUM_BAZ": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestMapJSON = {
  /**
   * Serializes TestMap to JSON.
   */
  encode: function (msg: PartialDeep<TestMap>): string {
    return JSON.stringify(TestMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMap from JSON.
   */
  decode: function (json: string): TestMap {
    return TestMapJSON._readMessage(TestMapJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes TestMap with all fields set to their default value.
   */
  initialize: function (): TestMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
      mapStringForeignMessage: {},
      mapInt32AllTypes: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<TestMap>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    if (msg.mapStringForeignMessage) {
      const _mapStringForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapStringForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringForeignMessage_).length > 0) {
        json["mapStringForeignMessage"] = _mapStringForeignMessage_;
      }
    }
    if (msg.mapInt32AllTypes) {
      const _mapInt32AllTypes_ = Object.fromEntries(
        Object.entries(msg.mapInt32AllTypes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32AllTypes_).length > 0) {
        json["mapInt32AllTypes"] = _mapInt32AllTypes_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMap, json: any): TestMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringForeignMessage_ =
      json["mapStringForeignMessage"] ?? json["map_string_foreign_message"];
    if (_mapStringForeignMessage_) {
      msg.mapStringForeignMessage = Object.fromEntries(
        Object.entries(_mapStringForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapStringForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32AllTypes_ =
      json["mapInt32AllTypes"] ?? json["map_int32_all_types"];
    if (_mapInt32AllTypes_) {
      msg.mapInt32AllTypes = Object.fromEntries(
        Object.entries(_mapInt32AllTypes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMapJSON.MapInt32AllTypes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Int32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Int32,
      json: any,
    ): TestMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt64Int64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt64Int64,
      json: any,
    ): TestMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapUint32Uint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint32Uint32,
      json: any,
    ): TestMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapUint64Uint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapUint64Uint64,
      json: any,
    ): TestMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSint32Sint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint32Sint32,
      json: any,
    ): TestMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSint64Sint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSint64Sint64,
      json: any,
    ): TestMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapFixed32Fixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed32Fixed32,
      json: any,
    ): TestMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapFixed64Fixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapFixed64Fixed64,
      json: any,
    ): TestMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSfixed32Sfixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed32Sfixed32,
      json: any,
    ): TestMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapSfixed64Sfixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapSfixed64Sfixed64,
      json: any,
    ): TestMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Float>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Float,
      json: any,
    ): TestMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Double>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Double,
      json: any,
    ): TestMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapBoolBool>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapBoolBool,
      json: any,
    ): TestMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapStringString>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringString,
      json: any,
    ): TestMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Bytes>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Bytes,
      json: any,
    ): TestMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32Enum>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32Enum,
      json: any,
    ): TestMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32ForeignMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32ForeignMessage,
      json: any,
    ): TestMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },

  MapStringForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapStringForeignMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapStringForeignMessage,
      json: any,
    ): TestMap.MapStringForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },

  MapInt32AllTypes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMap.MapInt32AllTypes>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMap.MapInt32AllTypes,
      json: any,
    ): TestMap.MapInt32AllTypes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestAllTypesJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestMapSubmessageJSON = {
  /**
   * Serializes TestMapSubmessage to JSON.
   */
  encode: function (msg: PartialDeep<TestMapSubmessage>): string {
    return JSON.stringify(TestMapSubmessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMapSubmessage from JSON.
   */
  decode: function (json: string): TestMapSubmessage {
    return TestMapSubmessageJSON._readMessage(
      TestMapSubmessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMapSubmessage with all fields set to their default value.
   */
  initialize: function (): TestMapSubmessage {
    return {
      testMap: TestMapJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMapSubmessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.testMap) {
      const _testMap_ = TestMapJSON._writeMessage(msg.testMap);
      if (Object.keys(_testMap_).length > 0) {
        json["testMap"] = _testMap_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMapSubmessage,
    json: any,
  ): TestMapSubmessage {
    const _testMap_ = json["testMap"] ?? json["test_map"];
    if (_testMap_) {
      TestMapJSON._readMessage(msg.testMap, _testMap_);
    }
    return msg;
  },
};

export const TestMessageMapJSON = {
  /**
   * Serializes TestMessageMap to JSON.
   */
  encode: function (msg: PartialDeep<TestMessageMap>): string {
    return JSON.stringify(TestMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMessageMap from JSON.
   */
  decode: function (json: string): TestMessageMap {
    return TestMessageMapJSON._readMessage(
      TestMessageMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMessageMap with all fields set to their default value.
   */
  initialize: function (): TestMessageMap {
    return {
      mapInt32Message: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMessageMap>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Message) {
      const _mapInt32Message_ = Object.fromEntries(
        Object.entries(msg.mapInt32Message)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Message_).length > 0) {
        json["mapInt32Message"] = _mapInt32Message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestMessageMap, json: any): TestMessageMap {
    const _mapInt32Message_ =
      json["mapInt32Message"] ?? json["map_int32_message"];
    if (_mapInt32Message_) {
      msg.mapInt32Message = Object.fromEntries(
        Object.entries(_mapInt32Message_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestMessageMapJSON.MapInt32Message._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Message: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMessageMap.MapInt32Message>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestAllTypesJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMessageMap.MapInt32Message,
      json: any,
    ): TestMessageMap.MapInt32Message {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestAllTypesJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestSameTypeMapJSON = {
  /**
   * Serializes TestSameTypeMap to JSON.
   */
  encode: function (msg: PartialDeep<TestSameTypeMap>): string {
    return JSON.stringify(TestSameTypeMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestSameTypeMap from JSON.
   */
  decode: function (json: string): TestSameTypeMap {
    return TestSameTypeMapJSON._readMessage(
      TestSameTypeMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestSameTypeMap with all fields set to their default value.
   */
  initialize: function (): TestSameTypeMap {
    return {
      map1: {},
      map2: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestSameTypeMap>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.map1) {
      const _map1_ = Object.fromEntries(
        Object.entries(msg.map1)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_map1_).length > 0) {
        json["map1"] = _map1_;
      }
    }
    if (msg.map2) {
      const _map2_ = Object.fromEntries(
        Object.entries(msg.map2)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_map2_).length > 0) {
        json["map2"] = _map2_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestSameTypeMap, json: any): TestSameTypeMap {
    const _map1_ = json["map1"];
    if (_map1_) {
      msg.map1 = Object.fromEntries(
        Object.entries(_map1_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map1._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _map2_ = json["map2"];
    if (_map2_) {
      msg.map2 = Object.fromEntries(
        Object.entries(_map2_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestSameTypeMapJSON.Map2._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Map1: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestSameTypeMap.Map1>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map1,
      json: any,
    ): TestSameTypeMap.Map1 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  Map2: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestSameTypeMap.Map2>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestSameTypeMap.Map2,
      json: any,
    ): TestSameTypeMap.Map2 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRequiredMessageMapJSON = {
  /**
   * Serializes TestRequiredMessageMap to JSON.
   */
  encode: function (msg: PartialDeep<TestRequiredMessageMap>): string {
    return JSON.stringify(TestRequiredMessageMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessageMap from JSON.
   */
  decode: function (json: string): TestRequiredMessageMap {
    return TestRequiredMessageMapJSON._readMessage(
      TestRequiredMessageMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredMessageMap with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessageMap {
    return {
      mapField: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredMessageMap>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapField) {
      const _mapField_ = Object.fromEntries(
        Object.entries(msg.mapField)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapField_).length > 0) {
        json["mapField"] = _mapField_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessageMap,
    json: any,
  ): TestRequiredMessageMap {
    const _mapField_ = json["mapField"] ?? json["map_field"];
    if (_mapField_) {
      msg.mapField = Object.fromEntries(
        Object.entries(_mapField_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRequiredMessageMapJSON.MapField._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapField: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRequiredMessageMap.MapField>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.TestRequiredJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredMessageMap.MapField,
      json: any,
    ): TestRequiredMessageMap.MapField {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.TestRequiredJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const TestArenaMapJSON = {
  /**
   * Serializes TestArenaMap to JSON.
   */
  encode: function (msg: PartialDeep<TestArenaMap>): string {
    return JSON.stringify(TestArenaMapJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestArenaMap from JSON.
   */
  decode: function (json: string): TestArenaMap {
    return TestArenaMapJSON._readMessage(
      TestArenaMapJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestArenaMap with all fields set to their default value.
   */
  initialize: function (): TestArenaMap {
    return {
      mapInt32Int32: {},
      mapInt64Int64: {},
      mapUint32Uint32: {},
      mapUint64Uint64: {},
      mapSint32Sint32: {},
      mapSint64Sint64: {},
      mapFixed32Fixed32: {},
      mapFixed64Fixed64: {},
      mapSfixed32Sfixed32: {},
      mapSfixed64Sfixed64: {},
      mapInt32Float: {},
      mapInt32Double: {},
      mapBoolBool: {},
      mapStringString: {},
      mapInt32Bytes: {},
      mapInt32Enum: {},
      mapInt32ForeignMessage: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestArenaMap>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.mapInt32Int32) {
      const _mapInt32Int32_ = Object.fromEntries(
        Object.entries(msg.mapInt32Int32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Int32_).length > 0) {
        json["mapInt32Int32"] = _mapInt32Int32_;
      }
    }
    if (msg.mapInt64Int64) {
      const _mapInt64Int64_ = Object.fromEntries(
        Object.entries(msg.mapInt64Int64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt64Int64_).length > 0) {
        json["mapInt64Int64"] = _mapInt64Int64_;
      }
    }
    if (msg.mapUint32Uint32) {
      const _mapUint32Uint32_ = Object.fromEntries(
        Object.entries(msg.mapUint32Uint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint32Uint32_).length > 0) {
        json["mapUint32Uint32"] = _mapUint32Uint32_;
      }
    }
    if (msg.mapUint64Uint64) {
      const _mapUint64Uint64_ = Object.fromEntries(
        Object.entries(msg.mapUint64Uint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapUint64Uint64_).length > 0) {
        json["mapUint64Uint64"] = _mapUint64Uint64_;
      }
    }
    if (msg.mapSint32Sint32) {
      const _mapSint32Sint32_ = Object.fromEntries(
        Object.entries(msg.mapSint32Sint32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint32Sint32_).length > 0) {
        json["mapSint32Sint32"] = _mapSint32Sint32_;
      }
    }
    if (msg.mapSint64Sint64) {
      const _mapSint64Sint64_ = Object.fromEntries(
        Object.entries(msg.mapSint64Sint64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSint64Sint64_).length > 0) {
        json["mapSint64Sint64"] = _mapSint64Sint64_;
      }
    }
    if (msg.mapFixed32Fixed32) {
      const _mapFixed32Fixed32_ = Object.fromEntries(
        Object.entries(msg.mapFixed32Fixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed32Fixed32_).length > 0) {
        json["mapFixed32Fixed32"] = _mapFixed32Fixed32_;
      }
    }
    if (msg.mapFixed64Fixed64) {
      const _mapFixed64Fixed64_ = Object.fromEntries(
        Object.entries(msg.mapFixed64Fixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapFixed64Fixed64_).length > 0) {
        json["mapFixed64Fixed64"] = _mapFixed64Fixed64_;
      }
    }
    if (msg.mapSfixed32Sfixed32) {
      const _mapSfixed32Sfixed32_ = Object.fromEntries(
        Object.entries(msg.mapSfixed32Sfixed32)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed32Sfixed32_).length > 0) {
        json["mapSfixed32Sfixed32"] = _mapSfixed32Sfixed32_;
      }
    }
    if (msg.mapSfixed64Sfixed64) {
      const _mapSfixed64Sfixed64_ = Object.fromEntries(
        Object.entries(msg.mapSfixed64Sfixed64)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapSfixed64Sfixed64_).length > 0) {
        json["mapSfixed64Sfixed64"] = _mapSfixed64Sfixed64_;
      }
    }
    if (msg.mapInt32Float) {
      const _mapInt32Float_ = Object.fromEntries(
        Object.entries(msg.mapInt32Float)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Float_).length > 0) {
        json["mapInt32Float"] = _mapInt32Float_;
      }
    }
    if (msg.mapInt32Double) {
      const _mapInt32Double_ = Object.fromEntries(
        Object.entries(msg.mapInt32Double)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Double_).length > 0) {
        json["mapInt32Double"] = _mapInt32Double_;
      }
    }
    if (msg.mapBoolBool) {
      const _mapBoolBool_ = Object.fromEntries(
        Object.entries(msg.mapBoolBool)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapBoolBool_).length > 0) {
        json["mapBoolBool"] = _mapBoolBool_;
      }
    }
    if (msg.mapStringString) {
      const _mapStringString_ = Object.fromEntries(
        Object.entries(msg.mapStringString)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapStringString_).length > 0) {
        json["mapStringString"] = _mapStringString_;
      }
    }
    if (msg.mapInt32Bytes) {
      const _mapInt32Bytes_ = Object.fromEntries(
        Object.entries(msg.mapInt32Bytes)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Bytes_).length > 0) {
        json["mapInt32Bytes"] = _mapInt32Bytes_;
      }
    }
    if (msg.mapInt32Enum) {
      const _mapInt32Enum_ = Object.fromEntries(
        Object.entries(msg.mapInt32Enum)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32Enum_).length > 0) {
        json["mapInt32Enum"] = _mapInt32Enum_;
      }
    }
    if (msg.mapInt32ForeignMessage) {
      const _mapInt32ForeignMessage_ = Object.fromEntries(
        Object.entries(msg.mapInt32ForeignMessage)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_mapInt32ForeignMessage_).length > 0) {
        json["mapInt32ForeignMessage"] = _mapInt32ForeignMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestArenaMap, json: any): TestArenaMap {
    const _mapInt32Int32_ = json["mapInt32Int32"] ?? json["map_int32_int32"];
    if (_mapInt32Int32_) {
      msg.mapInt32Int32 = Object.fromEntries(
        Object.entries(_mapInt32Int32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Int32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt64Int64_ = json["mapInt64Int64"] ?? json["map_int64_int64"];
    if (_mapInt64Int64_) {
      msg.mapInt64Int64 = Object.fromEntries(
        Object.entries(_mapInt64Int64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt64Int64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint32Uint32_ =
      json["mapUint32Uint32"] ?? json["map_uint32_uint32"];
    if (_mapUint32Uint32_) {
      msg.mapUint32Uint32 = Object.fromEntries(
        Object.entries(_mapUint32Uint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint32Uint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapUint64Uint64_ =
      json["mapUint64Uint64"] ?? json["map_uint64_uint64"];
    if (_mapUint64Uint64_) {
      msg.mapUint64Uint64 = Object.fromEntries(
        Object.entries(_mapUint64Uint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapUint64Uint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint32Sint32_ =
      json["mapSint32Sint32"] ?? json["map_sint32_sint32"];
    if (_mapSint32Sint32_) {
      msg.mapSint32Sint32 = Object.fromEntries(
        Object.entries(_mapSint32Sint32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint32Sint32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSint64Sint64_ =
      json["mapSint64Sint64"] ?? json["map_sint64_sint64"];
    if (_mapSint64Sint64_) {
      msg.mapSint64Sint64 = Object.fromEntries(
        Object.entries(_mapSint64Sint64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSint64Sint64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed32Fixed32_ =
      json["mapFixed32Fixed32"] ?? json["map_fixed32_fixed32"];
    if (_mapFixed32Fixed32_) {
      msg.mapFixed32Fixed32 = Object.fromEntries(
        Object.entries(_mapFixed32Fixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed32Fixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapFixed64Fixed64_ =
      json["mapFixed64Fixed64"] ?? json["map_fixed64_fixed64"];
    if (_mapFixed64Fixed64_) {
      msg.mapFixed64Fixed64 = Object.fromEntries(
        Object.entries(_mapFixed64Fixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapFixed64Fixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed32Sfixed32_ =
      json["mapSfixed32Sfixed32"] ?? json["map_sfixed32_sfixed32"];
    if (_mapSfixed32Sfixed32_) {
      msg.mapSfixed32Sfixed32 = Object.fromEntries(
        Object.entries(_mapSfixed32Sfixed32_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed32Sfixed32._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapSfixed64Sfixed64_ =
      json["mapSfixed64Sfixed64"] ?? json["map_sfixed64_sfixed64"];
    if (_mapSfixed64Sfixed64_) {
      msg.mapSfixed64Sfixed64 = Object.fromEntries(
        Object.entries(_mapSfixed64Sfixed64_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapSfixed64Sfixed64._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Float_ = json["mapInt32Float"] ?? json["map_int32_float"];
    if (_mapInt32Float_) {
      msg.mapInt32Float = Object.fromEntries(
        Object.entries(_mapInt32Float_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Float._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Double_ = json["mapInt32Double"] ?? json["map_int32_double"];
    if (_mapInt32Double_) {
      msg.mapInt32Double = Object.fromEntries(
        Object.entries(_mapInt32Double_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Double._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapBoolBool_ = json["mapBoolBool"] ?? json["map_bool_bool"];
    if (_mapBoolBool_) {
      msg.mapBoolBool = Object.fromEntries(
        Object.entries(_mapBoolBool_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapBoolBool._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapStringString_ =
      json["mapStringString"] ?? json["map_string_string"];
    if (_mapStringString_) {
      msg.mapStringString = Object.fromEntries(
        Object.entries(_mapStringString_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapStringString._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Bytes_ = json["mapInt32Bytes"] ?? json["map_int32_bytes"];
    if (_mapInt32Bytes_) {
      msg.mapInt32Bytes = Object.fromEntries(
        Object.entries(_mapInt32Bytes_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Bytes._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32Enum_ = json["mapInt32Enum"] ?? json["map_int32_enum"];
    if (_mapInt32Enum_) {
      msg.mapInt32Enum = Object.fromEntries(
        Object.entries(_mapInt32Enum_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32Enum._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _mapInt32ForeignMessage_ =
      json["mapInt32ForeignMessage"] ?? json["map_int32_foreign_message"];
    if (_mapInt32ForeignMessage_) {
      msg.mapInt32ForeignMessage = Object.fromEntries(
        Object.entries(_mapInt32ForeignMessage_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestArenaMapJSON.MapInt32ForeignMessage._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  MapInt32Int32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Int32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Int32,
      json: any,
    ): TestArenaMap.MapInt32Int32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt64Int64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt64Int64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt64Int64,
      json: any,
    ): TestArenaMap.MapInt64Int64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapUint32Uint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapUint32Uint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint32Uint32,
      json: any,
    ): TestArenaMap.MapUint32Uint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapUint64Uint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapUint64Uint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapUint64Uint64,
      json: any,
    ): TestArenaMap.MapUint64Uint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSint32Sint32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSint32Sint32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint32Sint32,
      json: any,
    ): TestArenaMap.MapSint32Sint32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSint64Sint64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSint64Sint64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSint64Sint64,
      json: any,
    ): TestArenaMap.MapSint64Sint64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapFixed32Fixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapFixed32Fixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed32Fixed32,
      json: any,
    ): TestArenaMap.MapFixed32Fixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapFixed64Fixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapFixed64Fixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapFixed64Fixed64,
      json: any,
    ): TestArenaMap.MapFixed64Fixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapSfixed32Sfixed32: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSfixed32Sfixed32>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed32Sfixed32,
      json: any,
    ): TestArenaMap.MapSfixed32Sfixed32 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapSfixed64Sfixed64: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapSfixed64Sfixed64>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key.toString();
      }
      if (msg.value) {
        json["value"] = msg.value.toString();
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapSfixed64Sfixed64,
      json: any,
    ): TestArenaMap.MapSfixed64Sfixed64 {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = BigInt(_key_);
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = BigInt(_value_);
      }
      return msg;
    },
  },

  MapInt32Float: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Float>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Float,
      json: any,
    ): TestArenaMap.MapInt32Float {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Double: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Double>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Double,
      json: any,
    ): TestArenaMap.MapInt32Double {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapBoolBool: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapBoolBool>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapBoolBool,
      json: any,
    ): TestArenaMap.MapBoolBool {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapStringString: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapStringString>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapStringString,
      json: any,
    ): TestArenaMap.MapStringString {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32Bytes: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Bytes>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value?.length) {
        json["value"] = encodeBase64Bytes(msg.value);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Bytes,
      json: any,
    ): TestArenaMap.MapInt32Bytes {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = decodeBase64Bytes(_value_);
      }
      return msg;
    },
  },

  MapInt32Enum: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32Enum>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value && MapEnumJSON._toInt(msg.value)) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32Enum,
      json: any,
    ): TestArenaMap.MapInt32Enum {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },

  MapInt32ForeignMessage: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestArenaMap.MapInt32ForeignMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = googleProtobufUnittest.ForeignMessageJSON._writeMessage(
          msg.value,
        );
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestArenaMap.MapInt32ForeignMessage,
      json: any,
    ): TestArenaMap.MapInt32ForeignMessage {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        googleProtobufUnittest.ForeignMessageJSON._readMessage(
          msg.value,
          _value_,
        );
      }
      return msg;
    },
  },
};

export const MessageContainingMapCalledEntryJSON = {
  /**
   * Serializes MessageContainingMapCalledEntry to JSON.
   */
  encode: function (msg: PartialDeep<MessageContainingMapCalledEntry>): string {
    return JSON.stringify(
      MessageContainingMapCalledEntryJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes MessageContainingMapCalledEntry from JSON.
   */
  decode: function (json: string): MessageContainingMapCalledEntry {
    return MessageContainingMapCalledEntryJSON._readMessage(
      MessageContainingMapCalledEntryJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MessageContainingMapCalledEntry with all fields set to their default value.
   */
  initialize: function (): MessageContainingMapCalledEntry {
    return {
      entry: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MessageContainingMapCalledEntry>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entry) {
      const _entry_ = Object.fromEntries(
        Object.entries(msg.entry)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_entry_).length > 0) {
        json["entry"] = _entry_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MessageContainingMapCalledEntry,
    json: any,
  ): MessageContainingMapCalledEntry {
    const _entry_ = json["entry"];
    if (_entry_) {
      msg.entry = Object.fromEntries(
        Object.entries(_entry_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(MessageContainingMapCalledEntryJSON.Entry._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  Entry: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<MessageContainingMapCalledEntry.Entry>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: MessageContainingMapCalledEntry.Entry,
      json: any,
    ): MessageContainingMapCalledEntry.Entry {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestRecursiveMapMessageJSON = {
  /**
   * Serializes TestRecursiveMapMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestRecursiveMapMessage>): string {
    return JSON.stringify(TestRecursiveMapMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMapMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMapMessage {
    return TestRecursiveMapMessageJSON._readMessage(
      TestRecursiveMapMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRecursiveMapMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMapMessage {
    return {
      a: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRecursiveMapMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = Object.fromEntries(
        Object.entries(msg.a)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMapMessage,
    json: any,
  ): TestRecursiveMapMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = Object.fromEntries(
        Object.entries(_a_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestRecursiveMapMessageJSON.A._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    return msg;
  },

  A: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRecursiveMapMessage.A>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = TestRecursiveMapMessageJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRecursiveMapMessage.A,
      json: any,
    ): TestRecursiveMapMessage.A {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = TestRecursiveMapMessageJSON.initialize();
        TestRecursiveMapMessageJSON._readMessage(msg.value, _value_);
      }
      return msg;
    },
  },
};
"
`;

exports[`TwirpScript Compiler generates TypeScript 6`] = `
"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: google/protobuf/unittest.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import {
  BinaryReader,
  BinaryWriter,
  encodeBase64Bytes,
  decodeBase64Bytes,
} from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running \`npx twirpscript\`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";
import * as googleProtobufUnittest_import from "./unittest_import.pb";
import * as googleProtobufUnittest_import_public from "./unittest_import_public.pb";

//========================================//
//                 Types                  //
//========================================//

export type ForeignEnum = "FOREIGN_FOO" | "FOREIGN_BAR" | "FOREIGN_BAZ";

/**
 * Test an enum that has multiple values with the same number.
 */
export type TestEnumWithDupValue = "FOO1" | "BAR1" | "BAZ" | "FOO2" | "BAR2";

/**
 * Test an enum with large, unordered values.
 */
export type TestSparseEnum =
  | "SPARSE_A"
  | "SPARSE_B"
  | "SPARSE_C"
  | "SPARSE_D"
  | "SPARSE_E"
  | "SPARSE_F"
  | "SPARSE_G";

export type VeryLargeEnum =
  | "ENUM_LABEL_DEFAULT"
  | "ENUM_LABEL_1"
  | "ENUM_LABEL_2"
  | "ENUM_LABEL_3"
  | "ENUM_LABEL_4"
  | "ENUM_LABEL_5"
  | "ENUM_LABEL_6"
  | "ENUM_LABEL_7"
  | "ENUM_LABEL_8"
  | "ENUM_LABEL_9"
  | "ENUM_LABEL_10"
  | "ENUM_LABEL_11"
  | "ENUM_LABEL_12"
  | "ENUM_LABEL_13"
  | "ENUM_LABEL_14"
  | "ENUM_LABEL_15"
  | "ENUM_LABEL_16"
  | "ENUM_LABEL_17"
  | "ENUM_LABEL_18"
  | "ENUM_LABEL_19"
  | "ENUM_LABEL_20"
  | "ENUM_LABEL_21"
  | "ENUM_LABEL_22"
  | "ENUM_LABEL_23"
  | "ENUM_LABEL_24"
  | "ENUM_LABEL_25"
  | "ENUM_LABEL_26"
  | "ENUM_LABEL_27"
  | "ENUM_LABEL_28"
  | "ENUM_LABEL_29"
  | "ENUM_LABEL_30"
  | "ENUM_LABEL_31"
  | "ENUM_LABEL_32"
  | "ENUM_LABEL_33"
  | "ENUM_LABEL_34"
  | "ENUM_LABEL_35"
  | "ENUM_LABEL_36"
  | "ENUM_LABEL_37"
  | "ENUM_LABEL_38"
  | "ENUM_LABEL_39"
  | "ENUM_LABEL_40"
  | "ENUM_LABEL_41"
  | "ENUM_LABEL_42"
  | "ENUM_LABEL_43"
  | "ENUM_LABEL_44"
  | "ENUM_LABEL_45"
  | "ENUM_LABEL_46"
  | "ENUM_LABEL_47"
  | "ENUM_LABEL_48"
  | "ENUM_LABEL_49"
  | "ENUM_LABEL_50"
  | "ENUM_LABEL_51"
  | "ENUM_LABEL_52"
  | "ENUM_LABEL_53"
  | "ENUM_LABEL_54"
  | "ENUM_LABEL_55"
  | "ENUM_LABEL_56"
  | "ENUM_LABEL_57"
  | "ENUM_LABEL_58"
  | "ENUM_LABEL_59"
  | "ENUM_LABEL_60"
  | "ENUM_LABEL_61"
  | "ENUM_LABEL_62"
  | "ENUM_LABEL_63"
  | "ENUM_LABEL_64"
  | "ENUM_LABEL_65"
  | "ENUM_LABEL_66"
  | "ENUM_LABEL_67"
  | "ENUM_LABEL_68"
  | "ENUM_LABEL_69"
  | "ENUM_LABEL_70"
  | "ENUM_LABEL_71"
  | "ENUM_LABEL_72"
  | "ENUM_LABEL_73"
  | "ENUM_LABEL_74"
  | "ENUM_LABEL_75"
  | "ENUM_LABEL_76"
  | "ENUM_LABEL_77"
  | "ENUM_LABEL_78"
  | "ENUM_LABEL_79"
  | "ENUM_LABEL_80"
  | "ENUM_LABEL_81"
  | "ENUM_LABEL_82"
  | "ENUM_LABEL_83"
  | "ENUM_LABEL_84"
  | "ENUM_LABEL_85"
  | "ENUM_LABEL_86"
  | "ENUM_LABEL_87"
  | "ENUM_LABEL_88"
  | "ENUM_LABEL_89"
  | "ENUM_LABEL_90"
  | "ENUM_LABEL_91"
  | "ENUM_LABEL_92"
  | "ENUM_LABEL_93"
  | "ENUM_LABEL_94"
  | "ENUM_LABEL_95"
  | "ENUM_LABEL_96"
  | "ENUM_LABEL_97"
  | "ENUM_LABEL_98"
  | "ENUM_LABEL_99"
  | "ENUM_LABEL_100";

/**
 * This proto includes every type of field in both singular and repeated
 * forms.
 */
export interface TestAllTypes {
  /**
   * Singular
   */
  optionalInt32: number;
  optionalInt64: bigint;
  optionalUint32: number;
  optionalUint64: bigint;
  optionalSint32: number;
  optionalSint64: bigint;
  optionalFixed32: number;
  optionalFixed64: bigint;
  optionalSfixed32: number;
  optionalSfixed64: bigint;
  optionalFloat: number;
  optionalDouble: number;
  optionalBool: boolean;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalNestedMessage: TestAllTypes.NestedMessage;
  optionalForeignMessage: ForeignMessage;
  optionalImportMessage: googleProtobufUnittest_import.ImportMessage;
  optionalNestedEnum: TestAllTypes.NestedEnum;
  optionalForeignEnum: ForeignEnum;
  optionalImportEnum: googleProtobufUnittest_import.ImportEnum;
  optionalStringPiece: string;
  optionalCord: string;
  optionalPublicImportMessage: googleProtobufUnittest_import_public.PublicImportMessage;
  /**
   * Defined in unittest_import_public.proto
   */
  optionalLazyMessage: TestAllTypes.NestedMessage;
  repeatedInt32: number[];
  /**
   * Repeated
   */
  repeatedInt64: bigint[];
  repeatedUint32: number[];
  repeatedUint64: bigint[];
  repeatedSint32: number[];
  repeatedSint64: bigint[];
  repeatedFixed32: number[];
  repeatedFixed64: bigint[];
  repeatedSfixed32: number[];
  repeatedSfixed64: bigint[];
  repeatedFloat: number[];
  repeatedDouble: number[];
  repeatedBool: boolean[];
  repeatedString: string[];
  repeatedBytes: Uint8Array[];
  repeatedNestedMessage: TestAllTypes.NestedMessage[];
  repeatedForeignMessage: ForeignMessage[];
  repeatedImportMessage: googleProtobufUnittest_import.ImportMessage[];
  repeatedNestedEnum: TestAllTypes.NestedEnum[];
  repeatedForeignEnum: ForeignEnum[];
  repeatedImportEnum: googleProtobufUnittest_import.ImportEnum[];
  repeatedStringPiece: string[];
  repeatedCord: string[];
  repeatedLazyMessage: TestAllTypes.NestedMessage[];
  defaultInt32: number;
  defaultInt64: bigint;
  /**
   * Singular with defaults
   */
  defaultUint32: number;
  defaultUint64: bigint;
  defaultSint32: number;
  defaultSint64: bigint;
  defaultFixed32: number;
  defaultFixed64: bigint;
  defaultSfixed32: number;
  defaultSfixed64: bigint;
  defaultFloat: number;
  defaultDouble: number;
  defaultBool: boolean;
  defaultString: string;
  defaultBytes: Uint8Array;
  defaultNestedEnum: TestAllTypes.NestedEnum;
  defaultForeignEnum: ForeignEnum;
  defaultImportEnum: googleProtobufUnittest_import.ImportEnum;
  defaultStringPiece: string;
  defaultCord: string;
  oneofUint32?: number | null | undefined;
  oneofNestedMessage?: TestAllTypes.NestedMessage | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestAllTypes {
  export type NestedEnum = "FOO" | "BAR" | "BAZ" | "NEG";

  export interface NestedMessage {
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }

  export interface OptionalGroup {
    a: number;
  }

  export interface RepeatedGroup {
    a: number;
  }
}

/**
 * This proto includes a recursively nested message.
 */
export interface NestedTestAllTypes {
  child: NestedTestAllTypes | null | undefined;
  payload: TestAllTypes;
  repeatedChild: NestedTestAllTypes[];
}

export interface TestDeprecatedFields {
  deprecatedInt32: number;
  deprecatedInt32InOneof?: number | null | undefined;
}

export interface TestDeprecatedMessage {}

/**
 * Define these after TestAllTypes to make sure the compiler can handle
 * that.
 */
export interface ForeignMessage {
  c: number;
  d: number;
}

export interface TestReservedFields {}

export interface TestAllExtensions {}

export interface OptionalGroup_extension {
  a: number;
}

export interface RepeatedGroup_extension {
  a: number;
}

export interface TestGroup {
  optionalForeignEnum: ForeignEnum;
}

export declare namespace TestGroup {
  export interface OptionalGroup {
    a: number;
  }
}

export interface TestGroupExtension {}

export interface TestNestedExtension {}

export declare namespace TestNestedExtension {
  export interface OptionalGroup_extension {
    a: number;
  }
}

export interface TestChildExtension {
  a: string;
  b: string;
  optionalExtension: TestAllExtensions;
}

/**
 * We have separate messages for testing required fields because it's
 * annoying to have to fill in required fields in TestProto in order to
 * do anything with it.  Note that we don't need to test every type of
 * required filed because the code output is basically identical to
 * optional fields for all types.
 */
export interface TestRequired {
  a: number;
  dummy2: number;
  b: number;
  /**
   * Pad the field count to 32 so that we can test that IsInitialized()
   * properly checks multiple elements of has_bits_.
   */
  dummy4: number;
  dummy5: number;
  dummy6: number;
  dummy7: number;
  dummy8: number;
  dummy9: number;
  dummy10: number;
  dummy11: number;
  dummy12: number;
  dummy13: number;
  dummy14: number;
  dummy15: number;
  dummy16: number;
  dummy17: number;
  dummy18: number;
  dummy19: number;
  dummy20: number;
  dummy21: number;
  dummy22: number;
  dummy23: number;
  dummy24: number;
  dummy25: number;
  dummy26: number;
  dummy27: number;
  dummy28: number;
  dummy29: number;
  dummy30: number;
  dummy31: number;
  dummy32: number;
  c: number;
}

export interface TestRequiredForeign {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  dummy: number;
}

export interface TestRequiredMessage {
  optionalMessage: TestRequired;
  repeatedMessage: TestRequired[];
  requiredMessage: TestRequired;
}

/**
 * Test that we can use NestedMessage from outside TestAllTypes.
 */
export interface TestForeignNested {
  foreignNested: TestAllTypes.NestedMessage;
}

/**
 * TestEmptyMessage is used to test unknown field support.
 */
export interface TestEmptyMessage {}

/**
 * Like above, but declare all field numbers as potential extensions.  No
 * actual extensions should ever be defined for this type.
 */
export interface TestEmptyMessageWithExtensions {}

/**
 * Needed for a Python test.
 */
export interface TestPickleNestedMessage {}

export declare namespace TestPickleNestedMessage {
  export interface NestedMessage {
    bb: number;
  }

  namespace NestedMessage {
    export interface NestedNestedMessage {
      cc: number;
    }
  }
}

export interface TestMultipleExtensionRanges {}

/**
 * Test that really large tag numbers don't break anything.
 */
export interface TestReallyLargeTagNumber {
  /**
   * The largest possible tag number is 2^28 - 1, since the wire format uses
   * three bits to communicate wire type.
   */
  a: number;
  bb: number;
}

export interface TestRecursiveMessage {
  a: TestRecursiveMessage | null | undefined;
  i: number;
}

/**
 * Test that mutual recursion works.
 */
export interface TestMutualRecursionA {
  bb: TestMutualRecursionB;
}

export declare namespace TestMutualRecursionA {
  export interface SubMessage {
    b: TestMutualRecursionB;
  }

  export interface SubGroup {
    subMessage: TestMutualRecursionA.SubMessage;
    notInThisScc: TestAllTypes;
  }
}

export interface TestMutualRecursionB {
  a: TestMutualRecursionA;
  optionalInt32: number;
}

export interface TestIsInitialized {
  subMessage: TestIsInitialized.SubMessage;
}

export declare namespace TestIsInitialized {
  export interface SubMessage {}

  namespace SubMessage {
    export interface SubGroup {
      i: number;
    }
  }
}

/**
 * Test that groups have disjoint field numbers from their siblings and
 * parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
 * to compile with proto1, this will emit an error; so we only include it
 * in protobuf_unittest_proto.
 */
export interface TestDupFieldNumber {
  a: number;
}

export declare namespace TestDupFieldNumber {
  export interface Foo {
    a: number;
  }

  export interface Bar {
    a: number;
  }
}

/**
 * Additional messages for testing lazy fields.
 */
export interface TestEagerMessage {
  subMessage: TestAllTypes;
}

export interface TestLazyMessage {
  subMessage: TestAllTypes;
}

/**
 * Needed for a Python test.
 */
export interface TestNestedMessageHasBits {
  optionalNestedMessage: TestNestedMessageHasBits.NestedMessage;
}

export declare namespace TestNestedMessageHasBits {
  export interface NestedMessage {
    nestedmessageRepeatedInt32: number[];
    nestedmessageRepeatedForeignmessage: ForeignMessage[];
  }
}

/**
 * Test message with CamelCase field names.  This violates Protocol Buffer
 * standard style.
 */
export interface TestCamelCaseFieldNames {
  PrimitiveField: number;
  StringField: string;
  EnumField: ForeignEnum;
  MessageField: ForeignMessage;
  StringPieceField: string;
  CordField: string;
  RepeatedPrimitiveField: number[];
  RepeatedStringField: string[];
  RepeatedEnumField: ForeignEnum[];
  RepeatedMessageField: ForeignMessage[];
  RepeatedStringPieceField: string[];
  RepeatedCordField: string[];
}

/**
 * We list fields out of order, to ensure that we're using field number and not
 * field index to determine serialization order.
 */
export interface TestFieldOrderings {
  myString: string;
  myInt: bigint;
  myFloat: number;
  optionalNestedMessage: TestFieldOrderings.NestedMessage;
}

export declare namespace TestFieldOrderings {
  export interface NestedMessage {
    oo: bigint;
    /**
     * The field name "b" fails to compile in proto1 because it conflicts with
     * a local variable named "b" in one of the generated methods.  Doh.
     * This file needs to compile in proto1 to test backwards-compatibility.
     */
    bb: number;
  }
}

export interface TestExtensionOrderings1 {
  myString: string;
}

export interface TestExtensionOrderings2 {
  myString: string;
}

export declare namespace TestExtensionOrderings2 {
  export interface TestExtensionOrderings3 {
    myString: string;
  }
}

export interface TestExtremeDefaultValues {
  escapedBytes: Uint8Array;
  largeUint32: number;
  largeUint64: bigint;
  smallInt32: number;
  smallInt64: bigint;
  reallySmallInt32: number;
  reallySmallInt64: bigint;
  /**
   * The default value here is UTF-8 for "\\u1234".  (We could also just type
   * the UTF-8 text directly into this text file rather than escape it, but
   * lots of people use editors that would be confused by this.)
   */
  utf8String: string;
  /**
   * Tests for single-precision floating-point values.
   */
  zeroFloat: number;
  oneFloat: number;
  smallFloat: number;
  negativeOneFloat: number;
  negativeFloat: number;
  /**
   * Using exponents
   */
  largeFloat: number;
  smallNegativeFloat: number;
  /**
   * Text for nonfinite floating-point values.
   */
  infDouble: number;
  negInfDouble: number;
  nanDouble: number;
  infFloat: number;
  negInfFloat: number;
  nanFloat: number;
  /**
   * Tests for C++ trigraphs.
   * Trigraphs should be escaped in C++ generated files, but they should not be
   * escaped for other languages.
   * Note that in .proto file, "\\?" is a valid way to escape ? in string
   * literals.
   */
  cppTrigraph: string;
  /**
   * String defaults containing the character '\\000'
   */
  stringWithZero: string;
  bytesWithZero: Uint8Array;
  stringPieceWithZero: string;
  cordWithZero: string;
  replacementString: string;
}

export interface SparseEnumMessage {
  sparseEnum: TestSparseEnum;
}

/**
 * Test String and Bytes: string is for valid UTF-8 strings
 */
export interface OneString {
  data: string;
}

export interface MoreString {
  data: string[];
}

export interface OneBytes {
  data: Uint8Array;
}

export interface MoreBytes {
  data: Uint8Array[];
}

/**
 * Test int32, uint32, int64, uint64, and bool are all compatible
 */
export interface Int32Message {
  data: number;
}

export interface Uint32Message {
  data: number;
}

export interface Int64Message {
  data: bigint;
}

export interface Uint64Message {
  data: bigint;
}

export interface BoolMessage {
  data: boolean;
}

/**
 * Test oneofs.
 */
export interface TestOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestAllTypes | null | undefined;
}

export declare namespace TestOneof {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneofBackwardsCompatible {
  fooInt: number;
  fooString: string;
  fooMessage: TestAllTypes;
}

export declare namespace TestOneofBackwardsCompatible {
  export interface FooGroup {
    a: number;
    b: string;
  }
}

export interface TestOneof2 {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooCord?: string | null | undefined;
  fooStringPiece?: string | null | undefined;
  fooBytes?: Uint8Array | null | undefined;
  fooEnum?: TestOneof2.NestedEnum | null | undefined;
  fooMessage?: TestOneof2.NestedMessage | null | undefined;
  fooLazyMessage?: TestOneof2.NestedMessage | null | undefined;
  barInt?: number | null | undefined;
  barString?: string | null | undefined;
  barCord?: string | null | undefined;
  barStringPiece?: string | null | undefined;
  barBytes?: Uint8Array | null | undefined;
  barEnum?: TestOneof2.NestedEnum | null | undefined;
  barStringWithEmptyDefault?: string | null | undefined;
  barCordWithEmptyDefault?: string | null | undefined;
  barStringPieceWithEmptyDefault?: string | null | undefined;
  barBytesWithEmptyDefault?: Uint8Array | null | undefined;
  bazInt: number;
  bazString: string;
}

export declare namespace TestOneof2 {
  export type NestedEnum = "FOO" | "BAR" | "BAZ";

  export interface FooGroup {
    a: number;
    b: string;
  }

  export interface NestedMessage {
    quxInt: bigint;
    corgeInt: number[];
  }
}

export interface TestRequiredOneof {
  fooInt?: number | null | undefined;
  fooString?: string | null | undefined;
  fooMessage?: TestRequiredOneof.NestedMessage | null | undefined;
}

export declare namespace TestRequiredOneof {
  export interface NestedMessage {
    requiredDouble: number;
  }
}

export interface TestPackedTypes {
  packedInt32: number[];
  packedInt64: bigint[];
  packedUint32: number[];
  packedUint64: bigint[];
  packedSint32: number[];
  packedSint64: bigint[];
  packedFixed32: number[];
  packedFixed64: bigint[];
  packedSfixed32: number[];
  packedSfixed64: bigint[];
  packedFloat: number[];
  packedDouble: number[];
  packedBool: boolean[];
  packedEnum: ForeignEnum[];
}

/**
 * A message with the same fields as TestPackedTypes, but without packing. Used
 * to test packed <-> unpacked wire compatibility.
 */
export interface TestUnpackedTypes {
  unpackedInt32: number[];
  unpackedInt64: bigint[];
  unpackedUint32: number[];
  unpackedUint64: bigint[];
  unpackedSint32: number[];
  unpackedSint64: bigint[];
  unpackedFixed32: number[];
  unpackedFixed64: bigint[];
  unpackedSfixed32: number[];
  unpackedSfixed64: bigint[];
  unpackedFloat: number[];
  unpackedDouble: number[];
  unpackedBool: boolean[];
  unpackedEnum: ForeignEnum[];
}

export interface TestPackedExtensions {}

export interface TestUnpackedExtensions {}

/**
 * Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
 * a set of extensions to TestAllExtensions dynamically, based on the fields
 * of this message type.
 */
export interface TestDynamicExtensions {
  scalarExtension: number;
  enumExtension: ForeignEnum;
  dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType;
  messageExtension: ForeignMessage;
  dynamicMessageExtension: TestDynamicExtensions.DynamicMessageType;
  repeatedExtension: string[];
  packedExtension: number[];
}

export declare namespace TestDynamicExtensions {
  export type DynamicEnumType = "DYNAMIC_FOO" | "DYNAMIC_BAR" | "DYNAMIC_BAZ";

  export interface DynamicMessageType {
    dynamicField: number;
  }
}

export interface TestRepeatedScalarDifferentTagSizes {
  /**
   * Parsing repeated fixed size values used to fail. This message needs to be
   * used in order to get a tag of the right size; all of the repeated fields
   * in TestAllTypes didn't trigger the check.
   */
  repeatedFixed32: number[];
  /**
   * Check for a varint type, just for good measure.
   */
  repeatedInt32: number[];
  /**
   * These have two-byte tags.
   */
  repeatedFixed64: bigint[];
  repeatedInt64: bigint[];
  /**
   * Three byte tags.
   */
  repeatedFloat: number[];
  repeatedUint64: bigint[];
}

/**
 * Test that if an optional or required message/group field appears multiple
 * times in the input, they need to be merged.
 */
export interface TestParsingMerge {
  requiredAllTypes: TestAllTypes;
  optionalAllTypes: TestAllTypes;
  repeatedAllTypes: TestAllTypes[];
}

export declare namespace TestParsingMerge {
  /**
   * RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
   * except that all fields are repeated. In the tests, we will serialize the
   * RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
   * Repeated fields in RepeatedFieldsGenerator are expected to be merged into
   * the corresponding required/optional fields in TestParsingMerge.
   */
  export interface RepeatedFieldsGenerator {
    field1: TestAllTypes[];
    field2: TestAllTypes[];
    field3: TestAllTypes[];
    ext1: TestAllTypes[];
    ext2: TestAllTypes[];
  }

  namespace RepeatedFieldsGenerator {
    export interface Group1 {
      field1: TestAllTypes;
    }

    export interface Group2 {
      field1: TestAllTypes;
    }
  }

  export interface OptionalGroup {
    optionalGroupAllTypes: TestAllTypes;
  }

  export interface RepeatedGroup {
    repeatedGroupAllTypes: TestAllTypes;
  }
}

export interface TestCommentInjectionMessage {
  /**
   * *\\/ <- This should not close the generated doc comment
   */
  a: string;
}

/**
 * Test that RPC services work.
 */
export interface FooRequest {}

export interface FooResponse {}

export interface FooClientMessage {}

export interface FooServerMessage {}

export interface BarRequest {}

export interface BarResponse {}

export interface TestJsonName {
  fieldName1: number;
  fieldName2: number;
  FieldName3: number;
  fieldName4: number;
  FIELDNAME5: number;
  fieldName6: number;
  fieldname7: number;
}

export interface TestHugeFieldNumbers {
  optionalInt32: number;
  fixed32: number;
  repeatedInt32: number[];
  packedInt32: number[];
  optionalEnum: ForeignEnum;
  optionalString: string;
  optionalBytes: Uint8Array;
  optionalMessage: ForeignMessage;
  stringStringMap: Record<
    string,
    TestHugeFieldNumbers.StringStringMap["value"] | undefined
  >;
  oneofUint32?: number | null | undefined;
  oneofTestAllTypes?: TestAllTypes | null | undefined;
  oneofString?: string | null | undefined;
  oneofBytes?: Uint8Array | null | undefined;
}

export declare namespace TestHugeFieldNumbers {
  export interface OptionalGroup {
    groupA: number;
  }

  interface StringStringMap {
    key: string;
    value: string;
  }
}

export interface TestExtensionInsideTable {
  field1: number;
  field2: number;
  field3: number;
  field4: number;
  field6: number;
  field7: number;
  field8: number;
  field9: number;
  field10: number;
}

export interface TestExtensionRangeSerialize {
  fooOne: number;
  fooTwo: number;
  fooThree: number;
  fooFour: number;
}

//========================================//
//      TestService Protobuf Client       //
//========================================//

export async function Foo(
  fooRequest: FooRequest,
  config?: ClientConfiguration,
): Promise<FooResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequest.encode(fooRequest),
    config,
  );
  return FooResponse.decode(response);
}

export async function Bar(
  barRequest: BarRequest,
  config?: ClientConfiguration,
): Promise<BarResponse> {
  const response = await PBrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequest.encode(barRequest),
    config,
  );
  return BarResponse.decode(response);
}

//========================================//
//        TestService JSON Client         //
//========================================//

export async function FooJSON(
  fooRequest: FooRequest,
  config?: ClientConfiguration,
): Promise<FooResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Foo",
    FooRequestJSON.encode(fooRequest),
    config,
  );
  return FooResponseJSON.decode(response);
}

export async function BarJSON(
  barRequest: BarRequest,
  config?: ClientConfiguration,
): Promise<BarResponse> {
  const response = await JSONrequest(
    "/protobuf_unittest.TestService/Bar",
    BarRequestJSON.encode(barRequest),
    config,
  );
  return BarResponseJSON.decode(response);
}

//========================================//
//              TestService               //
//========================================//

export interface TestService<Context = unknown> {
  Foo: (
    fooRequest: FooRequest,
    context: Context,
  ) => Promise<FooResponse> | FooResponse;
  Bar: (
    barRequest: BarRequest,
    context: Context,
  ) => Promise<BarResponse> | BarResponse;
}

export function createTestService<Context>(service: TestService<Context>) {
  return {
    name: "protobuf_unittest.TestService",
    methods: {
      Foo: {
        name: "Foo",
        handler: service.Foo,
        input: { protobuf: FooRequest, json: FooRequestJSON },
        output: { protobuf: FooResponse, json: FooResponseJSON },
      },
      Bar: {
        name: "Bar",
        handler: service.Bar,
        input: { protobuf: BarRequest, json: BarRequestJSON },
        output: { protobuf: BarResponse, json: BarResponseJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const ForeignEnum = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValue = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnum = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnum = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypes = {
  /**
   * Serializes TestAllTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestAllTypes>): Uint8Array {
    return TestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestAllTypes {
    return TestAllTypes._readMessage(
      TestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypes.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessage.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessage.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessage.initialize(),
      optionalLazyMessage: TestAllTypes.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(1, msg.optionalInt32);
    }
    if (msg.optionalInt64) {
      writer.writeInt64String(2, msg.optionalInt64.toString() as any);
    }
    if (msg.optionalUint32) {
      writer.writeUint32(3, msg.optionalUint32);
    }
    if (msg.optionalUint64) {
      writer.writeUint64String(4, msg.optionalUint64.toString() as any);
    }
    if (msg.optionalSint32) {
      writer.writeSint32(5, msg.optionalSint32);
    }
    if (msg.optionalSint64) {
      writer.writeSint64String(6, msg.optionalSint64.toString() as any);
    }
    if (msg.optionalFixed32) {
      writer.writeFixed32(7, msg.optionalFixed32);
    }
    if (msg.optionalFixed64) {
      writer.writeFixed64String(8, msg.optionalFixed64.toString() as any);
    }
    if (msg.optionalSfixed32) {
      writer.writeSfixed32(9, msg.optionalSfixed32);
    }
    if (msg.optionalSfixed64) {
      writer.writeSfixed64String(10, msg.optionalSfixed64.toString() as any);
    }
    if (msg.optionalFloat) {
      writer.writeFloat(11, msg.optionalFloat);
    }
    if (msg.optionalDouble) {
      writer.writeDouble(12, msg.optionalDouble);
    }
    if (msg.optionalBool) {
      writer.writeBool(13, msg.optionalBool);
    }
    if (msg.optionalString) {
      writer.writeString(14, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(15, msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        18,
        msg.optionalNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.optionalForeignMessage) {
      writer.writeMessage(
        19,
        msg.optionalForeignMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.optionalImportMessage) {
      writer.writeMessage(
        20,
        msg.optionalImportMessage,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      writer.writeEnum(
        21,
        TestAllTypes.NestedEnum._toInt(msg.optionalNestedEnum),
      );
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum)
    ) {
      writer.writeEnum(
        23,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.optionalImportEnum),
      );
    }
    if (msg.optionalStringPiece) {
      writer.writeString(24, msg.optionalStringPiece);
    }
    if (msg.optionalCord) {
      writer.writeString(25, msg.optionalCord);
    }
    if (msg.optionalPublicImportMessage) {
      writer.writeMessage(
        26,
        msg.optionalPublicImportMessage,
        googleProtobufUnittest_import_public.PublicImportMessage._writeMessage,
      );
    }
    if (msg.optionalLazyMessage) {
      writer.writeMessage(
        27,
        msg.optionalLazyMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(31, msg.repeatedInt32);
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        32,
        msg.repeatedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedUint32?.length) {
      writer.writePackedUint32(33, msg.repeatedUint32);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        34,
        msg.repeatedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSint32?.length) {
      writer.writePackedSint32(35, msg.repeatedSint32);
    }
    if (msg.repeatedSint64?.length) {
      writer.writePackedSint64String(
        36,
        msg.repeatedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(37, msg.repeatedFixed32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        38,
        msg.repeatedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedSfixed32?.length) {
      writer.writePackedSfixed32(39, msg.repeatedSfixed32);
    }
    if (msg.repeatedSfixed64?.length) {
      writer.writePackedSfixed64String(
        40,
        msg.repeatedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(41, msg.repeatedFloat);
    }
    if (msg.repeatedDouble?.length) {
      writer.writePackedDouble(42, msg.repeatedDouble);
    }
    if (msg.repeatedBool?.length) {
      writer.writePackedBool(43, msg.repeatedBool);
    }
    if (msg.repeatedString?.length) {
      writer.writeRepeatedString(44, msg.repeatedString);
    }
    if (msg.repeatedBytes?.length) {
      writer.writeRepeatedBytes(45, msg.repeatedBytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      writer.writeRepeatedMessage(
        48,
        msg.repeatedNestedMessage as any,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      writer.writeRepeatedMessage(
        49,
        msg.repeatedForeignMessage as any,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      writer.writeRepeatedMessage(
        50,
        msg.repeatedImportMessage as any,
        googleProtobufUnittest_import.ImportMessage._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      writer.writePackedEnum(
        51,
        msg.repeatedNestedEnum.map(TestAllTypes.NestedEnum._toInt),
      );
    }
    if (msg.repeatedForeignEnum?.length) {
      writer.writePackedEnum(
        52,
        msg.repeatedForeignEnum.map(ForeignEnum._toInt),
      );
    }
    if (msg.repeatedImportEnum?.length) {
      writer.writePackedEnum(
        53,
        msg.repeatedImportEnum.map(
          googleProtobufUnittest_import.ImportEnum._toInt,
        ),
      );
    }
    if (msg.repeatedStringPiece?.length) {
      writer.writeRepeatedString(54, msg.repeatedStringPiece);
    }
    if (msg.repeatedCord?.length) {
      writer.writeRepeatedString(55, msg.repeatedCord);
    }
    if (msg.repeatedLazyMessage?.length) {
      writer.writeRepeatedMessage(
        57,
        msg.repeatedLazyMessage as any,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.defaultInt32) {
      writer.writeInt32(61, msg.defaultInt32);
    }
    if (msg.defaultInt64) {
      writer.writeInt64String(62, msg.defaultInt64.toString() as any);
    }
    if (msg.defaultUint32) {
      writer.writeUint32(63, msg.defaultUint32);
    }
    if (msg.defaultUint64) {
      writer.writeUint64String(64, msg.defaultUint64.toString() as any);
    }
    if (msg.defaultSint32) {
      writer.writeSint32(65, msg.defaultSint32);
    }
    if (msg.defaultSint64) {
      writer.writeSint64String(66, msg.defaultSint64.toString() as any);
    }
    if (msg.defaultFixed32) {
      writer.writeFixed32(67, msg.defaultFixed32);
    }
    if (msg.defaultFixed64) {
      writer.writeFixed64String(68, msg.defaultFixed64.toString() as any);
    }
    if (msg.defaultSfixed32) {
      writer.writeSfixed32(69, msg.defaultSfixed32);
    }
    if (msg.defaultSfixed64) {
      writer.writeSfixed64String(70, msg.defaultSfixed64.toString() as any);
    }
    if (msg.defaultFloat) {
      writer.writeFloat(71, msg.defaultFloat);
    }
    if (msg.defaultDouble) {
      writer.writeDouble(72, msg.defaultDouble);
    }
    if (msg.defaultBool) {
      writer.writeBool(73, msg.defaultBool);
    }
    if (msg.defaultString) {
      writer.writeString(74, msg.defaultString);
    }
    if (msg.defaultBytes?.length) {
      writer.writeBytes(75, msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      writer.writeEnum(
        81,
        TestAllTypes.NestedEnum._toInt(msg.defaultNestedEnum),
      );
    }
    if (msg.defaultForeignEnum && ForeignEnum._toInt(msg.defaultForeignEnum)) {
      writer.writeEnum(82, ForeignEnum._toInt(msg.defaultForeignEnum));
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum)
    ) {
      writer.writeEnum(
        83,
        googleProtobufUnittest_import.ImportEnum._toInt(msg.defaultImportEnum),
      );
    }
    if (msg.defaultStringPiece) {
      writer.writeString(84, msg.defaultStringPiece);
    }
    if (msg.defaultCord) {
      writer.writeString(85, msg.defaultCord);
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(111, msg.oneofUint32);
    }
    if (msg.oneofNestedMessage != undefined) {
      writer.writeMessage(
        112,
        msg.oneofNestedMessage,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(113, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(114, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllTypes,
    reader: BinaryReader,
  ): TestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.optionalInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.optionalUint32 = reader.readUint32();
          break;
        }
        case 4: {
          msg.optionalUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 5: {
          msg.optionalSint32 = reader.readSint32();
          break;
        }
        case 6: {
          msg.optionalSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 7: {
          msg.optionalFixed32 = reader.readFixed32();
          break;
        }
        case 8: {
          msg.optionalFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 9: {
          msg.optionalSfixed32 = reader.readSfixed32();
          break;
        }
        case 10: {
          msg.optionalSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 11: {
          msg.optionalFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.optionalDouble = reader.readDouble();
          break;
        }
        case 13: {
          msg.optionalBool = reader.readBool();
          break;
        }
        case 14: {
          msg.optionalString = reader.readString();
          break;
        }
        case 15: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 18: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 19: {
          reader.readMessage(
            msg.optionalForeignMessage,
            ForeignMessage._readMessage,
          );
          break;
        }
        case 20: {
          reader.readMessage(
            msg.optionalImportMessage,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          break;
        }
        case 21: {
          msg.optionalNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 23: {
          msg.optionalImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum(),
            );
          break;
        }
        case 24: {
          msg.optionalStringPiece = reader.readString();
          break;
        }
        case 25: {
          msg.optionalCord = reader.readString();
          break;
        }
        case 26: {
          reader.readMessage(
            msg.optionalPublicImportMessage,
            googleProtobufUnittest_import_public.PublicImportMessage
              ._readMessage,
          );
          break;
        }
        case 27: {
          reader.readMessage(
            msg.optionalLazyMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 31: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 32: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 33: {
          if (reader.isDelimited()) {
            msg.repeatedUint32.push(...reader.readPackedUint32());
          } else {
            msg.repeatedUint32.push(reader.readUint32());
          }
          break;
        }
        case 34: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 35: {
          if (reader.isDelimited()) {
            msg.repeatedSint32.push(...reader.readPackedSint32());
          } else {
            msg.repeatedSint32.push(reader.readSint32());
          }
          break;
        }
        case 36: {
          if (reader.isDelimited()) {
            msg.repeatedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.repeatedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 37: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 38: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 39: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.repeatedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 40: {
          if (reader.isDelimited()) {
            msg.repeatedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.repeatedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 41: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 42: {
          if (reader.isDelimited()) {
            msg.repeatedDouble.push(...reader.readPackedDouble());
          } else {
            msg.repeatedDouble.push(reader.readDouble());
          }
          break;
        }
        case 43: {
          if (reader.isDelimited()) {
            msg.repeatedBool.push(...reader.readPackedBool());
          } else {
            msg.repeatedBool.push(reader.readBool());
          }
          break;
        }
        case 44: {
          msg.repeatedString.push(reader.readString());
          break;
        }
        case 45: {
          msg.repeatedBytes.push(reader.readBytes());
          break;
        }
        case 48: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedNestedMessage.push(m);
          break;
        }
        case 49: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.repeatedForeignMessage.push(m);
          break;
        }
        case 50: {
          const m = googleProtobufUnittest_import.ImportMessage.initialize();
          reader.readMessage(
            m,
            googleProtobufUnittest_import.ImportMessage._readMessage,
          );
          msg.repeatedImportMessage.push(m);
          break;
        }
        case 51: {
          if (reader.isDelimited()) {
            msg.repeatedNestedEnum.push(
              ...reader.readPackedEnum().map(TestAllTypes.NestedEnum._fromInt),
            );
          } else {
            msg.repeatedNestedEnum.push(
              TestAllTypes.NestedEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 52: {
          if (reader.isDelimited()) {
            msg.repeatedForeignEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.repeatedForeignEnum.push(
              ForeignEnum._fromInt(reader.readEnum()),
            );
          }
          break;
        }
        case 53: {
          if (reader.isDelimited()) {
            msg.repeatedImportEnum.push(
              ...reader
                .readPackedEnum()
                .map(googleProtobufUnittest_import.ImportEnum._fromInt),
            );
          } else {
            msg.repeatedImportEnum.push(
              googleProtobufUnittest_import.ImportEnum._fromInt(
                reader.readEnum(),
              ),
            );
          }
          break;
        }
        case 54: {
          msg.repeatedStringPiece.push(reader.readString());
          break;
        }
        case 55: {
          msg.repeatedCord.push(reader.readString());
          break;
        }
        case 57: {
          const m = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(m, TestAllTypes.NestedMessage._readMessage);
          msg.repeatedLazyMessage.push(m);
          break;
        }
        case 61: {
          msg.defaultInt32 = reader.readInt32();
          break;
        }
        case 62: {
          msg.defaultInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 63: {
          msg.defaultUint32 = reader.readUint32();
          break;
        }
        case 64: {
          msg.defaultUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 65: {
          msg.defaultSint32 = reader.readSint32();
          break;
        }
        case 66: {
          msg.defaultSint64 = BigInt(reader.readSint64String());
          break;
        }
        case 67: {
          msg.defaultFixed32 = reader.readFixed32();
          break;
        }
        case 68: {
          msg.defaultFixed64 = BigInt(reader.readFixed64String());
          break;
        }
        case 69: {
          msg.defaultSfixed32 = reader.readSfixed32();
          break;
        }
        case 70: {
          msg.defaultSfixed64 = BigInt(reader.readSfixed64String());
          break;
        }
        case 71: {
          msg.defaultFloat = reader.readFloat();
          break;
        }
        case 72: {
          msg.defaultDouble = reader.readDouble();
          break;
        }
        case 73: {
          msg.defaultBool = reader.readBool();
          break;
        }
        case 74: {
          msg.defaultString = reader.readString();
          break;
        }
        case 75: {
          msg.defaultBytes = reader.readBytes();
          break;
        }
        case 81: {
          msg.defaultNestedEnum = TestAllTypes.NestedEnum._fromInt(
            reader.readEnum(),
          );
          break;
        }
        case 82: {
          msg.defaultForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 83: {
          msg.defaultImportEnum =
            googleProtobufUnittest_import.ImportEnum._fromInt(
              reader.readEnum(),
            );
          break;
        }
        case 84: {
          msg.defaultStringPiece = reader.readString();
          break;
        }
        case 85: {
          msg.defaultCord = reader.readString();
          break;
        }
        case 111: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 112: {
          msg.oneofNestedMessage = TestAllTypes.NestedMessage.initialize();
          reader.readMessage(
            msg.oneofNestedMessage,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        case 113: {
          msg.oneofString = reader.readString();
          break;
        }
        case 114: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
    ): Uint8Array {
      return TestAllTypes.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.NestedMessage {
      return TestAllTypes.NestedMessage._readMessage(
        TestAllTypes.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      reader: BinaryReader,
    ): TestAllTypes.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypes.OptionalGroup>,
    ): Uint8Array {
      return TestAllTypes.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.OptionalGroup {
      return TestAllTypes.OptionalGroup._readMessage(
        TestAllTypes.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.OptionalGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      reader: BinaryReader,
    ): TestAllTypes.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestAllTypes.RepeatedGroup>,
    ): Uint8Array {
      return TestAllTypes.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestAllTypes.RepeatedGroup {
      return TestAllTypes.RepeatedGroup._readMessage(
        TestAllTypes.RepeatedGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.RepeatedGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(47, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      reader: BinaryReader,
    ): TestAllTypes.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 47: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const NestedTestAllTypes = {
  /**
   * Serializes NestedTestAllTypes to protobuf.
   */
  encode: function (msg: PartialDeep<NestedTestAllTypes>): Uint8Array {
    return NestedTestAllTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes NestedTestAllTypes from protobuf.
   */
  decode: function (bytes: ByteSource): NestedTestAllTypes {
    return NestedTestAllTypes._readMessage(
      NestedTestAllTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: undefined,
      payload: TestAllTypes.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NestedTestAllTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.child) {
      writer.writeMessage(1, msg.child, NestedTestAllTypes._writeMessage);
    }
    if (msg.payload) {
      writer.writeMessage(2, msg.payload, TestAllTypes._writeMessage);
    }
    if (msg.repeatedChild?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedChild as any,
        NestedTestAllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    reader: BinaryReader,
  ): NestedTestAllTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.child = NestedTestAllTypes.initialize();
          reader.readMessage(msg.child, NestedTestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.payload, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = NestedTestAllTypes.initialize();
          reader.readMessage(m, NestedTestAllTypes._readMessage);
          msg.repeatedChild.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedFields = {
  /**
   * Serializes TestDeprecatedFields to protobuf.
   */
  encode: function (msg: PartialDeep<TestDeprecatedFields>): Uint8Array {
    return TestDeprecatedFields._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDeprecatedFields from protobuf.
   */
  decode: function (bytes: ByteSource): TestDeprecatedFields {
    return TestDeprecatedFields._readMessage(
      TestDeprecatedFields.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDeprecatedFields>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.deprecatedInt32) {
      writer.writeInt32(1, msg.deprecatedInt32);
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      writer.writeInt32(2, msg.deprecatedInt32InOneof);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    reader: BinaryReader,
  ): TestDeprecatedFields {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.deprecatedInt32 = reader.readInt32();
          break;
        }
        case 2: {
          msg.deprecatedInt32InOneof = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestDeprecatedMessage = {
  /**
   * Serializes TestDeprecatedMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestDeprecatedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestDeprecatedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestDeprecatedMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestDeprecatedMessage,
    _reader: BinaryReader,
  ): TestDeprecatedMessage {
    return _msg;
  },
};

export const ForeignMessage = {
  /**
   * Serializes ForeignMessage to protobuf.
   */
  encode: function (msg: PartialDeep<ForeignMessage>): Uint8Array {
    return ForeignMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes ForeignMessage from protobuf.
   */
  decode: function (bytes: ByteSource): ForeignMessage {
    return ForeignMessage._readMessage(
      ForeignMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.c) {
      writer.writeInt32(1, msg.c);
    }
    if (msg.d) {
      writer.writeInt32(2, msg.d);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: ForeignMessage,
    reader: BinaryReader,
  ): ForeignMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.c = reader.readInt32();
          break;
        }
        case 2: {
          msg.d = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestReservedFields = {
  /**
   * Serializes TestReservedFields to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestReservedFields>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestReservedFields from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestReservedFields>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestReservedFields,
    _reader: BinaryReader,
  ): TestReservedFields {
    return _msg;
  },
};

export const TestAllExtensions = {
  /**
   * Serializes TestAllExtensions to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestAllExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestAllExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestAllExtensions>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestAllExtensions,
    _reader: BinaryReader,
  ): TestAllExtensions {
    return _msg;
  },
};

export const OptionalGroup_extension = {
  /**
   * Serializes OptionalGroup_extension to protobuf.
   */
  encode: function (msg: PartialDeep<OptionalGroup_extension>): Uint8Array {
    return OptionalGroup_extension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes OptionalGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): OptionalGroup_extension {
    return OptionalGroup_extension._readMessage(
      OptionalGroup_extension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OptionalGroup_extension>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(17, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    reader: BinaryReader,
  ): OptionalGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 17: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const RepeatedGroup_extension = {
  /**
   * Serializes RepeatedGroup_extension to protobuf.
   */
  encode: function (msg: PartialDeep<RepeatedGroup_extension>): Uint8Array {
    return RepeatedGroup_extension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes RepeatedGroup_extension from protobuf.
   */
  decode: function (bytes: ByteSource): RepeatedGroup_extension {
    return RepeatedGroup_extension._readMessage(
      RepeatedGroup_extension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RepeatedGroup_extension>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(47, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    reader: BinaryReader,
  ): RepeatedGroup_extension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 47: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestGroup = {
  /**
   * Serializes TestGroup to protobuf.
   */
  encode: function (msg: PartialDeep<TestGroup>): Uint8Array {
    return TestGroup._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestGroup from protobuf.
   */
  decode: function (bytes: ByteSource): TestGroup {
    return TestGroup._readMessage(
      TestGroup.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestGroup>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (
      msg.optionalForeignEnum &&
      ForeignEnum._toInt(msg.optionalForeignEnum)
    ) {
      writer.writeEnum(22, ForeignEnum._toInt(msg.optionalForeignEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, reader: BinaryReader): TestGroup {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 22: {
          msg.optionalForeignEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to protobuf.
     */
    encode: function (msg: PartialDeep<TestGroup.OptionalGroup>): Uint8Array {
      return TestGroup.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestGroup.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestGroup.OptionalGroup {
      return TestGroup.OptionalGroup._readMessage(
        TestGroup.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestGroup.OptionalGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      reader: BinaryReader,
    ): TestGroup.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestGroupExtension = {
  /**
   * Serializes TestGroupExtension to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestGroupExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestGroupExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestGroupExtension>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestGroupExtension,
    _reader: BinaryReader,
  ): TestGroupExtension {
    return _msg;
  },
};

export const TestNestedExtension = {
  /**
   * Serializes TestNestedExtension to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestNestedExtension>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestNestedExtension from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestNestedExtension>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestNestedExtension,
    _reader: BinaryReader,
  ): TestNestedExtension {
    return _msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestNestedExtension.OptionalGroup_extension>,
    ): Uint8Array {
      return TestNestedExtension.OptionalGroup_extension._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtension.OptionalGroup_extension._readMessage(
        TestNestedExtension.OptionalGroup_extension.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestNestedExtension.OptionalGroup_extension>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(17, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      reader: BinaryReader,
    ): TestNestedExtension.OptionalGroup_extension {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 17: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestChildExtension = {
  /**
   * Serializes TestChildExtension to protobuf.
   */
  encode: function (msg: PartialDeep<TestChildExtension>): Uint8Array {
    return TestChildExtension._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestChildExtension from protobuf.
   */
  decode: function (bytes: ByteSource): TestChildExtension {
    return TestChildExtension._readMessage(
      TestChildExtension.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensions.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestChildExtension>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    if (msg.b) {
      writer.writeString(2, msg.b);
    }
    if (msg.optionalExtension) {
      writer.writeMessage(
        3,
        msg.optionalExtension,
        TestAllExtensions._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    reader: BinaryReader,
  ): TestChildExtension {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        case 2: {
          msg.b = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(
            msg.optionalExtension,
            TestAllExtensions._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequired = {
  /**
   * Serializes TestRequired to protobuf.
   */
  encode: function (msg: PartialDeep<TestRequired>): Uint8Array {
    return TestRequired._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequired from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequired {
    return TestRequired._readMessage(
      TestRequired.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequired>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.dummy2) {
      writer.writeInt32(2, msg.dummy2);
    }
    if (msg.b) {
      writer.writeInt32(3, msg.b);
    }
    if (msg.dummy4) {
      writer.writeInt32(4, msg.dummy4);
    }
    if (msg.dummy5) {
      writer.writeInt32(5, msg.dummy5);
    }
    if (msg.dummy6) {
      writer.writeInt32(6, msg.dummy6);
    }
    if (msg.dummy7) {
      writer.writeInt32(7, msg.dummy7);
    }
    if (msg.dummy8) {
      writer.writeInt32(8, msg.dummy8);
    }
    if (msg.dummy9) {
      writer.writeInt32(9, msg.dummy9);
    }
    if (msg.dummy10) {
      writer.writeInt32(10, msg.dummy10);
    }
    if (msg.dummy11) {
      writer.writeInt32(11, msg.dummy11);
    }
    if (msg.dummy12) {
      writer.writeInt32(12, msg.dummy12);
    }
    if (msg.dummy13) {
      writer.writeInt32(13, msg.dummy13);
    }
    if (msg.dummy14) {
      writer.writeInt32(14, msg.dummy14);
    }
    if (msg.dummy15) {
      writer.writeInt32(15, msg.dummy15);
    }
    if (msg.dummy16) {
      writer.writeInt32(16, msg.dummy16);
    }
    if (msg.dummy17) {
      writer.writeInt32(17, msg.dummy17);
    }
    if (msg.dummy18) {
      writer.writeInt32(18, msg.dummy18);
    }
    if (msg.dummy19) {
      writer.writeInt32(19, msg.dummy19);
    }
    if (msg.dummy20) {
      writer.writeInt32(20, msg.dummy20);
    }
    if (msg.dummy21) {
      writer.writeInt32(21, msg.dummy21);
    }
    if (msg.dummy22) {
      writer.writeInt32(22, msg.dummy22);
    }
    if (msg.dummy23) {
      writer.writeInt32(23, msg.dummy23);
    }
    if (msg.dummy24) {
      writer.writeInt32(24, msg.dummy24);
    }
    if (msg.dummy25) {
      writer.writeInt32(25, msg.dummy25);
    }
    if (msg.dummy26) {
      writer.writeInt32(26, msg.dummy26);
    }
    if (msg.dummy27) {
      writer.writeInt32(27, msg.dummy27);
    }
    if (msg.dummy28) {
      writer.writeInt32(28, msg.dummy28);
    }
    if (msg.dummy29) {
      writer.writeInt32(29, msg.dummy29);
    }
    if (msg.dummy30) {
      writer.writeInt32(30, msg.dummy30);
    }
    if (msg.dummy31) {
      writer.writeInt32(31, msg.dummy31);
    }
    if (msg.dummy32) {
      writer.writeInt32(32, msg.dummy32);
    }
    if (msg.c) {
      writer.writeInt32(33, msg.c);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequired,
    reader: BinaryReader,
  ): TestRequired {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 2: {
          msg.dummy2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.b = reader.readInt32();
          break;
        }
        case 4: {
          msg.dummy4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.dummy5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.dummy6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.dummy7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.dummy8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.dummy9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.dummy10 = reader.readInt32();
          break;
        }
        case 11: {
          msg.dummy11 = reader.readInt32();
          break;
        }
        case 12: {
          msg.dummy12 = reader.readInt32();
          break;
        }
        case 13: {
          msg.dummy13 = reader.readInt32();
          break;
        }
        case 14: {
          msg.dummy14 = reader.readInt32();
          break;
        }
        case 15: {
          msg.dummy15 = reader.readInt32();
          break;
        }
        case 16: {
          msg.dummy16 = reader.readInt32();
          break;
        }
        case 17: {
          msg.dummy17 = reader.readInt32();
          break;
        }
        case 18: {
          msg.dummy18 = reader.readInt32();
          break;
        }
        case 19: {
          msg.dummy19 = reader.readInt32();
          break;
        }
        case 20: {
          msg.dummy20 = reader.readInt32();
          break;
        }
        case 21: {
          msg.dummy21 = reader.readInt32();
          break;
        }
        case 22: {
          msg.dummy22 = reader.readInt32();
          break;
        }
        case 23: {
          msg.dummy23 = reader.readInt32();
          break;
        }
        case 24: {
          msg.dummy24 = reader.readInt32();
          break;
        }
        case 25: {
          msg.dummy25 = reader.readInt32();
          break;
        }
        case 26: {
          msg.dummy26 = reader.readInt32();
          break;
        }
        case 27: {
          msg.dummy27 = reader.readInt32();
          break;
        }
        case 28: {
          msg.dummy28 = reader.readInt32();
          break;
        }
        case 29: {
          msg.dummy29 = reader.readInt32();
          break;
        }
        case 30: {
          msg.dummy30 = reader.readInt32();
          break;
        }
        case 31: {
          msg.dummy31 = reader.readInt32();
          break;
        }
        case 32: {
          msg.dummy32 = reader.readInt32();
          break;
        }
        case 33: {
          msg.c = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredForeign = {
  /**
   * Serializes TestRequiredForeign to protobuf.
   */
  encode: function (msg: PartialDeep<TestRequiredForeign>): Uint8Array {
    return TestRequiredForeign._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredForeign from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredForeign {
    return TestRequiredForeign._readMessage(
      TestRequiredForeign.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredForeign>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage,
      );
    }
    if (msg.dummy) {
      writer.writeInt32(3, msg.dummy);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    reader: BinaryReader,
  ): TestRequiredForeign {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          msg.dummy = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRequiredMessage = {
  /**
   * Serializes TestRequiredMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestRequiredMessage>): Uint8Array {
    return TestRequiredMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredMessage {
    return TestRequiredMessage._readMessage(
      TestRequiredMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequired.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequired.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalMessage) {
      writer.writeMessage(1, msg.optionalMessage, TestRequired._writeMessage);
    }
    if (msg.repeatedMessage?.length) {
      writer.writeRepeatedMessage(
        2,
        msg.repeatedMessage as any,
        TestRequired._writeMessage,
      );
    }
    if (msg.requiredMessage) {
      writer.writeMessage(3, msg.requiredMessage, TestRequired._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    reader: BinaryReader,
  ): TestRequiredMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.optionalMessage, TestRequired._readMessage);
          break;
        }
        case 2: {
          const m = TestRequired.initialize();
          reader.readMessage(m, TestRequired._readMessage);
          msg.repeatedMessage.push(m);
          break;
        }
        case 3: {
          reader.readMessage(msg.requiredMessage, TestRequired._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestForeignNested = {
  /**
   * Serializes TestForeignNested to protobuf.
   */
  encode: function (msg: PartialDeep<TestForeignNested>): Uint8Array {
    return TestForeignNested._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestForeignNested from protobuf.
   */
  decode: function (bytes: ByteSource): TestForeignNested {
    return TestForeignNested._readMessage(
      TestForeignNested.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypes.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestForeignNested>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.foreignNested) {
      writer.writeMessage(
        1,
        msg.foreignNested,
        TestAllTypes.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    reader: BinaryReader,
  ): TestForeignNested {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.foreignNested,
            TestAllTypes.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestEmptyMessage = {
  /**
   * Serializes TestEmptyMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestEmptyMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessage,
    _reader: BinaryReader,
  ): TestEmptyMessage {
    return _msg;
  },
};

export const TestEmptyMessageWithExtensions = {
  /**
   * Serializes TestEmptyMessageWithExtensions to protobuf.
   */
  encode: function (
    _msg?: PartialDeep<TestEmptyMessageWithExtensions>,
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessageWithExtensions>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestEmptyMessageWithExtensions,
    _reader: BinaryReader,
  ): TestEmptyMessageWithExtensions {
    return _msg;
  },
};

export const TestPickleNestedMessage = {
  /**
   * Serializes TestPickleNestedMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestPickleNestedMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPickleNestedMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestPickleNestedMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPickleNestedMessage,
    _reader: BinaryReader,
  ): TestPickleNestedMessage {
    return _msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestPickleNestedMessage.NestedMessage>,
    ): Uint8Array {
      return TestPickleNestedMessage.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessage.NestedMessage._readMessage(
        TestPickleNestedMessage.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestPickleNestedMessage.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      reader: BinaryReader,
    ): TestPickleNestedMessage.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to protobuf.
       */
      encode: function (
        msg: PartialDeep<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
      ): Uint8Array {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from protobuf.
       */
      decode: function (
        bytes: ByteSource,
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessage.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessage.NestedMessage.NestedNestedMessage.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
        writer: BinaryWriter,
      ): BinaryWriter {
        if (msg.cc) {
          writer.writeInt32(1, msg.cc);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        reader: BinaryReader,
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 1: {
              msg.cc = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRanges = {
  /**
   * Serializes TestMultipleExtensionRanges to protobuf.
   */
  encode: function (
    _msg?: PartialDeep<TestMultipleExtensionRanges>,
  ): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestMultipleExtensionRanges from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestMultipleExtensionRanges>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestMultipleExtensionRanges,
    _reader: BinaryReader,
  ): TestMultipleExtensionRanges {
    return _msg;
  },
};

export const TestReallyLargeTagNumber = {
  /**
   * Serializes TestReallyLargeTagNumber to protobuf.
   */
  encode: function (msg: PartialDeep<TestReallyLargeTagNumber>): Uint8Array {
    return TestReallyLargeTagNumber._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestReallyLargeTagNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumber._readMessage(
      TestReallyLargeTagNumber.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestReallyLargeTagNumber>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    if (msg.bb) {
      writer.writeInt32(268435455, msg.bb);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    reader: BinaryReader,
  ): TestReallyLargeTagNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        case 268435455: {
          msg.bb = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestRecursiveMessage = {
  /**
   * Serializes TestRecursiveMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestRecursiveMessage>): Uint8Array {
    return TestRecursiveMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRecursiveMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestRecursiveMessage {
    return TestRecursiveMessage._readMessage(
      TestRecursiveMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: undefined,
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRecursiveMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestRecursiveMessage._writeMessage);
    }
    if (msg.i) {
      writer.writeInt32(2, msg.i);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    reader: BinaryReader,
  ): TestRecursiveMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = TestRecursiveMessage.initialize();
          reader.readMessage(msg.a, TestRecursiveMessage._readMessage);
          break;
        }
        case 2: {
          msg.i = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestMutualRecursionA = {
  /**
   * Serializes TestMutualRecursionA to protobuf.
   */
  encode: function (msg: PartialDeep<TestMutualRecursionA>): Uint8Array {
    return TestMutualRecursionA._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionA from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionA {
    return TestMutualRecursionA._readMessage(
      TestMutualRecursionA.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionB.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMutualRecursionA>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.bb) {
      writer.writeMessage(1, msg.bb, TestMutualRecursionB._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    reader: BinaryReader,
  ): TestMutualRecursionA {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.bb, TestMutualRecursionB._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestMutualRecursionA.SubMessage>,
    ): Uint8Array {
      return TestMutualRecursionA.SubMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionA.SubMessage._readMessage(
        TestMutualRecursionA.SubMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionB.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMutualRecursionA.SubMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.b) {
        writer.writeMessage(1, msg.b, TestMutualRecursionB._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      reader: BinaryReader,
    ): TestMutualRecursionA.SubMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            reader.readMessage(msg.b, TestMutualRecursionB._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestMutualRecursionA.SubGroup>,
    ): Uint8Array {
      return TestMutualRecursionA.SubGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionA.SubGroup._readMessage(
        TestMutualRecursionA.SubGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionA.SubMessage.initialize(),
        notInThisScc: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMutualRecursionA.SubGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.subMessage) {
        writer.writeMessage(
          3,
          msg.subMessage,
          TestMutualRecursionA.SubMessage._writeMessage,
        );
      }
      if (msg.notInThisScc) {
        writer.writeMessage(4, msg.notInThisScc, TestAllTypes._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      reader: BinaryReader,
    ): TestMutualRecursionA.SubGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 3: {
            reader.readMessage(
              msg.subMessage,
              TestMutualRecursionA.SubMessage._readMessage,
            );
            break;
          }
          case 4: {
            reader.readMessage(msg.notInThisScc, TestAllTypes._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestMutualRecursionB = {
  /**
   * Serializes TestMutualRecursionB to protobuf.
   */
  encode: function (msg: PartialDeep<TestMutualRecursionB>): Uint8Array {
    return TestMutualRecursionB._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestMutualRecursionB from protobuf.
   */
  decode: function (bytes: ByteSource): TestMutualRecursionB {
    return TestMutualRecursionB._readMessage(
      TestMutualRecursionB.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionA.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMutualRecursionB>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeMessage(1, msg.a, TestMutualRecursionA._writeMessage);
    }
    if (msg.optionalInt32) {
      writer.writeInt32(2, msg.optionalInt32);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    reader: BinaryReader,
  ): TestMutualRecursionB {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.a, TestMutualRecursionA._readMessage);
          break;
        }
        case 2: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestIsInitialized = {
  /**
   * Serializes TestIsInitialized to protobuf.
   */
  encode: function (msg: PartialDeep<TestIsInitialized>): Uint8Array {
    return TestIsInitialized._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestIsInitialized from protobuf.
   */
  decode: function (bytes: ByteSource): TestIsInitialized {
    return TestIsInitialized._readMessage(
      TestIsInitialized.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitialized.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestIsInitialized>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(
        1,
        msg.subMessage,
        TestIsInitialized.SubMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    reader: BinaryReader,
  ): TestIsInitialized {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.subMessage,
            TestIsInitialized.SubMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to protobuf.
     */
    encode: function (
      _msg?: PartialDeep<TestIsInitialized.SubMessage>,
    ): Uint8Array {
      return new Uint8Array();
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from protobuf.
     */
    decode: function (_bytes?: ByteSource): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestIsInitialized.SubMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      _msg: TestIsInitialized.SubMessage,
      _reader: BinaryReader,
    ): TestIsInitialized.SubMessage {
      return _msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to protobuf.
       */
      encode: function (
        msg: PartialDeep<TestIsInitialized.SubMessage.SubGroup>,
      ): Uint8Array {
        return TestIsInitialized.SubMessage.SubGroup._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from protobuf.
       */
      decode: function (
        bytes: ByteSource,
      ): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitialized.SubMessage.SubGroup._readMessage(
          TestIsInitialized.SubMessage.SubGroup.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestIsInitialized.SubMessage.SubGroup>,
        writer: BinaryWriter,
      ): BinaryWriter {
        if (msg.i) {
          writer.writeInt32(2, msg.i);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        reader: BinaryReader,
      ): TestIsInitialized.SubMessage.SubGroup {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 2: {
              msg.i = reader.readInt32();
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumber = {
  /**
   * Serializes TestDupFieldNumber to protobuf.
   */
  encode: function (msg: PartialDeep<TestDupFieldNumber>): Uint8Array {
    return TestDupFieldNumber._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDupFieldNumber from protobuf.
   */
  decode: function (bytes: ByteSource): TestDupFieldNumber {
    return TestDupFieldNumber._readMessage(
      TestDupFieldNumber.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDupFieldNumber>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeInt32(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    reader: BinaryReader,
  ): TestDupFieldNumber {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to protobuf.
     */
    encode: function (msg: PartialDeep<TestDupFieldNumber.Foo>): Uint8Array {
      return TestDupFieldNumber.Foo._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Foo {
      return TestDupFieldNumber.Foo._readMessage(
        TestDupFieldNumber.Foo.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDupFieldNumber.Foo>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      reader: BinaryReader,
    ): TestDupFieldNumber.Foo {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to protobuf.
     */
    encode: function (msg: PartialDeep<TestDupFieldNumber.Bar>): Uint8Array {
      return TestDupFieldNumber.Bar._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from protobuf.
     */
    decode: function (bytes: ByteSource): TestDupFieldNumber.Bar {
      return TestDupFieldNumber.Bar._readMessage(
        TestDupFieldNumber.Bar.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDupFieldNumber.Bar>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(1, msg.a);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      reader: BinaryReader,
    ): TestDupFieldNumber.Bar {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.a = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestEagerMessage = {
  /**
   * Serializes TestEagerMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestEagerMessage>): Uint8Array {
    return TestEagerMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestEagerMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestEagerMessage {
    return TestEagerMessage._readMessage(
      TestEagerMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestEagerMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEagerMessage,
    reader: BinaryReader,
  ): TestEagerMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestLazyMessage = {
  /**
   * Serializes TestLazyMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestLazyMessage>): Uint8Array {
    return TestLazyMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestLazyMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestLazyMessage {
    return TestLazyMessage._readMessage(
      TestLazyMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestLazyMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.subMessage) {
      writer.writeMessage(1, msg.subMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestLazyMessage,
    reader: BinaryReader,
  ): TestLazyMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.subMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestNestedMessageHasBits = {
  /**
   * Serializes TestNestedMessageHasBits to protobuf.
   */
  encode: function (msg: PartialDeep<TestNestedMessageHasBits>): Uint8Array {
    return TestNestedMessageHasBits._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestNestedMessageHasBits from protobuf.
   */
  decode: function (bytes: ByteSource): TestNestedMessageHasBits {
    return TestNestedMessageHasBits._readMessage(
      TestNestedMessageHasBits.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBits.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestNestedMessageHasBits>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        1,
        msg.optionalNestedMessage,
        TestNestedMessageHasBits.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    reader: BinaryReader,
  ): TestNestedMessageHasBits {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestNestedMessageHasBits.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestNestedMessageHasBits.NestedMessage>,
    ): Uint8Array {
      return TestNestedMessageHasBits.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBits.NestedMessage._readMessage(
        TestNestedMessageHasBits.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestNestedMessageHasBits.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.nestedmessageRepeatedInt32?.length) {
        writer.writePackedInt32(1, msg.nestedmessageRepeatedInt32);
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.nestedmessageRepeatedForeignmessage as any,
          ForeignMessage._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      reader: BinaryReader,
    ): TestNestedMessageHasBits.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            if (reader.isDelimited()) {
              msg.nestedmessageRepeatedInt32.push(...reader.readPackedInt32());
            } else {
              msg.nestedmessageRepeatedInt32.push(reader.readInt32());
            }
            break;
          }
          case 2: {
            const m = ForeignMessage.initialize();
            reader.readMessage(m, ForeignMessage._readMessage);
            msg.nestedmessageRepeatedForeignmessage.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNames = {
  /**
   * Serializes TestCamelCaseFieldNames to protobuf.
   */
  encode: function (msg: PartialDeep<TestCamelCaseFieldNames>): Uint8Array {
    return TestCamelCaseFieldNames._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCamelCaseFieldNames from protobuf.
   */
  decode: function (bytes: ByteSource): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNames._readMessage(
      TestCamelCaseFieldNames.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessage.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestCamelCaseFieldNames>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.PrimitiveField) {
      writer.writeInt32(1, msg.PrimitiveField);
    }
    if (msg.StringField) {
      writer.writeString(2, msg.StringField);
    }
    if (msg.EnumField && ForeignEnum._toInt(msg.EnumField)) {
      writer.writeEnum(3, ForeignEnum._toInt(msg.EnumField));
    }
    if (msg.MessageField) {
      writer.writeMessage(4, msg.MessageField, ForeignMessage._writeMessage);
    }
    if (msg.StringPieceField) {
      writer.writeString(5, msg.StringPieceField);
    }
    if (msg.CordField) {
      writer.writeString(6, msg.CordField);
    }
    if (msg.RepeatedPrimitiveField?.length) {
      writer.writePackedInt32(7, msg.RepeatedPrimitiveField);
    }
    if (msg.RepeatedStringField?.length) {
      writer.writeRepeatedString(8, msg.RepeatedStringField);
    }
    if (msg.RepeatedEnumField?.length) {
      writer.writePackedEnum(9, msg.RepeatedEnumField.map(ForeignEnum._toInt));
    }
    if (msg.RepeatedMessageField?.length) {
      writer.writeRepeatedMessage(
        10,
        msg.RepeatedMessageField as any,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      writer.writeRepeatedString(11, msg.RepeatedStringPieceField);
    }
    if (msg.RepeatedCordField?.length) {
      writer.writeRepeatedString(12, msg.RepeatedCordField);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    reader: BinaryReader,
  ): TestCamelCaseFieldNames {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.PrimitiveField = reader.readInt32();
          break;
        }
        case 2: {
          msg.StringField = reader.readString();
          break;
        }
        case 3: {
          msg.EnumField = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          reader.readMessage(msg.MessageField, ForeignMessage._readMessage);
          break;
        }
        case 5: {
          msg.StringPieceField = reader.readString();
          break;
        }
        case 6: {
          msg.CordField = reader.readString();
          break;
        }
        case 7: {
          if (reader.isDelimited()) {
            msg.RepeatedPrimitiveField.push(...reader.readPackedInt32());
          } else {
            msg.RepeatedPrimitiveField.push(reader.readInt32());
          }
          break;
        }
        case 8: {
          msg.RepeatedStringField.push(reader.readString());
          break;
        }
        case 9: {
          if (reader.isDelimited()) {
            msg.RepeatedEnumField.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.RepeatedEnumField.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        case 10: {
          const m = ForeignMessage.initialize();
          reader.readMessage(m, ForeignMessage._readMessage);
          msg.RepeatedMessageField.push(m);
          break;
        }
        case 11: {
          msg.RepeatedStringPieceField.push(reader.readString());
          break;
        }
        case 12: {
          msg.RepeatedCordField.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestFieldOrderings = {
  /**
   * Serializes TestFieldOrderings to protobuf.
   */
  encode: function (msg: PartialDeep<TestFieldOrderings>): Uint8Array {
    return TestFieldOrderings._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestFieldOrderings from protobuf.
   */
  decode: function (bytes: ByteSource): TestFieldOrderings {
    return TestFieldOrderings._readMessage(
      TestFieldOrderings.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderings.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestFieldOrderings>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(11, msg.myString);
    }
    if (msg.myInt) {
      writer.writeInt64String(1, msg.myInt.toString() as any);
    }
    if (msg.myFloat) {
      writer.writeFloat(101, msg.myFloat);
    }
    if (msg.optionalNestedMessage) {
      writer.writeMessage(
        200,
        msg.optionalNestedMessage,
        TestFieldOrderings.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    reader: BinaryReader,
  ): TestFieldOrderings {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 11: {
          msg.myString = reader.readString();
          break;
        }
        case 1: {
          msg.myInt = BigInt(reader.readInt64String());
          break;
        }
        case 101: {
          msg.myFloat = reader.readFloat();
          break;
        }
        case 200: {
          reader.readMessage(
            msg.optionalNestedMessage,
            TestFieldOrderings.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestFieldOrderings.NestedMessage>,
    ): Uint8Array {
      return TestFieldOrderings.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestFieldOrderings.NestedMessage {
      return TestFieldOrderings.NestedMessage._readMessage(
        TestFieldOrderings.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestFieldOrderings.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.oo) {
        writer.writeInt64String(2, msg.oo.toString() as any);
      }
      if (msg.bb) {
        writer.writeInt32(1, msg.bb);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      reader: BinaryReader,
    ): TestFieldOrderings.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2: {
            msg.oo = BigInt(reader.readInt64String());
            break;
          }
          case 1: {
            msg.bb = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1 = {
  /**
   * Serializes TestExtensionOrderings1 to protobuf.
   */
  encode: function (msg: PartialDeep<TestExtensionOrderings1>): Uint8Array {
    return TestExtensionOrderings1._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings1 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings1 {
    return TestExtensionOrderings1._readMessage(
      TestExtensionOrderings1.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionOrderings1>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    reader: BinaryReader,
  ): TestExtensionOrderings1 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionOrderings2 = {
  /**
   * Serializes TestExtensionOrderings2 to protobuf.
   */
  encode: function (msg: PartialDeep<TestExtensionOrderings2>): Uint8Array {
    return TestExtensionOrderings2._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionOrderings2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionOrderings2 {
    return TestExtensionOrderings2._readMessage(
      TestExtensionOrderings2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionOrderings2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.myString) {
      writer.writeString(1, msg.myString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    reader: BinaryReader,
  ): TestExtensionOrderings2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.myString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestExtensionOrderings2.TestExtensionOrderings3>,
    ): Uint8Array {
      return TestExtensionOrderings2.TestExtensionOrderings3._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2.TestExtensionOrderings3.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestExtensionOrderings2.TestExtensionOrderings3>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.myString) {
        writer.writeString(1, msg.myString);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      reader: BinaryReader,
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.myString = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValues = {
  /**
   * Serializes TestExtremeDefaultValues to protobuf.
   */
  encode: function (msg: PartialDeep<TestExtremeDefaultValues>): Uint8Array {
    return TestExtremeDefaultValues._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtremeDefaultValues from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtremeDefaultValues {
    return TestExtremeDefaultValues._readMessage(
      TestExtremeDefaultValues.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtremeDefaultValues>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.escapedBytes?.length) {
      writer.writeBytes(1, msg.escapedBytes);
    }
    if (msg.largeUint32) {
      writer.writeUint32(2, msg.largeUint32);
    }
    if (msg.largeUint64) {
      writer.writeUint64String(3, msg.largeUint64.toString() as any);
    }
    if (msg.smallInt32) {
      writer.writeInt32(4, msg.smallInt32);
    }
    if (msg.smallInt64) {
      writer.writeInt64String(5, msg.smallInt64.toString() as any);
    }
    if (msg.reallySmallInt32) {
      writer.writeInt32(21, msg.reallySmallInt32);
    }
    if (msg.reallySmallInt64) {
      writer.writeInt64String(22, msg.reallySmallInt64.toString() as any);
    }
    if (msg.utf8String) {
      writer.writeString(6, msg.utf8String);
    }
    if (msg.zeroFloat) {
      writer.writeFloat(7, msg.zeroFloat);
    }
    if (msg.oneFloat) {
      writer.writeFloat(8, msg.oneFloat);
    }
    if (msg.smallFloat) {
      writer.writeFloat(9, msg.smallFloat);
    }
    if (msg.negativeOneFloat) {
      writer.writeFloat(10, msg.negativeOneFloat);
    }
    if (msg.negativeFloat) {
      writer.writeFloat(11, msg.negativeFloat);
    }
    if (msg.largeFloat) {
      writer.writeFloat(12, msg.largeFloat);
    }
    if (msg.smallNegativeFloat) {
      writer.writeFloat(13, msg.smallNegativeFloat);
    }
    if (msg.infDouble) {
      writer.writeDouble(14, msg.infDouble);
    }
    if (msg.negInfDouble) {
      writer.writeDouble(15, msg.negInfDouble);
    }
    if (msg.nanDouble) {
      writer.writeDouble(16, msg.nanDouble);
    }
    if (msg.infFloat) {
      writer.writeFloat(17, msg.infFloat);
    }
    if (msg.negInfFloat) {
      writer.writeFloat(18, msg.negInfFloat);
    }
    if (msg.nanFloat) {
      writer.writeFloat(19, msg.nanFloat);
    }
    if (msg.cppTrigraph) {
      writer.writeString(20, msg.cppTrigraph);
    }
    if (msg.stringWithZero) {
      writer.writeString(23, msg.stringWithZero);
    }
    if (msg.bytesWithZero?.length) {
      writer.writeBytes(24, msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      writer.writeString(25, msg.stringPieceWithZero);
    }
    if (msg.cordWithZero) {
      writer.writeString(26, msg.cordWithZero);
    }
    if (msg.replacementString) {
      writer.writeString(27, msg.replacementString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    reader: BinaryReader,
  ): TestExtremeDefaultValues {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.escapedBytes = reader.readBytes();
          break;
        }
        case 2: {
          msg.largeUint32 = reader.readUint32();
          break;
        }
        case 3: {
          msg.largeUint64 = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.smallInt32 = reader.readInt32();
          break;
        }
        case 5: {
          msg.smallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 21: {
          msg.reallySmallInt32 = reader.readInt32();
          break;
        }
        case 22: {
          msg.reallySmallInt64 = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.utf8String = reader.readString();
          break;
        }
        case 7: {
          msg.zeroFloat = reader.readFloat();
          break;
        }
        case 8: {
          msg.oneFloat = reader.readFloat();
          break;
        }
        case 9: {
          msg.smallFloat = reader.readFloat();
          break;
        }
        case 10: {
          msg.negativeOneFloat = reader.readFloat();
          break;
        }
        case 11: {
          msg.negativeFloat = reader.readFloat();
          break;
        }
        case 12: {
          msg.largeFloat = reader.readFloat();
          break;
        }
        case 13: {
          msg.smallNegativeFloat = reader.readFloat();
          break;
        }
        case 14: {
          msg.infDouble = reader.readDouble();
          break;
        }
        case 15: {
          msg.negInfDouble = reader.readDouble();
          break;
        }
        case 16: {
          msg.nanDouble = reader.readDouble();
          break;
        }
        case 17: {
          msg.infFloat = reader.readFloat();
          break;
        }
        case 18: {
          msg.negInfFloat = reader.readFloat();
          break;
        }
        case 19: {
          msg.nanFloat = reader.readFloat();
          break;
        }
        case 20: {
          msg.cppTrigraph = reader.readString();
          break;
        }
        case 23: {
          msg.stringWithZero = reader.readString();
          break;
        }
        case 24: {
          msg.bytesWithZero = reader.readBytes();
          break;
        }
        case 25: {
          msg.stringPieceWithZero = reader.readString();
          break;
        }
        case 26: {
          msg.cordWithZero = reader.readString();
          break;
        }
        case 27: {
          msg.replacementString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SparseEnumMessage = {
  /**
   * Serializes SparseEnumMessage to protobuf.
   */
  encode: function (msg: PartialDeep<SparseEnumMessage>): Uint8Array {
    return SparseEnumMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes SparseEnumMessage from protobuf.
   */
  decode: function (bytes: ByteSource): SparseEnumMessage {
    return SparseEnumMessage._readMessage(
      SparseEnumMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SparseEnumMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.sparseEnum && TestSparseEnum._toInt(msg.sparseEnum)) {
      writer.writeEnum(1, TestSparseEnum._toInt(msg.sparseEnum));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    reader: BinaryReader,
  ): SparseEnumMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sparseEnum = TestSparseEnum._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneString = {
  /**
   * Serializes OneString to protobuf.
   */
  encode: function (msg: PartialDeep<OneString>): Uint8Array {
    return OneString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneString from protobuf.
   */
  decode: function (bytes: ByteSource): OneString {
    return OneString._readMessage(
      OneString.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneString>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, reader: BinaryReader): OneString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreString = {
  /**
   * Serializes MoreString to protobuf.
   */
  encode: function (msg: PartialDeep<MoreString>): Uint8Array {
    return MoreString._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreString from protobuf.
   */
  decode: function (bytes: ByteSource): MoreString {
    return MoreString._readMessage(
      MoreString.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MoreString>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedString(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, reader: BinaryReader): MoreString {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const OneBytes = {
  /**
   * Serializes OneBytes to protobuf.
   */
  encode: function (msg: PartialDeep<OneBytes>): Uint8Array {
    return OneBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes OneBytes from protobuf.
   */
  decode: function (bytes: ByteSource): OneBytes {
    return OneBytes._readMessage(
      OneBytes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneBytes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, reader: BinaryReader): OneBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MoreBytes = {
  /**
   * Serializes MoreBytes to protobuf.
   */
  encode: function (msg: PartialDeep<MoreBytes>): Uint8Array {
    return MoreBytes._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes MoreBytes from protobuf.
   */
  decode: function (bytes: ByteSource): MoreBytes {
    return MoreBytes._readMessage(
      MoreBytes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MoreBytes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data?.length) {
      writer.writeRepeatedBytes(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, reader: BinaryReader): MoreBytes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data.push(reader.readBytes());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int32Message = {
  /**
   * Serializes Int32Message to protobuf.
   */
  encode: function (msg: PartialDeep<Int32Message>): Uint8Array {
    return Int32Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Int32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int32Message {
    return Int32Message._readMessage(
      Int32Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Int32Message>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int32Message,
    reader: BinaryReader,
  ): Int32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint32Message = {
  /**
   * Serializes Uint32Message to protobuf.
   */
  encode: function (msg: PartialDeep<Uint32Message>): Uint8Array {
    return Uint32Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint32Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint32Message {
    return Uint32Message._readMessage(
      Uint32Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Uint32Message>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint32(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint32Message,
    reader: BinaryReader,
  ): Uint32Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readUint32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Int64Message = {
  /**
   * Serializes Int64Message to protobuf.
   */
  encode: function (msg: PartialDeep<Int64Message>): Uint8Array {
    return Int64Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Int64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Int64Message {
    return Int64Message._readMessage(
      Int64Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Int64Message>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeInt64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Int64Message,
    reader: BinaryReader,
  ): Int64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readInt64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Uint64Message = {
  /**
   * Serializes Uint64Message to protobuf.
   */
  encode: function (msg: PartialDeep<Uint64Message>): Uint8Array {
    return Uint64Message._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Uint64Message from protobuf.
   */
  decode: function (bytes: ByteSource): Uint64Message {
    return Uint64Message._readMessage(
      Uint64Message.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Uint64Message>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeUint64String(1, msg.data.toString() as any);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Uint64Message,
    reader: BinaryReader,
  ): Uint64Message {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = BigInt(reader.readUint64String());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const BoolMessage = {
  /**
   * Serializes BoolMessage to protobuf.
   */
  encode: function (msg: PartialDeep<BoolMessage>): Uint8Array {
    return BoolMessage._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes BoolMessage from protobuf.
   */
  decode: function (bytes: ByteSource): BoolMessage {
    return BoolMessage._readMessage(
      BoolMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<BoolMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.data) {
      writer.writeBool(1, msg.data);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, reader: BinaryReader): BoolMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.data = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestOneof = {
  /**
   * Serializes TestOneof to protobuf.
   */
  encode: function (msg: PartialDeep<TestOneof>): Uint8Array {
    return TestOneof._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof {
    return TestOneof._readMessage(
      TestOneof.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, reader: BinaryReader): TestOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestAllTypes.initialize();
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to protobuf.
     */
    encode: function (msg: PartialDeep<TestOneof.FooGroup>): Uint8Array {
      return TestOneof.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof.FooGroup {
      return TestOneof.FooGroup._readMessage(
        TestOneof.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof.FooGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      reader: BinaryReader,
    ): TestOneof.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatible = {
  /**
   * Serializes TestOneofBackwardsCompatible to protobuf.
   */
  encode: function (
    msg: PartialDeep<TestOneofBackwardsCompatible>,
  ): Uint8Array {
    return TestOneofBackwardsCompatible._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatible._readMessage(
      TestOneofBackwardsCompatible.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypes.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneofBackwardsCompatible>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooInt) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage) {
      writer.writeMessage(3, msg.fooMessage, TestAllTypes._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    reader: BinaryReader,
  ): TestOneofBackwardsCompatible {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.fooMessage, TestAllTypes._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestOneofBackwardsCompatible.FooGroup>,
    ): Uint8Array {
      return TestOneofBackwardsCompatible.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatible.FooGroup._readMessage(
        TestOneofBackwardsCompatible.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneofBackwardsCompatible.FooGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(5, msg.a);
      }
      if (msg.b) {
        writer.writeString(6, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      reader: BinaryReader,
    ): TestOneofBackwardsCompatible.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 5: {
            msg.a = reader.readInt32();
            break;
          }
          case 6: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestOneof2 = {
  /**
   * Serializes TestOneof2 to protobuf.
   */
  encode: function (msg: PartialDeep<TestOneof2>): Uint8Array {
    return TestOneof2._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes TestOneof2 from protobuf.
   */
  decode: function (bytes: ByteSource): TestOneof2 {
    return TestOneof2._readMessage(
      TestOneof2.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof2>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooCord != undefined) {
      writer.writeString(3, msg.fooCord);
    }
    if (msg.fooStringPiece != undefined) {
      writer.writeString(4, msg.fooStringPiece);
    }
    if (msg.fooBytes?.length) {
      writer.writeBytes(5, msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      writer.writeEnum(6, TestOneof2.NestedEnum._toInt(msg.fooEnum));
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        7,
        msg.fooMessage,
        TestOneof2.NestedMessage._writeMessage,
      );
    }
    if (msg.fooLazyMessage != undefined) {
      writer.writeMessage(
        11,
        msg.fooLazyMessage,
        TestOneof2.NestedMessage._writeMessage,
      );
    }
    if (msg.barInt != undefined) {
      writer.writeInt32(12, msg.barInt);
    }
    if (msg.barString != undefined) {
      writer.writeString(13, msg.barString);
    }
    if (msg.barCord != undefined) {
      writer.writeString(14, msg.barCord);
    }
    if (msg.barStringPiece != undefined) {
      writer.writeString(15, msg.barStringPiece);
    }
    if (msg.barBytes?.length) {
      writer.writeBytes(16, msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      writer.writeEnum(17, TestOneof2.NestedEnum._toInt(msg.barEnum));
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      writer.writeString(20, msg.barStringWithEmptyDefault);
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      writer.writeString(21, msg.barCordWithEmptyDefault);
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      writer.writeString(22, msg.barStringPieceWithEmptyDefault);
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      writer.writeBytes(23, msg.barBytesWithEmptyDefault);
    }
    if (msg.bazInt) {
      writer.writeInt32(18, msg.bazInt);
    }
    if (msg.bazString) {
      writer.writeString(19, msg.bazString);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, reader: BinaryReader): TestOneof2 {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooCord = reader.readString();
          break;
        }
        case 4: {
          msg.fooStringPiece = reader.readString();
          break;
        }
        case 5: {
          msg.fooBytes = reader.readBytes();
          break;
        }
        case 6: {
          msg.fooEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 7: {
          msg.fooMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestOneof2.NestedMessage._readMessage,
          );
          break;
        }
        case 11: {
          msg.fooLazyMessage = TestOneof2.NestedMessage.initialize();
          reader.readMessage(
            msg.fooLazyMessage,
            TestOneof2.NestedMessage._readMessage,
          );
          break;
        }
        case 12: {
          msg.barInt = reader.readInt32();
          break;
        }
        case 13: {
          msg.barString = reader.readString();
          break;
        }
        case 14: {
          msg.barCord = reader.readString();
          break;
        }
        case 15: {
          msg.barStringPiece = reader.readString();
          break;
        }
        case 16: {
          msg.barBytes = reader.readBytes();
          break;
        }
        case 17: {
          msg.barEnum = TestOneof2.NestedEnum._fromInt(reader.readEnum());
          break;
        }
        case 20: {
          msg.barStringWithEmptyDefault = reader.readString();
          break;
        }
        case 21: {
          msg.barCordWithEmptyDefault = reader.readString();
          break;
        }
        case 22: {
          msg.barStringPieceWithEmptyDefault = reader.readString();
          break;
        }
        case 23: {
          msg.barBytesWithEmptyDefault = reader.readBytes();
          break;
        }
        case 18: {
          msg.bazInt = reader.readInt32();
          break;
        }
        case 19: {
          msg.bazString = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to protobuf.
     */
    encode: function (msg: PartialDeep<TestOneof2.FooGroup>): Uint8Array {
      return TestOneof2.FooGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.FooGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.FooGroup {
      return TestOneof2.FooGroup._readMessage(
        TestOneof2.FooGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof2.FooGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.a) {
        writer.writeInt32(9, msg.a);
      }
      if (msg.b) {
        writer.writeString(10, msg.b);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      reader: BinaryReader,
    ): TestOneof2.FooGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 9: {
            msg.a = reader.readInt32();
            break;
          }
          case 10: {
            msg.b = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to protobuf.
     */
    encode: function (msg: PartialDeep<TestOneof2.NestedMessage>): Uint8Array {
      return TestOneof2.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestOneof2.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestOneof2.NestedMessage {
      return TestOneof2.NestedMessage._readMessage(
        TestOneof2.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof2.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.quxInt) {
        writer.writeInt64String(1, msg.quxInt.toString() as any);
      }
      if (msg.corgeInt?.length) {
        writer.writePackedInt32(2, msg.corgeInt);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      reader: BinaryReader,
    ): TestOneof2.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.quxInt = BigInt(reader.readInt64String());
            break;
          }
          case 2: {
            if (reader.isDelimited()) {
              msg.corgeInt.push(...reader.readPackedInt32());
            } else {
              msg.corgeInt.push(reader.readInt32());
            }
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRequiredOneof = {
  /**
   * Serializes TestRequiredOneof to protobuf.
   */
  encode: function (msg: PartialDeep<TestRequiredOneof>): Uint8Array {
    return TestRequiredOneof._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRequiredOneof from protobuf.
   */
  decode: function (bytes: ByteSource): TestRequiredOneof {
    return TestRequiredOneof._readMessage(
      TestRequiredOneof.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredOneof>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooInt != undefined) {
      writer.writeInt32(1, msg.fooInt);
    }
    if (msg.fooString != undefined) {
      writer.writeString(2, msg.fooString);
    }
    if (msg.fooMessage != undefined) {
      writer.writeMessage(
        3,
        msg.fooMessage,
        TestRequiredOneof.NestedMessage._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    reader: BinaryReader,
  ): TestRequiredOneof {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooInt = reader.readInt32();
          break;
        }
        case 2: {
          msg.fooString = reader.readString();
          break;
        }
        case 3: {
          msg.fooMessage = TestRequiredOneof.NestedMessage.initialize();
          reader.readMessage(
            msg.fooMessage,
            TestRequiredOneof.NestedMessage._readMessage,
          );
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestRequiredOneof.NestedMessage>,
    ): Uint8Array {
      return TestRequiredOneof.NestedMessage._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from protobuf.
     */
    decode: function (bytes: ByteSource): TestRequiredOneof.NestedMessage {
      return TestRequiredOneof.NestedMessage._readMessage(
        TestRequiredOneof.NestedMessage.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRequiredOneof.NestedMessage>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.requiredDouble) {
        writer.writeDouble(1, msg.requiredDouble);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      reader: BinaryReader,
    ): TestRequiredOneof.NestedMessage {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.requiredDouble = reader.readDouble();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestPackedTypes = {
  /**
   * Serializes TestPackedTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestPackedTypes>): Uint8Array {
    return TestPackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestPackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestPackedTypes {
    return TestPackedTypes._readMessage(
      TestPackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestPackedTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(90, msg.packedInt32);
    }
    if (msg.packedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.packedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedUint32?.length) {
      writer.writePackedUint32(92, msg.packedUint32);
    }
    if (msg.packedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.packedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSint32?.length) {
      writer.writePackedSint32(94, msg.packedSint32);
    }
    if (msg.packedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.packedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFixed32?.length) {
      writer.writePackedFixed32(96, msg.packedFixed32);
    }
    if (msg.packedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.packedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.packedSfixed32);
    }
    if (msg.packedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.packedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.packedFloat?.length) {
      writer.writePackedFloat(100, msg.packedFloat);
    }
    if (msg.packedDouble?.length) {
      writer.writePackedDouble(101, msg.packedDouble);
    }
    if (msg.packedBool?.length) {
      writer.writePackedBool(102, msg.packedBool);
    }
    if (msg.packedEnum?.length) {
      writer.writePackedEnum(103, msg.packedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedTypes,
    reader: BinaryReader,
  ): TestPackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.packedInt64.push(...reader.readPackedInt64String().map(BigInt));
          } else {
            msg.packedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.packedUint32.push(...reader.readPackedUint32());
          } else {
            msg.packedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.packedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.packedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.packedSint32.push(...reader.readPackedSint32());
          } else {
            msg.packedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.packedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.packedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.packedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.packedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.packedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.packedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.packedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.packedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.packedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.packedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.packedFloat.push(...reader.readPackedFloat());
          } else {
            msg.packedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.packedDouble.push(...reader.readPackedDouble());
          } else {
            msg.packedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.packedBool.push(...reader.readPackedBool());
          } else {
            msg.packedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.packedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.packedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestUnpackedTypes = {
  /**
   * Serializes TestUnpackedTypes to protobuf.
   */
  encode: function (msg: PartialDeep<TestUnpackedTypes>): Uint8Array {
    return TestUnpackedTypes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestUnpackedTypes from protobuf.
   */
  decode: function (bytes: ByteSource): TestUnpackedTypes {
    return TestUnpackedTypes._readMessage(
      TestUnpackedTypes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestUnpackedTypes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.unpackedInt32?.length) {
      writer.writePackedInt32(90, msg.unpackedInt32);
    }
    if (msg.unpackedInt64?.length) {
      writer.writePackedInt64String(
        91,
        msg.unpackedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedUint32?.length) {
      writer.writePackedUint32(92, msg.unpackedUint32);
    }
    if (msg.unpackedUint64?.length) {
      writer.writePackedUint64String(
        93,
        msg.unpackedUint64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedSint32?.length) {
      writer.writePackedSint32(94, msg.unpackedSint32);
    }
    if (msg.unpackedSint64?.length) {
      writer.writePackedSint64String(
        95,
        msg.unpackedSint64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedFixed32?.length) {
      writer.writePackedFixed32(96, msg.unpackedFixed32);
    }
    if (msg.unpackedFixed64?.length) {
      writer.writePackedFixed64String(
        97,
        msg.unpackedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedSfixed32?.length) {
      writer.writePackedSfixed32(98, msg.unpackedSfixed32);
    }
    if (msg.unpackedSfixed64?.length) {
      writer.writePackedSfixed64String(
        99,
        msg.unpackedSfixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.unpackedFloat?.length) {
      writer.writePackedFloat(100, msg.unpackedFloat);
    }
    if (msg.unpackedDouble?.length) {
      writer.writePackedDouble(101, msg.unpackedDouble);
    }
    if (msg.unpackedBool?.length) {
      writer.writePackedBool(102, msg.unpackedBool);
    }
    if (msg.unpackedEnum?.length) {
      writer.writePackedEnum(103, msg.unpackedEnum.map(ForeignEnum._toInt));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    reader: BinaryReader,
  ): TestUnpackedTypes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 90: {
          if (reader.isDelimited()) {
            msg.unpackedInt32.push(...reader.readPackedInt32());
          } else {
            msg.unpackedInt32.push(reader.readInt32());
          }
          break;
        }
        case 91: {
          if (reader.isDelimited()) {
            msg.unpackedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.unpackedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 92: {
          if (reader.isDelimited()) {
            msg.unpackedUint32.push(...reader.readPackedUint32());
          } else {
            msg.unpackedUint32.push(reader.readUint32());
          }
          break;
        }
        case 93: {
          if (reader.isDelimited()) {
            msg.unpackedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.unpackedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        case 94: {
          if (reader.isDelimited()) {
            msg.unpackedSint32.push(...reader.readPackedSint32());
          } else {
            msg.unpackedSint32.push(reader.readSint32());
          }
          break;
        }
        case 95: {
          if (reader.isDelimited()) {
            msg.unpackedSint64.push(
              ...reader.readPackedSint64String().map(BigInt),
            );
          } else {
            msg.unpackedSint64.push(BigInt(reader.readSint64String()));
          }
          break;
        }
        case 96: {
          if (reader.isDelimited()) {
            msg.unpackedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.unpackedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 97: {
          if (reader.isDelimited()) {
            msg.unpackedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.unpackedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 98: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed32.push(...reader.readPackedSfixed32());
          } else {
            msg.unpackedSfixed32.push(reader.readSfixed32());
          }
          break;
        }
        case 99: {
          if (reader.isDelimited()) {
            msg.unpackedSfixed64.push(
              ...reader.readPackedSfixed64String().map(BigInt),
            );
          } else {
            msg.unpackedSfixed64.push(BigInt(reader.readSfixed64String()));
          }
          break;
        }
        case 100: {
          if (reader.isDelimited()) {
            msg.unpackedFloat.push(...reader.readPackedFloat());
          } else {
            msg.unpackedFloat.push(reader.readFloat());
          }
          break;
        }
        case 101: {
          if (reader.isDelimited()) {
            msg.unpackedDouble.push(...reader.readPackedDouble());
          } else {
            msg.unpackedDouble.push(reader.readDouble());
          }
          break;
        }
        case 102: {
          if (reader.isDelimited()) {
            msg.unpackedBool.push(...reader.readPackedBool());
          } else {
            msg.unpackedBool.push(reader.readBool());
          }
          break;
        }
        case 103: {
          if (reader.isDelimited()) {
            msg.unpackedEnum.push(
              ...reader.readPackedEnum().map(ForeignEnum._fromInt),
            );
          } else {
            msg.unpackedEnum.push(ForeignEnum._fromInt(reader.readEnum()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestPackedExtensions = {
  /**
   * Serializes TestPackedExtensions to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestPackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestPackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestPackedExtensions>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestPackedExtensions,
    _reader: BinaryReader,
  ): TestPackedExtensions {
    return _msg;
  },
};

export const TestUnpackedExtensions = {
  /**
   * Serializes TestUnpackedExtensions to protobuf.
   */
  encode: function (_msg?: PartialDeep<TestUnpackedExtensions>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes TestUnpackedExtensions from protobuf.
   */
  decode: function (_bytes?: ByteSource): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestUnpackedExtensions>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: TestUnpackedExtensions,
    _reader: BinaryReader,
  ): TestUnpackedExtensions {
    return _msg;
  },
};

export const TestDynamicExtensions = {
  /**
   * Serializes TestDynamicExtensions to protobuf.
   */
  encode: function (msg: PartialDeep<TestDynamicExtensions>): Uint8Array {
    return TestDynamicExtensions._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestDynamicExtensions from protobuf.
   */
  decode: function (bytes: ByteSource): TestDynamicExtensions {
    return TestDynamicExtensions._readMessage(
      TestDynamicExtensions.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessage.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensions.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDynamicExtensions>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.scalarExtension) {
      writer.writeFixed32(2000, msg.scalarExtension);
    }
    if (msg.enumExtension && ForeignEnum._toInt(msg.enumExtension)) {
      writer.writeEnum(2001, ForeignEnum._toInt(msg.enumExtension));
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      writer.writeEnum(
        2002,
        TestDynamicExtensions.DynamicEnumType._toInt(msg.dynamicEnumExtension),
      );
    }
    if (msg.messageExtension) {
      writer.writeMessage(
        2003,
        msg.messageExtension,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.dynamicMessageExtension) {
      writer.writeMessage(
        2004,
        msg.dynamicMessageExtension,
        TestDynamicExtensions.DynamicMessageType._writeMessage,
      );
    }
    if (msg.repeatedExtension?.length) {
      writer.writeRepeatedString(2005, msg.repeatedExtension);
    }
    if (msg.packedExtension?.length) {
      writer.writePackedSint32(2006, msg.packedExtension);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    reader: BinaryReader,
  ): TestDynamicExtensions {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2000: {
          msg.scalarExtension = reader.readFixed32();
          break;
        }
        case 2001: {
          msg.enumExtension = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 2002: {
          msg.dynamicEnumExtension =
            TestDynamicExtensions.DynamicEnumType._fromInt(reader.readEnum());
          break;
        }
        case 2003: {
          reader.readMessage(msg.messageExtension, ForeignMessage._readMessage);
          break;
        }
        case 2004: {
          reader.readMessage(
            msg.dynamicMessageExtension,
            TestDynamicExtensions.DynamicMessageType._readMessage,
          );
          break;
        }
        case 2005: {
          msg.repeatedExtension.push(reader.readString());
          break;
        }
        case 2006: {
          if (reader.isDelimited()) {
            msg.packedExtension.push(...reader.readPackedSint32());
          } else {
            msg.packedExtension.push(reader.readSint32());
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestDynamicExtensions.DynamicMessageType>,
    ): Uint8Array {
      return TestDynamicExtensions.DynamicMessageType._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensions.DynamicMessageType._readMessage(
        TestDynamicExtensions.DynamicMessageType.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDynamicExtensions.DynamicMessageType>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.dynamicField) {
        writer.writeInt32(2100, msg.dynamicField);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      reader: BinaryReader,
    ): TestDynamicExtensions.DynamicMessageType {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 2100: {
            msg.dynamicField = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizes = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to protobuf.
   */
  encode: function (
    msg: PartialDeep<TestRepeatedScalarDifferentTagSizes>,
  ): Uint8Array {
    return TestRepeatedScalarDifferentTagSizes._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from protobuf.
   */
  decode: function (bytes: ByteSource): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizes._readMessage(
      TestRepeatedScalarDifferentTagSizes.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRepeatedScalarDifferentTagSizes>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.repeatedFixed32?.length) {
      writer.writePackedFixed32(12, msg.repeatedFixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(13, msg.repeatedInt32);
    }
    if (msg.repeatedFixed64?.length) {
      writer.writePackedFixed64String(
        2046,
        msg.repeatedFixed64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedInt64?.length) {
      writer.writePackedInt64String(
        2047,
        msg.repeatedInt64.map((x) => x.toString() as any),
      );
    }
    if (msg.repeatedFloat?.length) {
      writer.writePackedFloat(262142, msg.repeatedFloat);
    }
    if (msg.repeatedUint64?.length) {
      writer.writePackedUint64String(
        262143,
        msg.repeatedUint64.map((x) => x.toString() as any),
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    reader: BinaryReader,
  ): TestRepeatedScalarDifferentTagSizes {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 12: {
          if (reader.isDelimited()) {
            msg.repeatedFixed32.push(...reader.readPackedFixed32());
          } else {
            msg.repeatedFixed32.push(reader.readFixed32());
          }
          break;
        }
        case 13: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 2046: {
          if (reader.isDelimited()) {
            msg.repeatedFixed64.push(
              ...reader.readPackedFixed64String().map(BigInt),
            );
          } else {
            msg.repeatedFixed64.push(BigInt(reader.readFixed64String()));
          }
          break;
        }
        case 2047: {
          if (reader.isDelimited()) {
            msg.repeatedInt64.push(
              ...reader.readPackedInt64String().map(BigInt),
            );
          } else {
            msg.repeatedInt64.push(BigInt(reader.readInt64String()));
          }
          break;
        }
        case 262142: {
          if (reader.isDelimited()) {
            msg.repeatedFloat.push(...reader.readPackedFloat());
          } else {
            msg.repeatedFloat.push(reader.readFloat());
          }
          break;
        }
        case 262143: {
          if (reader.isDelimited()) {
            msg.repeatedUint64.push(
              ...reader.readPackedUint64String().map(BigInt),
            );
          } else {
            msg.repeatedUint64.push(BigInt(reader.readUint64String()));
          }
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestParsingMerge = {
  /**
   * Serializes TestParsingMerge to protobuf.
   */
  encode: function (msg: PartialDeep<TestParsingMerge>): Uint8Array {
    return TestParsingMerge._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestParsingMerge from protobuf.
   */
  decode: function (bytes: ByteSource): TestParsingMerge {
    return TestParsingMerge._readMessage(
      TestParsingMerge.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypes.initialize(),
      optionalAllTypes: TestAllTypes.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestParsingMerge>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.requiredAllTypes) {
      writer.writeMessage(1, msg.requiredAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.optionalAllTypes) {
      writer.writeMessage(2, msg.optionalAllTypes, TestAllTypes._writeMessage);
    }
    if (msg.repeatedAllTypes?.length) {
      writer.writeRepeatedMessage(
        3,
        msg.repeatedAllTypes as any,
        TestAllTypes._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestParsingMerge,
    reader: BinaryReader,
  ): TestParsingMerge {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          reader.readMessage(msg.requiredAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 2: {
          reader.readMessage(msg.optionalAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 3: {
          const m = TestAllTypes.initialize();
          reader.readMessage(m, TestAllTypes._readMessage);
          msg.repeatedAllTypes.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator>,
    ): Uint8Array {
      return TestParsingMerge.RepeatedFieldsGenerator._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from protobuf.
     */
    decode: function (
      bytes: ByteSource,
    ): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMerge.RepeatedFieldsGenerator._readMessage(
        TestParsingMerge.RepeatedFieldsGenerator.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.field1?.length) {
        writer.writeRepeatedMessage(
          1,
          msg.field1 as any,
          TestAllTypes._writeMessage,
        );
      }
      if (msg.field2?.length) {
        writer.writeRepeatedMessage(
          2,
          msg.field2 as any,
          TestAllTypes._writeMessage,
        );
      }
      if (msg.field3?.length) {
        writer.writeRepeatedMessage(
          3,
          msg.field3 as any,
          TestAllTypes._writeMessage,
        );
      }
      if (msg.ext1?.length) {
        writer.writeRepeatedMessage(
          1000,
          msg.ext1 as any,
          TestAllTypes._writeMessage,
        );
      }
      if (msg.ext2?.length) {
        writer.writeRepeatedMessage(
          1001,
          msg.ext2 as any,
          TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      reader: BinaryReader,
    ): TestParsingMerge.RepeatedFieldsGenerator {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field1.push(m);
            break;
          }
          case 2: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field2.push(m);
            break;
          }
          case 3: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.field3.push(m);
            break;
          }
          case 1000: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext1.push(m);
            break;
          }
          case 1001: {
            const m = TestAllTypes.initialize();
            reader.readMessage(m, TestAllTypes._readMessage);
            msg.ext2.push(m);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to protobuf.
       */
      encode: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from protobuf.
       */
      decode: function (
        bytes: ByteSource,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group1.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
        writer: BinaryWriter,
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(11, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        reader: BinaryReader,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 11: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to protobuf.
       */
      encode: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
      ): Uint8Array {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._writeMessage(
          msg,
          new BinaryWriter(),
        ).getResultBuffer();
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from protobuf.
       */
      decode: function (
        bytes: ByteSource,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMerge.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMerge.RepeatedFieldsGenerator.Group2.initialize(),
          new BinaryReader(bytes),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypes.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
        writer: BinaryWriter,
      ): BinaryWriter {
        if (msg.field1) {
          writer.writeMessage(21, msg.field1, TestAllTypes._writeMessage);
        }
        return writer;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        reader: BinaryReader,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        while (reader.nextField()) {
          const field = reader.getFieldNumber();
          switch (field) {
            case 21: {
              reader.readMessage(msg.field1, TestAllTypes._readMessage);
              break;
            }
            default: {
              reader.skipField();
              break;
            }
          }
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.OptionalGroup>,
    ): Uint8Array {
      return TestParsingMerge.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.OptionalGroup {
      return TestParsingMerge.OptionalGroup._readMessage(
        TestParsingMerge.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.OptionalGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.optionalGroupAllTypes) {
        writer.writeMessage(
          11,
          msg.optionalGroupAllTypes,
          TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      reader: BinaryReader,
    ): TestParsingMerge.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 11: {
            reader.readMessage(
              msg.optionalGroupAllTypes,
              TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.RepeatedGroup>,
    ): Uint8Array {
      return TestParsingMerge.RepeatedGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestParsingMerge.RepeatedGroup {
      return TestParsingMerge.RepeatedGroup._readMessage(
        TestParsingMerge.RepeatedGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypes.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.RepeatedGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.repeatedGroupAllTypes) {
        writer.writeMessage(
          21,
          msg.repeatedGroupAllTypes,
          TestAllTypes._writeMessage,
        );
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      reader: BinaryReader,
    ): TestParsingMerge.RepeatedGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 21: {
            reader.readMessage(
              msg.repeatedGroupAllTypes,
              TestAllTypes._readMessage,
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessage = {
  /**
   * Serializes TestCommentInjectionMessage to protobuf.
   */
  encode: function (msg: PartialDeep<TestCommentInjectionMessage>): Uint8Array {
    return TestCommentInjectionMessage._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestCommentInjectionMessage from protobuf.
   */
  decode: function (bytes: ByteSource): TestCommentInjectionMessage {
    return TestCommentInjectionMessage._readMessage(
      TestCommentInjectionMessage.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestCommentInjectionMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.a) {
      writer.writeString(1, msg.a);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    reader: BinaryReader,
  ): TestCommentInjectionMessage {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.a = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FooRequest = {
  /**
   * Serializes FooRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<FooRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooRequest>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: FooRequest, _reader: BinaryReader): FooRequest {
    return _msg;
  },
};

export const FooResponse = {
  /**
   * Serializes FooResponse to protobuf.
   */
  encode: function (_msg?: PartialDeep<FooResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooResponse>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooResponse,
    _reader: BinaryReader,
  ): FooResponse {
    return _msg;
  },
};

export const FooClientMessage = {
  /**
   * Serializes FooClientMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<FooClientMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooClientMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooClientMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooClientMessage,
    _reader: BinaryReader,
  ): FooClientMessage {
    return _msg;
  },
};

export const FooServerMessage = {
  /**
   * Serializes FooServerMessage to protobuf.
   */
  encode: function (_msg?: PartialDeep<FooServerMessage>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes FooServerMessage from protobuf.
   */
  decode: function (_bytes?: ByteSource): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooServerMessage>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: FooServerMessage,
    _reader: BinaryReader,
  ): FooServerMessage {
    return _msg;
  },
};

export const BarRequest = {
  /**
   * Serializes BarRequest to protobuf.
   */
  encode: function (_msg?: PartialDeep<BarRequest>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarRequest from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BarRequest>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (_msg: BarRequest, _reader: BinaryReader): BarRequest {
    return _msg;
  },
};

export const BarResponse = {
  /**
   * Serializes BarResponse to protobuf.
   */
  encode: function (_msg?: PartialDeep<BarResponse>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes BarResponse from protobuf.
   */
  decode: function (_bytes?: ByteSource): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BarResponse>,
    writer: BinaryWriter,
  ): BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: BarResponse,
    _reader: BinaryReader,
  ): BarResponse {
    return _msg;
  },
};

export const TestJsonName = {
  /**
   * Serializes TestJsonName to protobuf.
   */
  encode: function (msg: PartialDeep<TestJsonName>): Uint8Array {
    return TestJsonName._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestJsonName from protobuf.
   */
  decode: function (bytes: ByteSource): TestJsonName {
    return TestJsonName._readMessage(
      TestJsonName.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      fieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestJsonName>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fieldName1) {
      writer.writeInt32(1, msg.fieldName1);
    }
    if (msg.fieldName2) {
      writer.writeInt32(2, msg.fieldName2);
    }
    if (msg.FieldName3) {
      writer.writeInt32(3, msg.FieldName3);
    }
    if (msg.fieldName4) {
      writer.writeInt32(4, msg.fieldName4);
    }
    if (msg.FIELDNAME5) {
      writer.writeInt32(5, msg.FIELDNAME5);
    }
    if (msg.fieldName6) {
      writer.writeInt32(6, msg.fieldName6);
    }
    if (msg.fieldname7) {
      writer.writeInt32(7, msg.fieldname7);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestJsonName,
    reader: BinaryReader,
  ): TestJsonName {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fieldName1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.fieldName2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.FieldName3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.fieldName4 = reader.readInt32();
          break;
        }
        case 5: {
          msg.FIELDNAME5 = reader.readInt32();
          break;
        }
        case 6: {
          msg.fieldName6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.fieldname7 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestHugeFieldNumbers = {
  /**
   * Serializes TestHugeFieldNumbers to protobuf.
   */
  encode: function (msg: PartialDeep<TestHugeFieldNumbers>): Uint8Array {
    return TestHugeFieldNumbers._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestHugeFieldNumbers from protobuf.
   */
  decode: function (bytes: ByteSource): TestHugeFieldNumbers {
    return TestHugeFieldNumbers._readMessage(
      TestHugeFieldNumbers.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessage.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestHugeFieldNumbers>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.optionalInt32) {
      writer.writeInt32(536870000, msg.optionalInt32);
    }
    if (msg.fixed32) {
      writer.writeInt32(536870001, msg.fixed32);
    }
    if (msg.repeatedInt32?.length) {
      writer.writePackedInt32(536870002, msg.repeatedInt32);
    }
    if (msg.packedInt32?.length) {
      writer.writePackedInt32(536870003, msg.packedInt32);
    }
    if (msg.optionalEnum && ForeignEnum._toInt(msg.optionalEnum)) {
      writer.writeEnum(536870004, ForeignEnum._toInt(msg.optionalEnum));
    }
    if (msg.optionalString) {
      writer.writeString(536870005, msg.optionalString);
    }
    if (msg.optionalBytes?.length) {
      writer.writeBytes(536870006, msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      writer.writeMessage(
        536870007,
        msg.optionalMessage,
        ForeignMessage._writeMessage,
      );
    }
    if (msg.stringStringMap) {
      writer.writeRepeatedMessage(
        536870010,
        Object.entries(msg.stringStringMap).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        TestHugeFieldNumbers.StringStringMap._writeMessage,
      );
    }
    if (msg.oneofUint32 != undefined) {
      writer.writeUint32(536870011, msg.oneofUint32);
    }
    if (msg.oneofTestAllTypes != undefined) {
      writer.writeMessage(
        536870012,
        msg.oneofTestAllTypes,
        TestAllTypes._writeMessage,
      );
    }
    if (msg.oneofString != undefined) {
      writer.writeString(536870013, msg.oneofString);
    }
    if (msg.oneofBytes?.length) {
      writer.writeBytes(536870014, msg.oneofBytes);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    reader: BinaryReader,
  ): TestHugeFieldNumbers {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 536870000: {
          msg.optionalInt32 = reader.readInt32();
          break;
        }
        case 536870001: {
          msg.fixed32 = reader.readInt32();
          break;
        }
        case 536870002: {
          if (reader.isDelimited()) {
            msg.repeatedInt32.push(...reader.readPackedInt32());
          } else {
            msg.repeatedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870003: {
          if (reader.isDelimited()) {
            msg.packedInt32.push(...reader.readPackedInt32());
          } else {
            msg.packedInt32.push(reader.readInt32());
          }
          break;
        }
        case 536870004: {
          msg.optionalEnum = ForeignEnum._fromInt(reader.readEnum());
          break;
        }
        case 536870005: {
          msg.optionalString = reader.readString();
          break;
        }
        case 536870006: {
          msg.optionalBytes = reader.readBytes();
          break;
        }
        case 536870007: {
          reader.readMessage(msg.optionalMessage, ForeignMessage._readMessage);
          break;
        }
        case 536870010: {
          const map = {} as TestHugeFieldNumbers.StringStringMap;
          reader.readMessage(
            map,
            TestHugeFieldNumbers.StringStringMap._readMessage,
          );
          msg.stringStringMap[map.key.toString()] = map.value;
          break;
        }
        case 536870011: {
          msg.oneofUint32 = reader.readUint32();
          break;
        }
        case 536870012: {
          msg.oneofTestAllTypes = TestAllTypes.initialize();
          reader.readMessage(msg.oneofTestAllTypes, TestAllTypes._readMessage);
          break;
        }
        case 536870013: {
          msg.oneofString = reader.readString();
          break;
        }
        case 536870014: {
          msg.oneofBytes = reader.readBytes();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to protobuf.
     */
    encode: function (
      msg: PartialDeep<TestHugeFieldNumbers.OptionalGroup>,
    ): Uint8Array {
      return TestHugeFieldNumbers.OptionalGroup._writeMessage(
        msg,
        new BinaryWriter(),
      ).getResultBuffer();
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from protobuf.
     */
    decode: function (bytes: ByteSource): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbers.OptionalGroup._readMessage(
        TestHugeFieldNumbers.OptionalGroup.initialize(),
        new BinaryReader(bytes),
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestHugeFieldNumbers.OptionalGroup>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.groupA) {
        writer.writeInt32(536870009, msg.groupA);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      reader: BinaryReader,
    ): TestHugeFieldNumbers.OptionalGroup {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 536870009: {
            msg.groupA = reader.readInt32();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestHugeFieldNumbers.StringStringMap>,
      writer: BinaryWriter,
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeString(2, msg.value);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      reader: BinaryReader,
    ): TestHugeFieldNumbers.StringStringMap {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = reader.readString();
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTable = {
  /**
   * Serializes TestExtensionInsideTable to protobuf.
   */
  encode: function (msg: PartialDeep<TestExtensionInsideTable>): Uint8Array {
    return TestExtensionInsideTable._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionInsideTable from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionInsideTable {
    return TestExtensionInsideTable._readMessage(
      TestExtensionInsideTable.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionInsideTable>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.field1) {
      writer.writeInt32(1, msg.field1);
    }
    if (msg.field2) {
      writer.writeInt32(2, msg.field2);
    }
    if (msg.field3) {
      writer.writeInt32(3, msg.field3);
    }
    if (msg.field4) {
      writer.writeInt32(4, msg.field4);
    }
    if (msg.field6) {
      writer.writeInt32(6, msg.field6);
    }
    if (msg.field7) {
      writer.writeInt32(7, msg.field7);
    }
    if (msg.field8) {
      writer.writeInt32(8, msg.field8);
    }
    if (msg.field9) {
      writer.writeInt32(9, msg.field9);
    }
    if (msg.field10) {
      writer.writeInt32(10, msg.field10);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    reader: BinaryReader,
  ): TestExtensionInsideTable {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.field1 = reader.readInt32();
          break;
        }
        case 2: {
          msg.field2 = reader.readInt32();
          break;
        }
        case 3: {
          msg.field3 = reader.readInt32();
          break;
        }
        case 4: {
          msg.field4 = reader.readInt32();
          break;
        }
        case 6: {
          msg.field6 = reader.readInt32();
          break;
        }
        case 7: {
          msg.field7 = reader.readInt32();
          break;
        }
        case 8: {
          msg.field8 = reader.readInt32();
          break;
        }
        case 9: {
          msg.field9 = reader.readInt32();
          break;
        }
        case 10: {
          msg.field10 = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TestExtensionRangeSerialize = {
  /**
   * Serializes TestExtensionRangeSerialize to protobuf.
   */
  encode: function (msg: PartialDeep<TestExtensionRangeSerialize>): Uint8Array {
    return TestExtensionRangeSerialize._writeMessage(
      msg,
      new BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TestExtensionRangeSerialize from protobuf.
   */
  decode: function (bytes: ByteSource): TestExtensionRangeSerialize {
    return TestExtensionRangeSerialize._readMessage(
      TestExtensionRangeSerialize.initialize(),
      new BinaryReader(bytes),
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionRangeSerialize>,
    writer: BinaryWriter,
  ): BinaryWriter {
    if (msg.fooOne) {
      writer.writeInt32(1, msg.fooOne);
    }
    if (msg.fooTwo) {
      writer.writeInt32(6, msg.fooTwo);
    }
    if (msg.fooThree) {
      writer.writeInt32(7, msg.fooThree);
    }
    if (msg.fooFour) {
      writer.writeInt32(13, msg.fooFour);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    reader: BinaryReader,
  ): TestExtensionRangeSerialize {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.fooOne = reader.readInt32();
          break;
        }
        case 6: {
          msg.fooTwo = reader.readInt32();
          break;
        }
        case 7: {
          msg.fooThree = reader.readInt32();
          break;
        }
        case 13: {
          msg.fooFour = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const ForeignEnumJSON = {
  FOREIGN_FOO: "FOREIGN_FOO",
  FOREIGN_BAR: "FOREIGN_BAR",
  FOREIGN_BAZ: "FOREIGN_BAZ",
  /**
   * @private
   */
  _fromInt: function (i: number): ForeignEnum {
    switch (i) {
      case 4: {
        return "FOREIGN_FOO";
      }
      case 5: {
        return "FOREIGN_BAR";
      }
      case 6: {
        return "FOREIGN_BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as ForeignEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: ForeignEnum): number {
    switch (i) {
      case "FOREIGN_FOO": {
        return 4;
      }
      case "FOREIGN_BAR": {
        return 5;
      }
      case "FOREIGN_BAZ": {
        return 6;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestEnumWithDupValueJSON = {
  FOO1: "FOO1",
  BAR1: "BAR1",
  BAZ: "BAZ",
  FOO2: "FOO2",
  BAR2: "BAR2",
  /**
   * @private
   */
  _fromInt: function (i: number): TestEnumWithDupValue {
    switch (i) {
      case 1: {
        return "FOO1";
      }
      case 2: {
        return "BAR1";
      }
      case 3: {
        return "BAZ";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestEnumWithDupValue;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestEnumWithDupValue): number {
    switch (i) {
      case "FOO1": {
        return 1;
      }
      case "BAR1": {
        return 2;
      }
      case "BAZ": {
        return 3;
      }
      case "FOO2": {
        return 1;
      }
      case "BAR2": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestSparseEnumJSON = {
  SPARSE_A: "SPARSE_A",
  SPARSE_B: "SPARSE_B",
  SPARSE_C: "SPARSE_C",
  SPARSE_D: "SPARSE_D",
  SPARSE_E: "SPARSE_E",
  SPARSE_F: "SPARSE_F",
  SPARSE_G: "SPARSE_G",
  /**
   * @private
   */
  _fromInt: function (i: number): TestSparseEnum {
    switch (i) {
      case 123: {
        return "SPARSE_A";
      }
      case 62374: {
        return "SPARSE_B";
      }
      case 12589234: {
        return "SPARSE_C";
      }
      case -15: {
        return "SPARSE_D";
      }
      case -53452: {
        return "SPARSE_E";
      }
      case 0: {
        return "SPARSE_F";
      }
      case 2: {
        return "SPARSE_G";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as TestSparseEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: TestSparseEnum): number {
    switch (i) {
      case "SPARSE_A": {
        return 123;
      }
      case "SPARSE_B": {
        return 62374;
      }
      case "SPARSE_C": {
        return 12589234;
      }
      case "SPARSE_D": {
        return -15;
      }
      case "SPARSE_E": {
        return -53452;
      }
      case "SPARSE_F": {
        return 0;
      }
      case "SPARSE_G": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const VeryLargeEnumJSON = {
  ENUM_LABEL_DEFAULT: "ENUM_LABEL_DEFAULT",
  ENUM_LABEL_1: "ENUM_LABEL_1",
  ENUM_LABEL_2: "ENUM_LABEL_2",
  ENUM_LABEL_3: "ENUM_LABEL_3",
  ENUM_LABEL_4: "ENUM_LABEL_4",
  ENUM_LABEL_5: "ENUM_LABEL_5",
  ENUM_LABEL_6: "ENUM_LABEL_6",
  ENUM_LABEL_7: "ENUM_LABEL_7",
  ENUM_LABEL_8: "ENUM_LABEL_8",
  ENUM_LABEL_9: "ENUM_LABEL_9",
  ENUM_LABEL_10: "ENUM_LABEL_10",
  ENUM_LABEL_11: "ENUM_LABEL_11",
  ENUM_LABEL_12: "ENUM_LABEL_12",
  ENUM_LABEL_13: "ENUM_LABEL_13",
  ENUM_LABEL_14: "ENUM_LABEL_14",
  ENUM_LABEL_15: "ENUM_LABEL_15",
  ENUM_LABEL_16: "ENUM_LABEL_16",
  ENUM_LABEL_17: "ENUM_LABEL_17",
  ENUM_LABEL_18: "ENUM_LABEL_18",
  ENUM_LABEL_19: "ENUM_LABEL_19",
  ENUM_LABEL_20: "ENUM_LABEL_20",
  ENUM_LABEL_21: "ENUM_LABEL_21",
  ENUM_LABEL_22: "ENUM_LABEL_22",
  ENUM_LABEL_23: "ENUM_LABEL_23",
  ENUM_LABEL_24: "ENUM_LABEL_24",
  ENUM_LABEL_25: "ENUM_LABEL_25",
  ENUM_LABEL_26: "ENUM_LABEL_26",
  ENUM_LABEL_27: "ENUM_LABEL_27",
  ENUM_LABEL_28: "ENUM_LABEL_28",
  ENUM_LABEL_29: "ENUM_LABEL_29",
  ENUM_LABEL_30: "ENUM_LABEL_30",
  ENUM_LABEL_31: "ENUM_LABEL_31",
  ENUM_LABEL_32: "ENUM_LABEL_32",
  ENUM_LABEL_33: "ENUM_LABEL_33",
  ENUM_LABEL_34: "ENUM_LABEL_34",
  ENUM_LABEL_35: "ENUM_LABEL_35",
  ENUM_LABEL_36: "ENUM_LABEL_36",
  ENUM_LABEL_37: "ENUM_LABEL_37",
  ENUM_LABEL_38: "ENUM_LABEL_38",
  ENUM_LABEL_39: "ENUM_LABEL_39",
  ENUM_LABEL_40: "ENUM_LABEL_40",
  ENUM_LABEL_41: "ENUM_LABEL_41",
  ENUM_LABEL_42: "ENUM_LABEL_42",
  ENUM_LABEL_43: "ENUM_LABEL_43",
  ENUM_LABEL_44: "ENUM_LABEL_44",
  ENUM_LABEL_45: "ENUM_LABEL_45",
  ENUM_LABEL_46: "ENUM_LABEL_46",
  ENUM_LABEL_47: "ENUM_LABEL_47",
  ENUM_LABEL_48: "ENUM_LABEL_48",
  ENUM_LABEL_49: "ENUM_LABEL_49",
  ENUM_LABEL_50: "ENUM_LABEL_50",
  ENUM_LABEL_51: "ENUM_LABEL_51",
  ENUM_LABEL_52: "ENUM_LABEL_52",
  ENUM_LABEL_53: "ENUM_LABEL_53",
  ENUM_LABEL_54: "ENUM_LABEL_54",
  ENUM_LABEL_55: "ENUM_LABEL_55",
  ENUM_LABEL_56: "ENUM_LABEL_56",
  ENUM_LABEL_57: "ENUM_LABEL_57",
  ENUM_LABEL_58: "ENUM_LABEL_58",
  ENUM_LABEL_59: "ENUM_LABEL_59",
  ENUM_LABEL_60: "ENUM_LABEL_60",
  ENUM_LABEL_61: "ENUM_LABEL_61",
  ENUM_LABEL_62: "ENUM_LABEL_62",
  ENUM_LABEL_63: "ENUM_LABEL_63",
  ENUM_LABEL_64: "ENUM_LABEL_64",
  ENUM_LABEL_65: "ENUM_LABEL_65",
  ENUM_LABEL_66: "ENUM_LABEL_66",
  ENUM_LABEL_67: "ENUM_LABEL_67",
  ENUM_LABEL_68: "ENUM_LABEL_68",
  ENUM_LABEL_69: "ENUM_LABEL_69",
  ENUM_LABEL_70: "ENUM_LABEL_70",
  ENUM_LABEL_71: "ENUM_LABEL_71",
  ENUM_LABEL_72: "ENUM_LABEL_72",
  ENUM_LABEL_73: "ENUM_LABEL_73",
  ENUM_LABEL_74: "ENUM_LABEL_74",
  ENUM_LABEL_75: "ENUM_LABEL_75",
  ENUM_LABEL_76: "ENUM_LABEL_76",
  ENUM_LABEL_77: "ENUM_LABEL_77",
  ENUM_LABEL_78: "ENUM_LABEL_78",
  ENUM_LABEL_79: "ENUM_LABEL_79",
  ENUM_LABEL_80: "ENUM_LABEL_80",
  ENUM_LABEL_81: "ENUM_LABEL_81",
  ENUM_LABEL_82: "ENUM_LABEL_82",
  ENUM_LABEL_83: "ENUM_LABEL_83",
  ENUM_LABEL_84: "ENUM_LABEL_84",
  ENUM_LABEL_85: "ENUM_LABEL_85",
  ENUM_LABEL_86: "ENUM_LABEL_86",
  ENUM_LABEL_87: "ENUM_LABEL_87",
  ENUM_LABEL_88: "ENUM_LABEL_88",
  ENUM_LABEL_89: "ENUM_LABEL_89",
  ENUM_LABEL_90: "ENUM_LABEL_90",
  ENUM_LABEL_91: "ENUM_LABEL_91",
  ENUM_LABEL_92: "ENUM_LABEL_92",
  ENUM_LABEL_93: "ENUM_LABEL_93",
  ENUM_LABEL_94: "ENUM_LABEL_94",
  ENUM_LABEL_95: "ENUM_LABEL_95",
  ENUM_LABEL_96: "ENUM_LABEL_96",
  ENUM_LABEL_97: "ENUM_LABEL_97",
  ENUM_LABEL_98: "ENUM_LABEL_98",
  ENUM_LABEL_99: "ENUM_LABEL_99",
  ENUM_LABEL_100: "ENUM_LABEL_100",
  /**
   * @private
   */
  _fromInt: function (i: number): VeryLargeEnum {
    switch (i) {
      case 0: {
        return "ENUM_LABEL_DEFAULT";
      }
      case 1: {
        return "ENUM_LABEL_1";
      }
      case 2: {
        return "ENUM_LABEL_2";
      }
      case 3: {
        return "ENUM_LABEL_3";
      }
      case 4: {
        return "ENUM_LABEL_4";
      }
      case 5: {
        return "ENUM_LABEL_5";
      }
      case 6: {
        return "ENUM_LABEL_6";
      }
      case 7: {
        return "ENUM_LABEL_7";
      }
      case 8: {
        return "ENUM_LABEL_8";
      }
      case 9: {
        return "ENUM_LABEL_9";
      }
      case 10: {
        return "ENUM_LABEL_10";
      }
      case 11: {
        return "ENUM_LABEL_11";
      }
      case 12: {
        return "ENUM_LABEL_12";
      }
      case 13: {
        return "ENUM_LABEL_13";
      }
      case 14: {
        return "ENUM_LABEL_14";
      }
      case 15: {
        return "ENUM_LABEL_15";
      }
      case 16: {
        return "ENUM_LABEL_16";
      }
      case 17: {
        return "ENUM_LABEL_17";
      }
      case 18: {
        return "ENUM_LABEL_18";
      }
      case 19: {
        return "ENUM_LABEL_19";
      }
      case 20: {
        return "ENUM_LABEL_20";
      }
      case 21: {
        return "ENUM_LABEL_21";
      }
      case 22: {
        return "ENUM_LABEL_22";
      }
      case 23: {
        return "ENUM_LABEL_23";
      }
      case 24: {
        return "ENUM_LABEL_24";
      }
      case 25: {
        return "ENUM_LABEL_25";
      }
      case 26: {
        return "ENUM_LABEL_26";
      }
      case 27: {
        return "ENUM_LABEL_27";
      }
      case 28: {
        return "ENUM_LABEL_28";
      }
      case 29: {
        return "ENUM_LABEL_29";
      }
      case 30: {
        return "ENUM_LABEL_30";
      }
      case 31: {
        return "ENUM_LABEL_31";
      }
      case 32: {
        return "ENUM_LABEL_32";
      }
      case 33: {
        return "ENUM_LABEL_33";
      }
      case 34: {
        return "ENUM_LABEL_34";
      }
      case 35: {
        return "ENUM_LABEL_35";
      }
      case 36: {
        return "ENUM_LABEL_36";
      }
      case 37: {
        return "ENUM_LABEL_37";
      }
      case 38: {
        return "ENUM_LABEL_38";
      }
      case 39: {
        return "ENUM_LABEL_39";
      }
      case 40: {
        return "ENUM_LABEL_40";
      }
      case 41: {
        return "ENUM_LABEL_41";
      }
      case 42: {
        return "ENUM_LABEL_42";
      }
      case 43: {
        return "ENUM_LABEL_43";
      }
      case 44: {
        return "ENUM_LABEL_44";
      }
      case 45: {
        return "ENUM_LABEL_45";
      }
      case 46: {
        return "ENUM_LABEL_46";
      }
      case 47: {
        return "ENUM_LABEL_47";
      }
      case 48: {
        return "ENUM_LABEL_48";
      }
      case 49: {
        return "ENUM_LABEL_49";
      }
      case 50: {
        return "ENUM_LABEL_50";
      }
      case 51: {
        return "ENUM_LABEL_51";
      }
      case 52: {
        return "ENUM_LABEL_52";
      }
      case 53: {
        return "ENUM_LABEL_53";
      }
      case 54: {
        return "ENUM_LABEL_54";
      }
      case 55: {
        return "ENUM_LABEL_55";
      }
      case 56: {
        return "ENUM_LABEL_56";
      }
      case 57: {
        return "ENUM_LABEL_57";
      }
      case 58: {
        return "ENUM_LABEL_58";
      }
      case 59: {
        return "ENUM_LABEL_59";
      }
      case 60: {
        return "ENUM_LABEL_60";
      }
      case 61: {
        return "ENUM_LABEL_61";
      }
      case 62: {
        return "ENUM_LABEL_62";
      }
      case 63: {
        return "ENUM_LABEL_63";
      }
      case 64: {
        return "ENUM_LABEL_64";
      }
      case 65: {
        return "ENUM_LABEL_65";
      }
      case 66: {
        return "ENUM_LABEL_66";
      }
      case 67: {
        return "ENUM_LABEL_67";
      }
      case 68: {
        return "ENUM_LABEL_68";
      }
      case 69: {
        return "ENUM_LABEL_69";
      }
      case 70: {
        return "ENUM_LABEL_70";
      }
      case 71: {
        return "ENUM_LABEL_71";
      }
      case 72: {
        return "ENUM_LABEL_72";
      }
      case 73: {
        return "ENUM_LABEL_73";
      }
      case 74: {
        return "ENUM_LABEL_74";
      }
      case 75: {
        return "ENUM_LABEL_75";
      }
      case 76: {
        return "ENUM_LABEL_76";
      }
      case 77: {
        return "ENUM_LABEL_77";
      }
      case 78: {
        return "ENUM_LABEL_78";
      }
      case 79: {
        return "ENUM_LABEL_79";
      }
      case 80: {
        return "ENUM_LABEL_80";
      }
      case 81: {
        return "ENUM_LABEL_81";
      }
      case 82: {
        return "ENUM_LABEL_82";
      }
      case 83: {
        return "ENUM_LABEL_83";
      }
      case 84: {
        return "ENUM_LABEL_84";
      }
      case 85: {
        return "ENUM_LABEL_85";
      }
      case 86: {
        return "ENUM_LABEL_86";
      }
      case 87: {
        return "ENUM_LABEL_87";
      }
      case 88: {
        return "ENUM_LABEL_88";
      }
      case 89: {
        return "ENUM_LABEL_89";
      }
      case 90: {
        return "ENUM_LABEL_90";
      }
      case 91: {
        return "ENUM_LABEL_91";
      }
      case 92: {
        return "ENUM_LABEL_92";
      }
      case 93: {
        return "ENUM_LABEL_93";
      }
      case 94: {
        return "ENUM_LABEL_94";
      }
      case 95: {
        return "ENUM_LABEL_95";
      }
      case 96: {
        return "ENUM_LABEL_96";
      }
      case 97: {
        return "ENUM_LABEL_97";
      }
      case 98: {
        return "ENUM_LABEL_98";
      }
      case 99: {
        return "ENUM_LABEL_99";
      }
      case 100: {
        return "ENUM_LABEL_100";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as VeryLargeEnum;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: VeryLargeEnum): number {
    switch (i) {
      case "ENUM_LABEL_DEFAULT": {
        return 0;
      }
      case "ENUM_LABEL_1": {
        return 1;
      }
      case "ENUM_LABEL_2": {
        return 2;
      }
      case "ENUM_LABEL_3": {
        return 3;
      }
      case "ENUM_LABEL_4": {
        return 4;
      }
      case "ENUM_LABEL_5": {
        return 5;
      }
      case "ENUM_LABEL_6": {
        return 6;
      }
      case "ENUM_LABEL_7": {
        return 7;
      }
      case "ENUM_LABEL_8": {
        return 8;
      }
      case "ENUM_LABEL_9": {
        return 9;
      }
      case "ENUM_LABEL_10": {
        return 10;
      }
      case "ENUM_LABEL_11": {
        return 11;
      }
      case "ENUM_LABEL_12": {
        return 12;
      }
      case "ENUM_LABEL_13": {
        return 13;
      }
      case "ENUM_LABEL_14": {
        return 14;
      }
      case "ENUM_LABEL_15": {
        return 15;
      }
      case "ENUM_LABEL_16": {
        return 16;
      }
      case "ENUM_LABEL_17": {
        return 17;
      }
      case "ENUM_LABEL_18": {
        return 18;
      }
      case "ENUM_LABEL_19": {
        return 19;
      }
      case "ENUM_LABEL_20": {
        return 20;
      }
      case "ENUM_LABEL_21": {
        return 21;
      }
      case "ENUM_LABEL_22": {
        return 22;
      }
      case "ENUM_LABEL_23": {
        return 23;
      }
      case "ENUM_LABEL_24": {
        return 24;
      }
      case "ENUM_LABEL_25": {
        return 25;
      }
      case "ENUM_LABEL_26": {
        return 26;
      }
      case "ENUM_LABEL_27": {
        return 27;
      }
      case "ENUM_LABEL_28": {
        return 28;
      }
      case "ENUM_LABEL_29": {
        return 29;
      }
      case "ENUM_LABEL_30": {
        return 30;
      }
      case "ENUM_LABEL_31": {
        return 31;
      }
      case "ENUM_LABEL_32": {
        return 32;
      }
      case "ENUM_LABEL_33": {
        return 33;
      }
      case "ENUM_LABEL_34": {
        return 34;
      }
      case "ENUM_LABEL_35": {
        return 35;
      }
      case "ENUM_LABEL_36": {
        return 36;
      }
      case "ENUM_LABEL_37": {
        return 37;
      }
      case "ENUM_LABEL_38": {
        return 38;
      }
      case "ENUM_LABEL_39": {
        return 39;
      }
      case "ENUM_LABEL_40": {
        return 40;
      }
      case "ENUM_LABEL_41": {
        return 41;
      }
      case "ENUM_LABEL_42": {
        return 42;
      }
      case "ENUM_LABEL_43": {
        return 43;
      }
      case "ENUM_LABEL_44": {
        return 44;
      }
      case "ENUM_LABEL_45": {
        return 45;
      }
      case "ENUM_LABEL_46": {
        return 46;
      }
      case "ENUM_LABEL_47": {
        return 47;
      }
      case "ENUM_LABEL_48": {
        return 48;
      }
      case "ENUM_LABEL_49": {
        return 49;
      }
      case "ENUM_LABEL_50": {
        return 50;
      }
      case "ENUM_LABEL_51": {
        return 51;
      }
      case "ENUM_LABEL_52": {
        return 52;
      }
      case "ENUM_LABEL_53": {
        return 53;
      }
      case "ENUM_LABEL_54": {
        return 54;
      }
      case "ENUM_LABEL_55": {
        return 55;
      }
      case "ENUM_LABEL_56": {
        return 56;
      }
      case "ENUM_LABEL_57": {
        return 57;
      }
      case "ENUM_LABEL_58": {
        return 58;
      }
      case "ENUM_LABEL_59": {
        return 59;
      }
      case "ENUM_LABEL_60": {
        return 60;
      }
      case "ENUM_LABEL_61": {
        return 61;
      }
      case "ENUM_LABEL_62": {
        return 62;
      }
      case "ENUM_LABEL_63": {
        return 63;
      }
      case "ENUM_LABEL_64": {
        return 64;
      }
      case "ENUM_LABEL_65": {
        return 65;
      }
      case "ENUM_LABEL_66": {
        return 66;
      }
      case "ENUM_LABEL_67": {
        return 67;
      }
      case "ENUM_LABEL_68": {
        return 68;
      }
      case "ENUM_LABEL_69": {
        return 69;
      }
      case "ENUM_LABEL_70": {
        return 70;
      }
      case "ENUM_LABEL_71": {
        return 71;
      }
      case "ENUM_LABEL_72": {
        return 72;
      }
      case "ENUM_LABEL_73": {
        return 73;
      }
      case "ENUM_LABEL_74": {
        return 74;
      }
      case "ENUM_LABEL_75": {
        return 75;
      }
      case "ENUM_LABEL_76": {
        return 76;
      }
      case "ENUM_LABEL_77": {
        return 77;
      }
      case "ENUM_LABEL_78": {
        return 78;
      }
      case "ENUM_LABEL_79": {
        return 79;
      }
      case "ENUM_LABEL_80": {
        return 80;
      }
      case "ENUM_LABEL_81": {
        return 81;
      }
      case "ENUM_LABEL_82": {
        return 82;
      }
      case "ENUM_LABEL_83": {
        return 83;
      }
      case "ENUM_LABEL_84": {
        return 84;
      }
      case "ENUM_LABEL_85": {
        return 85;
      }
      case "ENUM_LABEL_86": {
        return 86;
      }
      case "ENUM_LABEL_87": {
        return 87;
      }
      case "ENUM_LABEL_88": {
        return 88;
      }
      case "ENUM_LABEL_89": {
        return 89;
      }
      case "ENUM_LABEL_90": {
        return 90;
      }
      case "ENUM_LABEL_91": {
        return 91;
      }
      case "ENUM_LABEL_92": {
        return 92;
      }
      case "ENUM_LABEL_93": {
        return 93;
      }
      case "ENUM_LABEL_94": {
        return 94;
      }
      case "ENUM_LABEL_95": {
        return 95;
      }
      case "ENUM_LABEL_96": {
        return 96;
      }
      case "ENUM_LABEL_97": {
        return 97;
      }
      case "ENUM_LABEL_98": {
        return 98;
      }
      case "ENUM_LABEL_99": {
        return 99;
      }
      case "ENUM_LABEL_100": {
        return 100;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const TestAllTypesJSON = {
  /**
   * Serializes TestAllTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestAllTypes>): string {
    return JSON.stringify(TestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestAllTypes from JSON.
   */
  decode: function (json: string): TestAllTypes {
    return TestAllTypesJSON._readMessage(
      TestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestAllTypes with all fields set to their default value.
   */
  initialize: function (): TestAllTypes {
    return {
      optionalInt32: 0,
      optionalInt64: 0n,
      optionalUint32: 0,
      optionalUint64: 0n,
      optionalSint32: 0,
      optionalSint64: 0n,
      optionalFixed32: 0,
      optionalFixed64: 0n,
      optionalSfixed32: 0,
      optionalSfixed64: 0n,
      optionalFloat: 0,
      optionalDouble: 0,
      optionalBool: false,
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalNestedMessage: TestAllTypesJSON.NestedMessage.initialize(),
      optionalForeignMessage: ForeignMessageJSON.initialize(),
      optionalImportMessage:
        googleProtobufUnittest_import.ImportMessageJSON.initialize(),
      optionalNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      optionalForeignEnum: ForeignEnum._fromInt(0),
      optionalImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      optionalStringPiece: "",
      optionalCord: "",
      optionalPublicImportMessage:
        googleProtobufUnittest_import_public.PublicImportMessageJSON.initialize(),
      optionalLazyMessage: TestAllTypesJSON.NestedMessage.initialize(),
      repeatedInt32: [],
      repeatedInt64: [],
      repeatedUint32: [],
      repeatedUint64: [],
      repeatedSint32: [],
      repeatedSint64: [],
      repeatedFixed32: [],
      repeatedFixed64: [],
      repeatedSfixed32: [],
      repeatedSfixed64: [],
      repeatedFloat: [],
      repeatedDouble: [],
      repeatedBool: [],
      repeatedString: [],
      repeatedBytes: [],
      repeatedNestedMessage: [],
      repeatedForeignMessage: [],
      repeatedImportMessage: [],
      repeatedNestedEnum: [],
      repeatedForeignEnum: [],
      repeatedImportEnum: [],
      repeatedStringPiece: [],
      repeatedCord: [],
      repeatedLazyMessage: [],
      defaultInt32: 0,
      defaultInt64: 0n,
      defaultUint32: 0,
      defaultUint64: 0n,
      defaultSint32: 0,
      defaultSint64: 0n,
      defaultFixed32: 0,
      defaultFixed64: 0n,
      defaultSfixed32: 0,
      defaultSfixed64: 0n,
      defaultFloat: 0,
      defaultDouble: 0,
      defaultBool: false,
      defaultString: "",
      defaultBytes: new Uint8Array(),
      defaultNestedEnum: TestAllTypes.NestedEnum._fromInt(0),
      defaultForeignEnum: ForeignEnum._fromInt(0),
      defaultImportEnum: googleProtobufUnittest_import.ImportEnum._fromInt(0),
      defaultStringPiece: "",
      defaultCord: "",
      oneofUint32: undefined,
      oneofNestedMessage: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestAllTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.optionalInt64) {
      json["optionalInt64"] = msg.optionalInt64.toString();
    }
    if (msg.optionalUint32) {
      json["optionalUint32"] = msg.optionalUint32;
    }
    if (msg.optionalUint64) {
      json["optionalUint64"] = msg.optionalUint64.toString();
    }
    if (msg.optionalSint32) {
      json["optionalSint32"] = msg.optionalSint32;
    }
    if (msg.optionalSint64) {
      json["optionalSint64"] = msg.optionalSint64.toString();
    }
    if (msg.optionalFixed32) {
      json["optionalFixed32"] = msg.optionalFixed32;
    }
    if (msg.optionalFixed64) {
      json["optionalFixed64"] = msg.optionalFixed64.toString();
    }
    if (msg.optionalSfixed32) {
      json["optionalSfixed32"] = msg.optionalSfixed32;
    }
    if (msg.optionalSfixed64) {
      json["optionalSfixed64"] = msg.optionalSfixed64.toString();
    }
    if (msg.optionalFloat) {
      json["optionalFloat"] = msg.optionalFloat;
    }
    if (msg.optionalDouble) {
      json["optionalDouble"] = msg.optionalDouble;
    }
    if (msg.optionalBool) {
      json["optionalBool"] = msg.optionalBool;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalNestedMessage);
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    if (msg.optionalForeignMessage) {
      const _optionalForeignMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalForeignMessage,
      );
      if (Object.keys(_optionalForeignMessage_).length > 0) {
        json["optionalForeignMessage"] = _optionalForeignMessage_;
      }
    }
    if (msg.optionalImportMessage) {
      const _optionalImportMessage_ =
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage(
          msg.optionalImportMessage,
        );
      if (Object.keys(_optionalImportMessage_).length > 0) {
        json["optionalImportMessage"] = _optionalImportMessage_;
      }
    }
    if (
      msg.optionalNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.optionalNestedEnum)
    ) {
      json["optionalNestedEnum"] = msg.optionalNestedEnum;
    }
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    if (
      msg.optionalImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(
        msg.optionalImportEnum,
      )
    ) {
      json["optionalImportEnum"] = msg.optionalImportEnum;
    }
    if (msg.optionalStringPiece) {
      json["optionalStringPiece"] = msg.optionalStringPiece;
    }
    if (msg.optionalCord) {
      json["optionalCord"] = msg.optionalCord;
    }
    if (msg.optionalPublicImportMessage) {
      const _optionalPublicImportMessage_ =
        googleProtobufUnittest_import_public.PublicImportMessageJSON._writeMessage(
          msg.optionalPublicImportMessage,
        );
      if (Object.keys(_optionalPublicImportMessage_).length > 0) {
        json["optionalPublicImportMessage"] = _optionalPublicImportMessage_;
      }
    }
    if (msg.optionalLazyMessage) {
      const _optionalLazyMessage_ =
        TestAllTypesJSON.NestedMessage._writeMessage(msg.optionalLazyMessage);
      if (Object.keys(_optionalLazyMessage_).length > 0) {
        json["optionalLazyMessage"] = _optionalLazyMessage_;
      }
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedUint32?.length) {
      json["repeatedUint32"] = msg.repeatedUint32;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    if (msg.repeatedSint32?.length) {
      json["repeatedSint32"] = msg.repeatedSint32;
    }
    if (msg.repeatedSint64?.length) {
      json["repeatedSint64"] = msg.repeatedSint64.map((x) => x.toString());
    }
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedSfixed32?.length) {
      json["repeatedSfixed32"] = msg.repeatedSfixed32;
    }
    if (msg.repeatedSfixed64?.length) {
      json["repeatedSfixed64"] = msg.repeatedSfixed64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedDouble?.length) {
      json["repeatedDouble"] = msg.repeatedDouble;
    }
    if (msg.repeatedBool?.length) {
      json["repeatedBool"] = msg.repeatedBool;
    }
    if (msg.repeatedString?.length) {
      json["repeatedString"] = msg.repeatedString;
    }
    if (msg.repeatedBytes?.length) {
      json["repeatedBytes"] = msg.repeatedBytes.map(encodeBase64Bytes);
    }
    if (msg.repeatedNestedMessage?.length) {
      json["repeatedNestedMessage"] = msg.repeatedNestedMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.repeatedForeignMessage?.length) {
      json["repeatedForeignMessage"] = msg.repeatedForeignMessage.map(
        ForeignMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedImportMessage?.length) {
      json["repeatedImportMessage"] = msg.repeatedImportMessage.map(
        googleProtobufUnittest_import.ImportMessageJSON._writeMessage,
      );
    }
    if (msg.repeatedNestedEnum?.length) {
      json["repeatedNestedEnum"] = msg.repeatedNestedEnum;
    }
    if (msg.repeatedForeignEnum?.length) {
      json["repeatedForeignEnum"] = msg.repeatedForeignEnum;
    }
    if (msg.repeatedImportEnum?.length) {
      json["repeatedImportEnum"] = msg.repeatedImportEnum;
    }
    if (msg.repeatedStringPiece?.length) {
      json["repeatedStringPiece"] = msg.repeatedStringPiece;
    }
    if (msg.repeatedCord?.length) {
      json["repeatedCord"] = msg.repeatedCord;
    }
    if (msg.repeatedLazyMessage?.length) {
      json["repeatedLazyMessage"] = msg.repeatedLazyMessage.map(
        TestAllTypesJSON.NestedMessage._writeMessage,
      );
    }
    if (msg.defaultInt32) {
      json["defaultInt32"] = msg.defaultInt32;
    }
    if (msg.defaultInt64) {
      json["defaultInt64"] = msg.defaultInt64.toString();
    }
    if (msg.defaultUint32) {
      json["defaultUint32"] = msg.defaultUint32;
    }
    if (msg.defaultUint64) {
      json["defaultUint64"] = msg.defaultUint64.toString();
    }
    if (msg.defaultSint32) {
      json["defaultSint32"] = msg.defaultSint32;
    }
    if (msg.defaultSint64) {
      json["defaultSint64"] = msg.defaultSint64.toString();
    }
    if (msg.defaultFixed32) {
      json["defaultFixed32"] = msg.defaultFixed32;
    }
    if (msg.defaultFixed64) {
      json["defaultFixed64"] = msg.defaultFixed64.toString();
    }
    if (msg.defaultSfixed32) {
      json["defaultSfixed32"] = msg.defaultSfixed32;
    }
    if (msg.defaultSfixed64) {
      json["defaultSfixed64"] = msg.defaultSfixed64.toString();
    }
    if (msg.defaultFloat) {
      json["defaultFloat"] = msg.defaultFloat;
    }
    if (msg.defaultDouble) {
      json["defaultDouble"] = msg.defaultDouble;
    }
    if (msg.defaultBool) {
      json["defaultBool"] = msg.defaultBool;
    }
    if (msg.defaultString) {
      json["defaultString"] = msg.defaultString;
    }
    if (msg.defaultBytes?.length) {
      json["defaultBytes"] = encodeBase64Bytes(msg.defaultBytes);
    }
    if (
      msg.defaultNestedEnum &&
      TestAllTypesJSON.NestedEnum._toInt(msg.defaultNestedEnum)
    ) {
      json["defaultNestedEnum"] = msg.defaultNestedEnum;
    }
    if (
      msg.defaultForeignEnum &&
      ForeignEnumJSON._toInt(msg.defaultForeignEnum)
    ) {
      json["defaultForeignEnum"] = msg.defaultForeignEnum;
    }
    if (
      msg.defaultImportEnum &&
      googleProtobufUnittest_import.ImportEnumJSON._toInt(msg.defaultImportEnum)
    ) {
      json["defaultImportEnum"] = msg.defaultImportEnum;
    }
    if (msg.defaultStringPiece) {
      json["defaultStringPiece"] = msg.defaultStringPiece;
    }
    if (msg.defaultCord) {
      json["defaultCord"] = msg.defaultCord;
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofNestedMessage != undefined) {
      const _oneofNestedMessage_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.oneofNestedMessage,
      );
      json["oneofNestedMessage"] = _oneofNestedMessage_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestAllTypes, json: any): TestAllTypes {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _optionalInt64_ = json["optionalInt64"] ?? json["optional_int64"];
    if (_optionalInt64_) {
      msg.optionalInt64 = BigInt(_optionalInt64_);
    }
    const _optionalUint32_ = json["optionalUint32"] ?? json["optional_uint32"];
    if (_optionalUint32_) {
      msg.optionalUint32 = _optionalUint32_;
    }
    const _optionalUint64_ = json["optionalUint64"] ?? json["optional_uint64"];
    if (_optionalUint64_) {
      msg.optionalUint64 = BigInt(_optionalUint64_);
    }
    const _optionalSint32_ = json["optionalSint32"] ?? json["optional_sint32"];
    if (_optionalSint32_) {
      msg.optionalSint32 = _optionalSint32_;
    }
    const _optionalSint64_ = json["optionalSint64"] ?? json["optional_sint64"];
    if (_optionalSint64_) {
      msg.optionalSint64 = BigInt(_optionalSint64_);
    }
    const _optionalFixed32_ =
      json["optionalFixed32"] ?? json["optional_fixed32"];
    if (_optionalFixed32_) {
      msg.optionalFixed32 = _optionalFixed32_;
    }
    const _optionalFixed64_ =
      json["optionalFixed64"] ?? json["optional_fixed64"];
    if (_optionalFixed64_) {
      msg.optionalFixed64 = BigInt(_optionalFixed64_);
    }
    const _optionalSfixed32_ =
      json["optionalSfixed32"] ?? json["optional_sfixed32"];
    if (_optionalSfixed32_) {
      msg.optionalSfixed32 = _optionalSfixed32_;
    }
    const _optionalSfixed64_ =
      json["optionalSfixed64"] ?? json["optional_sfixed64"];
    if (_optionalSfixed64_) {
      msg.optionalSfixed64 = BigInt(_optionalSfixed64_);
    }
    const _optionalFloat_ = json["optionalFloat"] ?? json["optional_float"];
    if (_optionalFloat_) {
      msg.optionalFloat = _optionalFloat_;
    }
    const _optionalDouble_ = json["optionalDouble"] ?? json["optional_double"];
    if (_optionalDouble_) {
      msg.optionalDouble = _optionalDouble_;
    }
    const _optionalBool_ = json["optionalBool"] ?? json["optional_bool"];
    if (_optionalBool_) {
      msg.optionalBool = _optionalBool_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    const _optionalForeignMessage_ =
      json["optionalForeignMessage"] ?? json["optional_foreign_message"];
    if (_optionalForeignMessage_) {
      ForeignMessageJSON._readMessage(
        msg.optionalForeignMessage,
        _optionalForeignMessage_,
      );
    }
    const _optionalImportMessage_ =
      json["optionalImportMessage"] ?? json["optional_import_message"];
    if (_optionalImportMessage_) {
      googleProtobufUnittest_import.ImportMessageJSON._readMessage(
        msg.optionalImportMessage,
        _optionalImportMessage_,
      );
    }
    const _optionalNestedEnum_ =
      json["optionalNestedEnum"] ?? json["optional_nested_enum"];
    if (_optionalNestedEnum_) {
      msg.optionalNestedEnum = _optionalNestedEnum_;
    }
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    const _optionalImportEnum_ =
      json["optionalImportEnum"] ?? json["optional_import_enum"];
    if (_optionalImportEnum_) {
      msg.optionalImportEnum = _optionalImportEnum_;
    }
    const _optionalStringPiece_ =
      json["optionalStringPiece"] ?? json["optional_string_piece"];
    if (_optionalStringPiece_) {
      msg.optionalStringPiece = _optionalStringPiece_;
    }
    const _optionalCord_ = json["optionalCord"] ?? json["optional_cord"];
    if (_optionalCord_) {
      msg.optionalCord = _optionalCord_;
    }
    const _optionalPublicImportMessage_ =
      json["optionalPublicImportMessage"] ??
      json["optional_public_import_message"];
    if (_optionalPublicImportMessage_) {
      googleProtobufUnittest_import_public.PublicImportMessageJSON._readMessage(
        msg.optionalPublicImportMessage,
        _optionalPublicImportMessage_,
      );
    }
    const _optionalLazyMessage_ =
      json["optionalLazyMessage"] ?? json["optional_lazy_message"];
    if (_optionalLazyMessage_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.optionalLazyMessage,
        _optionalLazyMessage_,
      );
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedUint32_ = json["repeatedUint32"] ?? json["repeated_uint32"];
    if (_repeatedUint32_) {
      msg.repeatedUint32 = _repeatedUint32_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    const _repeatedSint32_ = json["repeatedSint32"] ?? json["repeated_sint32"];
    if (_repeatedSint32_) {
      msg.repeatedSint32 = _repeatedSint32_;
    }
    const _repeatedSint64_ = json["repeatedSint64"] ?? json["repeated_sint64"];
    if (_repeatedSint64_) {
      msg.repeatedSint64 = _repeatedSint64_.map(BigInt);
    }
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedSfixed32_ =
      json["repeatedSfixed32"] ?? json["repeated_sfixed32"];
    if (_repeatedSfixed32_) {
      msg.repeatedSfixed32 = _repeatedSfixed32_;
    }
    const _repeatedSfixed64_ =
      json["repeatedSfixed64"] ?? json["repeated_sfixed64"];
    if (_repeatedSfixed64_) {
      msg.repeatedSfixed64 = _repeatedSfixed64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedDouble_ = json["repeatedDouble"] ?? json["repeated_double"];
    if (_repeatedDouble_) {
      msg.repeatedDouble = _repeatedDouble_;
    }
    const _repeatedBool_ = json["repeatedBool"] ?? json["repeated_bool"];
    if (_repeatedBool_) {
      msg.repeatedBool = _repeatedBool_;
    }
    const _repeatedString_ = json["repeatedString"] ?? json["repeated_string"];
    if (_repeatedString_) {
      msg.repeatedString = _repeatedString_;
    }
    const _repeatedBytes_ = json["repeatedBytes"] ?? json["repeated_bytes"];
    if (_repeatedBytes_) {
      msg.repeatedBytes = _repeatedBytes_.map(decodeBase64Bytes);
    }
    const _repeatedNestedMessage_ =
      json["repeatedNestedMessage"] ?? json["repeated_nested_message"];
    if (_repeatedNestedMessage_) {
      for (const item of _repeatedNestedMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedNestedMessage.push(m);
      }
    }
    const _repeatedForeignMessage_ =
      json["repeatedForeignMessage"] ?? json["repeated_foreign_message"];
    if (_repeatedForeignMessage_) {
      for (const item of _repeatedForeignMessage_) {
        const m = ForeignMessageJSON.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.repeatedForeignMessage.push(m);
      }
    }
    const _repeatedImportMessage_ =
      json["repeatedImportMessage"] ?? json["repeated_import_message"];
    if (_repeatedImportMessage_) {
      for (const item of _repeatedImportMessage_) {
        const m = googleProtobufUnittest_import.ImportMessageJSON.initialize();
        googleProtobufUnittest_import.ImportMessageJSON._readMessage(m, item);
        msg.repeatedImportMessage.push(m);
      }
    }
    const _repeatedNestedEnum_ =
      json["repeatedNestedEnum"] ?? json["repeated_nested_enum"];
    if (_repeatedNestedEnum_) {
      msg.repeatedNestedEnum = _repeatedNestedEnum_;
    }
    const _repeatedForeignEnum_ =
      json["repeatedForeignEnum"] ?? json["repeated_foreign_enum"];
    if (_repeatedForeignEnum_) {
      msg.repeatedForeignEnum = _repeatedForeignEnum_;
    }
    const _repeatedImportEnum_ =
      json["repeatedImportEnum"] ?? json["repeated_import_enum"];
    if (_repeatedImportEnum_) {
      msg.repeatedImportEnum = _repeatedImportEnum_;
    }
    const _repeatedStringPiece_ =
      json["repeatedStringPiece"] ?? json["repeated_string_piece"];
    if (_repeatedStringPiece_) {
      msg.repeatedStringPiece = _repeatedStringPiece_;
    }
    const _repeatedCord_ = json["repeatedCord"] ?? json["repeated_cord"];
    if (_repeatedCord_) {
      msg.repeatedCord = _repeatedCord_;
    }
    const _repeatedLazyMessage_ =
      json["repeatedLazyMessage"] ?? json["repeated_lazy_message"];
    if (_repeatedLazyMessage_) {
      for (const item of _repeatedLazyMessage_) {
        const m = TestAllTypesJSON.NestedMessage.initialize();
        TestAllTypesJSON.NestedMessage._readMessage(m, item);
        msg.repeatedLazyMessage.push(m);
      }
    }
    const _defaultInt32_ = json["defaultInt32"] ?? json["default_int32"];
    if (_defaultInt32_) {
      msg.defaultInt32 = _defaultInt32_;
    }
    const _defaultInt64_ = json["defaultInt64"] ?? json["default_int64"];
    if (_defaultInt64_) {
      msg.defaultInt64 = BigInt(_defaultInt64_);
    }
    const _defaultUint32_ = json["defaultUint32"] ?? json["default_uint32"];
    if (_defaultUint32_) {
      msg.defaultUint32 = _defaultUint32_;
    }
    const _defaultUint64_ = json["defaultUint64"] ?? json["default_uint64"];
    if (_defaultUint64_) {
      msg.defaultUint64 = BigInt(_defaultUint64_);
    }
    const _defaultSint32_ = json["defaultSint32"] ?? json["default_sint32"];
    if (_defaultSint32_) {
      msg.defaultSint32 = _defaultSint32_;
    }
    const _defaultSint64_ = json["defaultSint64"] ?? json["default_sint64"];
    if (_defaultSint64_) {
      msg.defaultSint64 = BigInt(_defaultSint64_);
    }
    const _defaultFixed32_ = json["defaultFixed32"] ?? json["default_fixed32"];
    if (_defaultFixed32_) {
      msg.defaultFixed32 = _defaultFixed32_;
    }
    const _defaultFixed64_ = json["defaultFixed64"] ?? json["default_fixed64"];
    if (_defaultFixed64_) {
      msg.defaultFixed64 = BigInt(_defaultFixed64_);
    }
    const _defaultSfixed32_ =
      json["defaultSfixed32"] ?? json["default_sfixed32"];
    if (_defaultSfixed32_) {
      msg.defaultSfixed32 = _defaultSfixed32_;
    }
    const _defaultSfixed64_ =
      json["defaultSfixed64"] ?? json["default_sfixed64"];
    if (_defaultSfixed64_) {
      msg.defaultSfixed64 = BigInt(_defaultSfixed64_);
    }
    const _defaultFloat_ = json["defaultFloat"] ?? json["default_float"];
    if (_defaultFloat_) {
      msg.defaultFloat = _defaultFloat_;
    }
    const _defaultDouble_ = json["defaultDouble"] ?? json["default_double"];
    if (_defaultDouble_) {
      msg.defaultDouble = _defaultDouble_;
    }
    const _defaultBool_ = json["defaultBool"] ?? json["default_bool"];
    if (_defaultBool_) {
      msg.defaultBool = _defaultBool_;
    }
    const _defaultString_ = json["defaultString"] ?? json["default_string"];
    if (_defaultString_) {
      msg.defaultString = _defaultString_;
    }
    const _defaultBytes_ = json["defaultBytes"] ?? json["default_bytes"];
    if (_defaultBytes_) {
      msg.defaultBytes = decodeBase64Bytes(_defaultBytes_);
    }
    const _defaultNestedEnum_ =
      json["defaultNestedEnum"] ?? json["default_nested_enum"];
    if (_defaultNestedEnum_) {
      msg.defaultNestedEnum = _defaultNestedEnum_;
    }
    const _defaultForeignEnum_ =
      json["defaultForeignEnum"] ?? json["default_foreign_enum"];
    if (_defaultForeignEnum_) {
      msg.defaultForeignEnum = _defaultForeignEnum_;
    }
    const _defaultImportEnum_ =
      json["defaultImportEnum"] ?? json["default_import_enum"];
    if (_defaultImportEnum_) {
      msg.defaultImportEnum = _defaultImportEnum_;
    }
    const _defaultStringPiece_ =
      json["defaultStringPiece"] ?? json["default_string_piece"];
    if (_defaultStringPiece_) {
      msg.defaultStringPiece = _defaultStringPiece_;
    }
    const _defaultCord_ = json["defaultCord"] ?? json["default_cord"];
    if (_defaultCord_) {
      msg.defaultCord = _defaultCord_;
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofNestedMessage_ =
      json["oneofNestedMessage"] ?? json["oneof_nested_message"];
    if (_oneofNestedMessage_) {
      msg.oneofNestedMessage = TestAllTypesJSON.NestedMessage.initialize();
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.oneofNestedMessage,
        _oneofNestedMessage_,
      );
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    NEG: "NEG",
    /**
     * @private
     */
    _fromInt: function (i: number): TestAllTypes.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        case -1: {
          return "NEG";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestAllTypes.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestAllTypes.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        case "NEG": {
          return -1;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  NestedMessage: {
    /**
     * Serializes TestAllTypes.NestedMessage to JSON.
     */
    encode: function (msg: PartialDeep<TestAllTypes.NestedMessage>): string {
      return JSON.stringify(TestAllTypesJSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.NestedMessage from JSON.
     */
    decode: function (json: string): TestAllTypes.NestedMessage {
      return TestAllTypesJSON.NestedMessage._readMessage(
        TestAllTypesJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.NestedMessage,
      json: any,
    ): TestAllTypes.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestAllTypes.OptionalGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestAllTypes.OptionalGroup>): string {
      return JSON.stringify(TestAllTypesJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.OptionalGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.OptionalGroup {
      return TestAllTypesJSON.OptionalGroup._readMessage(
        TestAllTypesJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.OptionalGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.OptionalGroup,
      json: any,
    ): TestAllTypes.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestAllTypes.RepeatedGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestAllTypes.RepeatedGroup>): string {
      return JSON.stringify(TestAllTypesJSON.RepeatedGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestAllTypes.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestAllTypes.RepeatedGroup {
      return TestAllTypesJSON.RepeatedGroup._readMessage(
        TestAllTypesJSON.RepeatedGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestAllTypes.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestAllTypes.RepeatedGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestAllTypes.RepeatedGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestAllTypes.RepeatedGroup,
      json: any,
    ): TestAllTypes.RepeatedGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const NestedTestAllTypesJSON = {
  /**
   * Serializes NestedTestAllTypes to JSON.
   */
  encode: function (msg: PartialDeep<NestedTestAllTypes>): string {
    return JSON.stringify(NestedTestAllTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes NestedTestAllTypes from JSON.
   */
  decode: function (json: string): NestedTestAllTypes {
    return NestedTestAllTypesJSON._readMessage(
      NestedTestAllTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes NestedTestAllTypes with all fields set to their default value.
   */
  initialize: function (): NestedTestAllTypes {
    return {
      child: undefined,
      payload: TestAllTypesJSON.initialize(),
      repeatedChild: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<NestedTestAllTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.child) {
      const _child_ = NestedTestAllTypesJSON._writeMessage(msg.child);
      if (Object.keys(_child_).length > 0) {
        json["child"] = _child_;
      }
    }
    if (msg.payload) {
      const _payload_ = TestAllTypesJSON._writeMessage(msg.payload);
      if (Object.keys(_payload_).length > 0) {
        json["payload"] = _payload_;
      }
    }
    if (msg.repeatedChild?.length) {
      json["repeatedChild"] = msg.repeatedChild.map(
        NestedTestAllTypesJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: NestedTestAllTypes,
    json: any,
  ): NestedTestAllTypes {
    const _child_ = json["child"];
    if (_child_) {
      msg.child = NestedTestAllTypesJSON.initialize();
      NestedTestAllTypesJSON._readMessage(msg.child, _child_);
    }
    const _payload_ = json["payload"];
    if (_payload_) {
      TestAllTypesJSON._readMessage(msg.payload, _payload_);
    }
    const _repeatedChild_ = json["repeatedChild"] ?? json["repeated_child"];
    if (_repeatedChild_) {
      for (const item of _repeatedChild_) {
        const m = NestedTestAllTypesJSON.initialize();
        NestedTestAllTypesJSON._readMessage(m, item);
        msg.repeatedChild.push(m);
      }
    }
    return msg;
  },
};

export const TestDeprecatedFieldsJSON = {
  /**
   * Serializes TestDeprecatedFields to JSON.
   */
  encode: function (msg: PartialDeep<TestDeprecatedFields>): string {
    return JSON.stringify(TestDeprecatedFieldsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDeprecatedFields from JSON.
   */
  decode: function (json: string): TestDeprecatedFields {
    return TestDeprecatedFieldsJSON._readMessage(
      TestDeprecatedFieldsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDeprecatedFields with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedFields {
    return {
      deprecatedInt32: 0,
      deprecatedInt32InOneof: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDeprecatedFields>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.deprecatedInt32) {
      json["deprecatedInt32"] = msg.deprecatedInt32;
    }
    if (msg.deprecatedInt32InOneof != undefined) {
      json["deprecatedInt32InOneof"] = msg.deprecatedInt32InOneof;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedFields,
    json: any,
  ): TestDeprecatedFields {
    const _deprecatedInt32_ =
      json["deprecatedInt32"] ?? json["deprecated_int32"];
    if (_deprecatedInt32_) {
      msg.deprecatedInt32 = _deprecatedInt32_;
    }
    const _deprecatedInt32InOneof_ =
      json["deprecatedInt32InOneof"] ?? json["deprecated_int32_in_oneof"];
    if (_deprecatedInt32InOneof_) {
      msg.deprecatedInt32InOneof = _deprecatedInt32InOneof_;
    }
    return msg;
  },
};

export const TestDeprecatedMessageJSON = {
  /**
   * Serializes TestDeprecatedMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<TestDeprecatedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestDeprecatedMessage from JSON.
   */
  decode: function (_json?: string): TestDeprecatedMessage {
    return {};
  },

  /**
   * Initializes TestDeprecatedMessage with all fields set to their default value.
   */
  initialize: function (): TestDeprecatedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestDeprecatedMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDeprecatedMessage,
    _json: any,
  ): TestDeprecatedMessage {
    return msg;
  },
};

export const ForeignMessageJSON = {
  /**
   * Serializes ForeignMessage to JSON.
   */
  encode: function (msg: PartialDeep<ForeignMessage>): string {
    return JSON.stringify(ForeignMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes ForeignMessage from JSON.
   */
  decode: function (json: string): ForeignMessage {
    return ForeignMessageJSON._readMessage(
      ForeignMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes ForeignMessage with all fields set to their default value.
   */
  initialize: function (): ForeignMessage {
    return {
      c: 0,
      d: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<ForeignMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.c) {
      json["c"] = msg.c;
    }
    if (msg.d) {
      json["d"] = msg.d;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: ForeignMessage, json: any): ForeignMessage {
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    const _d_ = json["d"];
    if (_d_) {
      msg.d = _d_;
    }
    return msg;
  },
};

export const TestReservedFieldsJSON = {
  /**
   * Serializes TestReservedFields to JSON.
   */
  encode: function (_msg?: PartialDeep<TestReservedFields>): string {
    return "{}";
  },

  /**
   * Deserializes TestReservedFields from JSON.
   */
  decode: function (_json?: string): TestReservedFields {
    return {};
  },

  /**
   * Initializes TestReservedFields with all fields set to their default value.
   */
  initialize: function (): TestReservedFields {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestReservedFields>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReservedFields,
    _json: any,
  ): TestReservedFields {
    return msg;
  },
};

export const TestAllExtensionsJSON = {
  /**
   * Serializes TestAllExtensions to JSON.
   */
  encode: function (_msg?: PartialDeep<TestAllExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestAllExtensions from JSON.
   */
  decode: function (_json?: string): TestAllExtensions {
    return {};
  },

  /**
   * Initializes TestAllExtensions with all fields set to their default value.
   */
  initialize: function (): TestAllExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestAllExtensions>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestAllExtensions,
    _json: any,
  ): TestAllExtensions {
    return msg;
  },
};

export const OptionalGroup_extensionJSON = {
  /**
   * Serializes OptionalGroup_extension to JSON.
   */
  encode: function (msg: PartialDeep<OptionalGroup_extension>): string {
    return JSON.stringify(OptionalGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes OptionalGroup_extension from JSON.
   */
  decode: function (json: string): OptionalGroup_extension {
    return OptionalGroup_extensionJSON._readMessage(
      OptionalGroup_extensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OptionalGroup_extension with all fields set to their default value.
   */
  initialize: function (): OptionalGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OptionalGroup_extension>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: OptionalGroup_extension,
    json: any,
  ): OptionalGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const RepeatedGroup_extensionJSON = {
  /**
   * Serializes RepeatedGroup_extension to JSON.
   */
  encode: function (msg: PartialDeep<RepeatedGroup_extension>): string {
    return JSON.stringify(RepeatedGroup_extensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes RepeatedGroup_extension from JSON.
   */
  decode: function (json: string): RepeatedGroup_extension {
    return RepeatedGroup_extensionJSON._readMessage(
      RepeatedGroup_extensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes RepeatedGroup_extension with all fields set to their default value.
   */
  initialize: function (): RepeatedGroup_extension {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<RepeatedGroup_extension>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: RepeatedGroup_extension,
    json: any,
  ): RepeatedGroup_extension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const TestGroupJSON = {
  /**
   * Serializes TestGroup to JSON.
   */
  encode: function (msg: PartialDeep<TestGroup>): string {
    return JSON.stringify(TestGroupJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestGroup from JSON.
   */
  decode: function (json: string): TestGroup {
    return TestGroupJSON._readMessage(
      TestGroupJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestGroup with all fields set to their default value.
   */
  initialize: function (): TestGroup {
    return {
      optionalForeignEnum: ForeignEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestGroup>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (
      msg.optionalForeignEnum &&
      ForeignEnumJSON._toInt(msg.optionalForeignEnum)
    ) {
      json["optionalForeignEnum"] = msg.optionalForeignEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestGroup, json: any): TestGroup {
    const _optionalForeignEnum_ =
      json["optionalForeignEnum"] ?? json["optional_foreign_enum"];
    if (_optionalForeignEnum_) {
      msg.optionalForeignEnum = _optionalForeignEnum_;
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestGroup.OptionalGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestGroup.OptionalGroup>): string {
      return JSON.stringify(TestGroupJSON.OptionalGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestGroup.OptionalGroup from JSON.
     */
    decode: function (json: string): TestGroup.OptionalGroup {
      return TestGroupJSON.OptionalGroup._readMessage(
        TestGroupJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestGroup.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestGroup.OptionalGroup {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestGroup.OptionalGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestGroup.OptionalGroup,
      json: any,
    ): TestGroup.OptionalGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestGroupExtensionJSON = {
  /**
   * Serializes TestGroupExtension to JSON.
   */
  encode: function (_msg?: PartialDeep<TestGroupExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestGroupExtension from JSON.
   */
  decode: function (_json?: string): TestGroupExtension {
    return {};
  },

  /**
   * Initializes TestGroupExtension with all fields set to their default value.
   */
  initialize: function (): TestGroupExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestGroupExtension>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestGroupExtension,
    _json: any,
  ): TestGroupExtension {
    return msg;
  },
};

export const TestNestedExtensionJSON = {
  /**
   * Serializes TestNestedExtension to JSON.
   */
  encode: function (_msg?: PartialDeep<TestNestedExtension>): string {
    return "{}";
  },

  /**
   * Deserializes TestNestedExtension from JSON.
   */
  decode: function (_json?: string): TestNestedExtension {
    return {};
  },

  /**
   * Initializes TestNestedExtension with all fields set to their default value.
   */
  initialize: function (): TestNestedExtension {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestNestedExtension>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedExtension,
    _json: any,
  ): TestNestedExtension {
    return msg;
  },

  OptionalGroup_extension: {
    /**
     * Serializes TestNestedExtension.OptionalGroup_extension to JSON.
     */
    encode: function (
      msg: PartialDeep<TestNestedExtension.OptionalGroup_extension>,
    ): string {
      return JSON.stringify(
        TestNestedExtensionJSON.OptionalGroup_extension._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestNestedExtension.OptionalGroup_extension from JSON.
     */
    decode: function (
      json: string,
    ): TestNestedExtension.OptionalGroup_extension {
      return TestNestedExtensionJSON.OptionalGroup_extension._readMessage(
        TestNestedExtensionJSON.OptionalGroup_extension.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestNestedExtension.OptionalGroup_extension with all fields set to their default value.
     */
    initialize: function (): TestNestedExtension.OptionalGroup_extension {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestNestedExtension.OptionalGroup_extension>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedExtension.OptionalGroup_extension,
      json: any,
    ): TestNestedExtension.OptionalGroup_extension {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestChildExtensionJSON = {
  /**
   * Serializes TestChildExtension to JSON.
   */
  encode: function (msg: PartialDeep<TestChildExtension>): string {
    return JSON.stringify(TestChildExtensionJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestChildExtension from JSON.
   */
  decode: function (json: string): TestChildExtension {
    return TestChildExtensionJSON._readMessage(
      TestChildExtensionJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestChildExtension with all fields set to their default value.
   */
  initialize: function (): TestChildExtension {
    return {
      a: "",
      b: "",
      optionalExtension: TestAllExtensionsJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestChildExtension>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.optionalExtension) {
      const _optionalExtension_ = TestAllExtensionsJSON._writeMessage(
        msg.optionalExtension,
      );
      if (Object.keys(_optionalExtension_).length > 0) {
        json["optionalExtension"] = _optionalExtension_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestChildExtension,
    json: any,
  ): TestChildExtension {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _optionalExtension_ =
      json["optionalExtension"] ?? json["optional_extension"];
    if (_optionalExtension_) {
      TestAllExtensionsJSON._readMessage(
        msg.optionalExtension,
        _optionalExtension_,
      );
    }
    return msg;
  },
};

export const TestRequiredJSON = {
  /**
   * Serializes TestRequired to JSON.
   */
  encode: function (msg: PartialDeep<TestRequired>): string {
    return JSON.stringify(TestRequiredJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequired from JSON.
   */
  decode: function (json: string): TestRequired {
    return TestRequiredJSON._readMessage(
      TestRequiredJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequired with all fields set to their default value.
   */
  initialize: function (): TestRequired {
    return {
      a: 0,
      dummy2: 0,
      b: 0,
      dummy4: 0,
      dummy5: 0,
      dummy6: 0,
      dummy7: 0,
      dummy8: 0,
      dummy9: 0,
      dummy10: 0,
      dummy11: 0,
      dummy12: 0,
      dummy13: 0,
      dummy14: 0,
      dummy15: 0,
      dummy16: 0,
      dummy17: 0,
      dummy18: 0,
      dummy19: 0,
      dummy20: 0,
      dummy21: 0,
      dummy22: 0,
      dummy23: 0,
      dummy24: 0,
      dummy25: 0,
      dummy26: 0,
      dummy27: 0,
      dummy28: 0,
      dummy29: 0,
      dummy30: 0,
      dummy31: 0,
      dummy32: 0,
      c: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequired>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.dummy2) {
      json["dummy2"] = msg.dummy2;
    }
    if (msg.b) {
      json["b"] = msg.b;
    }
    if (msg.dummy4) {
      json["dummy4"] = msg.dummy4;
    }
    if (msg.dummy5) {
      json["dummy5"] = msg.dummy5;
    }
    if (msg.dummy6) {
      json["dummy6"] = msg.dummy6;
    }
    if (msg.dummy7) {
      json["dummy7"] = msg.dummy7;
    }
    if (msg.dummy8) {
      json["dummy8"] = msg.dummy8;
    }
    if (msg.dummy9) {
      json["dummy9"] = msg.dummy9;
    }
    if (msg.dummy10) {
      json["dummy10"] = msg.dummy10;
    }
    if (msg.dummy11) {
      json["dummy11"] = msg.dummy11;
    }
    if (msg.dummy12) {
      json["dummy12"] = msg.dummy12;
    }
    if (msg.dummy13) {
      json["dummy13"] = msg.dummy13;
    }
    if (msg.dummy14) {
      json["dummy14"] = msg.dummy14;
    }
    if (msg.dummy15) {
      json["dummy15"] = msg.dummy15;
    }
    if (msg.dummy16) {
      json["dummy16"] = msg.dummy16;
    }
    if (msg.dummy17) {
      json["dummy17"] = msg.dummy17;
    }
    if (msg.dummy18) {
      json["dummy18"] = msg.dummy18;
    }
    if (msg.dummy19) {
      json["dummy19"] = msg.dummy19;
    }
    if (msg.dummy20) {
      json["dummy20"] = msg.dummy20;
    }
    if (msg.dummy21) {
      json["dummy21"] = msg.dummy21;
    }
    if (msg.dummy22) {
      json["dummy22"] = msg.dummy22;
    }
    if (msg.dummy23) {
      json["dummy23"] = msg.dummy23;
    }
    if (msg.dummy24) {
      json["dummy24"] = msg.dummy24;
    }
    if (msg.dummy25) {
      json["dummy25"] = msg.dummy25;
    }
    if (msg.dummy26) {
      json["dummy26"] = msg.dummy26;
    }
    if (msg.dummy27) {
      json["dummy27"] = msg.dummy27;
    }
    if (msg.dummy28) {
      json["dummy28"] = msg.dummy28;
    }
    if (msg.dummy29) {
      json["dummy29"] = msg.dummy29;
    }
    if (msg.dummy30) {
      json["dummy30"] = msg.dummy30;
    }
    if (msg.dummy31) {
      json["dummy31"] = msg.dummy31;
    }
    if (msg.dummy32) {
      json["dummy32"] = msg.dummy32;
    }
    if (msg.c) {
      json["c"] = msg.c;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestRequired, json: any): TestRequired {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _dummy2_ = json["dummy2"];
    if (_dummy2_) {
      msg.dummy2 = _dummy2_;
    }
    const _b_ = json["b"];
    if (_b_) {
      msg.b = _b_;
    }
    const _dummy4_ = json["dummy4"];
    if (_dummy4_) {
      msg.dummy4 = _dummy4_;
    }
    const _dummy5_ = json["dummy5"];
    if (_dummy5_) {
      msg.dummy5 = _dummy5_;
    }
    const _dummy6_ = json["dummy6"];
    if (_dummy6_) {
      msg.dummy6 = _dummy6_;
    }
    const _dummy7_ = json["dummy7"];
    if (_dummy7_) {
      msg.dummy7 = _dummy7_;
    }
    const _dummy8_ = json["dummy8"];
    if (_dummy8_) {
      msg.dummy8 = _dummy8_;
    }
    const _dummy9_ = json["dummy9"];
    if (_dummy9_) {
      msg.dummy9 = _dummy9_;
    }
    const _dummy10_ = json["dummy10"];
    if (_dummy10_) {
      msg.dummy10 = _dummy10_;
    }
    const _dummy11_ = json["dummy11"];
    if (_dummy11_) {
      msg.dummy11 = _dummy11_;
    }
    const _dummy12_ = json["dummy12"];
    if (_dummy12_) {
      msg.dummy12 = _dummy12_;
    }
    const _dummy13_ = json["dummy13"];
    if (_dummy13_) {
      msg.dummy13 = _dummy13_;
    }
    const _dummy14_ = json["dummy14"];
    if (_dummy14_) {
      msg.dummy14 = _dummy14_;
    }
    const _dummy15_ = json["dummy15"];
    if (_dummy15_) {
      msg.dummy15 = _dummy15_;
    }
    const _dummy16_ = json["dummy16"];
    if (_dummy16_) {
      msg.dummy16 = _dummy16_;
    }
    const _dummy17_ = json["dummy17"];
    if (_dummy17_) {
      msg.dummy17 = _dummy17_;
    }
    const _dummy18_ = json["dummy18"];
    if (_dummy18_) {
      msg.dummy18 = _dummy18_;
    }
    const _dummy19_ = json["dummy19"];
    if (_dummy19_) {
      msg.dummy19 = _dummy19_;
    }
    const _dummy20_ = json["dummy20"];
    if (_dummy20_) {
      msg.dummy20 = _dummy20_;
    }
    const _dummy21_ = json["dummy21"];
    if (_dummy21_) {
      msg.dummy21 = _dummy21_;
    }
    const _dummy22_ = json["dummy22"];
    if (_dummy22_) {
      msg.dummy22 = _dummy22_;
    }
    const _dummy23_ = json["dummy23"];
    if (_dummy23_) {
      msg.dummy23 = _dummy23_;
    }
    const _dummy24_ = json["dummy24"];
    if (_dummy24_) {
      msg.dummy24 = _dummy24_;
    }
    const _dummy25_ = json["dummy25"];
    if (_dummy25_) {
      msg.dummy25 = _dummy25_;
    }
    const _dummy26_ = json["dummy26"];
    if (_dummy26_) {
      msg.dummy26 = _dummy26_;
    }
    const _dummy27_ = json["dummy27"];
    if (_dummy27_) {
      msg.dummy27 = _dummy27_;
    }
    const _dummy28_ = json["dummy28"];
    if (_dummy28_) {
      msg.dummy28 = _dummy28_;
    }
    const _dummy29_ = json["dummy29"];
    if (_dummy29_) {
      msg.dummy29 = _dummy29_;
    }
    const _dummy30_ = json["dummy30"];
    if (_dummy30_) {
      msg.dummy30 = _dummy30_;
    }
    const _dummy31_ = json["dummy31"];
    if (_dummy31_) {
      msg.dummy31 = _dummy31_;
    }
    const _dummy32_ = json["dummy32"];
    if (_dummy32_) {
      msg.dummy32 = _dummy32_;
    }
    const _c_ = json["c"];
    if (_c_) {
      msg.c = _c_;
    }
    return msg;
  },
};

export const TestRequiredForeignJSON = {
  /**
   * Serializes TestRequiredForeign to JSON.
   */
  encode: function (msg: PartialDeep<TestRequiredForeign>): string {
    return JSON.stringify(TestRequiredForeignJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredForeign from JSON.
   */
  decode: function (json: string): TestRequiredForeign {
    return TestRequiredForeignJSON._readMessage(
      TestRequiredForeignJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredForeign with all fields set to their default value.
   */
  initialize: function (): TestRequiredForeign {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      dummy: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredForeign>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage,
      );
    }
    if (msg.dummy) {
      json["dummy"] = msg.dummy;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredForeign,
    json: any,
  ): TestRequiredForeign {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      TestRequiredJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequiredJSON.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _dummy_ = json["dummy"];
    if (_dummy_) {
      msg.dummy = _dummy_;
    }
    return msg;
  },
};

export const TestRequiredMessageJSON = {
  /**
   * Serializes TestRequiredMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestRequiredMessage>): string {
    return JSON.stringify(TestRequiredMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredMessage from JSON.
   */
  decode: function (json: string): TestRequiredMessage {
    return TestRequiredMessageJSON._readMessage(
      TestRequiredMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredMessage with all fields set to their default value.
   */
  initialize: function (): TestRequiredMessage {
    return {
      optionalMessage: TestRequiredJSON.initialize(),
      repeatedMessage: [],
      requiredMessage: TestRequiredJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalMessage) {
      const _optionalMessage_ = TestRequiredJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.repeatedMessage?.length) {
      json["repeatedMessage"] = msg.repeatedMessage.map(
        TestRequiredJSON._writeMessage,
      );
    }
    if (msg.requiredMessage) {
      const _requiredMessage_ = TestRequiredJSON._writeMessage(
        msg.requiredMessage,
      );
      if (Object.keys(_requiredMessage_).length > 0) {
        json["requiredMessage"] = _requiredMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredMessage,
    json: any,
  ): TestRequiredMessage {
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      TestRequiredJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _repeatedMessage_ =
      json["repeatedMessage"] ?? json["repeated_message"];
    if (_repeatedMessage_) {
      for (const item of _repeatedMessage_) {
        const m = TestRequiredJSON.initialize();
        TestRequiredJSON._readMessage(m, item);
        msg.repeatedMessage.push(m);
      }
    }
    const _requiredMessage_ =
      json["requiredMessage"] ?? json["required_message"];
    if (_requiredMessage_) {
      TestRequiredJSON._readMessage(msg.requiredMessage, _requiredMessage_);
    }
    return msg;
  },
};

export const TestForeignNestedJSON = {
  /**
   * Serializes TestForeignNested to JSON.
   */
  encode: function (msg: PartialDeep<TestForeignNested>): string {
    return JSON.stringify(TestForeignNestedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestForeignNested from JSON.
   */
  decode: function (json: string): TestForeignNested {
    return TestForeignNestedJSON._readMessage(
      TestForeignNestedJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestForeignNested with all fields set to their default value.
   */
  initialize: function (): TestForeignNested {
    return {
      foreignNested: TestAllTypesJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestForeignNested>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.foreignNested) {
      const _foreignNested_ = TestAllTypesJSON.NestedMessage._writeMessage(
        msg.foreignNested,
      );
      if (Object.keys(_foreignNested_).length > 0) {
        json["foreignNested"] = _foreignNested_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestForeignNested,
    json: any,
  ): TestForeignNested {
    const _foreignNested_ = json["foreignNested"] ?? json["foreign_nested"];
    if (_foreignNested_) {
      TestAllTypesJSON.NestedMessage._readMessage(
        msg.foreignNested,
        _foreignNested_,
      );
    }
    return msg;
  },
};

export const TestEmptyMessageJSON = {
  /**
   * Serializes TestEmptyMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<TestEmptyMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessage from JSON.
   */
  decode: function (_json?: string): TestEmptyMessage {
    return {};
  },

  /**
   * Initializes TestEmptyMessage with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEmptyMessage, _json: any): TestEmptyMessage {
    return msg;
  },
};

export const TestEmptyMessageWithExtensionsJSON = {
  /**
   * Serializes TestEmptyMessageWithExtensions to JSON.
   */
  encode: function (
    _msg?: PartialDeep<TestEmptyMessageWithExtensions>,
  ): string {
    return "{}";
  },

  /**
   * Deserializes TestEmptyMessageWithExtensions from JSON.
   */
  decode: function (_json?: string): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * Initializes TestEmptyMessageWithExtensions with all fields set to their default value.
   */
  initialize: function (): TestEmptyMessageWithExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestEmptyMessageWithExtensions>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestEmptyMessageWithExtensions,
    _json: any,
  ): TestEmptyMessageWithExtensions {
    return msg;
  },
};

export const TestPickleNestedMessageJSON = {
  /**
   * Serializes TestPickleNestedMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<TestPickleNestedMessage>): string {
    return "{}";
  },

  /**
   * Deserializes TestPickleNestedMessage from JSON.
   */
  decode: function (_json?: string): TestPickleNestedMessage {
    return {};
  },

  /**
   * Initializes TestPickleNestedMessage with all fields set to their default value.
   */
  initialize: function (): TestPickleNestedMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestPickleNestedMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPickleNestedMessage,
    _json: any,
  ): TestPickleNestedMessage {
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestPickleNestedMessage.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestPickleNestedMessage.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestPickleNestedMessageJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestPickleNestedMessage.NestedMessage from JSON.
     */
    decode: function (json: string): TestPickleNestedMessage.NestedMessage {
      return TestPickleNestedMessageJSON.NestedMessage._readMessage(
        TestPickleNestedMessageJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestPickleNestedMessage.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestPickleNestedMessage.NestedMessage {
      return {
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestPickleNestedMessage.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestPickleNestedMessage.NestedMessage,
      json: any,
    ): TestPickleNestedMessage.NestedMessage {
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },

    NestedNestedMessage: {
      /**
       * Serializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage to JSON.
       */
      encode: function (
        msg: PartialDeep<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
      ): string {
        return JSON.stringify(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage from JSON.
       */
      decode: function (
        json: string,
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        return TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage._readMessage(
          TestPickleNestedMessageJSON.NestedMessage.NestedNestedMessage.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestPickleNestedMessage.NestedMessage.NestedNestedMessage with all fields set to their default value.
       */
      initialize:
        function (): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
          return {
            cc: 0,
          };
        },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestPickleNestedMessage.NestedMessage.NestedNestedMessage>,
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.cc) {
          json["cc"] = msg.cc;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestPickleNestedMessage.NestedMessage.NestedNestedMessage,
        json: any,
      ): TestPickleNestedMessage.NestedMessage.NestedNestedMessage {
        const _cc_ = json["cc"];
        if (_cc_) {
          msg.cc = _cc_;
        }
        return msg;
      },
    },
  },
};

export const TestMultipleExtensionRangesJSON = {
  /**
   * Serializes TestMultipleExtensionRanges to JSON.
   */
  encode: function (_msg?: PartialDeep<TestMultipleExtensionRanges>): string {
    return "{}";
  },

  /**
   * Deserializes TestMultipleExtensionRanges from JSON.
   */
  decode: function (_json?: string): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * Initializes TestMultipleExtensionRanges with all fields set to their default value.
   */
  initialize: function (): TestMultipleExtensionRanges {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestMultipleExtensionRanges>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMultipleExtensionRanges,
    _json: any,
  ): TestMultipleExtensionRanges {
    return msg;
  },
};

export const TestReallyLargeTagNumberJSON = {
  /**
   * Serializes TestReallyLargeTagNumber to JSON.
   */
  encode: function (msg: PartialDeep<TestReallyLargeTagNumber>): string {
    return JSON.stringify(TestReallyLargeTagNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestReallyLargeTagNumber from JSON.
   */
  decode: function (json: string): TestReallyLargeTagNumber {
    return TestReallyLargeTagNumberJSON._readMessage(
      TestReallyLargeTagNumberJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestReallyLargeTagNumber with all fields set to their default value.
   */
  initialize: function (): TestReallyLargeTagNumber {
    return {
      a: 0,
      bb: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestReallyLargeTagNumber>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    if (msg.bb) {
      json["bb"] = msg.bb;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestReallyLargeTagNumber,
    json: any,
  ): TestReallyLargeTagNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    const _bb_ = json["bb"];
    if (_bb_) {
      msg.bb = _bb_;
    }
    return msg;
  },
};

export const TestRecursiveMessageJSON = {
  /**
   * Serializes TestRecursiveMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestRecursiveMessage>): string {
    return JSON.stringify(TestRecursiveMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRecursiveMessage from JSON.
   */
  decode: function (json: string): TestRecursiveMessage {
    return TestRecursiveMessageJSON._readMessage(
      TestRecursiveMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRecursiveMessage with all fields set to their default value.
   */
  initialize: function (): TestRecursiveMessage {
    return {
      a: undefined,
      i: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRecursiveMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestRecursiveMessageJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.i) {
      json["i"] = msg.i;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRecursiveMessage,
    json: any,
  ): TestRecursiveMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = TestRecursiveMessageJSON.initialize();
      TestRecursiveMessageJSON._readMessage(msg.a, _a_);
    }
    const _i_ = json["i"];
    if (_i_) {
      msg.i = _i_;
    }
    return msg;
  },
};

export const TestMutualRecursionAJSON = {
  /**
   * Serializes TestMutualRecursionA to JSON.
   */
  encode: function (msg: PartialDeep<TestMutualRecursionA>): string {
    return JSON.stringify(TestMutualRecursionAJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionA from JSON.
   */
  decode: function (json: string): TestMutualRecursionA {
    return TestMutualRecursionAJSON._readMessage(
      TestMutualRecursionAJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMutualRecursionA with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionA {
    return {
      bb: TestMutualRecursionBJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMutualRecursionA>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.bb) {
      const _bb_ = TestMutualRecursionBJSON._writeMessage(msg.bb);
      if (Object.keys(_bb_).length > 0) {
        json["bb"] = _bb_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionA,
    json: any,
  ): TestMutualRecursionA {
    const _bb_ = json["bb"];
    if (_bb_) {
      TestMutualRecursionBJSON._readMessage(msg.bb, _bb_);
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestMutualRecursionA.SubMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestMutualRecursionA.SubMessage>,
    ): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubMessage from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubMessage {
      return TestMutualRecursionAJSON.SubMessage._readMessage(
        TestMutualRecursionAJSON.SubMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubMessage {
      return {
        b: TestMutualRecursionBJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMutualRecursionA.SubMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.b) {
        const _b_ = TestMutualRecursionBJSON._writeMessage(msg.b);
        if (Object.keys(_b_).length > 0) {
          json["b"] = _b_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubMessage,
      json: any,
    ): TestMutualRecursionA.SubMessage {
      const _b_ = json["b"];
      if (_b_) {
        TestMutualRecursionBJSON._readMessage(msg.b, _b_);
      }
      return msg;
    },
  },

  SubGroup: {
    /**
     * Serializes TestMutualRecursionA.SubGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestMutualRecursionA.SubGroup>): string {
      return JSON.stringify(
        TestMutualRecursionAJSON.SubGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestMutualRecursionA.SubGroup from JSON.
     */
    decode: function (json: string): TestMutualRecursionA.SubGroup {
      return TestMutualRecursionAJSON.SubGroup._readMessage(
        TestMutualRecursionAJSON.SubGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestMutualRecursionA.SubGroup with all fields set to their default value.
     */
    initialize: function (): TestMutualRecursionA.SubGroup {
      return {
        subMessage: TestMutualRecursionAJSON.SubMessage.initialize(),
        notInThisScc: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestMutualRecursionA.SubGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.subMessage) {
        const _subMessage_ = TestMutualRecursionAJSON.SubMessage._writeMessage(
          msg.subMessage,
        );
        if (Object.keys(_subMessage_).length > 0) {
          json["subMessage"] = _subMessage_;
        }
      }
      if (msg.notInThisScc) {
        const _notInThisScc_ = TestAllTypesJSON._writeMessage(msg.notInThisScc);
        if (Object.keys(_notInThisScc_).length > 0) {
          json["notInThisScc"] = _notInThisScc_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestMutualRecursionA.SubGroup,
      json: any,
    ): TestMutualRecursionA.SubGroup {
      const _subMessage_ = json["subMessage"] ?? json["sub_message"];
      if (_subMessage_) {
        TestMutualRecursionAJSON.SubMessage._readMessage(
          msg.subMessage,
          _subMessage_,
        );
      }
      const _notInThisScc_ = json["notInThisScc"] ?? json["not_in_this_scc"];
      if (_notInThisScc_) {
        TestAllTypesJSON._readMessage(msg.notInThisScc, _notInThisScc_);
      }
      return msg;
    },
  },
};

export const TestMutualRecursionBJSON = {
  /**
   * Serializes TestMutualRecursionB to JSON.
   */
  encode: function (msg: PartialDeep<TestMutualRecursionB>): string {
    return JSON.stringify(TestMutualRecursionBJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestMutualRecursionB from JSON.
   */
  decode: function (json: string): TestMutualRecursionB {
    return TestMutualRecursionBJSON._readMessage(
      TestMutualRecursionBJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestMutualRecursionB with all fields set to their default value.
   */
  initialize: function (): TestMutualRecursionB {
    return {
      a: TestMutualRecursionAJSON.initialize(),
      optionalInt32: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestMutualRecursionB>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      const _a_ = TestMutualRecursionAJSON._writeMessage(msg.a);
      if (Object.keys(_a_).length > 0) {
        json["a"] = _a_;
      }
    }
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestMutualRecursionB,
    json: any,
  ): TestMutualRecursionB {
    const _a_ = json["a"];
    if (_a_) {
      TestMutualRecursionAJSON._readMessage(msg.a, _a_);
    }
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    return msg;
  },
};

export const TestIsInitializedJSON = {
  /**
   * Serializes TestIsInitialized to JSON.
   */
  encode: function (msg: PartialDeep<TestIsInitialized>): string {
    return JSON.stringify(TestIsInitializedJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestIsInitialized from JSON.
   */
  decode: function (json: string): TestIsInitialized {
    return TestIsInitializedJSON._readMessage(
      TestIsInitializedJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestIsInitialized with all fields set to their default value.
   */
  initialize: function (): TestIsInitialized {
    return {
      subMessage: TestIsInitializedJSON.SubMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestIsInitialized>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestIsInitializedJSON.SubMessage._writeMessage(
        msg.subMessage,
      );
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestIsInitialized,
    json: any,
  ): TestIsInitialized {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestIsInitializedJSON.SubMessage._readMessage(
        msg.subMessage,
        _subMessage_,
      );
    }
    return msg;
  },

  SubMessage: {
    /**
     * Serializes TestIsInitialized.SubMessage to JSON.
     */
    encode: function (
      _msg?: PartialDeep<TestIsInitialized.SubMessage>,
    ): string {
      return "{}";
    },

    /**
     * Deserializes TestIsInitialized.SubMessage from JSON.
     */
    decode: function (_json?: string): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * Initializes TestIsInitialized.SubMessage with all fields set to their default value.
     */
    initialize: function (): TestIsInitialized.SubMessage {
      return {};
    },

    /**
     * @private
     */
    _writeMessage: function (
      _msg: PartialDeep<TestIsInitialized.SubMessage>,
    ): Record<string, unknown> {
      return {};
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestIsInitialized.SubMessage,
      _json: any,
    ): TestIsInitialized.SubMessage {
      return msg;
    },

    SubGroup: {
      /**
       * Serializes TestIsInitialized.SubMessage.SubGroup to JSON.
       */
      encode: function (
        msg: PartialDeep<TestIsInitialized.SubMessage.SubGroup>,
      ): string {
        return JSON.stringify(
          TestIsInitializedJSON.SubMessage.SubGroup._writeMessage(msg),
        );
      },

      /**
       * Deserializes TestIsInitialized.SubMessage.SubGroup from JSON.
       */
      decode: function (json: string): TestIsInitialized.SubMessage.SubGroup {
        return TestIsInitializedJSON.SubMessage.SubGroup._readMessage(
          TestIsInitializedJSON.SubMessage.SubGroup.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestIsInitialized.SubMessage.SubGroup with all fields set to their default value.
       */
      initialize: function (): TestIsInitialized.SubMessage.SubGroup {
        return {
          i: 0,
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestIsInitialized.SubMessage.SubGroup>,
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.i) {
          json["i"] = msg.i;
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestIsInitialized.SubMessage.SubGroup,
        json: any,
      ): TestIsInitialized.SubMessage.SubGroup {
        const _i_ = json["i"];
        if (_i_) {
          msg.i = _i_;
        }
        return msg;
      },
    },
  },
};

export const TestDupFieldNumberJSON = {
  /**
   * Serializes TestDupFieldNumber to JSON.
   */
  encode: function (msg: PartialDeep<TestDupFieldNumber>): string {
    return JSON.stringify(TestDupFieldNumberJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDupFieldNumber from JSON.
   */
  decode: function (json: string): TestDupFieldNumber {
    return TestDupFieldNumberJSON._readMessage(
      TestDupFieldNumberJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDupFieldNumber with all fields set to their default value.
   */
  initialize: function (): TestDupFieldNumber {
    return {
      a: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDupFieldNumber>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDupFieldNumber,
    json: any,
  ): TestDupFieldNumber {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },

  Foo: {
    /**
     * Serializes TestDupFieldNumber.Foo to JSON.
     */
    encode: function (msg: PartialDeep<TestDupFieldNumber.Foo>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Foo._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Foo from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Foo {
      return TestDupFieldNumberJSON.Foo._readMessage(
        TestDupFieldNumberJSON.Foo.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Foo with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Foo {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDupFieldNumber.Foo>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Foo,
      json: any,
    ): TestDupFieldNumber.Foo {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },

  Bar: {
    /**
     * Serializes TestDupFieldNumber.Bar to JSON.
     */
    encode: function (msg: PartialDeep<TestDupFieldNumber.Bar>): string {
      return JSON.stringify(TestDupFieldNumberJSON.Bar._writeMessage(msg));
    },

    /**
     * Deserializes TestDupFieldNumber.Bar from JSON.
     */
    decode: function (json: string): TestDupFieldNumber.Bar {
      return TestDupFieldNumberJSON.Bar._readMessage(
        TestDupFieldNumberJSON.Bar.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDupFieldNumber.Bar with all fields set to their default value.
     */
    initialize: function (): TestDupFieldNumber.Bar {
      return {
        a: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDupFieldNumber.Bar>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDupFieldNumber.Bar,
      json: any,
    ): TestDupFieldNumber.Bar {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      return msg;
    },
  },
};

export const TestEagerMessageJSON = {
  /**
   * Serializes TestEagerMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestEagerMessage>): string {
    return JSON.stringify(TestEagerMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestEagerMessage from JSON.
   */
  decode: function (json: string): TestEagerMessage {
    return TestEagerMessageJSON._readMessage(
      TestEagerMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestEagerMessage with all fields set to their default value.
   */
  initialize: function (): TestEagerMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestEagerMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestEagerMessage, json: any): TestEagerMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestAllTypesJSON._readMessage(msg.subMessage, _subMessage_);
    }
    return msg;
  },
};

export const TestLazyMessageJSON = {
  /**
   * Serializes TestLazyMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestLazyMessage>): string {
    return JSON.stringify(TestLazyMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestLazyMessage from JSON.
   */
  decode: function (json: string): TestLazyMessage {
    return TestLazyMessageJSON._readMessage(
      TestLazyMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestLazyMessage with all fields set to their default value.
   */
  initialize: function (): TestLazyMessage {
    return {
      subMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestLazyMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.subMessage) {
      const _subMessage_ = TestAllTypesJSON._writeMessage(msg.subMessage);
      if (Object.keys(_subMessage_).length > 0) {
        json["subMessage"] = _subMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestLazyMessage, json: any): TestLazyMessage {
    const _subMessage_ = json["subMessage"] ?? json["sub_message"];
    if (_subMessage_) {
      TestAllTypesJSON._readMessage(msg.subMessage, _subMessage_);
    }
    return msg;
  },
};

export const TestNestedMessageHasBitsJSON = {
  /**
   * Serializes TestNestedMessageHasBits to JSON.
   */
  encode: function (msg: PartialDeep<TestNestedMessageHasBits>): string {
    return JSON.stringify(TestNestedMessageHasBitsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestNestedMessageHasBits from JSON.
   */
  decode: function (json: string): TestNestedMessageHasBits {
    return TestNestedMessageHasBitsJSON._readMessage(
      TestNestedMessageHasBitsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestNestedMessageHasBits with all fields set to their default value.
   */
  initialize: function (): TestNestedMessageHasBits {
    return {
      optionalNestedMessage:
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestNestedMessageHasBits>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage,
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestNestedMessageHasBits,
    json: any,
  ): TestNestedMessageHasBits {
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestNestedMessageHasBits.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestNestedMessageHasBits.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestNestedMessageHasBitsJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestNestedMessageHasBits.NestedMessage from JSON.
     */
    decode: function (json: string): TestNestedMessageHasBits.NestedMessage {
      return TestNestedMessageHasBitsJSON.NestedMessage._readMessage(
        TestNestedMessageHasBitsJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestNestedMessageHasBits.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestNestedMessageHasBits.NestedMessage {
      return {
        nestedmessageRepeatedInt32: [],
        nestedmessageRepeatedForeignmessage: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestNestedMessageHasBits.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.nestedmessageRepeatedInt32?.length) {
        json["nestedmessageRepeatedInt32"] = msg.nestedmessageRepeatedInt32;
      }
      if (msg.nestedmessageRepeatedForeignmessage?.length) {
        json["nestedmessageRepeatedForeignmessage"] =
          msg.nestedmessageRepeatedForeignmessage.map(
            ForeignMessageJSON._writeMessage,
          );
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestNestedMessageHasBits.NestedMessage,
      json: any,
    ): TestNestedMessageHasBits.NestedMessage {
      const _nestedmessageRepeatedInt32_ =
        json["nestedmessageRepeatedInt32"] ??
        json["nestedmessage_repeated_int32"];
      if (_nestedmessageRepeatedInt32_) {
        msg.nestedmessageRepeatedInt32 = _nestedmessageRepeatedInt32_;
      }
      const _nestedmessageRepeatedForeignmessage_ =
        json["nestedmessageRepeatedForeignmessage"] ??
        json["nestedmessage_repeated_foreignmessage"];
      if (_nestedmessageRepeatedForeignmessage_) {
        for (const item of _nestedmessageRepeatedForeignmessage_) {
          const m = ForeignMessageJSON.initialize();
          ForeignMessageJSON._readMessage(m, item);
          msg.nestedmessageRepeatedForeignmessage.push(m);
        }
      }
      return msg;
    },
  },
};

export const TestCamelCaseFieldNamesJSON = {
  /**
   * Serializes TestCamelCaseFieldNames to JSON.
   */
  encode: function (msg: PartialDeep<TestCamelCaseFieldNames>): string {
    return JSON.stringify(TestCamelCaseFieldNamesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCamelCaseFieldNames from JSON.
   */
  decode: function (json: string): TestCamelCaseFieldNames {
    return TestCamelCaseFieldNamesJSON._readMessage(
      TestCamelCaseFieldNamesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestCamelCaseFieldNames with all fields set to their default value.
   */
  initialize: function (): TestCamelCaseFieldNames {
    return {
      PrimitiveField: 0,
      StringField: "",
      EnumField: ForeignEnum._fromInt(0),
      MessageField: ForeignMessageJSON.initialize(),
      StringPieceField: "",
      CordField: "",
      RepeatedPrimitiveField: [],
      RepeatedStringField: [],
      RepeatedEnumField: [],
      RepeatedMessageField: [],
      RepeatedStringPieceField: [],
      RepeatedCordField: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestCamelCaseFieldNames>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.PrimitiveField) {
      json["PrimitiveField"] = msg.PrimitiveField;
    }
    if (msg.StringField) {
      json["StringField"] = msg.StringField;
    }
    if (msg.EnumField && ForeignEnumJSON._toInt(msg.EnumField)) {
      json["EnumField"] = msg.EnumField;
    }
    if (msg.MessageField) {
      const _MessageField_ = ForeignMessageJSON._writeMessage(msg.MessageField);
      if (Object.keys(_MessageField_).length > 0) {
        json["MessageField"] = _MessageField_;
      }
    }
    if (msg.StringPieceField) {
      json["StringPieceField"] = msg.StringPieceField;
    }
    if (msg.CordField) {
      json["CordField"] = msg.CordField;
    }
    if (msg.RepeatedPrimitiveField?.length) {
      json["RepeatedPrimitiveField"] = msg.RepeatedPrimitiveField;
    }
    if (msg.RepeatedStringField?.length) {
      json["RepeatedStringField"] = msg.RepeatedStringField;
    }
    if (msg.RepeatedEnumField?.length) {
      json["RepeatedEnumField"] = msg.RepeatedEnumField;
    }
    if (msg.RepeatedMessageField?.length) {
      json["RepeatedMessageField"] = msg.RepeatedMessageField.map(
        ForeignMessageJSON._writeMessage,
      );
    }
    if (msg.RepeatedStringPieceField?.length) {
      json["RepeatedStringPieceField"] = msg.RepeatedStringPieceField;
    }
    if (msg.RepeatedCordField?.length) {
      json["RepeatedCordField"] = msg.RepeatedCordField;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCamelCaseFieldNames,
    json: any,
  ): TestCamelCaseFieldNames {
    const _PrimitiveField_ = json["PrimitiveField"];
    if (_PrimitiveField_) {
      msg.PrimitiveField = _PrimitiveField_;
    }
    const _StringField_ = json["StringField"];
    if (_StringField_) {
      msg.StringField = _StringField_;
    }
    const _EnumField_ = json["EnumField"];
    if (_EnumField_) {
      msg.EnumField = _EnumField_;
    }
    const _MessageField_ = json["MessageField"];
    if (_MessageField_) {
      ForeignMessageJSON._readMessage(msg.MessageField, _MessageField_);
    }
    const _StringPieceField_ = json["StringPieceField"];
    if (_StringPieceField_) {
      msg.StringPieceField = _StringPieceField_;
    }
    const _CordField_ = json["CordField"];
    if (_CordField_) {
      msg.CordField = _CordField_;
    }
    const _RepeatedPrimitiveField_ = json["RepeatedPrimitiveField"];
    if (_RepeatedPrimitiveField_) {
      msg.RepeatedPrimitiveField = _RepeatedPrimitiveField_;
    }
    const _RepeatedStringField_ = json["RepeatedStringField"];
    if (_RepeatedStringField_) {
      msg.RepeatedStringField = _RepeatedStringField_;
    }
    const _RepeatedEnumField_ = json["RepeatedEnumField"];
    if (_RepeatedEnumField_) {
      msg.RepeatedEnumField = _RepeatedEnumField_;
    }
    const _RepeatedMessageField_ = json["RepeatedMessageField"];
    if (_RepeatedMessageField_) {
      for (const item of _RepeatedMessageField_) {
        const m = ForeignMessageJSON.initialize();
        ForeignMessageJSON._readMessage(m, item);
        msg.RepeatedMessageField.push(m);
      }
    }
    const _RepeatedStringPieceField_ = json["RepeatedStringPieceField"];
    if (_RepeatedStringPieceField_) {
      msg.RepeatedStringPieceField = _RepeatedStringPieceField_;
    }
    const _RepeatedCordField_ = json["RepeatedCordField"];
    if (_RepeatedCordField_) {
      msg.RepeatedCordField = _RepeatedCordField_;
    }
    return msg;
  },
};

export const TestFieldOrderingsJSON = {
  /**
   * Serializes TestFieldOrderings to JSON.
   */
  encode: function (msg: PartialDeep<TestFieldOrderings>): string {
    return JSON.stringify(TestFieldOrderingsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestFieldOrderings from JSON.
   */
  decode: function (json: string): TestFieldOrderings {
    return TestFieldOrderingsJSON._readMessage(
      TestFieldOrderingsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestFieldOrderings with all fields set to their default value.
   */
  initialize: function (): TestFieldOrderings {
    return {
      myString: "",
      myInt: 0n,
      myFloat: 0,
      optionalNestedMessage: TestFieldOrderingsJSON.NestedMessage.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestFieldOrderings>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    if (msg.myInt) {
      json["myInt"] = msg.myInt.toString();
    }
    if (msg.myFloat) {
      json["myFloat"] = msg.myFloat;
    }
    if (msg.optionalNestedMessage) {
      const _optionalNestedMessage_ =
        TestFieldOrderingsJSON.NestedMessage._writeMessage(
          msg.optionalNestedMessage,
        );
      if (Object.keys(_optionalNestedMessage_).length > 0) {
        json["optionalNestedMessage"] = _optionalNestedMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestFieldOrderings,
    json: any,
  ): TestFieldOrderings {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    const _myInt_ = json["myInt"] ?? json["my_int"];
    if (_myInt_) {
      msg.myInt = BigInt(_myInt_);
    }
    const _myFloat_ = json["myFloat"] ?? json["my_float"];
    if (_myFloat_) {
      msg.myFloat = _myFloat_;
    }
    const _optionalNestedMessage_ =
      json["optionalNestedMessage"] ?? json["optional_nested_message"];
    if (_optionalNestedMessage_) {
      TestFieldOrderingsJSON.NestedMessage._readMessage(
        msg.optionalNestedMessage,
        _optionalNestedMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestFieldOrderings.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestFieldOrderings.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestFieldOrderingsJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestFieldOrderings.NestedMessage from JSON.
     */
    decode: function (json: string): TestFieldOrderings.NestedMessage {
      return TestFieldOrderingsJSON.NestedMessage._readMessage(
        TestFieldOrderingsJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestFieldOrderings.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestFieldOrderings.NestedMessage {
      return {
        oo: 0n,
        bb: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestFieldOrderings.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.oo) {
        json["oo"] = msg.oo.toString();
      }
      if (msg.bb) {
        json["bb"] = msg.bb;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestFieldOrderings.NestedMessage,
      json: any,
    ): TestFieldOrderings.NestedMessage {
      const _oo_ = json["oo"];
      if (_oo_) {
        msg.oo = BigInt(_oo_);
      }
      const _bb_ = json["bb"];
      if (_bb_) {
        msg.bb = _bb_;
      }
      return msg;
    },
  },
};

export const TestExtensionOrderings1JSON = {
  /**
   * Serializes TestExtensionOrderings1 to JSON.
   */
  encode: function (msg: PartialDeep<TestExtensionOrderings1>): string {
    return JSON.stringify(TestExtensionOrderings1JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings1 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings1 {
    return TestExtensionOrderings1JSON._readMessage(
      TestExtensionOrderings1JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionOrderings1 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings1 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionOrderings1>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings1,
    json: any,
  ): TestExtensionOrderings1 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },
};

export const TestExtensionOrderings2JSON = {
  /**
   * Serializes TestExtensionOrderings2 to JSON.
   */
  encode: function (msg: PartialDeep<TestExtensionOrderings2>): string {
    return JSON.stringify(TestExtensionOrderings2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionOrderings2 from JSON.
   */
  decode: function (json: string): TestExtensionOrderings2 {
    return TestExtensionOrderings2JSON._readMessage(
      TestExtensionOrderings2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionOrderings2 with all fields set to their default value.
   */
  initialize: function (): TestExtensionOrderings2 {
    return {
      myString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionOrderings2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.myString) {
      json["myString"] = msg.myString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionOrderings2,
    json: any,
  ): TestExtensionOrderings2 {
    const _myString_ = json["myString"] ?? json["my_string"];
    if (_myString_) {
      msg.myString = _myString_;
    }
    return msg;
  },

  TestExtensionOrderings3: {
    /**
     * Serializes TestExtensionOrderings2.TestExtensionOrderings3 to JSON.
     */
    encode: function (
      msg: PartialDeep<TestExtensionOrderings2.TestExtensionOrderings3>,
    ): string {
      return JSON.stringify(
        TestExtensionOrderings2JSON.TestExtensionOrderings3._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestExtensionOrderings2.TestExtensionOrderings3 from JSON.
     */
    decode: function (
      json: string,
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      return TestExtensionOrderings2JSON.TestExtensionOrderings3._readMessage(
        TestExtensionOrderings2JSON.TestExtensionOrderings3.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestExtensionOrderings2.TestExtensionOrderings3 with all fields set to their default value.
     */
    initialize: function (): TestExtensionOrderings2.TestExtensionOrderings3 {
      return {
        myString: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestExtensionOrderings2.TestExtensionOrderings3>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.myString) {
        json["myString"] = msg.myString;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestExtensionOrderings2.TestExtensionOrderings3,
      json: any,
    ): TestExtensionOrderings2.TestExtensionOrderings3 {
      const _myString_ = json["myString"] ?? json["my_string"];
      if (_myString_) {
        msg.myString = _myString_;
      }
      return msg;
    },
  },
};

export const TestExtremeDefaultValuesJSON = {
  /**
   * Serializes TestExtremeDefaultValues to JSON.
   */
  encode: function (msg: PartialDeep<TestExtremeDefaultValues>): string {
    return JSON.stringify(TestExtremeDefaultValuesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtremeDefaultValues from JSON.
   */
  decode: function (json: string): TestExtremeDefaultValues {
    return TestExtremeDefaultValuesJSON._readMessage(
      TestExtremeDefaultValuesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtremeDefaultValues with all fields set to their default value.
   */
  initialize: function (): TestExtremeDefaultValues {
    return {
      escapedBytes: new Uint8Array(),
      largeUint32: 0,
      largeUint64: 0n,
      smallInt32: 0,
      smallInt64: 0n,
      reallySmallInt32: 0,
      reallySmallInt64: 0n,
      utf8String: "",
      zeroFloat: 0,
      oneFloat: 0,
      smallFloat: 0,
      negativeOneFloat: 0,
      negativeFloat: 0,
      largeFloat: 0,
      smallNegativeFloat: 0,
      infDouble: 0,
      negInfDouble: 0,
      nanDouble: 0,
      infFloat: 0,
      negInfFloat: 0,
      nanFloat: 0,
      cppTrigraph: "",
      stringWithZero: "",
      bytesWithZero: new Uint8Array(),
      stringPieceWithZero: "",
      cordWithZero: "",
      replacementString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtremeDefaultValues>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.escapedBytes?.length) {
      json["escapedBytes"] = encodeBase64Bytes(msg.escapedBytes);
    }
    if (msg.largeUint32) {
      json["largeUint32"] = msg.largeUint32;
    }
    if (msg.largeUint64) {
      json["largeUint64"] = msg.largeUint64.toString();
    }
    if (msg.smallInt32) {
      json["smallInt32"] = msg.smallInt32;
    }
    if (msg.smallInt64) {
      json["smallInt64"] = msg.smallInt64.toString();
    }
    if (msg.reallySmallInt32) {
      json["reallySmallInt32"] = msg.reallySmallInt32;
    }
    if (msg.reallySmallInt64) {
      json["reallySmallInt64"] = msg.reallySmallInt64.toString();
    }
    if (msg.utf8String) {
      json["utf8String"] = msg.utf8String;
    }
    if (msg.zeroFloat) {
      json["zeroFloat"] = msg.zeroFloat;
    }
    if (msg.oneFloat) {
      json["oneFloat"] = msg.oneFloat;
    }
    if (msg.smallFloat) {
      json["smallFloat"] = msg.smallFloat;
    }
    if (msg.negativeOneFloat) {
      json["negativeOneFloat"] = msg.negativeOneFloat;
    }
    if (msg.negativeFloat) {
      json["negativeFloat"] = msg.negativeFloat;
    }
    if (msg.largeFloat) {
      json["largeFloat"] = msg.largeFloat;
    }
    if (msg.smallNegativeFloat) {
      json["smallNegativeFloat"] = msg.smallNegativeFloat;
    }
    if (msg.infDouble) {
      json["infDouble"] = msg.infDouble;
    }
    if (msg.negInfDouble) {
      json["negInfDouble"] = msg.negInfDouble;
    }
    if (msg.nanDouble) {
      json["nanDouble"] = msg.nanDouble;
    }
    if (msg.infFloat) {
      json["infFloat"] = msg.infFloat;
    }
    if (msg.negInfFloat) {
      json["negInfFloat"] = msg.negInfFloat;
    }
    if (msg.nanFloat) {
      json["nanFloat"] = msg.nanFloat;
    }
    if (msg.cppTrigraph) {
      json["cppTrigraph"] = msg.cppTrigraph;
    }
    if (msg.stringWithZero) {
      json["stringWithZero"] = msg.stringWithZero;
    }
    if (msg.bytesWithZero?.length) {
      json["bytesWithZero"] = encodeBase64Bytes(msg.bytesWithZero);
    }
    if (msg.stringPieceWithZero) {
      json["stringPieceWithZero"] = msg.stringPieceWithZero;
    }
    if (msg.cordWithZero) {
      json["cordWithZero"] = msg.cordWithZero;
    }
    if (msg.replacementString) {
      json["replacementString"] = msg.replacementString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtremeDefaultValues,
    json: any,
  ): TestExtremeDefaultValues {
    const _escapedBytes_ = json["escapedBytes"] ?? json["escaped_bytes"];
    if (_escapedBytes_) {
      msg.escapedBytes = decodeBase64Bytes(_escapedBytes_);
    }
    const _largeUint32_ = json["largeUint32"] ?? json["large_uint32"];
    if (_largeUint32_) {
      msg.largeUint32 = _largeUint32_;
    }
    const _largeUint64_ = json["largeUint64"] ?? json["large_uint64"];
    if (_largeUint64_) {
      msg.largeUint64 = BigInt(_largeUint64_);
    }
    const _smallInt32_ = json["smallInt32"] ?? json["small_int32"];
    if (_smallInt32_) {
      msg.smallInt32 = _smallInt32_;
    }
    const _smallInt64_ = json["smallInt64"] ?? json["small_int64"];
    if (_smallInt64_) {
      msg.smallInt64 = BigInt(_smallInt64_);
    }
    const _reallySmallInt32_ =
      json["reallySmallInt32"] ?? json["really_small_int32"];
    if (_reallySmallInt32_) {
      msg.reallySmallInt32 = _reallySmallInt32_;
    }
    const _reallySmallInt64_ =
      json["reallySmallInt64"] ?? json["really_small_int64"];
    if (_reallySmallInt64_) {
      msg.reallySmallInt64 = BigInt(_reallySmallInt64_);
    }
    const _utf8String_ = json["utf8String"] ?? json["utf8_string"];
    if (_utf8String_) {
      msg.utf8String = _utf8String_;
    }
    const _zeroFloat_ = json["zeroFloat"] ?? json["zero_float"];
    if (_zeroFloat_) {
      msg.zeroFloat = _zeroFloat_;
    }
    const _oneFloat_ = json["oneFloat"] ?? json["one_float"];
    if (_oneFloat_) {
      msg.oneFloat = _oneFloat_;
    }
    const _smallFloat_ = json["smallFloat"] ?? json["small_float"];
    if (_smallFloat_) {
      msg.smallFloat = _smallFloat_;
    }
    const _negativeOneFloat_ =
      json["negativeOneFloat"] ?? json["negative_one_float"];
    if (_negativeOneFloat_) {
      msg.negativeOneFloat = _negativeOneFloat_;
    }
    const _negativeFloat_ = json["negativeFloat"] ?? json["negative_float"];
    if (_negativeFloat_) {
      msg.negativeFloat = _negativeFloat_;
    }
    const _largeFloat_ = json["largeFloat"] ?? json["large_float"];
    if (_largeFloat_) {
      msg.largeFloat = _largeFloat_;
    }
    const _smallNegativeFloat_ =
      json["smallNegativeFloat"] ?? json["small_negative_float"];
    if (_smallNegativeFloat_) {
      msg.smallNegativeFloat = _smallNegativeFloat_;
    }
    const _infDouble_ = json["infDouble"] ?? json["inf_double"];
    if (_infDouble_) {
      msg.infDouble = _infDouble_;
    }
    const _negInfDouble_ = json["negInfDouble"] ?? json["neg_inf_double"];
    if (_negInfDouble_) {
      msg.negInfDouble = _negInfDouble_;
    }
    const _nanDouble_ = json["nanDouble"] ?? json["nan_double"];
    if (_nanDouble_) {
      msg.nanDouble = _nanDouble_;
    }
    const _infFloat_ = json["infFloat"] ?? json["inf_float"];
    if (_infFloat_) {
      msg.infFloat = _infFloat_;
    }
    const _negInfFloat_ = json["negInfFloat"] ?? json["neg_inf_float"];
    if (_negInfFloat_) {
      msg.negInfFloat = _negInfFloat_;
    }
    const _nanFloat_ = json["nanFloat"] ?? json["nan_float"];
    if (_nanFloat_) {
      msg.nanFloat = _nanFloat_;
    }
    const _cppTrigraph_ = json["cppTrigraph"] ?? json["cpp_trigraph"];
    if (_cppTrigraph_) {
      msg.cppTrigraph = _cppTrigraph_;
    }
    const _stringWithZero_ = json["stringWithZero"] ?? json["string_with_zero"];
    if (_stringWithZero_) {
      msg.stringWithZero = _stringWithZero_;
    }
    const _bytesWithZero_ = json["bytesWithZero"] ?? json["bytes_with_zero"];
    if (_bytesWithZero_) {
      msg.bytesWithZero = decodeBase64Bytes(_bytesWithZero_);
    }
    const _stringPieceWithZero_ =
      json["stringPieceWithZero"] ?? json["string_piece_with_zero"];
    if (_stringPieceWithZero_) {
      msg.stringPieceWithZero = _stringPieceWithZero_;
    }
    const _cordWithZero_ = json["cordWithZero"] ?? json["cord_with_zero"];
    if (_cordWithZero_) {
      msg.cordWithZero = _cordWithZero_;
    }
    const _replacementString_ =
      json["replacementString"] ?? json["replacement_string"];
    if (_replacementString_) {
      msg.replacementString = _replacementString_;
    }
    return msg;
  },
};

export const SparseEnumMessageJSON = {
  /**
   * Serializes SparseEnumMessage to JSON.
   */
  encode: function (msg: PartialDeep<SparseEnumMessage>): string {
    return JSON.stringify(SparseEnumMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes SparseEnumMessage from JSON.
   */
  decode: function (json: string): SparseEnumMessage {
    return SparseEnumMessageJSON._readMessage(
      SparseEnumMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes SparseEnumMessage with all fields set to their default value.
   */
  initialize: function (): SparseEnumMessage {
    return {
      sparseEnum: TestSparseEnum._fromInt(0),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<SparseEnumMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sparseEnum && TestSparseEnumJSON._toInt(msg.sparseEnum)) {
      json["sparseEnum"] = msg.sparseEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SparseEnumMessage,
    json: any,
  ): SparseEnumMessage {
    const _sparseEnum_ = json["sparseEnum"] ?? json["sparse_enum"];
    if (_sparseEnum_) {
      msg.sparseEnum = _sparseEnum_;
    }
    return msg;
  },
};

export const OneStringJSON = {
  /**
   * Serializes OneString to JSON.
   */
  encode: function (msg: PartialDeep<OneString>): string {
    return JSON.stringify(OneStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneString from JSON.
   */
  decode: function (json: string): OneString {
    return OneStringJSON._readMessage(
      OneStringJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OneString with all fields set to their default value.
   */
  initialize: function (): OneString {
    return {
      data: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneString>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneString, json: any): OneString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const MoreStringJSON = {
  /**
   * Serializes MoreString to JSON.
   */
  encode: function (msg: PartialDeep<MoreString>): string {
    return JSON.stringify(MoreStringJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreString from JSON.
   */
  decode: function (json: string): MoreString {
    return MoreStringJSON._readMessage(
      MoreStringJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MoreString with all fields set to their default value.
   */
  initialize: function (): MoreString {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MoreString>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreString, json: any): MoreString {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const OneBytesJSON = {
  /**
   * Serializes OneBytes to JSON.
   */
  encode: function (msg: PartialDeep<OneBytes>): string {
    return JSON.stringify(OneBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes OneBytes from JSON.
   */
  decode: function (json: string): OneBytes {
    return OneBytesJSON._readMessage(
      OneBytesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes OneBytes with all fields set to their default value.
   */
  initialize: function (): OneBytes {
    return {
      data: new Uint8Array(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<OneBytes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = encodeBase64Bytes(msg.data);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: OneBytes, json: any): OneBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = decodeBase64Bytes(_data_);
    }
    return msg;
  },
};

export const MoreBytesJSON = {
  /**
   * Serializes MoreBytes to JSON.
   */
  encode: function (msg: PartialDeep<MoreBytes>): string {
    return JSON.stringify(MoreBytesJSON._writeMessage(msg));
  },

  /**
   * Deserializes MoreBytes from JSON.
   */
  decode: function (json: string): MoreBytes {
    return MoreBytesJSON._readMessage(
      MoreBytesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MoreBytes with all fields set to their default value.
   */
  initialize: function (): MoreBytes {
    return {
      data: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MoreBytes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data?.length) {
      json["data"] = msg.data.map(encodeBase64Bytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MoreBytes, json: any): MoreBytes {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_.map(decodeBase64Bytes);
    }
    return msg;
  },
};

export const Int32MessageJSON = {
  /**
   * Serializes Int32Message to JSON.
   */
  encode: function (msg: PartialDeep<Int32Message>): string {
    return JSON.stringify(Int32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int32Message from JSON.
   */
  decode: function (json: string): Int32Message {
    return Int32MessageJSON._readMessage(
      Int32MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Int32Message with all fields set to their default value.
   */
  initialize: function (): Int32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Int32Message>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int32Message, json: any): Int32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Uint32MessageJSON = {
  /**
   * Serializes Uint32Message to JSON.
   */
  encode: function (msg: PartialDeep<Uint32Message>): string {
    return JSON.stringify(Uint32MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint32Message from JSON.
   */
  decode: function (json: string): Uint32Message {
    return Uint32MessageJSON._readMessage(
      Uint32MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Uint32Message with all fields set to their default value.
   */
  initialize: function (): Uint32Message {
    return {
      data: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Uint32Message>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint32Message, json: any): Uint32Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const Int64MessageJSON = {
  /**
   * Serializes Int64Message to JSON.
   */
  encode: function (msg: PartialDeep<Int64Message>): string {
    return JSON.stringify(Int64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Int64Message from JSON.
   */
  decode: function (json: string): Int64Message {
    return Int64MessageJSON._readMessage(
      Int64MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Int64Message with all fields set to their default value.
   */
  initialize: function (): Int64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Int64Message>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Int64Message, json: any): Int64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const Uint64MessageJSON = {
  /**
   * Serializes Uint64Message to JSON.
   */
  encode: function (msg: PartialDeep<Uint64Message>): string {
    return JSON.stringify(Uint64MessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Uint64Message from JSON.
   */
  decode: function (json: string): Uint64Message {
    return Uint64MessageJSON._readMessage(
      Uint64MessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes Uint64Message with all fields set to their default value.
   */
  initialize: function (): Uint64Message {
    return {
      data: 0n,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Uint64Message>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data.toString();
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Uint64Message, json: any): Uint64Message {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = BigInt(_data_);
    }
    return msg;
  },
};

export const BoolMessageJSON = {
  /**
   * Serializes BoolMessage to JSON.
   */
  encode: function (msg: PartialDeep<BoolMessage>): string {
    return JSON.stringify(BoolMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes BoolMessage from JSON.
   */
  decode: function (json: string): BoolMessage {
    return BoolMessageJSON._readMessage(
      BoolMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes BoolMessage with all fields set to their default value.
   */
  initialize: function (): BoolMessage {
    return {
      data: false,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<BoolMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.data) {
      json["data"] = msg.data;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: BoolMessage, json: any): BoolMessage {
    const _data_ = json["data"];
    if (_data_) {
      msg.data = _data_;
    }
    return msg;
  },
};

export const TestOneofJSON = {
  /**
   * Serializes TestOneof to JSON.
   */
  encode: function (msg: PartialDeep<TestOneof>): string {
    return JSON.stringify(TestOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof from JSON.
   */
  decode: function (json: string): TestOneof {
    return TestOneofJSON._readMessage(
      TestOneofJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneof with all fields set to their default value.
   */
  initialize: function (): TestOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof, json: any): TestOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestAllTypesJSON.initialize();
      TestAllTypesJSON._readMessage(msg.fooMessage, _fooMessage_);
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneof.FooGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestOneof.FooGroup>): string {
      return JSON.stringify(TestOneofJSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof.FooGroup {
      return TestOneofJSON.FooGroup._readMessage(
        TestOneofJSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof.FooGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof.FooGroup,
      json: any,
    ): TestOneof.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneofBackwardsCompatibleJSON = {
  /**
   * Serializes TestOneofBackwardsCompatible to JSON.
   */
  encode: function (msg: PartialDeep<TestOneofBackwardsCompatible>): string {
    return JSON.stringify(TestOneofBackwardsCompatibleJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneofBackwardsCompatible from JSON.
   */
  decode: function (json: string): TestOneofBackwardsCompatible {
    return TestOneofBackwardsCompatibleJSON._readMessage(
      TestOneofBackwardsCompatibleJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneofBackwardsCompatible with all fields set to their default value.
   */
  initialize: function (): TestOneofBackwardsCompatible {
    return {
      fooInt: 0,
      fooString: "",
      fooMessage: TestAllTypesJSON.initialize(),
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneofBackwardsCompatible>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage) {
      const _fooMessage_ = TestAllTypesJSON._writeMessage(msg.fooMessage);
      if (Object.keys(_fooMessage_).length > 0) {
        json["fooMessage"] = _fooMessage_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestOneofBackwardsCompatible,
    json: any,
  ): TestOneofBackwardsCompatible {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      TestAllTypesJSON._readMessage(msg.fooMessage, _fooMessage_);
    }
    return msg;
  },

  FooGroup: {
    /**
     * Serializes TestOneofBackwardsCompatible.FooGroup to JSON.
     */
    encode: function (
      msg: PartialDeep<TestOneofBackwardsCompatible.FooGroup>,
    ): string {
      return JSON.stringify(
        TestOneofBackwardsCompatibleJSON.FooGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestOneofBackwardsCompatible.FooGroup from JSON.
     */
    decode: function (json: string): TestOneofBackwardsCompatible.FooGroup {
      return TestOneofBackwardsCompatibleJSON.FooGroup._readMessage(
        TestOneofBackwardsCompatibleJSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneofBackwardsCompatible.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneofBackwardsCompatible.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneofBackwardsCompatible.FooGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneofBackwardsCompatible.FooGroup,
      json: any,
    ): TestOneofBackwardsCompatible.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },
};

export const TestOneof2JSON = {
  /**
   * Serializes TestOneof2 to JSON.
   */
  encode: function (msg: PartialDeep<TestOneof2>): string {
    return JSON.stringify(TestOneof2JSON._writeMessage(msg));
  },

  /**
   * Deserializes TestOneof2 from JSON.
   */
  decode: function (json: string): TestOneof2 {
    return TestOneof2JSON._readMessage(
      TestOneof2JSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestOneof2 with all fields set to their default value.
   */
  initialize: function (): TestOneof2 {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooCord: undefined,
      fooStringPiece: undefined,
      fooBytes: undefined,
      fooEnum: undefined,
      fooMessage: undefined,
      fooLazyMessage: undefined,
      barInt: undefined,
      barString: undefined,
      barCord: undefined,
      barStringPiece: undefined,
      barBytes: undefined,
      barEnum: undefined,
      barStringWithEmptyDefault: undefined,
      barCordWithEmptyDefault: undefined,
      barStringPieceWithEmptyDefault: undefined,
      barBytesWithEmptyDefault: undefined,
      bazInt: 0,
      bazString: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestOneof2>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooCord != undefined) {
      json["fooCord"] = msg.fooCord;
    }
    if (msg.fooStringPiece != undefined) {
      json["fooStringPiece"] = msg.fooStringPiece;
    }
    if (msg.fooBytes?.length) {
      json["fooBytes"] = encodeBase64Bytes(msg.fooBytes);
    }
    if (msg.fooEnum != undefined) {
      json["fooEnum"] = msg.fooEnum;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooMessage,
      );
      json["fooMessage"] = _fooMessage_;
    }
    if (msg.fooLazyMessage != undefined) {
      const _fooLazyMessage_ = TestOneof2JSON.NestedMessage._writeMessage(
        msg.fooLazyMessage,
      );
      json["fooLazyMessage"] = _fooLazyMessage_;
    }
    if (msg.barInt != undefined) {
      json["barInt"] = msg.barInt;
    }
    if (msg.barString != undefined) {
      json["barString"] = msg.barString;
    }
    if (msg.barCord != undefined) {
      json["barCord"] = msg.barCord;
    }
    if (msg.barStringPiece != undefined) {
      json["barStringPiece"] = msg.barStringPiece;
    }
    if (msg.barBytes?.length) {
      json["barBytes"] = encodeBase64Bytes(msg.barBytes);
    }
    if (msg.barEnum != undefined) {
      json["barEnum"] = msg.barEnum;
    }
    if (msg.barStringWithEmptyDefault != undefined) {
      json["barStringWithEmptyDefault"] = msg.barStringWithEmptyDefault;
    }
    if (msg.barCordWithEmptyDefault != undefined) {
      json["barCordWithEmptyDefault"] = msg.barCordWithEmptyDefault;
    }
    if (msg.barStringPieceWithEmptyDefault != undefined) {
      json["barStringPieceWithEmptyDefault"] =
        msg.barStringPieceWithEmptyDefault;
    }
    if (msg.barBytesWithEmptyDefault?.length) {
      json["barBytesWithEmptyDefault"] = encodeBase64Bytes(
        msg.barBytesWithEmptyDefault,
      );
    }
    if (msg.bazInt) {
      json["bazInt"] = msg.bazInt;
    }
    if (msg.bazString) {
      json["bazString"] = msg.bazString;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestOneof2, json: any): TestOneof2 {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooCord_ = json["fooCord"] ?? json["foo_cord"];
    if (_fooCord_) {
      msg.fooCord = _fooCord_;
    }
    const _fooStringPiece_ = json["fooStringPiece"] ?? json["foo_string_piece"];
    if (_fooStringPiece_) {
      msg.fooStringPiece = _fooStringPiece_;
    }
    const _fooBytes_ = json["fooBytes"] ?? json["foo_bytes"];
    if (_fooBytes_) {
      msg.fooBytes = decodeBase64Bytes(_fooBytes_);
    }
    const _fooEnum_ = json["fooEnum"] ?? json["foo_enum"];
    if (_fooEnum_) {
      msg.fooEnum = _fooEnum_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestOneof2JSON.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(msg.fooMessage, _fooMessage_);
    }
    const _fooLazyMessage_ = json["fooLazyMessage"] ?? json["foo_lazy_message"];
    if (_fooLazyMessage_) {
      msg.fooLazyMessage = TestOneof2JSON.NestedMessage.initialize();
      TestOneof2JSON.NestedMessage._readMessage(
        msg.fooLazyMessage,
        _fooLazyMessage_,
      );
    }
    const _barInt_ = json["barInt"] ?? json["bar_int"];
    if (_barInt_) {
      msg.barInt = _barInt_;
    }
    const _barString_ = json["barString"] ?? json["bar_string"];
    if (_barString_) {
      msg.barString = _barString_;
    }
    const _barCord_ = json["barCord"] ?? json["bar_cord"];
    if (_barCord_) {
      msg.barCord = _barCord_;
    }
    const _barStringPiece_ = json["barStringPiece"] ?? json["bar_string_piece"];
    if (_barStringPiece_) {
      msg.barStringPiece = _barStringPiece_;
    }
    const _barBytes_ = json["barBytes"] ?? json["bar_bytes"];
    if (_barBytes_) {
      msg.barBytes = decodeBase64Bytes(_barBytes_);
    }
    const _barEnum_ = json["barEnum"] ?? json["bar_enum"];
    if (_barEnum_) {
      msg.barEnum = _barEnum_;
    }
    const _barStringWithEmptyDefault_ =
      json["barStringWithEmptyDefault"] ??
      json["bar_string_with_empty_default"];
    if (_barStringWithEmptyDefault_) {
      msg.barStringWithEmptyDefault = _barStringWithEmptyDefault_;
    }
    const _barCordWithEmptyDefault_ =
      json["barCordWithEmptyDefault"] ?? json["bar_cord_with_empty_default"];
    if (_barCordWithEmptyDefault_) {
      msg.barCordWithEmptyDefault = _barCordWithEmptyDefault_;
    }
    const _barStringPieceWithEmptyDefault_ =
      json["barStringPieceWithEmptyDefault"] ??
      json["bar_string_piece_with_empty_default"];
    if (_barStringPieceWithEmptyDefault_) {
      msg.barStringPieceWithEmptyDefault = _barStringPieceWithEmptyDefault_;
    }
    const _barBytesWithEmptyDefault_ =
      json["barBytesWithEmptyDefault"] ?? json["bar_bytes_with_empty_default"];
    if (_barBytesWithEmptyDefault_) {
      msg.barBytesWithEmptyDefault = decodeBase64Bytes(
        _barBytesWithEmptyDefault_,
      );
    }
    const _bazInt_ = json["bazInt"] ?? json["baz_int"];
    if (_bazInt_) {
      msg.bazInt = _bazInt_;
    }
    const _bazString_ = json["bazString"] ?? json["baz_string"];
    if (_bazString_) {
      msg.bazString = _bazString_;
    }
    return msg;
  },

  NestedEnum: {
    FOO: "FOO",
    BAR: "BAR",
    BAZ: "BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestOneof2.NestedEnum {
      switch (i) {
        case 1: {
          return "FOO";
        }
        case 2: {
          return "BAR";
        }
        case 3: {
          return "BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestOneof2.NestedEnum;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestOneof2.NestedEnum): number {
      switch (i) {
        case "FOO": {
          return 1;
        }
        case "BAR": {
          return 2;
        }
        case "BAZ": {
          return 3;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  FooGroup: {
    /**
     * Serializes TestOneof2.FooGroup to JSON.
     */
    encode: function (msg: PartialDeep<TestOneof2.FooGroup>): string {
      return JSON.stringify(TestOneof2JSON.FooGroup._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.FooGroup from JSON.
     */
    decode: function (json: string): TestOneof2.FooGroup {
      return TestOneof2JSON.FooGroup._readMessage(
        TestOneof2JSON.FooGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof2.FooGroup with all fields set to their default value.
     */
    initialize: function (): TestOneof2.FooGroup {
      return {
        a: 0,
        b: "",
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof2.FooGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.a) {
        json["a"] = msg.a;
      }
      if (msg.b) {
        json["b"] = msg.b;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.FooGroup,
      json: any,
    ): TestOneof2.FooGroup {
      const _a_ = json["a"];
      if (_a_) {
        msg.a = _a_;
      }
      const _b_ = json["b"];
      if (_b_) {
        msg.b = _b_;
      }
      return msg;
    },
  },

  NestedMessage: {
    /**
     * Serializes TestOneof2.NestedMessage to JSON.
     */
    encode: function (msg: PartialDeep<TestOneof2.NestedMessage>): string {
      return JSON.stringify(TestOneof2JSON.NestedMessage._writeMessage(msg));
    },

    /**
     * Deserializes TestOneof2.NestedMessage from JSON.
     */
    decode: function (json: string): TestOneof2.NestedMessage {
      return TestOneof2JSON.NestedMessage._readMessage(
        TestOneof2JSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestOneof2.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestOneof2.NestedMessage {
      return {
        quxInt: 0n,
        corgeInt: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestOneof2.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.quxInt) {
        json["quxInt"] = msg.quxInt.toString();
      }
      if (msg.corgeInt?.length) {
        json["corgeInt"] = msg.corgeInt;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestOneof2.NestedMessage,
      json: any,
    ): TestOneof2.NestedMessage {
      const _quxInt_ = json["quxInt"] ?? json["qux_int"];
      if (_quxInt_) {
        msg.quxInt = BigInt(_quxInt_);
      }
      const _corgeInt_ = json["corgeInt"] ?? json["corge_int"];
      if (_corgeInt_) {
        msg.corgeInt = _corgeInt_;
      }
      return msg;
    },
  },
};

export const TestRequiredOneofJSON = {
  /**
   * Serializes TestRequiredOneof to JSON.
   */
  encode: function (msg: PartialDeep<TestRequiredOneof>): string {
    return JSON.stringify(TestRequiredOneofJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestRequiredOneof from JSON.
   */
  decode: function (json: string): TestRequiredOneof {
    return TestRequiredOneofJSON._readMessage(
      TestRequiredOneofJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRequiredOneof with all fields set to their default value.
   */
  initialize: function (): TestRequiredOneof {
    return {
      fooInt: undefined,
      fooString: undefined,
      fooMessage: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRequiredOneof>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooInt != undefined) {
      json["fooInt"] = msg.fooInt;
    }
    if (msg.fooString != undefined) {
      json["fooString"] = msg.fooString;
    }
    if (msg.fooMessage != undefined) {
      const _fooMessage_ = TestRequiredOneofJSON.NestedMessage._writeMessage(
        msg.fooMessage,
      );
      json["fooMessage"] = _fooMessage_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRequiredOneof,
    json: any,
  ): TestRequiredOneof {
    const _fooInt_ = json["fooInt"] ?? json["foo_int"];
    if (_fooInt_) {
      msg.fooInt = _fooInt_;
    }
    const _fooString_ = json["fooString"] ?? json["foo_string"];
    if (_fooString_) {
      msg.fooString = _fooString_;
    }
    const _fooMessage_ = json["fooMessage"] ?? json["foo_message"];
    if (_fooMessage_) {
      msg.fooMessage = TestRequiredOneofJSON.NestedMessage.initialize();
      TestRequiredOneofJSON.NestedMessage._readMessage(
        msg.fooMessage,
        _fooMessage_,
      );
    }
    return msg;
  },

  NestedMessage: {
    /**
     * Serializes TestRequiredOneof.NestedMessage to JSON.
     */
    encode: function (
      msg: PartialDeep<TestRequiredOneof.NestedMessage>,
    ): string {
      return JSON.stringify(
        TestRequiredOneofJSON.NestedMessage._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestRequiredOneof.NestedMessage from JSON.
     */
    decode: function (json: string): TestRequiredOneof.NestedMessage {
      return TestRequiredOneofJSON.NestedMessage._readMessage(
        TestRequiredOneofJSON.NestedMessage.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestRequiredOneof.NestedMessage with all fields set to their default value.
     */
    initialize: function (): TestRequiredOneof.NestedMessage {
      return {
        requiredDouble: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestRequiredOneof.NestedMessage>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.requiredDouble) {
        json["requiredDouble"] = msg.requiredDouble;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestRequiredOneof.NestedMessage,
      json: any,
    ): TestRequiredOneof.NestedMessage {
      const _requiredDouble_ =
        json["requiredDouble"] ?? json["required_double"];
      if (_requiredDouble_) {
        msg.requiredDouble = _requiredDouble_;
      }
      return msg;
    },
  },
};

export const TestPackedTypesJSON = {
  /**
   * Serializes TestPackedTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestPackedTypes>): string {
    return JSON.stringify(TestPackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestPackedTypes from JSON.
   */
  decode: function (json: string): TestPackedTypes {
    return TestPackedTypesJSON._readMessage(
      TestPackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestPackedTypes with all fields set to their default value.
   */
  initialize: function (): TestPackedTypes {
    return {
      packedInt32: [],
      packedInt64: [],
      packedUint32: [],
      packedUint64: [],
      packedSint32: [],
      packedSint64: [],
      packedFixed32: [],
      packedFixed64: [],
      packedSfixed32: [],
      packedSfixed64: [],
      packedFloat: [],
      packedDouble: [],
      packedBool: [],
      packedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestPackedTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.packedInt64?.length) {
      json["packedInt64"] = msg.packedInt64.map((x) => x.toString());
    }
    if (msg.packedUint32?.length) {
      json["packedUint32"] = msg.packedUint32;
    }
    if (msg.packedUint64?.length) {
      json["packedUint64"] = msg.packedUint64.map((x) => x.toString());
    }
    if (msg.packedSint32?.length) {
      json["packedSint32"] = msg.packedSint32;
    }
    if (msg.packedSint64?.length) {
      json["packedSint64"] = msg.packedSint64.map((x) => x.toString());
    }
    if (msg.packedFixed32?.length) {
      json["packedFixed32"] = msg.packedFixed32;
    }
    if (msg.packedFixed64?.length) {
      json["packedFixed64"] = msg.packedFixed64.map((x) => x.toString());
    }
    if (msg.packedSfixed32?.length) {
      json["packedSfixed32"] = msg.packedSfixed32;
    }
    if (msg.packedSfixed64?.length) {
      json["packedSfixed64"] = msg.packedSfixed64.map((x) => x.toString());
    }
    if (msg.packedFloat?.length) {
      json["packedFloat"] = msg.packedFloat;
    }
    if (msg.packedDouble?.length) {
      json["packedDouble"] = msg.packedDouble;
    }
    if (msg.packedBool?.length) {
      json["packedBool"] = msg.packedBool;
    }
    if (msg.packedEnum?.length) {
      json["packedEnum"] = msg.packedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestPackedTypes, json: any): TestPackedTypes {
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _packedInt64_ = json["packedInt64"] ?? json["packed_int64"];
    if (_packedInt64_) {
      msg.packedInt64 = _packedInt64_.map(BigInt);
    }
    const _packedUint32_ = json["packedUint32"] ?? json["packed_uint32"];
    if (_packedUint32_) {
      msg.packedUint32 = _packedUint32_;
    }
    const _packedUint64_ = json["packedUint64"] ?? json["packed_uint64"];
    if (_packedUint64_) {
      msg.packedUint64 = _packedUint64_.map(BigInt);
    }
    const _packedSint32_ = json["packedSint32"] ?? json["packed_sint32"];
    if (_packedSint32_) {
      msg.packedSint32 = _packedSint32_;
    }
    const _packedSint64_ = json["packedSint64"] ?? json["packed_sint64"];
    if (_packedSint64_) {
      msg.packedSint64 = _packedSint64_.map(BigInt);
    }
    const _packedFixed32_ = json["packedFixed32"] ?? json["packed_fixed32"];
    if (_packedFixed32_) {
      msg.packedFixed32 = _packedFixed32_;
    }
    const _packedFixed64_ = json["packedFixed64"] ?? json["packed_fixed64"];
    if (_packedFixed64_) {
      msg.packedFixed64 = _packedFixed64_.map(BigInt);
    }
    const _packedSfixed32_ = json["packedSfixed32"] ?? json["packed_sfixed32"];
    if (_packedSfixed32_) {
      msg.packedSfixed32 = _packedSfixed32_;
    }
    const _packedSfixed64_ = json["packedSfixed64"] ?? json["packed_sfixed64"];
    if (_packedSfixed64_) {
      msg.packedSfixed64 = _packedSfixed64_.map(BigInt);
    }
    const _packedFloat_ = json["packedFloat"] ?? json["packed_float"];
    if (_packedFloat_) {
      msg.packedFloat = _packedFloat_;
    }
    const _packedDouble_ = json["packedDouble"] ?? json["packed_double"];
    if (_packedDouble_) {
      msg.packedDouble = _packedDouble_;
    }
    const _packedBool_ = json["packedBool"] ?? json["packed_bool"];
    if (_packedBool_) {
      msg.packedBool = _packedBool_;
    }
    const _packedEnum_ = json["packedEnum"] ?? json["packed_enum"];
    if (_packedEnum_) {
      msg.packedEnum = _packedEnum_;
    }
    return msg;
  },
};

export const TestUnpackedTypesJSON = {
  /**
   * Serializes TestUnpackedTypes to JSON.
   */
  encode: function (msg: PartialDeep<TestUnpackedTypes>): string {
    return JSON.stringify(TestUnpackedTypesJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestUnpackedTypes from JSON.
   */
  decode: function (json: string): TestUnpackedTypes {
    return TestUnpackedTypesJSON._readMessage(
      TestUnpackedTypesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestUnpackedTypes with all fields set to their default value.
   */
  initialize: function (): TestUnpackedTypes {
    return {
      unpackedInt32: [],
      unpackedInt64: [],
      unpackedUint32: [],
      unpackedUint64: [],
      unpackedSint32: [],
      unpackedSint64: [],
      unpackedFixed32: [],
      unpackedFixed64: [],
      unpackedSfixed32: [],
      unpackedSfixed64: [],
      unpackedFloat: [],
      unpackedDouble: [],
      unpackedBool: [],
      unpackedEnum: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestUnpackedTypes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.unpackedInt32?.length) {
      json["unpackedInt32"] = msg.unpackedInt32;
    }
    if (msg.unpackedInt64?.length) {
      json["unpackedInt64"] = msg.unpackedInt64.map((x) => x.toString());
    }
    if (msg.unpackedUint32?.length) {
      json["unpackedUint32"] = msg.unpackedUint32;
    }
    if (msg.unpackedUint64?.length) {
      json["unpackedUint64"] = msg.unpackedUint64.map((x) => x.toString());
    }
    if (msg.unpackedSint32?.length) {
      json["unpackedSint32"] = msg.unpackedSint32;
    }
    if (msg.unpackedSint64?.length) {
      json["unpackedSint64"] = msg.unpackedSint64.map((x) => x.toString());
    }
    if (msg.unpackedFixed32?.length) {
      json["unpackedFixed32"] = msg.unpackedFixed32;
    }
    if (msg.unpackedFixed64?.length) {
      json["unpackedFixed64"] = msg.unpackedFixed64.map((x) => x.toString());
    }
    if (msg.unpackedSfixed32?.length) {
      json["unpackedSfixed32"] = msg.unpackedSfixed32;
    }
    if (msg.unpackedSfixed64?.length) {
      json["unpackedSfixed64"] = msg.unpackedSfixed64.map((x) => x.toString());
    }
    if (msg.unpackedFloat?.length) {
      json["unpackedFloat"] = msg.unpackedFloat;
    }
    if (msg.unpackedDouble?.length) {
      json["unpackedDouble"] = msg.unpackedDouble;
    }
    if (msg.unpackedBool?.length) {
      json["unpackedBool"] = msg.unpackedBool;
    }
    if (msg.unpackedEnum?.length) {
      json["unpackedEnum"] = msg.unpackedEnum;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedTypes,
    json: any,
  ): TestUnpackedTypes {
    const _unpackedInt32_ = json["unpackedInt32"] ?? json["unpacked_int32"];
    if (_unpackedInt32_) {
      msg.unpackedInt32 = _unpackedInt32_;
    }
    const _unpackedInt64_ = json["unpackedInt64"] ?? json["unpacked_int64"];
    if (_unpackedInt64_) {
      msg.unpackedInt64 = _unpackedInt64_.map(BigInt);
    }
    const _unpackedUint32_ = json["unpackedUint32"] ?? json["unpacked_uint32"];
    if (_unpackedUint32_) {
      msg.unpackedUint32 = _unpackedUint32_;
    }
    const _unpackedUint64_ = json["unpackedUint64"] ?? json["unpacked_uint64"];
    if (_unpackedUint64_) {
      msg.unpackedUint64 = _unpackedUint64_.map(BigInt);
    }
    const _unpackedSint32_ = json["unpackedSint32"] ?? json["unpacked_sint32"];
    if (_unpackedSint32_) {
      msg.unpackedSint32 = _unpackedSint32_;
    }
    const _unpackedSint64_ = json["unpackedSint64"] ?? json["unpacked_sint64"];
    if (_unpackedSint64_) {
      msg.unpackedSint64 = _unpackedSint64_.map(BigInt);
    }
    const _unpackedFixed32_ =
      json["unpackedFixed32"] ?? json["unpacked_fixed32"];
    if (_unpackedFixed32_) {
      msg.unpackedFixed32 = _unpackedFixed32_;
    }
    const _unpackedFixed64_ =
      json["unpackedFixed64"] ?? json["unpacked_fixed64"];
    if (_unpackedFixed64_) {
      msg.unpackedFixed64 = _unpackedFixed64_.map(BigInt);
    }
    const _unpackedSfixed32_ =
      json["unpackedSfixed32"] ?? json["unpacked_sfixed32"];
    if (_unpackedSfixed32_) {
      msg.unpackedSfixed32 = _unpackedSfixed32_;
    }
    const _unpackedSfixed64_ =
      json["unpackedSfixed64"] ?? json["unpacked_sfixed64"];
    if (_unpackedSfixed64_) {
      msg.unpackedSfixed64 = _unpackedSfixed64_.map(BigInt);
    }
    const _unpackedFloat_ = json["unpackedFloat"] ?? json["unpacked_float"];
    if (_unpackedFloat_) {
      msg.unpackedFloat = _unpackedFloat_;
    }
    const _unpackedDouble_ = json["unpackedDouble"] ?? json["unpacked_double"];
    if (_unpackedDouble_) {
      msg.unpackedDouble = _unpackedDouble_;
    }
    const _unpackedBool_ = json["unpackedBool"] ?? json["unpacked_bool"];
    if (_unpackedBool_) {
      msg.unpackedBool = _unpackedBool_;
    }
    const _unpackedEnum_ = json["unpackedEnum"] ?? json["unpacked_enum"];
    if (_unpackedEnum_) {
      msg.unpackedEnum = _unpackedEnum_;
    }
    return msg;
  },
};

export const TestPackedExtensionsJSON = {
  /**
   * Serializes TestPackedExtensions to JSON.
   */
  encode: function (_msg?: PartialDeep<TestPackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestPackedExtensions from JSON.
   */
  decode: function (_json?: string): TestPackedExtensions {
    return {};
  },

  /**
   * Initializes TestPackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestPackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestPackedExtensions>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestPackedExtensions,
    _json: any,
  ): TestPackedExtensions {
    return msg;
  },
};

export const TestUnpackedExtensionsJSON = {
  /**
   * Serializes TestUnpackedExtensions to JSON.
   */
  encode: function (_msg?: PartialDeep<TestUnpackedExtensions>): string {
    return "{}";
  },

  /**
   * Deserializes TestUnpackedExtensions from JSON.
   */
  decode: function (_json?: string): TestUnpackedExtensions {
    return {};
  },

  /**
   * Initializes TestUnpackedExtensions with all fields set to their default value.
   */
  initialize: function (): TestUnpackedExtensions {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<TestUnpackedExtensions>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestUnpackedExtensions,
    _json: any,
  ): TestUnpackedExtensions {
    return msg;
  },
};

export const TestDynamicExtensionsJSON = {
  /**
   * Serializes TestDynamicExtensions to JSON.
   */
  encode: function (msg: PartialDeep<TestDynamicExtensions>): string {
    return JSON.stringify(TestDynamicExtensionsJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestDynamicExtensions from JSON.
   */
  decode: function (json: string): TestDynamicExtensions {
    return TestDynamicExtensionsJSON._readMessage(
      TestDynamicExtensionsJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestDynamicExtensions with all fields set to their default value.
   */
  initialize: function (): TestDynamicExtensions {
    return {
      scalarExtension: 0,
      enumExtension: ForeignEnum._fromInt(0),
      dynamicEnumExtension: TestDynamicExtensions.DynamicEnumType._fromInt(0),
      messageExtension: ForeignMessageJSON.initialize(),
      dynamicMessageExtension:
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
      repeatedExtension: [],
      packedExtension: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestDynamicExtensions>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.scalarExtension) {
      json["scalarExtension"] = msg.scalarExtension;
    }
    if (msg.enumExtension && ForeignEnumJSON._toInt(msg.enumExtension)) {
      json["enumExtension"] = msg.enumExtension;
    }
    if (
      msg.dynamicEnumExtension &&
      TestDynamicExtensionsJSON.DynamicEnumType._toInt(msg.dynamicEnumExtension)
    ) {
      json["dynamicEnumExtension"] = msg.dynamicEnumExtension;
    }
    if (msg.messageExtension) {
      const _messageExtension_ = ForeignMessageJSON._writeMessage(
        msg.messageExtension,
      );
      if (Object.keys(_messageExtension_).length > 0) {
        json["messageExtension"] = _messageExtension_;
      }
    }
    if (msg.dynamicMessageExtension) {
      const _dynamicMessageExtension_ =
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(
          msg.dynamicMessageExtension,
        );
      if (Object.keys(_dynamicMessageExtension_).length > 0) {
        json["dynamicMessageExtension"] = _dynamicMessageExtension_;
      }
    }
    if (msg.repeatedExtension?.length) {
      json["repeatedExtension"] = msg.repeatedExtension;
    }
    if (msg.packedExtension?.length) {
      json["packedExtension"] = msg.packedExtension;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestDynamicExtensions,
    json: any,
  ): TestDynamicExtensions {
    const _scalarExtension_ =
      json["scalarExtension"] ?? json["scalar_extension"];
    if (_scalarExtension_) {
      msg.scalarExtension = _scalarExtension_;
    }
    const _enumExtension_ = json["enumExtension"] ?? json["enum_extension"];
    if (_enumExtension_) {
      msg.enumExtension = _enumExtension_;
    }
    const _dynamicEnumExtension_ =
      json["dynamicEnumExtension"] ?? json["dynamic_enum_extension"];
    if (_dynamicEnumExtension_) {
      msg.dynamicEnumExtension = _dynamicEnumExtension_;
    }
    const _messageExtension_ =
      json["messageExtension"] ?? json["message_extension"];
    if (_messageExtension_) {
      ForeignMessageJSON._readMessage(msg.messageExtension, _messageExtension_);
    }
    const _dynamicMessageExtension_ =
      json["dynamicMessageExtension"] ?? json["dynamic_message_extension"];
    if (_dynamicMessageExtension_) {
      TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        msg.dynamicMessageExtension,
        _dynamicMessageExtension_,
      );
    }
    const _repeatedExtension_ =
      json["repeatedExtension"] ?? json["repeated_extension"];
    if (_repeatedExtension_) {
      msg.repeatedExtension = _repeatedExtension_;
    }
    const _packedExtension_ =
      json["packedExtension"] ?? json["packed_extension"];
    if (_packedExtension_) {
      msg.packedExtension = _packedExtension_;
    }
    return msg;
  },

  DynamicEnumType: {
    DYNAMIC_FOO: "DYNAMIC_FOO",
    DYNAMIC_BAR: "DYNAMIC_BAR",
    DYNAMIC_BAZ: "DYNAMIC_BAZ",
    /**
     * @private
     */
    _fromInt: function (i: number): TestDynamicExtensions.DynamicEnumType {
      switch (i) {
        case 2200: {
          return "DYNAMIC_FOO";
        }
        case 2201: {
          return "DYNAMIC_BAR";
        }
        case 2202: {
          return "DYNAMIC_BAZ";
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as TestDynamicExtensions.DynamicEnumType;
        }
      }
    },
    /**
     * @private
     */
    _toInt: function (i: TestDynamicExtensions.DynamicEnumType): number {
      switch (i) {
        case "DYNAMIC_FOO": {
          return 2200;
        }
        case "DYNAMIC_BAR": {
          return 2201;
        }
        case "DYNAMIC_BAZ": {
          return 2202;
        }
        // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
        default: {
          return i as unknown as number;
        }
      }
    },
  } as const,

  DynamicMessageType: {
    /**
     * Serializes TestDynamicExtensions.DynamicMessageType to JSON.
     */
    encode: function (
      msg: PartialDeep<TestDynamicExtensions.DynamicMessageType>,
    ): string {
      return JSON.stringify(
        TestDynamicExtensionsJSON.DynamicMessageType._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestDynamicExtensions.DynamicMessageType from JSON.
     */
    decode: function (json: string): TestDynamicExtensions.DynamicMessageType {
      return TestDynamicExtensionsJSON.DynamicMessageType._readMessage(
        TestDynamicExtensionsJSON.DynamicMessageType.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestDynamicExtensions.DynamicMessageType with all fields set to their default value.
     */
    initialize: function (): TestDynamicExtensions.DynamicMessageType {
      return {
        dynamicField: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestDynamicExtensions.DynamicMessageType>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.dynamicField) {
        json["dynamicField"] = msg.dynamicField;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestDynamicExtensions.DynamicMessageType,
      json: any,
    ): TestDynamicExtensions.DynamicMessageType {
      const _dynamicField_ = json["dynamicField"] ?? json["dynamic_field"];
      if (_dynamicField_) {
        msg.dynamicField = _dynamicField_;
      }
      return msg;
    },
  },
};

export const TestRepeatedScalarDifferentTagSizesJSON = {
  /**
   * Serializes TestRepeatedScalarDifferentTagSizes to JSON.
   */
  encode: function (
    msg: PartialDeep<TestRepeatedScalarDifferentTagSizes>,
  ): string {
    return JSON.stringify(
      TestRepeatedScalarDifferentTagSizesJSON._writeMessage(msg),
    );
  },

  /**
   * Deserializes TestRepeatedScalarDifferentTagSizes from JSON.
   */
  decode: function (json: string): TestRepeatedScalarDifferentTagSizes {
    return TestRepeatedScalarDifferentTagSizesJSON._readMessage(
      TestRepeatedScalarDifferentTagSizesJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestRepeatedScalarDifferentTagSizes with all fields set to their default value.
   */
  initialize: function (): TestRepeatedScalarDifferentTagSizes {
    return {
      repeatedFixed32: [],
      repeatedInt32: [],
      repeatedFixed64: [],
      repeatedInt64: [],
      repeatedFloat: [],
      repeatedUint64: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestRepeatedScalarDifferentTagSizes>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.repeatedFixed32?.length) {
      json["repeatedFixed32"] = msg.repeatedFixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.repeatedFixed64?.length) {
      json["repeatedFixed64"] = msg.repeatedFixed64.map((x) => x.toString());
    }
    if (msg.repeatedInt64?.length) {
      json["repeatedInt64"] = msg.repeatedInt64.map((x) => x.toString());
    }
    if (msg.repeatedFloat?.length) {
      json["repeatedFloat"] = msg.repeatedFloat;
    }
    if (msg.repeatedUint64?.length) {
      json["repeatedUint64"] = msg.repeatedUint64.map((x) => x.toString());
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestRepeatedScalarDifferentTagSizes,
    json: any,
  ): TestRepeatedScalarDifferentTagSizes {
    const _repeatedFixed32_ =
      json["repeatedFixed32"] ?? json["repeated_fixed32"];
    if (_repeatedFixed32_) {
      msg.repeatedFixed32 = _repeatedFixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _repeatedFixed64_ =
      json["repeatedFixed64"] ?? json["repeated_fixed64"];
    if (_repeatedFixed64_) {
      msg.repeatedFixed64 = _repeatedFixed64_.map(BigInt);
    }
    const _repeatedInt64_ = json["repeatedInt64"] ?? json["repeated_int64"];
    if (_repeatedInt64_) {
      msg.repeatedInt64 = _repeatedInt64_.map(BigInt);
    }
    const _repeatedFloat_ = json["repeatedFloat"] ?? json["repeated_float"];
    if (_repeatedFloat_) {
      msg.repeatedFloat = _repeatedFloat_;
    }
    const _repeatedUint64_ = json["repeatedUint64"] ?? json["repeated_uint64"];
    if (_repeatedUint64_) {
      msg.repeatedUint64 = _repeatedUint64_.map(BigInt);
    }
    return msg;
  },
};

export const TestParsingMergeJSON = {
  /**
   * Serializes TestParsingMerge to JSON.
   */
  encode: function (msg: PartialDeep<TestParsingMerge>): string {
    return JSON.stringify(TestParsingMergeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestParsingMerge from JSON.
   */
  decode: function (json: string): TestParsingMerge {
    return TestParsingMergeJSON._readMessage(
      TestParsingMergeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestParsingMerge with all fields set to their default value.
   */
  initialize: function (): TestParsingMerge {
    return {
      requiredAllTypes: TestAllTypesJSON.initialize(),
      optionalAllTypes: TestAllTypesJSON.initialize(),
      repeatedAllTypes: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestParsingMerge>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.requiredAllTypes) {
      const _requiredAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.requiredAllTypes,
      );
      if (Object.keys(_requiredAllTypes_).length > 0) {
        json["requiredAllTypes"] = _requiredAllTypes_;
      }
    }
    if (msg.optionalAllTypes) {
      const _optionalAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.optionalAllTypes,
      );
      if (Object.keys(_optionalAllTypes_).length > 0) {
        json["optionalAllTypes"] = _optionalAllTypes_;
      }
    }
    if (msg.repeatedAllTypes?.length) {
      json["repeatedAllTypes"] = msg.repeatedAllTypes.map(
        TestAllTypesJSON._writeMessage,
      );
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestParsingMerge, json: any): TestParsingMerge {
    const _requiredAllTypes_ =
      json["requiredAllTypes"] ?? json["required_all_types"];
    if (_requiredAllTypes_) {
      TestAllTypesJSON._readMessage(msg.requiredAllTypes, _requiredAllTypes_);
    }
    const _optionalAllTypes_ =
      json["optionalAllTypes"] ?? json["optional_all_types"];
    if (_optionalAllTypes_) {
      TestAllTypesJSON._readMessage(msg.optionalAllTypes, _optionalAllTypes_);
    }
    const _repeatedAllTypes_ =
      json["repeatedAllTypes"] ?? json["repeated_all_types"];
    if (_repeatedAllTypes_) {
      for (const item of _repeatedAllTypes_) {
        const m = TestAllTypesJSON.initialize();
        TestAllTypesJSON._readMessage(m, item);
        msg.repeatedAllTypes.push(m);
      }
    }
    return msg;
  },

  RepeatedFieldsGenerator: {
    /**
     * Serializes TestParsingMerge.RepeatedFieldsGenerator to JSON.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator>,
    ): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedFieldsGenerator._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedFieldsGenerator from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedFieldsGenerator {
      return TestParsingMergeJSON.RepeatedFieldsGenerator._readMessage(
        TestParsingMergeJSON.RepeatedFieldsGenerator.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedFieldsGenerator with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedFieldsGenerator {
      return {
        field1: [],
        field2: [],
        field3: [],
        ext1: [],
        ext2: [],
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.field1?.length) {
        json["field1"] = msg.field1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field2?.length) {
        json["field2"] = msg.field2.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.field3?.length) {
        json["field3"] = msg.field3.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext1?.length) {
        json["ext1"] = msg.ext1.map(TestAllTypesJSON._writeMessage);
      }
      if (msg.ext2?.length) {
        json["ext2"] = msg.ext2.map(TestAllTypesJSON._writeMessage);
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedFieldsGenerator,
      json: any,
    ): TestParsingMerge.RepeatedFieldsGenerator {
      const _field1_ = json["field1"];
      if (_field1_) {
        for (const item of _field1_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field1.push(m);
        }
      }
      const _field2_ = json["field2"];
      if (_field2_) {
        for (const item of _field2_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field2.push(m);
        }
      }
      const _field3_ = json["field3"];
      if (_field3_) {
        for (const item of _field3_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.field3.push(m);
        }
      }
      const _ext1_ = json["ext1"];
      if (_ext1_) {
        for (const item of _ext1_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext1.push(m);
        }
      }
      const _ext2_ = json["ext2"];
      if (_ext2_) {
        for (const item of _ext2_) {
          const m = TestAllTypesJSON.initialize();
          TestAllTypesJSON._readMessage(m, item);
          msg.ext2.push(m);
        }
      }
      return msg;
    },

    Group1: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group1 to JSON.
       */
      encode: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group1 from JSON.
       */
      decode: function (
        json: string,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group1._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group1.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group1 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group1>,
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group1,
        json: any,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group1 {
        const _field1_ = json["field1"];
        if (_field1_) {
          TestAllTypesJSON._readMessage(msg.field1, _field1_);
        }
        return msg;
      },
    },

    Group2: {
      /**
       * Serializes TestParsingMerge.RepeatedFieldsGenerator.Group2 to JSON.
       */
      encode: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
      ): string {
        return JSON.stringify(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._writeMessage(
            msg,
          ),
        );
      },

      /**
       * Deserializes TestParsingMerge.RepeatedFieldsGenerator.Group2 from JSON.
       */
      decode: function (
        json: string,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return TestParsingMergeJSON.RepeatedFieldsGenerator.Group2._readMessage(
          TestParsingMergeJSON.RepeatedFieldsGenerator.Group2.initialize(),
          JSON.parse(json),
        );
      },

      /**
       * Initializes TestParsingMerge.RepeatedFieldsGenerator.Group2 with all fields set to their default value.
       */
      initialize: function (): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        return {
          field1: TestAllTypesJSON.initialize(),
        };
      },

      /**
       * @private
       */
      _writeMessage: function (
        msg: PartialDeep<TestParsingMerge.RepeatedFieldsGenerator.Group2>,
      ): Record<string, unknown> {
        const json: Record<string, unknown> = {};
        if (msg.field1) {
          const _field1_ = TestAllTypesJSON._writeMessage(msg.field1);
          if (Object.keys(_field1_).length > 0) {
            json["field1"] = _field1_;
          }
        }
        return json;
      },

      /**
       * @private
       */
      _readMessage: function (
        msg: TestParsingMerge.RepeatedFieldsGenerator.Group2,
        json: any,
      ): TestParsingMerge.RepeatedFieldsGenerator.Group2 {
        const _field1_ = json["field1"];
        if (_field1_) {
          TestAllTypesJSON._readMessage(msg.field1, _field1_);
        }
        return msg;
      },
    },
  },

  OptionalGroup: {
    /**
     * Serializes TestParsingMerge.OptionalGroup to JSON.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.OptionalGroup>,
    ): string {
      return JSON.stringify(
        TestParsingMergeJSON.OptionalGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.OptionalGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.OptionalGroup {
      return TestParsingMergeJSON.OptionalGroup._readMessage(
        TestParsingMergeJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.OptionalGroup {
      return {
        optionalGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.OptionalGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.optionalGroupAllTypes) {
        const _optionalGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.optionalGroupAllTypes,
        );
        if (Object.keys(_optionalGroupAllTypes_).length > 0) {
          json["optionalGroupAllTypes"] = _optionalGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.OptionalGroup,
      json: any,
    ): TestParsingMerge.OptionalGroup {
      const _optionalGroupAllTypes_ =
        json["optionalGroupAllTypes"] ?? json["optional_group_all_types"];
      if (_optionalGroupAllTypes_) {
        TestAllTypesJSON._readMessage(
          msg.optionalGroupAllTypes,
          _optionalGroupAllTypes_,
        );
      }
      return msg;
    },
  },

  RepeatedGroup: {
    /**
     * Serializes TestParsingMerge.RepeatedGroup to JSON.
     */
    encode: function (
      msg: PartialDeep<TestParsingMerge.RepeatedGroup>,
    ): string {
      return JSON.stringify(
        TestParsingMergeJSON.RepeatedGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestParsingMerge.RepeatedGroup from JSON.
     */
    decode: function (json: string): TestParsingMerge.RepeatedGroup {
      return TestParsingMergeJSON.RepeatedGroup._readMessage(
        TestParsingMergeJSON.RepeatedGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestParsingMerge.RepeatedGroup with all fields set to their default value.
     */
    initialize: function (): TestParsingMerge.RepeatedGroup {
      return {
        repeatedGroupAllTypes: TestAllTypesJSON.initialize(),
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestParsingMerge.RepeatedGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.repeatedGroupAllTypes) {
        const _repeatedGroupAllTypes_ = TestAllTypesJSON._writeMessage(
          msg.repeatedGroupAllTypes,
        );
        if (Object.keys(_repeatedGroupAllTypes_).length > 0) {
          json["repeatedGroupAllTypes"] = _repeatedGroupAllTypes_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestParsingMerge.RepeatedGroup,
      json: any,
    ): TestParsingMerge.RepeatedGroup {
      const _repeatedGroupAllTypes_ =
        json["repeatedGroupAllTypes"] ?? json["repeated_group_all_types"];
      if (_repeatedGroupAllTypes_) {
        TestAllTypesJSON._readMessage(
          msg.repeatedGroupAllTypes,
          _repeatedGroupAllTypes_,
        );
      }
      return msg;
    },
  },
};

export const TestCommentInjectionMessageJSON = {
  /**
   * Serializes TestCommentInjectionMessage to JSON.
   */
  encode: function (msg: PartialDeep<TestCommentInjectionMessage>): string {
    return JSON.stringify(TestCommentInjectionMessageJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestCommentInjectionMessage from JSON.
   */
  decode: function (json: string): TestCommentInjectionMessage {
    return TestCommentInjectionMessageJSON._readMessage(
      TestCommentInjectionMessageJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestCommentInjectionMessage with all fields set to their default value.
   */
  initialize: function (): TestCommentInjectionMessage {
    return {
      a: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestCommentInjectionMessage>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.a) {
      json["a"] = msg.a;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestCommentInjectionMessage,
    json: any,
  ): TestCommentInjectionMessage {
    const _a_ = json["a"];
    if (_a_) {
      msg.a = _a_;
    }
    return msg;
  },
};

export const FooRequestJSON = {
  /**
   * Serializes FooRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<FooRequest>): string {
    return "{}";
  },

  /**
   * Deserializes FooRequest from JSON.
   */
  decode: function (_json?: string): FooRequest {
    return {};
  },

  /**
   * Initializes FooRequest with all fields set to their default value.
   */
  initialize: function (): FooRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooRequest, _json: any): FooRequest {
    return msg;
  },
};

export const FooResponseJSON = {
  /**
   * Serializes FooResponse to JSON.
   */
  encode: function (_msg?: PartialDeep<FooResponse>): string {
    return "{}";
  },

  /**
   * Deserializes FooResponse from JSON.
   */
  decode: function (_json?: string): FooResponse {
    return {};
  },

  /**
   * Initializes FooResponse with all fields set to their default value.
   */
  initialize: function (): FooResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooResponse>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooResponse, _json: any): FooResponse {
    return msg;
  },
};

export const FooClientMessageJSON = {
  /**
   * Serializes FooClientMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<FooClientMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooClientMessage from JSON.
   */
  decode: function (_json?: string): FooClientMessage {
    return {};
  },

  /**
   * Initializes FooClientMessage with all fields set to their default value.
   */
  initialize: function (): FooClientMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooClientMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooClientMessage, _json: any): FooClientMessage {
    return msg;
  },
};

export const FooServerMessageJSON = {
  /**
   * Serializes FooServerMessage to JSON.
   */
  encode: function (_msg?: PartialDeep<FooServerMessage>): string {
    return "{}";
  },

  /**
   * Deserializes FooServerMessage from JSON.
   */
  decode: function (_json?: string): FooServerMessage {
    return {};
  },

  /**
   * Initializes FooServerMessage with all fields set to their default value.
   */
  initialize: function (): FooServerMessage {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<FooServerMessage>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: FooServerMessage, _json: any): FooServerMessage {
    return msg;
  },
};

export const BarRequestJSON = {
  /**
   * Serializes BarRequest to JSON.
   */
  encode: function (_msg?: PartialDeep<BarRequest>): string {
    return "{}";
  },

  /**
   * Deserializes BarRequest from JSON.
   */
  decode: function (_json?: string): BarRequest {
    return {};
  },

  /**
   * Initializes BarRequest with all fields set to their default value.
   */
  initialize: function (): BarRequest {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BarRequest>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarRequest, _json: any): BarRequest {
    return msg;
  },
};

export const BarResponseJSON = {
  /**
   * Serializes BarResponse to JSON.
   */
  encode: function (_msg?: PartialDeep<BarResponse>): string {
    return "{}";
  },

  /**
   * Deserializes BarResponse from JSON.
   */
  decode: function (_json?: string): BarResponse {
    return {};
  },

  /**
   * Initializes BarResponse with all fields set to their default value.
   */
  initialize: function (): BarResponse {
    return {};
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<BarResponse>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: BarResponse, _json: any): BarResponse {
    return msg;
  },
};

export const TestJsonNameJSON = {
  /**
   * Serializes TestJsonName to JSON.
   */
  encode: function (msg: PartialDeep<TestJsonName>): string {
    return JSON.stringify(TestJsonNameJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestJsonName from JSON.
   */
  decode: function (json: string): TestJsonName {
    return TestJsonNameJSON._readMessage(
      TestJsonNameJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestJsonName with all fields set to their default value.
   */
  initialize: function (): TestJsonName {
    return {
      fieldName1: 0,
      fieldName2: 0,
      FieldName3: 0,
      fieldName4: 0,
      FIELDNAME5: 0,
      fieldName6: 0,
      fieldname7: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestJsonName>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fieldName1) {
      json["fieldName1"] = msg.fieldName1;
    }
    if (msg.fieldName2) {
      json["fieldName2"] = msg.fieldName2;
    }
    if (msg.FieldName3) {
      json["FieldName3"] = msg.FieldName3;
    }
    if (msg.fieldName4) {
      json["FieldName4"] = msg.fieldName4;
    }
    if (msg.FIELDNAME5) {
      json["FIELDNAME5"] = msg.FIELDNAME5;
    }
    if (msg.fieldName6) {
      json["@type"] = msg.fieldName6;
    }
    if (msg.fieldname7) {
      json["fieldname7"] = msg.fieldname7;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TestJsonName, json: any): TestJsonName {
    const _fieldName1_ = json["fieldName1"] ?? json["field_name1"];
    if (_fieldName1_) {
      msg.fieldName1 = _fieldName1_;
    }
    const _fieldName2_ = json["fieldName2"];
    if (_fieldName2_) {
      msg.fieldName2 = _fieldName2_;
    }
    const _FieldName3_ = json["FieldName3"];
    if (_FieldName3_) {
      msg.FieldName3 = _FieldName3_;
    }
    const _fieldName4_ =
      json["FieldName4"] ?? json["fieldName4"] ?? json["_field_name4"];
    if (_fieldName4_) {
      msg.fieldName4 = _fieldName4_;
    }
    const _FIELDNAME5_ = json["FIELDNAME5"] ?? json["FIELD_NAME5"];
    if (_FIELDNAME5_) {
      msg.FIELDNAME5 = _FIELDNAME5_;
    }
    const _fieldName6_ =
      json["@type"] ?? json["fieldName6"] ?? json["field_name6"];
    if (_fieldName6_) {
      msg.fieldName6 = _fieldName6_;
    }
    const _fieldname7_ = json["fieldname7"];
    if (_fieldname7_) {
      msg.fieldname7 = _fieldname7_;
    }
    return msg;
  },
};

export const TestHugeFieldNumbersJSON = {
  /**
   * Serializes TestHugeFieldNumbers to JSON.
   */
  encode: function (msg: PartialDeep<TestHugeFieldNumbers>): string {
    return JSON.stringify(TestHugeFieldNumbersJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestHugeFieldNumbers from JSON.
   */
  decode: function (json: string): TestHugeFieldNumbers {
    return TestHugeFieldNumbersJSON._readMessage(
      TestHugeFieldNumbersJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestHugeFieldNumbers with all fields set to their default value.
   */
  initialize: function (): TestHugeFieldNumbers {
    return {
      optionalInt32: 0,
      fixed32: 0,
      repeatedInt32: [],
      packedInt32: [],
      optionalEnum: ForeignEnum._fromInt(0),
      optionalString: "",
      optionalBytes: new Uint8Array(),
      optionalMessage: ForeignMessageJSON.initialize(),
      stringStringMap: {},
      oneofUint32: undefined,
      oneofTestAllTypes: undefined,
      oneofString: undefined,
      oneofBytes: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestHugeFieldNumbers>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.optionalInt32) {
      json["optionalInt32"] = msg.optionalInt32;
    }
    if (msg.fixed32) {
      json["fixed32"] = msg.fixed32;
    }
    if (msg.repeatedInt32?.length) {
      json["repeatedInt32"] = msg.repeatedInt32;
    }
    if (msg.packedInt32?.length) {
      json["packedInt32"] = msg.packedInt32;
    }
    if (msg.optionalEnum && ForeignEnumJSON._toInt(msg.optionalEnum)) {
      json["optionalEnum"] = msg.optionalEnum;
    }
    if (msg.optionalString) {
      json["optionalString"] = msg.optionalString;
    }
    if (msg.optionalBytes?.length) {
      json["optionalBytes"] = encodeBase64Bytes(msg.optionalBytes);
    }
    if (msg.optionalMessage) {
      const _optionalMessage_ = ForeignMessageJSON._writeMessage(
        msg.optionalMessage,
      );
      if (Object.keys(_optionalMessage_).length > 0) {
        json["optionalMessage"] = _optionalMessage_;
      }
    }
    if (msg.stringStringMap) {
      const _stringStringMap_ = Object.fromEntries(
        Object.entries(msg.stringStringMap)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._writeMessage)
          .map(({ key, value }) => [key, value]),
      );
      if (Object.keys(_stringStringMap_).length > 0) {
        json["stringStringMap"] = _stringStringMap_;
      }
    }
    if (msg.oneofUint32 != undefined) {
      json["oneofUint32"] = msg.oneofUint32;
    }
    if (msg.oneofTestAllTypes != undefined) {
      const _oneofTestAllTypes_ = TestAllTypesJSON._writeMessage(
        msg.oneofTestAllTypes,
      );
      json["oneofTestAllTypes"] = _oneofTestAllTypes_;
    }
    if (msg.oneofString != undefined) {
      json["oneofString"] = msg.oneofString;
    }
    if (msg.oneofBytes?.length) {
      json["oneofBytes"] = encodeBase64Bytes(msg.oneofBytes);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestHugeFieldNumbers,
    json: any,
  ): TestHugeFieldNumbers {
    const _optionalInt32_ = json["optionalInt32"] ?? json["optional_int32"];
    if (_optionalInt32_) {
      msg.optionalInt32 = _optionalInt32_;
    }
    const _fixed32_ = json["fixed32"] ?? json["fixed_32"];
    if (_fixed32_) {
      msg.fixed32 = _fixed32_;
    }
    const _repeatedInt32_ = json["repeatedInt32"] ?? json["repeated_int32"];
    if (_repeatedInt32_) {
      msg.repeatedInt32 = _repeatedInt32_;
    }
    const _packedInt32_ = json["packedInt32"] ?? json["packed_int32"];
    if (_packedInt32_) {
      msg.packedInt32 = _packedInt32_;
    }
    const _optionalEnum_ = json["optionalEnum"] ?? json["optional_enum"];
    if (_optionalEnum_) {
      msg.optionalEnum = _optionalEnum_;
    }
    const _optionalString_ = json["optionalString"] ?? json["optional_string"];
    if (_optionalString_) {
      msg.optionalString = _optionalString_;
    }
    const _optionalBytes_ = json["optionalBytes"] ?? json["optional_bytes"];
    if (_optionalBytes_) {
      msg.optionalBytes = decodeBase64Bytes(_optionalBytes_);
    }
    const _optionalMessage_ =
      json["optionalMessage"] ?? json["optional_message"];
    if (_optionalMessage_) {
      ForeignMessageJSON._readMessage(msg.optionalMessage, _optionalMessage_);
    }
    const _stringStringMap_ =
      json["stringStringMap"] ?? json["string_string_map"];
    if (_stringStringMap_) {
      msg.stringStringMap = Object.fromEntries(
        Object.entries(_stringStringMap_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(TestHugeFieldNumbersJSON.StringStringMap._readMessage)
          .map(({ key, value }) => [key, value]),
      );
    }
    const _oneofUint32_ = json["oneofUint32"] ?? json["oneof_uint32"];
    if (_oneofUint32_) {
      msg.oneofUint32 = _oneofUint32_;
    }
    const _oneofTestAllTypes_ =
      json["oneofTestAllTypes"] ?? json["oneof_test_all_types"];
    if (_oneofTestAllTypes_) {
      msg.oneofTestAllTypes = TestAllTypesJSON.initialize();
      TestAllTypesJSON._readMessage(msg.oneofTestAllTypes, _oneofTestAllTypes_);
    }
    const _oneofString_ = json["oneofString"] ?? json["oneof_string"];
    if (_oneofString_) {
      msg.oneofString = _oneofString_;
    }
    const _oneofBytes_ = json["oneofBytes"] ?? json["oneof_bytes"];
    if (_oneofBytes_) {
      msg.oneofBytes = decodeBase64Bytes(_oneofBytes_);
    }
    return msg;
  },

  OptionalGroup: {
    /**
     * Serializes TestHugeFieldNumbers.OptionalGroup to JSON.
     */
    encode: function (
      msg: PartialDeep<TestHugeFieldNumbers.OptionalGroup>,
    ): string {
      return JSON.stringify(
        TestHugeFieldNumbersJSON.OptionalGroup._writeMessage(msg),
      );
    },

    /**
     * Deserializes TestHugeFieldNumbers.OptionalGroup from JSON.
     */
    decode: function (json: string): TestHugeFieldNumbers.OptionalGroup {
      return TestHugeFieldNumbersJSON.OptionalGroup._readMessage(
        TestHugeFieldNumbersJSON.OptionalGroup.initialize(),
        JSON.parse(json),
      );
    },

    /**
     * Initializes TestHugeFieldNumbers.OptionalGroup with all fields set to their default value.
     */
    initialize: function (): TestHugeFieldNumbers.OptionalGroup {
      return {
        groupA: 0,
      };
    },

    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestHugeFieldNumbers.OptionalGroup>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.groupA) {
        json["groupA"] = msg.groupA;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.OptionalGroup,
      json: any,
    ): TestHugeFieldNumbers.OptionalGroup {
      const _groupA_ = json["groupA"] ?? json["group_a"];
      if (_groupA_) {
        msg.groupA = _groupA_;
      }
      return msg;
    },
  },

  StringStringMap: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: PartialDeep<TestHugeFieldNumbers.StringStringMap>,
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        json["value"] = msg.value;
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: TestHugeFieldNumbers.StringStringMap,
      json: any,
    ): TestHugeFieldNumbers.StringStringMap {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        msg.value = _value_;
      }
      return msg;
    },
  },
};

export const TestExtensionInsideTableJSON = {
  /**
   * Serializes TestExtensionInsideTable to JSON.
   */
  encode: function (msg: PartialDeep<TestExtensionInsideTable>): string {
    return JSON.stringify(TestExtensionInsideTableJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionInsideTable from JSON.
   */
  decode: function (json: string): TestExtensionInsideTable {
    return TestExtensionInsideTableJSON._readMessage(
      TestExtensionInsideTableJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionInsideTable with all fields set to their default value.
   */
  initialize: function (): TestExtensionInsideTable {
    return {
      field1: 0,
      field2: 0,
      field3: 0,
      field4: 0,
      field6: 0,
      field7: 0,
      field8: 0,
      field9: 0,
      field10: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionInsideTable>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.field1) {
      json["field1"] = msg.field1;
    }
    if (msg.field2) {
      json["field2"] = msg.field2;
    }
    if (msg.field3) {
      json["field3"] = msg.field3;
    }
    if (msg.field4) {
      json["field4"] = msg.field4;
    }
    if (msg.field6) {
      json["field6"] = msg.field6;
    }
    if (msg.field7) {
      json["field7"] = msg.field7;
    }
    if (msg.field8) {
      json["field8"] = msg.field8;
    }
    if (msg.field9) {
      json["field9"] = msg.field9;
    }
    if (msg.field10) {
      json["field10"] = msg.field10;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionInsideTable,
    json: any,
  ): TestExtensionInsideTable {
    const _field1_ = json["field1"];
    if (_field1_) {
      msg.field1 = _field1_;
    }
    const _field2_ = json["field2"];
    if (_field2_) {
      msg.field2 = _field2_;
    }
    const _field3_ = json["field3"];
    if (_field3_) {
      msg.field3 = _field3_;
    }
    const _field4_ = json["field4"];
    if (_field4_) {
      msg.field4 = _field4_;
    }
    const _field6_ = json["field6"];
    if (_field6_) {
      msg.field6 = _field6_;
    }
    const _field7_ = json["field7"];
    if (_field7_) {
      msg.field7 = _field7_;
    }
    const _field8_ = json["field8"];
    if (_field8_) {
      msg.field8 = _field8_;
    }
    const _field9_ = json["field9"];
    if (_field9_) {
      msg.field9 = _field9_;
    }
    const _field10_ = json["field10"];
    if (_field10_) {
      msg.field10 = _field10_;
    }
    return msg;
  },
};

export const TestExtensionRangeSerializeJSON = {
  /**
   * Serializes TestExtensionRangeSerialize to JSON.
   */
  encode: function (msg: PartialDeep<TestExtensionRangeSerialize>): string {
    return JSON.stringify(TestExtensionRangeSerializeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TestExtensionRangeSerialize from JSON.
   */
  decode: function (json: string): TestExtensionRangeSerialize {
    return TestExtensionRangeSerializeJSON._readMessage(
      TestExtensionRangeSerializeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TestExtensionRangeSerialize with all fields set to their default value.
   */
  initialize: function (): TestExtensionRangeSerialize {
    return {
      fooOne: 0,
      fooTwo: 0,
      fooThree: 0,
      fooFour: 0,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TestExtensionRangeSerialize>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.fooOne) {
      json["fooOne"] = msg.fooOne;
    }
    if (msg.fooTwo) {
      json["fooTwo"] = msg.fooTwo;
    }
    if (msg.fooThree) {
      json["fooThree"] = msg.fooThree;
    }
    if (msg.fooFour) {
      json["fooFour"] = msg.fooFour;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TestExtensionRangeSerialize,
    json: any,
  ): TestExtensionRangeSerialize {
    const _fooOne_ = json["fooOne"] ?? json["foo_one"];
    if (_fooOne_) {
      msg.fooOne = _fooOne_;
    }
    const _fooTwo_ = json["fooTwo"] ?? json["foo_two"];
    if (_fooTwo_) {
      msg.fooTwo = _fooTwo_;
    }
    const _fooThree_ = json["fooThree"] ?? json["foo_three"];
    if (_fooThree_) {
      msg.fooThree = _fooThree_;
    }
    const _fooFour_ = json["fooFour"] ?? json["foo_four"];
    if (_fooFour_) {
      msg.fooFour = _fooFour_;
    }
    return msg;
  },
};
"
`;
